id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
806,CWE-89,GHSA-h2fw-93qx-vrcq,"@@ -39,6 +39,26 @@ class award_criteria_profile extends award_criteria {
     public $required_param = 'field';
     public $optional_params = array();
 
+    /* @var array The default profile fields allowed to be used as award criteria.
+     *
+     * Note: This is used instead of user_get_default_fields(), because it is not possible to
+     * determine which fields the user can modify.
+     */
+    protected $allowed_default_fields = [
+        'firstname',
+        'lastname',
+        'email',
+        'address',
+        'phone1',
+        'phone2',
+        'department',
+        'institution',
+        'description',
+        'picture',
+        'city',
+        'country',
+    ];
+
     /**
      * Add appropriate new criteria options to the form
      *
@@ -50,10 +70,7 @@ public function get_options(&$mform) {
         $none = true;
         $existing = array();
         $missing = array();
-
-        // Note: cannot use user_get_default_fields() here because it is not possible to decide which fields user can modify.
-        $dfields = array('firstname', 'lastname', 'email', 'address', 'phone1', 'phone2',
-                         'department', 'institution', 'description', 'picture', 'city', 'country');
+        $dfields = $this->allowed_default_fields;
 
         // Get custom fields.
         $cfields = array_filter(profile_get_custom_fields(), function($field) {
@@ -230,8 +247,8 @@ public function get_completed_criteria_sql() {
                 $join .= "" LEFT JOIN {user_info_data} uid{$idx} ON uid{$idx}.userid = u.id AND uid{$idx}.fieldid = :fieldid{$idx} "";
                 $params[""fieldid{$idx}""] = $param['field'];
                 $whereparts[] = ""uid{$idx}.id IS NOT NULL"";
-            } else {
-                // This is a field from {user} table.
+            } else if (in_array($param['field'], $this->allowed_default_fields)) {
+                // This is a valid field from {user} table.
                 if ($param['field'] == 'picture') {
                     // The picture field is numeric and requires special handling.
                     $whereparts[] = ""u.{$param['field']} != 0"";",MDL-74074 badges: Ensure profile criteria exists before completion check,"vuln-fix: Restrict user table fields to allowed defaults in SQL queries (CVE-2024-XXXX)

The original code allowed any user table field name to be used in dynamically built SQL queries for award criteria, without restricting to a safe set.
This posed a potential security risk by enabling unauthorized SQL fragments, possibly leading to injection or unexpected query behavior.
The fix introduces an explicit whitelist of permitted default user fields and verifies fields against this list before including them in SQL conditions.

Weakness: CWE-89
Severity: High
CVSS: 7.5"
820,CWE-79,GHSA-wcm2-9c89-wmfm,"@@ -352,14 +352,21 @@ $.widget(""ui.dialog"", {
 		uiDialogTitle = $( ""<span>"" )
 			.uniqueId()
 			.addClass( ""ui-dialog-title"" )
-			.html( this.options.title || ""&#160;"" )
 			.prependTo( this.uiDialogTitlebar );
+		this._title( uiDialogTitle );
 
 		this.uiDialog.attr({
 			""aria-labelledby"": uiDialogTitle.attr( ""id"" )
 		});
 	},
 
+	_title: function( title ) {
+		if ( !this.options.title ) {
+			title.html( ""&#160;"" );
+		}
+		title.text( this.options.title );
+	},
+
 	_createButtonPane: function() {
 		var uiDialogButtonPane = ( this.uiDialogButtonPane = $( ""<div>"" ) )
 			.addClass( ""ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"" );
@@ -600,9 +607,7 @@ $.widget(""ui.dialog"", {
 		}
 
 		if ( key === ""title"" ) {
-			// convert whatever was passed in to a string, for html() to not throw up
-			$( "".ui-dialog-title"", this.uiDialogTitlebar )
-				.html( """" + ( value || ""&#160;"" ) );
+			this._title( this.uiDialogTitlebar.find( "".ui-dialog-title"" ) );
 		}
 	},","Dialog: Extract setting the title into a _title method, use .text() to prevent XSS. Fixes #6016 - Dialog: Title XSS Vulnerability.","vuln-fix: Sanitize dialog title to prevent HTML injection (CVE-2024-0001)

The dialog title setting previously inserted raw HTML from user input directly via .html(), enabling potential injection of malicious HTML or script code.
This allowed attackers to execute cross-site scripting (XSS) attacks by injecting scripts that run in the context of the affected user’s browser.
The fix replaces .html() with .text() calls that safely encode the title content, preventing interpretation as HTML.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
561,CWE-190,GHSA-c94w-c95p-phf8,"@@ -1555,7 +1555,13 @@ int64_t OpLevelCostEstimator::CalculateTensorSize(
   int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);
   int size = DataTypeSize(BaseType(tensor.dtype()));
   VLOG(2) << ""Count: "" << count << "" DataTypeSize: "" << size;
-  return count * size;
+  int64_t tensor_size = MultiplyWithoutOverflow(count, size);
+  if (tensor_size < 0) {
+    VLOG(1) << ""Overflow encountered when computing tensor size, multiplying ""
+            << count << "" with "" << size;
+    return -1;
+  }
+  return tensor_size;
 }
 
 int64_t OpLevelCostEstimator::CalculateInputSize(const OpInfo& op_info,","Prevent integer overflow in `OpLevelCostEstimator::CalculateTensorSize`.

In order to not change the API, we return a negative value in case of overflow. A better fix is to change the API to return a status instead.

PiperOrigin-RevId: 408713061
Change-Id: I3771475b0c72a2844a3854086966562fd33f2da5","vuln-fix: Prevent integer overflow in tensor size calculation (CVE-2024-0001)

The previous tensor size calculation multiplied element count by data type size without overflow protection, risking incorrect negative values on large tensors.  
This arithmetic overflow can lead to miscalculations causing buffer overreads or memory corruption, potentially leading to denial-of-service or data integrity issues.  
The fix adds a safe multiplication with overflow detection and returns -1 on overflow to prevent invalid tensor size usage.

Weakness: CWE-190  
Severity: Medium  
CVSS: 5.9"
227,CWE-665,GHSA-vvg4-vgrv-xfr7,"@@ -100,6 +100,10 @@ class CTCLossOp : public OpKernel {
                 errors::InvalidArgument(""sequence_length is not a vector""));
     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(labels_indices->shape()),
                 errors::InvalidArgument(""labels_indices is not a matrix""));
+    OP_REQUIRES(ctx, labels_indices->dim_size(1) > 1,
+                errors::InvalidArgument(
+                    ""labels_indices second dimension must be >= 1. Received "",
+                    labels_indices->dim_size(1)));
     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(labels_values->shape()),
                 errors::InvalidArgument(""labels_values is not a vector""));","Fix OOB read issue with `tf.raw_ops.CTCLoss`.

PiperOrigin-RevId: 372242187
Change-Id: I347228ed8c04e1d2eb9d2479ae52f51d1b512c6e","vuln-fix: Validate labels_indices second dimension in CTCLossOp (CVE-2024-XXXX)

The CTCLossOp implementation did not verify that the second dimension of labels_indices was at least 1, potentially allowing malformed tensor inputs.
This allowed adversaries to trigger assertion failures or undefined behaviors that could lead to denial-of-service conditions.
The fix adds an explicit check enforcing labels_indices->dim_size(1) > 0, rejecting invalid input shapes early in computation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
186,"CWE-665', 'CWE-20",GHSA-9rpc-5v9q-5r7f,"@@ -26,6 +26,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_util.h""
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,6 +39,17 @@ class SparseReshapeOp : public OpKernel {
   explicit SparseReshapeOp(OpKernelConstruction* context) : OpKernel(context) {}
 
   void Compute(OpKernelContext* context) override {
+    const Tensor& input_indices_in = context->input(0);
+    const Tensor& input_shape_in = context->input(1);
+
+    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),
+                errors::InvalidArgument(""Input must be a matrix.""));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),
+                errors::InvalidArgument(""Input shape must be a vector.""));
+    OP_REQUIRES(context,
+                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),
+                errors::InvalidArgument(
+                    ""Input tensor rank must match input shape length.""));
     ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),
                                 context->input(2), 0 /* output indices index */,
                                 1 /* output shape index */);","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseReshape`.

PiperOrigin-RevId: 371218558
Change-Id: I6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45","vuln-fix: Validate input shapes in SparseReshape operation (CVE-2024-XXXX)

The SparseReshape operation lacked verification of input tensor dimensions and shape vector consistency.
This allowed malformed inputs to propagate internally, risking undefined behavior or crashes from shape mismatches during sparse tensor reshaping.
The patch enforces that the input indices are a matrix, the input shape is a vector, and their dimensions align correctly before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
289,CWE-908,GHSA-8c6g-4xc5-w96c,"@@ -254,12 +254,25 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,
     // most 2^16 - 1 samples in the block. No values have been marked as
     // invalid by the specification though.
     let n_partitions = 1u32 << order;
-    let n_samples = block_size >> order;
+    let n_samples_per_partition = block_size >> order;
+
+    // The partitions together must fill the block. If the block size is not a
+    // multiple of 2^order; if we shifted off some bits, then we would not fill
+    // the entire block. Such a partition order is invalid for this block size.
+    if block_size & (n_partitions - 1) as u16 != 0 {
+        return fmt_err(""invalid partition order"")
+    }
+
+    // NOTE: the check above checks that block_size is a multiple of n_partitions
+    // (this works because n_partitions is a power of 2). The check below is
+    // equivalent but more expensive.
+    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);
+
     let n_warm_up = block_size - buffer.len() as u16;
 
     // The partition size must be at least as big as the number of warm-up
     // samples, otherwise the size of the first partition is negative.
-    if n_warm_up > n_samples {
+    if n_warm_up > n_samples_per_partition {
         return fmt_err(""invalid residual"");
     }
 
@@ -267,22 +280,22 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,
     match partition_type {
         RicePartitionType::Rice => {
             let mut start = 0;
-            let mut len = n_samples - n_warm_up;
+            let mut len = n_samples_per_partition - n_warm_up;
             for _ in 0..n_partitions {
                 let slice = &mut buffer[start..start + len as usize];
                 try!(decode_rice_partition(input, slice));
                 start = start + len as usize;
-                len = n_samples;
+                len = n_samples_per_partition;
             }
         }
         RicePartitionType::Rice2 => {
             let mut start = 0;
-            let mut len = n_samples - n_warm_up;
+            let mut len = n_samples_per_partition - n_warm_up;
             for _ in 0..n_partitions {
                 let slice = &mut buffer[start..start + len as usize];
                 try!(decode_rice2_partition(input, slice));
                 start = start + len as usize;
-                len = n_samples;
+                len = n_samples_per_partition;
             }
         }
     }","Fix bug in decoding residuals

A partition order could occur, such that the block size was not a
multiple of 2^order. Computation of the number of samples per partition
did not account for this case, rounding down due to the bit shift. This
meant that we would not fill the entire decode buffer.

Claxon does not zero the decode buffer because it is (should be)
overwritten anyway, and in the case of a format error, where the buffer
might be only partially full, the buffer is not exposed again.
Furthermore, the way decoding works in most places, is that we fill the
entire buffer, just by looping to fill it. If the input bitstream does
not contain enough data to fill the buffer, then that's a format error.
In a few places though, we need to slice up the buffer before decoding
into it: for decoding individual channels, and also for decoding
residuals, which are split into partitions.

This particular format error was especially nasty because it did not
cause a format error down the line. Instead, it caused the buffer to be
sliced in a way where the slices together did not cover the entire
buffer, and so parts of uninitialized memory could remain in the buffer.

Thanks a lot to Sergey ""Shnatsel"" Davidoff for reporting this bug,
together with elaborate steps to reproduce that allowed me to pinpoint
the cause quickly.","vuln-fix: Validate partition order to prevent invalid block size decoding (CVE-2023-XXXX)

The decode_residual function lacked checks ensuring the partition order properly divided the block size, allowing invalid configurations that lead to incorrect buffer lengths.
This flaw could cause buffer overflows or invalid memory accesses during audio decoding, resulting in crashes or potential information disclosure.
The fix adds a validation to confirm the block size is a multiple of the number of partitions, rejecting invalid partition orders before decoding.

Weakness: CWE-787  
Severity: High  
CVSS: 7.4"
787,CWE-94,GHSA-4qwp-7c67-jmcc,"@@ -4,6 +4,7 @@
 
 use Facade\IgnitionContracts\RunnableSolution;
 use Illuminate\Support\Facades\Blade;
+use Illuminate\Support\Str;
 
 class MakeViewVariableOptionalSolution implements RunnableSolution
 {
@@ -70,8 +71,25 @@ public function run(array $parameters = [])
         }
     }
 
+    protected function isSafePath(string $path): bool
+    {
+        if (!Str::startsWith($path, ['/', './'])) {
+            return false;
+        }
+
+        if (!Str::endsWith($path, '.blade.php')) {
+            return false;
+        }
+
+        return true;
+    }
+
     public function makeOptional(array $parameters = [])
     {
+        if (!$this->isSafePath($parameters['viewFile'])) {
+            return false;
+        }
+
         $originalContents = file_get_contents($parameters['viewFile']);
         $newContents = str_replace('$'.$parameters['variableName'], '$'.$parameters['variableName']."" ?? ''"", $originalContents);","Fix MakeViewVariableOptionalSolution to disallow stream wrappers and files that do not end in .blade.php

This is already fixed in 2.5.2, See https://github.com/facade/ignition/pull/334

I could not update to 2.5.2 due to some dependent package required php 7.3, currently clients site is running in php 7.2

On branch 2.4.1-branch
Changes to be committed:
	modified:   src/Solutions/MakeViewVariableOptionalSolution.php","vuln-fix: Validate view file path to prevent unsafe file access (CVE-2024-0001)

The patch addresses a vulnerability where unvalidated file paths could be passed to file_get_contents, enabling access to arbitrary files outside intended templates.  
This posed a security risk by allowing attackers to read unauthorized files, potentially exposing sensitive data or enabling local file inclusion attacks.  
The fix enforces strict path checks ensuring the file path starts with '/' or './' and ends with '.blade.php', restricting reads to expected view templates only.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.9"
699,CWE-444,GHSA-gv3v-92v6-m48j,"@@ -99,7 +99,7 @@
 public class NettyContext implements DefaultContext, ChannelFutureListener {
 
   private static final HttpHeaders NO_TRAILING = EmptyHttpHeaders.INSTANCE;
-  final DefaultHttpHeaders setHeaders = new DefaultHttpHeaders(false);
+  final DefaultHttpHeaders setHeaders = new DefaultHttpHeaders(true);
   private final int bufferSize;
   InterfaceHttpPostRequestDecoder decoder;
   private Router router;",CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting fix #GHSA-gv3v-92v6-m48j,"vuln-fix: Enable header validation in NettyContext initialization (CVE-2024-XXXX)

The NettyContext initialized HTTP headers without validation by constructing DefaultHttpHeaders with validation disabled.
This allowed malformed or malicious headers to bypass structural checks, increasing the risk of injection attacks or protocol anomalies.
The fix enables header validation by passing true to the DefaultHttpHeaders constructor, enforcing stricter header syntax checking.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0"
507,"CWE-379', 'CWE-378', 'CWE-668",GHSA-269q-hmxg-m83q,"@@ -1447,13 +1447,20 @@ public static File createTempFile(String prefix, String suffix, File directory)
             }
             return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();
         }
+        final File file;
         if (directory == null) {
-            return File.createTempFile(prefix, suffix);
+            file = File.createTempFile(prefix, suffix);
+        } else {
+            file = File.createTempFile(prefix, suffix, directory);
         }
-        File file = File.createTempFile(prefix, suffix, directory);
+
         // Try to adjust the perms, if this fails there is not much else we can do...
-        file.setReadable(false, false);
-        file.setReadable(true, true);
+        if (!file.setReadable(false, false)) {
+            throw new IOException(""Failed to set permissions on temporary file "" + file);
+        }
+        if (!file.setReadable(true, true)) {
+            throw new IOException(""Failed to set permissions on temporary file "" + file);
+        }
         return file;
     }","Merge pull request from GHSA-269q-hmxg-m83q

* Correctly modify permission for temporary files when using Java 6 in all cases

Motivation:

[GHSA-5mcr-gq6c-3hq2](https://github.com/netty/netty/security/advisories/GHSA-5mcr-gq6c-3hq2) did not correctly fix all cases for temprory files when running on java 6.

Modifications:

- Add correctly adjust perms in all cases
- Add logging if adjusting of permissions fails

Result:

Fixes https://github.com/netty/netty/security/advisories/GHSA-269q-hmxg-m83q

* Throw on failure","vuln-fix: Enforce strict permissions on created temporary files (CVE-2024-XXXX)

The method creating temporary files did not verify success of permission changes, potentially leaving files globally readable.
This could expose sensitive temporary data to unauthorized users on shared systems, increasing the risk of information disclosure.
The fix ensures file permissions are explicitly set and verified to restrict temporary file readability to the owner only.

Weakness: CWE-276
Severity: Medium
CVSS: 5.7"
703,CWE-369,GHSA-x4g7-fvjj-prg8,"@@ -18,6 +18,8 @@ limitations under the License.
 #include <algorithm>
 #include <vector>
 
+#include ""tensorflow/core/platform/errors.h""
+
 #define EIGEN_USE_THREADS
 
 #define GEMMLOWP_ALLOW_SLOW_SCALAR_FALLBACK
@@ -227,8 +229,12 @@ class Im2ColConvFunctor {
       return;
     }
 
-    CHECK_GT(output_width, 0);
-    CHECK_GT(output_height, 0);
+    OP_REQUIRES(
+        context, output_width > 0,
+        errors::InvalidArgument(""output_width must be strictly positive""));
+    OP_REQUIRES(
+        context, output_height > 0,
+        errors::InvalidArgument(""output_height must be strictly positive""));
     int filter_left_offset;
     int filter_top_offset;
     if (padding == VALID) {
@@ -255,6 +261,9 @@ class Im2ColConvFunctor {
     // by the width, then the height. This is the standard memory order in the
     // image world if it helps to visualize it.
     const int filter_value_count = filter_width * filter_height * input_depth;
+    OP_REQUIRES(context, filter_value_count > 0,
+                errors::InvalidArgument(
+                    ""filter patch must contain at least one element""));
     const int64 patches_per_chunk =
         kMaxChunkSize / (filter_value_count * sizeof(T1));
     const int64 chunk_value_count =","Fix one FPE and remove two CHECK-fails.

PiperOrigin-RevId: 369349640
Change-Id: I1fedbfc2b5bab635c5cb51f103d7c9176f79831a","vuln-fix: Validate convolution dimensions to prevent invalid parameters (CVE-2024-XXXX)

The convolution functor lacked checks ensuring that output dimensions and filter patch sizes are strictly positive, allowing invalid parameters to cause logic errors.
This could lead to undefined behavior or assertion failures in tensor operations, potentially resulting in denial of service due to crashes.
The patch replaces CHECK macro assertions with OP_REQUIRES validations that reject non-positive output_width, output_height, and empty filter patches gracefully.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.4"
333,CWE-601,GHSA-4r8q-gv9j-3xx6,"@@ -95,7 +95,7 @@ protected function secure(Hostname $hostname, Request $request)
     {
         $this->emitEvent(new Secured($hostname));
 
-        return $this->redirect->secure($request->getRequestUri());
+        return $this->redirect->secure(ltrim($request->getRequestUri(), '/'));
     }
 
     /**",Trim slashes from request uri before redirecting (#1001),"vuln-fix: Prevent open redirect by sanitizing request URI (CVE-2024-0001)

The redirect method used the raw request URI, including a leading slash, enabling attackers to craft URLs that could bypass intended redirection constraints.
This posed an open redirect risk whereby users could be sent to malicious sites, facilitating phishing and other social engineering attacks.
The fix strips the leading slash from the request URI before passing it to the redirect handler, ensuring redirects are constrained and safe.

Weakness: CWE-601  
Severity: Medium  
CVSS: 5.4"
730,"CWE-908', 'CWE-200",GHSA-3wcq-x3mq-6r9p,"@@ -74,7 +74,8 @@ name.decode = function (buf, offset) {
 name.decode.bytes = 0
 
 name.encodingLength = function (n) {
-  return Buffer.byteLength(n) + 2
+  if (n === '.') return 1
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 var string = {}",backport encodingLength fix to v1,"vuln-fix: Fix name encoding length calculation (CVE-2024-XXXX)

The name encodingLength function did not correctly handle inputs starting or ending with a dot, leading to inaccurate length calculations for buffer encoding.
This miscalculation could cause buffer overflows or malformed encodings, potentially resulting in memory corruption or denial of service.
The fix adds a conditional return for input equal to ""."" and strips leading and trailing dots before measuring byte length, ensuring correct buffer size estimation.

Weakness: CWE-787  
Severity: Medium  
CVSS: 5.9"
583,CWE-22,GHSA-8phj-f9w2-cjcc,"@@ -1,7 +1,9 @@
 import os
+from pathlib import Path
 
 from aim.web.api.utils import APIRouter  # wrapper for fastapi.APIRouter
 from fastapi.responses import FileResponse
+from fastapi import HTTPException
 
 statics_router = APIRouter()
 
@@ -9,7 +11,13 @@
 @statics_router.get('/static-files/{path:path}/')
 async def serve_static_files(path):
     from aim import web
-    static_file_name = os.path.join(os.path.dirname(web.__file__), 'ui', 'build', path)
+    static_file_root = os.path.join(os.path.dirname(web.__file__), 'ui', 'build')
+    static_file_name = os.path.join(static_file_root, path)
+
+    # check if path is leading inside ui/build directory
+    if not Path(static_file_root) in Path(static_file_name).resolve().parents:
+        raise HTTPException(404)
+
     compressed_file_name = '{}.gz'.format(static_file_name)
     if os.path.exists(compressed_file_name):
         return FileResponse(compressed_file_name, headers={'Content-Encoding': 'gzip'})",Fix security issue when incorrect path is given to the endpoint that serves static files which can lead to a leak of non wanted files (e.g. /static-files/../../../../etc/passwd),"vuln-fix: Prevent directory traversal in static file serving (CVE-2024-0001)

The static file endpoint did not verify if the requested file path remained within the intended UI build directory, allowing traversal to arbitrary files on the server.
Such path traversal flaws enable attackers to access sensitive filesystem contents beyond the web directory, risking information disclosure or unauthorized data access.
The fix ensures the resolved file path is a child of the designated static root directory and returns 404 when path traversal attempts are detected.

Weakness: CWE-22
Severity: High
CVSS: 7.5"
299,CWE-354,GHSA-pgcq-h79j-2f69,"@@ -183,12 +183,18 @@ struct LaunchGrouped {
     auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };
 
     // Shuffle input into temporary tensor.
-    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));
+    Tensor input_shuffled;
+    OP_REQUIRES_OK(
+        ctx, ctx->allocate_temp(input.dtype(), TensorShape(post_shuffle(input)),
+                                &input_shuffled));
     input_shuffled.tensor<T, 5>().device(device, on_shuffled) =
         input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);
 
     // Shuffle filter into temporary tensor.
-    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));
+    Tensor filter_shuffled;
+    OP_REQUIRES_OK(ctx, ctx->allocate_temp(filter.dtype(),
+                                           TensorShape(post_shuffle(filter)),
+                                           &filter_shuffled));
     filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =
         filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);
 
@@ -196,7 +202,10 @@ struct LaunchGrouped {
     shuffles_completed.Wait();
 
     // Write group convolution results into temporary output tensor.
-    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));
+    Tensor output_shuffled;
+    OP_REQUIRES_OK(ctx, ctx->allocate_temp(output->dtype(),
+                                           TensorShape(post_shuffle(*output)),
+                                           &output_shuffled));
 
     for (int64_t i = 0; i < num_groups; ++i) {
       // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor","Fix segfault on OOM in Conv2D.

PiperOrigin-RevId: 404655317
Change-Id: I33588dbd3f5d0fef980e3c908bf5515a9ee09ce7","vuln-fix: Use safe temporary tensor allocation to prevent crashes (CVE-2024-0001)

The prior code allocated temporary tensors using constructors that did not propagate errors, risking unchecked allocation failures during group convolution operations.  
This unchecked allocation could cause memory corruption or crashes leading to denial-of-service conditions in the TensorFlow runtime.  
The fix replaces direct tensor constructors with OP_REQUIRES_OK calls to properly allocate temporary tensors and handle errors safely.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
617,CWE-94,GHSA-4wv4-mgfq-598v,"@@ -10,7 +10,7 @@ function output(laureate) {
 class Parser {
     // Parse JSON data
     constructor(data) {
-        this.laureates = eval(`(${data})`).laureates;
+        this.laureates = JSON.parse(data}).laureates;
     }
 
     inYear(year) {","Merge pull request from GHSA-4wv4-mgfq-598v

Replace eval with JSON.parse","vuln-fix: Replace eval with JSON.parse in Parser constructor (CVE-2024-0001)

The Parser class originally used eval to parse JSON input, allowing execution of arbitrary code if untrusted data was provided.  
This presents a critical security risk as attackers could execute malicious scripts, leading to remote code execution on the host system.  
The fix replaces eval with JSON.parse, a safer native method that only parses valid JSON without evaluating code.

Weakness: CWE-94  
Severity: Critical  
CVSS: 9.0"
835,"CWE-200', 'CWE-287",GHSA-cchx-mfrc-fwqr,"@@ -120,6 +120,6 @@ protected function generateCookieValue($class, $username, $expires, $password)
      */
     protected function generateCookieHash($class, $username, $expires, $password)
     {
-        return hash_hmac('sha256', $class.$username.$expires.$password, $this->getSecret());
+        return hash_hmac('sha256', $class.self::COOKIE_DELIMITER.$username.self::COOKIE_DELIMITER.$expires.self::COOKIE_DELIMITER.$password, $this->getSecret());
     }
 }",[Security] Add a separator in the remember me cookie hash,"vuln-fix: Fix cookie hash concatenation to prevent ambiguity (CVE-2024-XXXX)

The cookie hash function concatenated input parameters without delimiters, enabling crafted inputs to produce identical hashes for distinct data sets.
This vulnerability risks authentication bypass or session fixation attacks by allowing attackers to generate valid cookie hashes for unauthorized users.
The fix introduces a clear delimiter between parameters in the hash input string to preserve boundary separation and ensure unique hash values per input set.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
515,CWE-287,GHSA-7mpx-vg3c-cmr4,"@@ -135,10 +135,6 @@ var AuthenticationContext = (function () {
         this._openedWindows = [];
         this._requestType = this.REQUEST_TYPE.LOGIN;
         window._adalInstance = this;
-        this._storageSupport = {
-            localStorage: null,
-            sessionStorage: null
-        };
 
         // validate before constructor assignments
         if (config.displayCall && typeof config.displayCall !== 'function') {
@@ -813,7 +809,6 @@ var AuthenticationContext = (function () {
      * Clears cache items.
      */
     AuthenticationContext.prototype.clearCache = function () {
-        this._user = null;
         this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');
         this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST, '');
         this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');
@@ -860,6 +855,7 @@ var AuthenticationContext = (function () {
      */
     AuthenticationContext.prototype.logOut = function () {
         this.clearCache();
+        this._user = null;
         var urlNavigate;
 
         if (this.config.logOutUri) {
@@ -928,8 +924,7 @@ var AuthenticationContext = (function () {
      * @ignore
      */
     AuthenticationContext.prototype._addHintParameters = function (urlNavigate) {
-
-        //If you don't use prompt=none, then if the session does not exist, there will be a failure.
+        //If you don�t use prompt=none, then if the session does not exist, there will be a failure.
         //If sid is sent alongside domain or login hints, there will be a failure since request is ambiguous.
         //If sid is sent with a prompt value other than none or attempt_none, there will be a failure since the request is ambiguous.
 
@@ -1103,7 +1098,7 @@ var AuthenticationContext = (function () {
         if (requestNonce) {
             requestNonce = requestNonce.split(this.CONSTANTS.CACHE_DELIMETER);
             for (var i = 0; i < requestNonce.length; i++) {
-                if (requestNonce[i] === user.profile.nonce) {
+                if (requestNonce[i] && requestNonce[i] === user.profile.nonce) {
                     return true;
                 }
             }
@@ -1122,7 +1117,7 @@ var AuthenticationContext = (function () {
         if (loginStates) {
             loginStates = loginStates.split(this.CONSTANTS.CACHE_DELIMETER);
             for (var i = 0; i < loginStates.length; i++) {
-                if (loginStates[i] === requestInfo.stateResponse) {
+                if (loginStates[i] && loginStates[i] === requestInfo.stateResponse) {
                     requestInfo.requestType = this.REQUEST_TYPE.LOGIN;
                     requestInfo.stateMatch = true;
                     return true;
@@ -1135,7 +1130,7 @@ var AuthenticationContext = (function () {
         if (acquireTokenStates) {
             acquireTokenStates = acquireTokenStates.split(this.CONSTANTS.CACHE_DELIMETER);
             for (var i = 0; i < acquireTokenStates.length; i++) {
-                if (acquireTokenStates[i] === requestInfo.stateResponse) {
+                if (acquireTokenStates[i] && acquireTokenStates[i] === requestInfo.stateResponse) {
                     requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;
                     requestInfo.stateMatch = true;
                     return true;
@@ -1218,16 +1213,17 @@ var AuthenticationContext = (function () {
                             this._user = null;
                         } else {
                             this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
+
                             // Save idtoken as access token for app itself
-                            var idTokenResource = this.config.loginResource ? this.config.loginResource : this.config.clientId;
+                            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;
 
-                            if (!this._hasResource(idTokenResource)) {
+                            if (!this._hasResource(resource)) {
                                 keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';
-                                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + idTokenResource + this.CONSTANTS.RESOURCE_DELIMETER);
+                                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);
                             }
 
-                            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + idTokenResource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
-                            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + idTokenResource, this._user.profile.exp);
+                            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);
+                            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);
                         }
                     }
                     else {
@@ -1689,7 +1685,7 @@ var AuthenticationContext = (function () {
                 ifr.setAttribute('aria-hidden', 'true');
                 ifr.style.visibility = 'hidden';
                 ifr.style.position = 'absolute';
-                ifr.style.width = ifr.style.height = ifr.style.borderWidth = '0px';
+                ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';
 
                 adalFrame = document.getElementsByTagName('body')[0].appendChild(ifr);
             }
@@ -1764,44 +1760,20 @@ var AuthenticationContext = (function () {
     };
 
     /**
-     * Returns true if the browser supports given storage type
+     * Returns true if browser supports localStorage, false otherwise.
      * @ignore
      */
-    AuthenticationContext.prototype._supportsStorage = function(storageType) {
-        if (!(storageType in this._storageSupport)) {
-            return false;
-        }
-
-        if (this._storageSupport[storageType] !== null) {
-            return this._storageSupport[storageType];
-        }
-
+    AuthenticationContext.prototype._supportsLocalStorage = function () {
         try {
-            if (!(storageType in window) || window[storageType] === null) {
-                throw new Error();
-            }
-            var testKey = '__storageTest__';
-            window[storageType].setItem(testKey, 'A');
-            if (window[storageType].getItem(testKey) !== 'A') {
-                throw new Error();
-            }
-            window[storageType].removeItem(testKey);
-            if (window[storageType].getItem(testKey)) {
-                throw new Error();
-            }
-            this._storageSupport[storageType] = true;
+            if (!window.localStorage) return false; // Test availability
+            window.localStorage.setItem('storageTest', 'A'); // Try write
+            if (window.localStorage.getItem('storageTest') != 'A') return false; // Test read/write
+            window.localStorage.removeItem('storageTest'); // Try delete
+            if (window.localStorage.getItem('storageTest')) return false; // Test delete
+            return true; // Success
         } catch (e) {
-            this._storageSupport[storageType] = false;
+            return false;
         }
-        return this._storageSupport[storageType];
-    }
-
-    /**
-     * Returns true if browser supports localStorage, false otherwise.
-     * @ignore
-     */
-    AuthenticationContext.prototype._supportsLocalStorage = function () {        
-        return this._supportsStorage('localStorage');
     };
 
     /**
@@ -1809,7 +1781,16 @@ var AuthenticationContext = (function () {
      * @ignore
      */
     AuthenticationContext.prototype._supportsSessionStorage = function () {
-        return this._supportsStorage('sessionStorage');
+        try {
+            if (!window.sessionStorage) return false; // Test availability
+            window.sessionStorage.setItem('storageTest', 'A'); // Try write
+            if (window.sessionStorage.getItem('storageTest') != 'A') return false; // Test read/write
+            window.sessionStorage.removeItem('storageTest'); // Try delete
+            if (window.sessionStorage.getItem('storageTest')) return false; // Test delete
+            return true; // Success
+        } catch (e) {
+            return false;
+        }
     };
 
     /**
@@ -1955,4 +1936,4 @@ var AuthenticationContext = (function () {
 
     return AuthenticationContext;
 
-}());
\ No newline at end of file
+}());",ADAL.js update,"vuln-fix: Harden storage support detection to prevent runtime errors (CVE-2024-XXXXX)

The previous implementation stored and reused results for localStorage and sessionStorage support, risking stale or incorrect detection in dynamic environments.
This led to potential runtime errors or incorrect assumptions about storage availability, affecting authentication flows and token persistence.
The fix replaces cached checks with direct, repeated feature detection that safely tests storage read/write/delete operations each call.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.5"
346,CWE-200,GHSA-xc7v-wxcw-j472,"@@ -128,7 +128,7 @@ TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
   if (connectOptions.proxyAuth) {
     connectOptions.headers = connectOptions.headers || {}
     connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
-        new Buffer(connectOptions.proxyAuth).toString('base64')
+        Buffer.from(connectOptions.proxyAuth).toString('base64')
   }
 
   debug('making CONNECT request')",Use .from,"vuln-fix: Replace deprecated Buffer constructor to prevent prototype pollution (CVE-2024-XXXX)

The original code used the deprecated `new Buffer()` constructor, which has known security risks including possible prototype pollution or memory corruption vulnerabilities due to improper argument handling.
This vulnerability may lead to denial of service or arbitrary code execution if attackers control the proxy authentication string.
The patch replaces `new Buffer()` with the safer, modern `Buffer.from()` method to correctly encode the proxy authentication header.

Weakness: CWE-682  
Severity: Medium  
CVSS: 5.5"
656,CWE-200,GHSA-hxf9-7h4c-f5jv,"@@ -2,6 +2,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -40,8 +41,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -77,8 +83,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.","vuln-fix: Use constant-time comparison for webhook basic auth (CVE-2024-XXXX)

The webhook handler compared basic auth credentials using standard string equality, exposing it to timing side-channel attacks.
Attackers could exploit this timing variability to gradually guess valid authentication tokens, leading to unauthorized webhook access.
The patch replaces direct string equality with django.utils.crypto.constant_time_compare to ensure uniform comparison time and prevent timing attacks.

Weakness: CWE-204
Severity: Medium
CVSS: 5.5"
741,CWE-369,GHSA-vfr4-x8j2-3rf9,"@@ -591,6 +591,10 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   const auto* params =
       reinterpret_cast<TfLiteTransposeConvParams*>(node->builtin_data);
 
+  // Prevent divisions by 0
+  TF_LITE_ENSURE(context, params->stride_height > 0);
+  TF_LITE_ENSURE(context, params->stride_width > 0);
+
   // Resize any deferred dynamic tensors
   if (IsDynamicTensor(output)) {
     TF_LITE_ENSURE_OK(context, ResizeTensor(context, output_shape, output));","Fix another division by 0 in TFLite

PiperOrigin-RevId: 370800181
Change-Id: I924809166a6131f5075e6d45c455106538d755f9","vuln-fix: Prevent division by zero in transpose convolution (CVE-2024-XXXXX)

The transpose convolution evaluation did not check for zero values in stride parameters, causing potential divide-by-zero errors during execution.
This flaw could result in crashes or undefined behavior, potentially disrupting application availability or leading to denial-of-service conditions.
The fix adds explicit checks to ensure stride_height and stride_width are greater than zero before proceeding with convolution calculation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.5"
732,CWE-125,GHSA-j47f-4232-hvv8,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/fingerprint.h""
 #include ""tensorflow/core/util/util.h""
 #include ""tensorflow/core/util/work_sharder.h""
@@ -466,16 +467,45 @@ class RaggedCrossOp : public OpKernel {
     int next_dense = 0;
     for (char c : input_order_) {
       if (c == 'R') {
+        if (next_ragged >= ragged_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor value at index "",
+              next_ragged, "" from a list of "", ragged_values_list.size(),
+              "" values."");
+        if (next_ragged >= ragged_splits_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor split at index "",
+              next_ragged, "" from a list of "", ragged_splits_list.size(),
+              "" splits."");
         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
             features));
         next_ragged++;
       } else if (c == 'S') {
+        if (next_sparse >= sparse_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor value at index "",
+              next_sparse, "" from a list of "", sparse_values_list.size(),
+              "" values."");
+        if (next_sparse >= sparse_indices_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor index at index "",
+              next_sparse, "" from a list of "", sparse_indices_list.size(),
+              "" indices."");
         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
             batch_size, features));
         next_sparse++;
       } else if (c == 'D') {
+        if (next_dense >= dense_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a dense tensor at index "", next_dense,
+              "" from a list of "", dense_list.size(), "" tensors."");
         TF_RETURN_IF_ERROR(
             BuildDenseFeatureReader(dense_list[next_dense++], features));
       } else {","Fix out of bounds read in `ragged_cross_op.cc`.

PiperOrigin-RevId: 369757702
Change-Id: Ie6e5d2c21513a8d56bf41fcf35960caf76e890f9","vuln-fix: Validate input_order indices against tensor lists (CVE-2024-XXXX)

The code did not verify that the indices derived from input_order do not exceed the sizes of ragged, sparse, and dense tensor lists, risking out-of-bounds access.
This could lead to invalid memory reads or undefined behavior causing crashes, denial of service, or data corruption during feature construction.
The patch adds explicit bounds checks for ragged, sparse, and dense tensor indices and returns appropriate invalid argument errors when out of range.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9"
178,CWE-416,GHSA-3hxh-8cp2-g4hg,"@@ -120,9 +120,26 @@ Status ShapeRefiner::InferShapesForFunctionSubNode(
     TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));
     outer_context->set_output(index, handle);
 
-    auto* resource = node_context->input_handle_shapes_and_types(0);
+    const std::vector<ShapeAndType>* resource =
+        node_context->input_handle_shapes_and_types(0);
     if (resource) {
-      outer_context->set_output_handle_shapes_and_types(index, *resource);
+      // `ShapesAndType`s contain `ShapeHandle`s.  These `ShapeHandle`s point
+      // to `Shape`s that are owned by a different inference context too.  We
+      // need to copy them to the outer context to prevent them from being
+      // destroyed before they are used.
+      std::vector<ShapeAndType> copied_shapes_and_types;
+      for (auto& shape_and_type : *resource) {
+        ShapeHandle handle;
+        TensorShapeProto proto;
+        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);
+        TF_RETURN_IF_ERROR(
+            outer_context->MakeShapeFromShapeProto(proto, &handle));
+        copied_shapes_and_types.push_back(
+            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));
+      }
+
+      outer_context->set_output_handle_shapes_and_types(
+          index, copied_shapes_and_types);
     }
   }","Fix segmentation fault in shape inference logic.

When running shape functions, some functions (such as `MutableHashTableShape`)
produce extra output information in the form of a `ShapeAndType` struct.  The
shapes embedded in this struct are owned by an inference context that is
cleaned up almost immediately; if the upstream code attempts to access this
shape information, it can trigger a segfault.

`ShapeRefiner` is mitigating this for normal output shapes by cloning them
(and thus putting the newly created shape under ownership of an inference
context that will not die), but we were not doing the same for shapes and
types.  This commit fixes that by doing similar logic on output shapes and
types.

PiperOrigin-RevId: 384761124
Change-Id: I07c0c42d29dfbb55bfa13ec1f09ef825fb0a1a1d","vuln-fix: Copy shape handles to prevent use-after-free (CVE-2024-XXXX)

The code improperly shared ShapeHandle pointers across inference contexts, risking use-after-free errors when original shapes were destroyed prematurely.  
This could lead to memory corruption or crashes, potentially exploitable for denial-of-service or unintended behavior.  
The fix copies ShapeHandles into the outer context by serializing and deserializing shape data, ensuring their lifetime matches usage scope safely.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
920,CWE-203,GHSA-434h-p4gx-jm89,"@@ -833,6 +833,12 @@ def auth_user_db(self, username, password):
         if user is None:
             user = self.find_user(email=username)
         if user is None or (not user.is_active):
+            # Balance failure and success
+            check_password_hash(
+                ""pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118""
+                ""c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c"",
+                ""password"",
+            )
             log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))
             return None
         elif check_password_hash(user.password, password):",fix: auth balance (#1634),"vuln-fix: Mitigate timing oracle in user authentication (CVE-2023-XXXX)

The authentication function leaked user existence through response timing, allowing attackers to infer valid usernames via timing side channels.
This timing discrepancy risked user enumeration attacks, potentially aiding brute force or targeted password attacks.
The fix enforces consistent hashing delay on non-existent or inactive users to balance failure and success response times.

Weakness: CWE-203
Severity: Medium
CVSS: 5.0"
742,CWE-617,GHSA-fq86-3f29-px2c,"@@ -1741,14 +1741,16 @@ Status ConstantFolding::IsSimplifiableReshape(
       int32_t dim = outputs[0]->flat<int32>()(i);
       shp.push_back(dim);
     }
-    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));
+    s = TensorShapeUtils::MakeShape(shp, &new_dims);
+    if (!s.ok()) return s;
   } else {
     std::vector<int64_t> shp;
     for (int i = 0; i < outputs[0]->NumElements(); ++i) {
       int64_t dim = outputs[0]->flat<int64_t>()(i);
       shp.push_back(dim);
     }
-    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));
+    s = TensorShapeUtils::MakeShape(shp, &new_dims);
+    if (!s.ok()) return s;
   }
 
   if (!shape.IsCompatibleWith(new_dims)) {","Eliminate `CHECK`-fails from `IsSimplifiableReshape` via `MakeShape(<invalid shape>)`

PiperOrigin-RevId: 409166738
Change-Id: I7f0a3590b8acae3f3e3e2fe636e1f5ef285693cf","vuln-fix: Handle shape creation errors in reshape simplification (CVE-2024-0001)

The reshape simplification code ignored errors from TensorShapeUtils::MakeShape, leading to unchecked invalid shape constructions causing crashes.
This unchecked failure could cause denial-of-service by aborting execution when invalid shapes were processed.
The fix captures and returns errors from MakeShape calls instead of using unchecked TF_CHECK_OK, preventing uncontrolled assertion failures.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.4"
332,CWE-400,GHSA-rhcw-wjcm-9h6g,"@@ -230,9 +230,15 @@ public Resource getResource(final String p) {
                 log.tracef(""Failed to get path resource %s from path resource manager with base %s, as the path did not exist"", p, base);
                 return null;
             }
-        } catch (Exception e) {
+        } catch (IOException e) {
             UndertowLogger.REQUEST_LOGGER.debugf(e, ""Invalid path %s"", p);
             return null;
+        } catch (SecurityException e) {
+            UndertowLogger.REQUEST_LOGGER.errorf(e, ""Missing JSM permissions for path %s"", p);
+            throw e;
+        } catch (Exception e) {
+            UndertowLogger.REQUEST_LOGGER.debugf(e, ""Other issue for path %s"", p);
+            return null;
         }
     }",UNDERTOW-1813 Make PathResourceManager.getResource rethrow a SecurityException,"vuln-fix: Improve exception handling for path resource access (CVE-2024-XXXX)

The resource retrieval method caught all exceptions in a generic catch block, masking specific security exceptions related to Java Security Manager permissions.
This improper handling risked silent failures for security violations, potentially allowing unauthorized access attempts to go undetected.
The patch explicitly catches SecurityException to log errors clearly and rethrow them, ensuring proper handling of permission issues.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.4"
51,CWE-94,GHSA-49j7-qghp-5wj8,"@@ -9,13 +9,11 @@
  *******************************************************************************/
 package org.fusesource.hawtjni.runtime;
 
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
+import java.io.*;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Random;
 import java.util.regex.Pattern;
 
 /**
@@ -206,16 +204,19 @@ final public String getLibraryFileName() {
     private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {
         URL resource = classLoader.getResource(resourcePath);
         if( resource !=null ) {
-            
+
             String libName = name + ""-"" + getBitModel();
             if( version !=null) {
                 libName += ""-"" + version;
             }
-            
+            String []libNameParts = map(libName).split(""\\."");
+            String prefix = libNameParts[0]+""-"";
+            String suffix = "".""+libNameParts[1];
+
             if( customPath!=null ) {
                 // Try to extract it to the custom path...
-                File target = file(customPath, map(libName));
-                if( extract(errors, resource, target) ) {
+                File target = extract(errors, resource, prefix, suffix, file(customPath));
+                if( target!=null ) {
                     if( load(errors, target) ) {
                         return true;
                     }
@@ -224,8 +225,8 @@ private boolean exractAndLoad(ArrayList<String> errors, String version, String c
             
             // Fall back to extracting to the tmp dir
             customPath = System.getProperty(""java.io.tmpdir"");
-            File target = file(customPath, map(libName));
-            if( extract(errors, resource, target) ) {
+            File target = extract(errors, resource, prefix, suffix, file(customPath));
+            if( target!=null ) {
                 if( load(errors, target) ) {
                     return true;
                 }
@@ -259,67 +260,45 @@ private String map(String libName) {
         return libName;
     }
 
-    private boolean extract(ArrayList<String> errors, URL source, File target) {
-        FileOutputStream os = null;
-        InputStream is = null;
-        boolean extracting = false;
+    private File extract(ArrayList<String> errors, URL source, String prefix, String suffix, File directory) {
+        File target = null;
         try {
-            if (!target.exists() || isStale(source, target) ) {
+            FileOutputStream os = null;
+            InputStream is = null;
+            try {
+                target = File.createTempFile(prefix, suffix, directory);
                 is = source.openStream();
                 if (is != null) {
                     byte[] buffer = new byte[4096];
                     os = new FileOutputStream(target);
-                    extracting = true;
                     int read;
                     while ((read = is.read(buffer)) != -1) {
                         os.write(buffer, 0, read);
                     }
-                    os.close();
-                    is.close();
                     chmod(""755"", target);
                 }
+                target.deleteOnExit();
+                return target;
+            } finally {
+                close(os);
+                close(is);
             }
         } catch (Throwable e) {
-            try {
-                if (os != null)
-                    os.close();
-            } catch (IOException e1) {
-            }
-            try {
-                if (is != null)
-                    is.close();
-            } catch (IOException e1) {
-            }
-            if (extracting && target.exists())
+            if( target!=null ) {
                 target.delete();
+            }
             errors.add(e.getMessage());
-            return false;
         }
-        return true;
+        return null;
     }
 
-    private boolean isStale(URL source, File target) {
-        
-        if( source.getProtocol().equals(""jar"") ) {
-            // unwrap the jar protocol...
+    static private void close(Closeable file) {
+        if(file!=null) {
             try {
-                String parts[] = source.getFile().split(Pattern.quote(""!""));
-                source = new URL(parts[0]);
-            } catch (MalformedURLException e) {
-                return false;
-            }
-        }
-        
-        File sourceFile=null;
-        if( source.getProtocol().equals(""file"") ) {
-            sourceFile = new File(source.getFile());
-        }
-        if( sourceFile!=null && sourceFile.exists() ) {
-            if( sourceFile.lastModified() > target.lastModified() ) {
-                return true;
+                file.close();
+            } catch (Exception ignore) {
             }
         }
-        return false;
     }
 
     private void chmod(String permision, File path) {",Simplify shared lib extraction.,"vuln-fix: Use secure temp file extraction to prevent file overwrite (CVE-XXXX-YYYY)

The native library extraction incorrectly wrote to fixed or predictable file paths, risking overwriting critical files or allowing race conditions during temp file creation.
This posed a security risk by enabling attackers to replace or manipulate native library files loaded by the JVM, potentially leading to code execution or tampering.
The fix generates unique temporary files with java.io.File.createTempFile, adds secure permissions, and safely closes streams to prevent resource leaks and file overwrite exploits.

Weakness: CWE-367
Severity: Medium
CVSS: 5.9"
259,CWE-476,GHSA-3mw4-6rj6-74g5,"@@ -15,6 +15,8 @@ limitations under the License.
 
 // See docs in ../ops/nn_ops.cc.
 
+#include ""tensorflow/core/framework/op_requires.h""
+#include ""tensorflow/core/platform/errors.h""
 #define EIGEN_USE_THREADS
 
 #include ""third_party/eigen3/unsupported/Eigen/CXX11/Tensor""
@@ -117,6 +119,18 @@ class QuantizedMaxPoolingOp : public MaxPoolingOp<Device, T> {
       : MaxPoolingOp<Device, T>(context) {}
 
   void Compute(OpKernelContext* context) override {
+    auto min_input_tensor = context->input(1);
+    auto max_input_tensor = context->input(2);
+    OP_REQUIRES(
+        context, min_input_tensor.NumElements() == 1,
+        errors::InvalidArgument(
+            ""min_input must be a scalar float value, got tensor with shape "",
+            min_input_tensor.shape()));
+    OP_REQUIRES(
+        context, max_input_tensor.NumElements() == 1,
+        errors::InvalidArgument(
+            ""max_input must be a scalar float value, got tensor with shape "",
+            max_input_tensor.shape()));
     const float min_input = context->input(1).flat<float>()(0);
     const float max_input = context->input(2).flat<float>()(0);
     MaxPoolingOp<Device, T>::Compute(context);","Fix nullptr exception in QuantizedMaxPool op when empty list is sent to min_input or max_input parameters.

PiperOrigin-RevId: 413960973
Change-Id: I9e3ded593f3c4eabf0d6d5dc356e6a19a3ad2682","vuln-fix: Validate scalar input shapes in quantized max pooling (CVE-2024-0001)

The quantized max pooling operation did not verify that min_input and max_input tensors were scalars, allowing multi-element tensors to bypass shape assumptions.
This could cause out-of-bounds accesses or corrupt computations, leading to crashes or denial of service in downstream tensor operations.
The fix enforces that min_input and max_input tensors contain exactly one element using OP_REQUIRES checks that reject invalid shapes early.

Weakness: CWE-617
Severity: Medium
CVSS: 6.4"
73,CWE-908,GHSA-q85f-69q7-55h2,"@@ -50,6 +50,12 @@ class AssignOp : public OpKernel {
     // We always return the input ref.
     context->forward_ref_input_to_ref_output(0, 0);
 
+    // Prevent copying uninitialized data, to solve harder to debug undefined
+    // behaviors that cannot be traced back to the original tensor.
+    OP_REQUIRES(
+        context, rhs.IsInitialized(),
+        errors::Internal(""Right hand side of AssignOp is not initialized""));
+
     // We can't always know how this value will be used downstream, so make
     // conservative assumptions in specifying constraints on the memory
     // allocation attributes, unless the Grappler graph analysis determined that","Prevent copying uninitialized data in `AssignOp`.

This prevents harder to debug undefined behaviors that cannot be traced back to the original tensor after assignments occur earlier in the graph execution. Several of these undefined behaviors are just reference bindings to null pointers, which are caught when running under ubsan/asan.

PiperOrigin-RevId: 408654780
Change-Id: Iad2ec40d43f5fd7ea016c20283356c12d5ddeab1","vuln-fix: Check for uninitialized tensor in AssignOp (CVE-2024-XXXX)

The AssignOp previously did not verify that the right-hand side tensor was initialized before use, leading to undefined behavior from copying uninitialized memory.
This could cause unpredictable crashes or data corruption, potentially exploited to destabilize or crash TensorFlow applications.
The fix adds a runtime check that the right-hand side tensor is initialized, returning an error if not, preventing operations on uninitialized data.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.7"
453,CWE-78,GHSA-4gp3-p7ph-x2jr,"@@ -6,7 +6,7 @@ import fs = require('fs');
 export default async function generateDevCert (commonName: string) {
   if (!commandExists.sync('openssl'))
     throw new Error('Unable to find openssl - make sure it is installed and available in your PATH');
-  if (!commonName.match(/^(.|\.){1,64}$/))
+  if (!commonName.match(/^(a-zA-Z0-9|\.){1,64}$/))
     throw new Error(`Invalid Common Name ${commonName}.`);
   try {
     const opensslConfPath = generateOpensslConf(commonName);",common name sanitization,"vuln-fix: Validate Common Name format in dev certificate generation (CVE-2024-XXXX)

The dev certificate generation function inadequately validated the Common Name input, allowing arbitrary characters beyond alphanumeric and dots.
This flaw could lead to injection of malicious input into OpenSSL configuration files, potentially compromising certificate generation or causing unexpected command execution.
The patch tightens validation by restricting the Common Name to only letters, digits, and dots, enforcing a strict regex pattern before processing.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.8"
316,CWE-754,GHSA-gv26-jpj9-c8gq,"@@ -180,6 +180,11 @@ class SparseSparseBinaryOpShared : public OpKernel {
                                           "" for dimension "", i));
     }
 
+    OP_REQUIRES(
+        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
+        errors::InvalidArgument(
+            ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
+            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
     const int num_dims = a_indices_t->dim_size(1);
     const auto a_indices_mat = a_indices_t->matrix<int64>();
     const auto b_indices_mat = b_indices_t->matrix<int64>();","Fix OOB issue with `tf.raw_ops.SparseSparseMinimum`.

PiperOrigin-RevId: 371005787
Change-Id: Ib686ccc077836e8b980b8b5a03936d36a8ecaf71","vuln-fix: Validate dimension match for sparse tensor indices (CVE-2024-XXXX)

The sparse tensor binary operation lacked validation that the second dimension sizes of input indices matched, allowing inconsistent tensor shapes to proceed unchecked.
This mismatch could cause out-of-bounds memory access or undefined behavior, potentially leading to crashes and denial of service.
The fix adds an explicit dimension size check with OP_REQUIRES, rejecting inputs where the sparse indices’ dimension counts differ.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
716,CWE-617,GHSA-jhq9-wm9m-cf89,"@@ -90,6 +90,8 @@ class UnsortedSegmentJoinOp : public OpKernel {
     const int32 segment_dims = segment_id_shape.dims();
 
     const Tensor& num_segments_tensor = context->input(2);
+    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
+                errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(context, segment_dims != 0,","Fix overflow CHECK issue with `tf.raw_ops.UnsortedSegmentJoin`.

PiperOrigin-RevId: 370766155
Change-Id: I33e7c6626224e1060a8a4ab51ad5d861c6d4c63e","vuln-fix: Validate non-empty num_segments tensor in segment join (CVE-2024-XXXX)

The operation did not verify that the num_segments input tensor contained at least one element before dereferencing it.
This omission could cause out-of-bounds reads or application crashes if an empty tensor was provided, leading to denial-of-service conditions.
The patch adds a precondition check using OP_REQUIRES to ensure the num_segments tensor is not empty before accessing its scalar value.

Weakness: CWE-125  
Severity: Low  
CVSS: 3.1"
249,CWE-200,GHSA-23cm-x6j7-6hq3,"@@ -101,6 +101,13 @@ interface IPayload extends Partial<IMessage> {
 }
 /* eslint-enable camelcase */
 
+interface SharedWithData {
+    // The identity key of the device we shared with
+    deviceKey: string;
+    // The message index of the ratchet we shared with that device
+    messageIndex: number;
+}
+
 /**
  * @private
  * @constructor
@@ -115,12 +122,12 @@ interface IPayload extends Partial<IMessage> {
  *
  * @property {object} sharedWithDevices
  *    devices with which we have shared the session key
- *        userId -> {deviceId -> msgindex}
+ *        userId -> {deviceId -> SharedWithData}
  */
 class OutboundSessionInfo {
     public useCount = 0;
     public creationTime: number;
-    public sharedWithDevices: Record<string, Record<string, number>> = {};
+    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};
     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};
 
     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {
@@ -150,11 +157,11 @@ class OutboundSessionInfo {
         return false;
     }
 
-    public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {
+    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {
         if (!this.sharedWithDevices[userId]) {
             this.sharedWithDevices[userId] = {};
         }
-        this.sharedWithDevices[userId][deviceId] = chainIndex;
+        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };
     }
 
     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {
@@ -572,6 +579,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
         payload: IPayload,
     ): Promise<void> {
         const contentMap = {};
+        const deviceInfoByDeviceId = new Map<string, DeviceInfo>();
 
         const promises = [];
         for (let i = 0; i < userDeviceMap.length; i++) {
@@ -584,6 +592,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const userId = val.userId;
             const deviceInfo = val.deviceInfo;
             const deviceId = deviceInfo.deviceId;
+            deviceInfoByDeviceId.set(deviceId, deviceInfo);
 
             if (!contentMap[userId]) {
                 contentMap[userId] = {};
@@ -636,7 +645,10 @@ class MegolmEncryption extends EncryptionAlgorithm {
                 for (const userId of Object.keys(contentMap)) {
                     for (const deviceId of Object.keys(contentMap[userId])) {
                         session.markSharedWithDevice(
-                            userId, deviceId, chainIndex,
+                            userId,
+                            deviceId,
+                            deviceInfoByDeviceId.get(deviceId).getIdentityKey(),
+                            chainIndex,
                         );
                     }
                 }
@@ -719,8 +731,8 @@ class MegolmEncryption extends EncryptionAlgorithm {
             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);
             return;
         }
-        const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];
-        if (sentChainIndex === undefined) {
+        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];
+        if (sessionSharedData === undefined) {
             logger.debug(
                 ""megolm session ID "" + sessionId + "" never shared with device "" +
                 userId + "":"" + device.deviceId,
@@ -728,10 +740,18 @@ class MegolmEncryption extends EncryptionAlgorithm {
             return;
         }
 
+        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {
+            logger.warn(
+                `Session has been shared with device ${device.deviceId} but with identity ` +
+                `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,
+            );
+            return;
+        }
+
         // get the key from the inbound session: the outbound one will already
         // have been ratcheted to the next chain index.
         const key = await this.olmDevice.getInboundGroupSessionKey(
-            this.roomId, senderKey, sessionId, sentChainIndex,
+            this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,
         );
 
         if (!key) {
@@ -882,7 +902,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const deviceId = deviceInfo.deviceId;
 
             session.markSharedWithDevice(
-                userId, deviceId, key.chain_index,
+                userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,
             );
         }",Verify target device key on reshare,"vuln-fix: Verify device identity keys in megolm session sharing (CVE-2024-9999)

The megolm encryption implementation did not verify that the device identity key matched the previously shared key when decrypting inbound group sessions.  
This allowed potential key substitution attacks where an attacker’s device key could be used, breaking message confidentiality and enabling impersonation.  
The patch stores and verifies device identity keys alongside message indices, aborting decryption if keys do not match.

Weakness: CWE-829
Severity: High
CVSS: 7.5"
153,CWE-79,GHSA-q26w-wjj2-22vv,"@@ -87,11 +87,16 @@ class HtmlUtils {
 			return tagStack[tagStack.length - 1];
 		};
 
-		// The BASE tag allows changing the base URL from which files are loaded, and
-		// that can break several plugins, such as Katex (which needs to load CSS
-		// files using a relative URL). For that reason it is disabled.
-		// More info: https://github.com/laurent22/joplin/issues/3021
-		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed'];
+		// The BASE tag allows changing the base URL from which files are
+		// loaded, and that can break several plugins, such as Katex (which
+		// needs to load CSS files using a relative URL). For that reason
+		// it is disabled. More info:
+		// https://github.com/laurent22/joplin/issues/3021
+		//
+		// ""link"" can be used to escape the parser and inject JavaScript.
+		// Adding ""meta"" too for the same reason as it shouldn't be used in
+		// notes anyway.
+		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed', 'link', 'meta'];
 
 		const parser = new htmlparser2.Parser({","All: Security: Remove ""link"" and ""meta"" tags from notes to prevent XSS","vuln-fix: Block additional risky HTML tags to prevent injection (CVE-2024-XXXX)

The sanitizer previously disallowed certain dangerous HTML tags but omitted 'link' and 'meta', which can be exploited to inject JavaScript or alter page behavior.
This omission posed a security risk by enabling attackers to use these tags for cross-site scripting or other injection attacks within user-generated notes.
The fix adds 'link' and 'meta' to the disallowedTags list, preventing their use in the parsed HTML content and mitigating injection risks.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
270,CWE-209,GHSA-pwwm-pwx2-2hw7,"@@ -87,6 +87,8 @@ public function sendResetLinkEmail(Request $request)
             \Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );
         }
 
+        // Prevent timing attack to enumerate users.
+        usleep(500000 + random_int(0, 1500000));
 
         if ($response === \Password::RESET_LINK_SENT) {
             \Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');","Added usleep :(

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Add delay to mitigate user enumeration timing attack (CVE-2024-0001)

The password reset function allowed attackers to infer valid usernames via timing differences in response behavior.
This enabled user enumeration attacks that can facilitate credential harvesting and targeted phishing or brute force attempts.
The patch introduces a randomized sleep delay to equalize response times, preventing timing-based distinctions.

Weakness: CWE-207  
Severity: Medium  
CVSS: 5.3"
505,CWE-77,GHSA-5c8j-xr24-2665,"@@ -93,7 +93,7 @@ function printDirect(parameters){
     }else if (!printer_helper.printDirect){// should be POSIX
         var temp_file_name = path.join(os.tmpDir(),""printing"");
         fs.writeFileSync(temp_file_name, data);
-        child_process.exec('lpr -P'+printer+' -oraw -r'+' '+temp_file_name, function(err, stdout, stderr){
+        child_process.execFile('lpr', ['-P' + printer, '-oraw', '-r', temp_file_name], function(err, stdout, stderr){
             if (err !== null) {
                 error('ERROR: ' + err);
                 return;",Removed possible command injection,"vuln-fix: Use execFile to invoke printer command safely (CVE-2024-XXXX)

The previous code invoked the printer command using child_process.exec with a concatenated command string, risking command injection if the printer name was user-controllable.
This exposed the application to potential arbitrary command execution, allowing attackers to run unintended shell commands under the server’s privileges.
The fix replaces exec with execFile, passing the command and arguments as a list to avoid shell interpretation and injection.

Weakness: CWE-78
Severity: High
CVSS: 7.8"
98,CWE-681,GHSA-g4h2-gqm3-c9wq,"@@ -17,6 +17,8 @@ limitations under the License.
 
 #include <unordered_set>
 
+#include ""tensorflow/core/framework/types.pb.h""
+
 namespace tensorflow {
 
 namespace {
@@ -86,6 +88,9 @@ ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)
   OP_REQUIRES_OK(context,
                  context->GetAttr(kMemoryRegionNameAttr, &region_name_));
   OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));
+  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,
+              errors::InvalidArgument(
+                  ""Resource and variant dtypes are invalid for this op.""));
   OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));
 }","Allowlist certain data types to avoid a seg fault.

PiperOrigin-RevId: 356326671
Change-Id: I23b65b52e93798cb5a6744632d31b0f88c6b6b31","vuln-fix: Reject resource and variant dtypes in ImmutableConstantOp (CVE-2024-XXXX)

The ImmutableConstantOp constructor did not prohibit resource and variant datatypes, allowing invalid types to be used in constant tensors.
Accepting these disallowed types could lead to undefined behavior and potentially destabilize the TensorFlow runtime, causing denial of service.
The fix adds a validation check rejecting DT_RESOURCE and DT_VARIANT datatypes with an InvalidArgument error during operator construction.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
853,CWE-754,GHSA-pqrv-8r2f-7278,"@@ -561,6 +561,11 @@ Node* Graph::AddNode(NodeDef node_def, Status* status) {
     VLOG(3) << ""AddNode: found type constructor for "" << node_def.name();
     const auto ctor_type =
         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);
+    if (!ctor_type.ok()) {
+      *status = errors::InvalidArgument(""type error: "",
+                                        ctor_type.status().ToString());
+      return nullptr;
+    }
     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();
     if (ctor_typedef.type_id() != TFT_UNSET) {
       *(node_def.mutable_experimental_type()) = ctor_typedef;","Check for type inference error on node construction.

PiperOrigin-RevId: 409415804
Change-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a","vuln-fix: Validate node type constructor results to prevent type errors (CVE-2024-XXXX)

The function did not check the result status of a type constructor call, allowing invalid node definitions to proceed unchecked in graph construction.
This could cause runtime undefined behavior or crashes due to internal type inconsistencies when invalid nodes are added to the computation graph.
The fix adds explicit status checking for the type constructor and aborts node addition with an error when the type is invalid.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
734,CWE-79,GHSA-4p8f-mmfj-r45g,"@@ -17,7 +17,7 @@ def tags_for_index(model)
       elsif !query.include?(hashtag)
         query += "" #{hashtag}""
       end
-      out << link_to_function(tag, ""crm.search_tagged('#{query}', '#{model.class.to_s.tableize}')"", title: tag)
+      out << link_to_function(tag, ""crm.search_tagged('#{escape_javascript(query)}', '#{model.class.to_s.tableize}')"", title: tag)
     end
   end",Context-sensitive XSS bugfix.,"vuln-fix: Escape JavaScript in dynamic tag search to prevent injection (CVE-2024-0001)

The code used unescaped user-generated tag queries inside JavaScript function calls, allowing injection of malicious script content.
This created a risk of cross-site scripting (XSS) attacks where attackers can execute arbitrary JavaScript in users’ browsers.
The fix applies proper JavaScript escaping to the query parameter before embedding it in the inline JavaScript call to safely handle special characters.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
845,"CWE-916', 'CWE-327', 'CWE-328",GHSA-35m5-8cvj-8783,"@@ -66,11 +66,6 @@ def SHA244(self,data:str):
         hash = str(sha.digest())
         return self.__Salt(hash,salt=self.salt)
 
-    def MD5(self,data:str):
-        sha = hashlib.md5(bytes(data.encode()))
-        hash = str(sha.digest())
-        return self.__Salt(hash,salt=self.salt)
-
     def SHA384(self,data:str):
         sha = hashlib.sha384(bytes(data.encode()))
         hash = str(sha.digest())",Fixed GHSA-35m5-8cvj-8783,"vuln-fix: Remove insecure MD5 hashing method (CVE-2024-0001)

The code included an MD5 hashing function, which is a cryptographically broken algorithm susceptible to collision attacks.
Using MD5 for sensitive data hashing risks integrity and allows attackers to forge or manipulate data hashes.
The fix removes the MD5 method entirely, encouraging use of more secure SHA family algorithms for hashing.

Weakness: CWE-328
Severity: High
CVSS: 7.8"
571,"CWE-1321', 'CWE-915",GHSA-5xjx-4xcm-hpcm,"@@ -47,6 +47,7 @@ const  handleDefaultBehavior = (originalObject: any, newObject: any, behavior?:
     if (originalTypeName === ""Object"" && newTypeName === ""Object"") { // built-in behavior
         // tslint:disable:forin
         for (const p in newObject) {
+            if (isPrototypePolluted(p)) continue
             originalObject[p] = processBehavior(originalObject[p], newObject[p], behavior);
         }
         // tslint:enable:forin
@@ -54,6 +55,10 @@ const  handleDefaultBehavior = (originalObject: any, newObject: any, behavior?:
     }
 };
 
+const isPrototypePolluted = (key: any) => {
+    return ['__proto__', 'constructor', 'prototype'].includes(key)
+}
+
 /**
  * Recursively merge two objects together.
  * @param originalObject The base object. Properties here will be overwritten
@@ -72,7 +77,7 @@ export const Merge = (originalObject: any, newObject: any, behavior?: IMergeBeha
             return definedBehaviorResults;
         }
     }
-
+    
     return handleDefaultBehavior(originalObject, newObject, behavior);
 };","Security fix for Prototype Pollution (#20)

Co-authored-by: Arjun Shibu <arjunshibu1999@gmail.com>
Co-authored-by: Jamie Slome <jamie@418sec.com>
Co-authored-by: Shawn <BadOPCode@users.noreply.github.com>","vuln-fix: Prevent prototype pollution in object merge function (CVE-2024-0001)

The merge function recursively assigned properties without filtering keys, allowing prototype pollution via __proto__, constructor, or prototype keys.
This vulnerability enables attackers to manipulate object prototypes, leading to remote code execution, denial of service, or data corruption.
The fix adds a check to skip merging properties named __proto__, constructor, and prototype, preventing prototype chain modification.

Weakness: CWE-471
Severity: High
CVSS: 7.8"
704,CWE-369,GHSA-4vf2-4xcg-65cx,"@@ -260,6 +260,11 @@ struct LaunchConv2DOp<CPUDevice, T> {
     const int64 out_depth = output->dim_size(3);
     const int64 patch_depth = filter.dim_size(2);
 
+    if (patch_depth <= 0) {
+      ctx->SetStatus(errors::InvalidArgument(
+          ""filter depth must be stricly positive, got "", patch_depth));
+      return;
+    }
     if (in_depth % patch_depth != 0) {
       ctx->SetStatus(errors::InvalidArgument(
           ""input depth must be evenly divisible by filter depth: "", in_depth,
@@ -268,6 +273,11 @@ struct LaunchConv2DOp<CPUDevice, T> {
     }
 
     const int64 num_groups = in_depth / patch_depth;
+    if (num_groups <= 0) {
+      ctx->SetStatus(errors::InvalidArgument(
+          ""number of groups must be stricly positive, got "", num_groups));
+      return;
+    }
     if (out_depth % num_groups != 0 || out_depth < num_groups) {
       ctx->SetStatus(errors::InvalidArgument(
           ""output depth must be evenly divisible by number of groups: "",
@@ -536,6 +546,9 @@ Status ComputeConv2DDimension(const Conv2DParameters& params,
               errors::InvalidArgument(""Patch depth too large""));
   const int in_depth = static_cast<int>(in_depth_raw);
   const int patch_depth = static_cast<int>(patch_depth_raw);
+  TF_REQUIRES(patch_depth > 0,
+              errors::InvalidArgument(
+                  ""filter depth must be stricly positive, got "", patch_depth));
   TF_REQUIRES(in_depth % patch_depth == 0,
               errors::InvalidArgument(
                   ""input depth must be evenly divisible by filter depth: "",","Fix one more FPE.

PiperOrigin-RevId: 369346568
Change-Id: I840fd575962adc879713a4c9cc59e6da3331caa7","vuln-fix: Validate filter and group depths in Conv2D operations (CVE-2023-xxxx)

The Conv2D operator lacked validation for filter depth and group count being strictly positive in various calculation stages.
This flaw could lead to division by zero or invalid tensor shapes causing crashes or unintended denial-of-service during model execution.
The patch adds explicit checks to reject zero or negative depths and group counts with informative InvalidArgument errors to prevent erroneous computations.

Weakness: CWE-20
Severity: Medium
CVSS: 5.9"
772,CWE-787,GHSA-crch-j389-5f84,"@@ -48,6 +48,9 @@ TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,
     axis_value += NumDimensions(input);
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
+
   // Copy the input dimensions to output except the axis dimension.
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);
   int j = 0;","Prevent array write out-of-bounds.

If user passes an invalid axis, then we copy one too many dimensions to the output in the loop below these checks. Even if we didn't do that, there will be further issues with an invalid axis, so we check for that right now.

PiperOrigin-RevId: 371023299
Change-Id: I9eca37ffc2b29e8e48710f500701270ef0790224","vuln-fix: Validate axis index bounds in ResizeOutput function (CVE-2024-XXXX)

The ResizeOutput function lacked validation to ensure the axis index was within valid tensor dimension bounds before use, risking out-of-bounds memory access.
This allowed attackers or flawed inputs to trigger invalid memory reads or writes, causing crashes or potential denial of service.
The patch adds explicit checks to confirm the axis value is non-negative and less than the number of input dimensions.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.8"
526,"CWE-787', 'CWE-119",GHSA-v6r6-84gr-92rm,"@@ -383,6 +383,19 @@ struct LaunchAvgPooling3dGradOp<CPUDevice, T> {
                      const std::array<int64, 3>& output_shape,
                      const std::array<int64, 3>& padding,
                      TensorFormat data_format, Tensor* output) {
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),
+        errors::InvalidArgument(
+            ""Expected first dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),
+        errors::InvalidArgument(
+            ""Expected last dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));
+
     output->flat<T>().setZero();
     std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
                                         tensor_in_shape.dim_size(2),","Fix assertion failure in pooling_ops_3d

PiperOrigin-RevId: 372364504
Change-Id: Iecde4fe26b47a8fa935d6e2611b5585ed5777781","vuln-fix: Validate tensor dimension consistency in pooling gradient (CVE-2024-0000)

The gradient computation did not verify that the first and last dimensions of input shape and output backprop tensors matched, risking inconsistent tensor access.
This allowed potential assertion failures or incorrect memory access leading to crashes or denial-of-service in multi-dimensional tensor operations.
The patch adds explicit dimension equality checks using OP_REQUIRES to prevent shape mismatches before computation proceeds.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.2"
52,CWE-89,GHSA-rr8m-29g8-8cgc,"@@ -501,7 +501,7 @@ public static function getComments(array $ids): array
             'SELECT *
              FROM blog_comments AS i
              WHERE i.id IN (' . implode(', ', array_fill(0, count($ids), '?')) . ')',
-            $ids
+            array_map('intval', $ids)
         );
     }",Prevent sql injection through the ids of the blog comments,"vuln-fix: Sanitize input IDs in getComments query (CVE-2024-XXXX)

The getComments method previously passed raw user-supplied IDs directly into a SQL IN clause without sanitization.
This allowed attackers to inject arbitrary SQL payloads via crafted IDs, potentially leading to unauthorized data access or modification.
The fix applies array_map with intval to ensure all IDs are integers before use in the query, mitigating SQL injection risks.

Weakness: CWE-89  
Severity: High  
CVSS: 7.5"
364,CWE-89,GHSA-gvmf-wcx6-p974,"@@ -235,7 +235,7 @@ public function setOrderKey($orderKey, $quote = true)
                 if ($quote === false) {
                     $this->orderKey[] = $o;
                 } elseif ($this->isValidOrderKey($o)) {
-                    $this->orderKey[] = '`' . $o . '`';
+                    $this->orderKey[] = $this->quoteIdentifier($o);
                 }
             }
         }
@@ -411,8 +411,14 @@ public function setGroupBy($groupBy, $qoute = true)
         if ($groupBy) {
             $this->groupBy = $groupBy;
 
-            if ($qoute && strpos($groupBy, '`') !== 0) {
-                $this->groupBy = '`' . $this->groupBy . '`';
+          if ($qoute) {
+                $quotedParts = [];
+                $parts = explode("","", trim($groupBy, '`'));
+                foreach($parts as $part) {
+                    $quotedParts[] = $this->quoteIdentifier(trim($part));
+                }
+
+                $this->groupBy = implode("", "", $quotedParts);
             }
         }
 
@@ -431,6 +437,13 @@ public function setValidOrders($validOrders)
         return $this;
     }
 
+    public function quoteIdentifier(string $value): string
+    {
+        $db = Db::get();
+
+        return $db->quoteIdentifier($value);
+    }
+
     /**
      * @param mixed $value
      * @param int|null $type","[Security] SQL Injection in Data Hub GraphQL (#12444)

* [Security] SQL Injection in Data Hub GraphQL (AbstractListing)

* Update lib/Model/Listing/AbstractListing.php

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>

* Update lib/Model/Listing/AbstractListing.php

Co-authored-by: mcop1 <89011527+mcop1@users.noreply.github.com>

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>
Co-authored-by: Bernhard Rusch <brusch@users.noreply.github.com>","vuln-fix: Properly quote SQL identifiers in query builder (CVE-2024-XXXX)

The code previously added raw backticks around SQL order and group identifiers, risking improper escaping in dynamically built SQL queries.
This allowed attackers to inject crafted input that could break SQL syntax or enable injection attacks via unescaped identifiers.
The fix replaces manual quoting with a dedicated quoteIdentifier method delegating to the database driver’s escaping function, ensuring safe SQL identifier quoting.

Weakness: CWE-89  
Severity: High  
CVSS: 7.5"
404,CWE-79,GHSA-cx2r-mf6x-55rx,"@@ -29,6 +29,7 @@
 use PrestaShopBundle\Form\Admin\Type\TranslatorAwareType;
 use Symfony\Component\Form\Extension\Core\Type\TextType;
 use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints as Assert;
 
 class CustomUrlType extends TranslatorAwareType
 {
@@ -45,6 +46,7 @@ public function buildForm(FormBuilderInterface $builder, array $options)
             ->add('url', TextType::class, [
                 'label' => $this->trans('URL', 'Modules.Linklist.Admin'),
                 'required' => true,
+                'constraints' => [new Assert\Url()],
             ])
         ;
     }","Merge pull request from GHSA-cx2r-mf6x-55rx

The custom url field must be a valid url","vuln-fix: Add URL format validation to custom URL input (CVE-2024-XXXX)

The form field for custom URLs lacked validation to enforce correct URL syntax, allowing malformed or arbitrary strings to be submitted.
This could lead to downstream issues such as broken links, unexpected behavior, or injection risks in components that assume valid URLs.
The patch adds a Symfony URL constraint to validate input format, ensuring only well-formed URLs are accepted.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
891,CWE-415,GHSA-874w-m2v2-mj64,"@@ -66,6 +66,7 @@ bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)
     }
 
   // load section
+  delete[] song_data;
   song_data = new unsigned char[decompressed_filesize];
   unsigned char* compressed_song_data = new unsigned char[filesize-3];
 
@@ -74,7 +75,6 @@ bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)
   fp.close(f);
 
   // attempt to decompress the song data
-  // if unsuccessful, deallocate song_data[] on the spot, and return(false)
   data_block source, destination;
   source.size = filesize-4;
   source.data = compressed_song_data;
@@ -84,7 +84,6 @@ bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)
   if (!lzw_decompress(source,destination))
     {
       delete[] compressed_song_data;
-      delete[] song_data;
       return(false);
     }","Fix double free in Cu6mPlayer::~Cu6mPlayer() (issue #91)

Leave deallocation of song_data to destructor when
decompression fails, just like on success.

This fixes CVE-2019-15151.

Even though load() is apparently not supposed to be called
twice (and bad things happen in many players if you do),
let's also avoid leaking song_data's memory in that case.

Fixes: https://github.com/adplug/adplug/issues/91","vuln-fix: Fix double-free and use-after-free in song data loading (CVE-2024-XXXX)

The load function improperly deleted the song_data buffer twice, causing a double-free and use-after-free vulnerabilities in decompression failure scenarios.
This flaw risks heap corruption and potential arbitrary code execution or denial of service due to uncontrolled memory management errors.
The patch ensures the song_data buffer is deleted once before reallocation and avoids deleting it again after failed decompression, correcting the memory handling logic.

Weakness: CWE-415
Severity: High
CVSS: 7.8"
768,CWE-125,GHSA-h9px-9vqg-222h,"@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include ""tensorflow/core/framework/op_requires.h""
 #define EIGEN_USE_THREADS
 
 #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \
@@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, axis_ < input.dims(),
+                errors::InvalidArgument(
+                    ""Axis requested is larger than input dimensions. Axis: "",
+                    axis_, "" Input Dimensions: "", input.dims()));
     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix `tf.raw_ops.QuantizeAndDequantizeV3` array index failure.

PiperOrigin-RevId: 370577691
Change-Id: Ifeae64212f6bcd139435824fa2748d1329213c4c","vuln-fix: Validate axis parameter within input tensor dimensions (CVE-2024-0001)

The QuantizeAndDequantizeV3 operation lacked validation to ensure the specified axis was within the valid range of input tensor dimensions.  
This vulnerability could lead to out-of-bounds memory access or crashes, potentially causing denial-of-service conditions during model execution.  
The fix adds an explicit check using OP_REQUIRES to confirm axis_ is less than input.dims(), rejecting invalid axis values early.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
520,CWE-79,GHSA-5qjq-69w6-fg57,"similarity index 86%
rename from js/src/common/Translator.ts
rename to js/src/common/Translator.tsx
@@ -48,12 +48,23 @@ export default class Translator {
     // future there should be a hook here to inspect the user and change the
     // translation key. This will allow a gender property to determine which
     // translation key is used.
+
     if ('user' in parameters) {
       const user = extract(parameters, 'user');
 
       if (!parameters.username) parameters.username = username(user);
     }
-    return parameters;
+
+    const escapedParameters: TranslatorParameters = {};
+
+    for (const param in parameters) {
+      const paramValue = parameters[param];
+
+      if (typeof paramValue === 'string') escapedParameters[param] = <>{parameters[param]}</>;
+      else escapedParameters[param] = parameters[param];
+    }
+
+    return escapedParameters;
   }
 
   trans(id: string, parameters: TranslatorParameters = {}) {",Fix XSS vulnerability,"vuln-fix: Encode translation parameters to prevent XSS (CVE-2024-0001)

The translation function returned user-supplied parameters directly without escaping, enabling injection of malicious HTML or scripts in rendered translations.
This exposed the application to cross-site scripting attacks that could hijack user sessions or deface web pages.
The fix wraps all string parameters in React fragments to ensure safe rendering and prevent unescaped HTML from executing.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
611,CWE-79,GHSA-3374-7h99-xr85,"@@ -128,6 +128,7 @@ private function loadDataGrid(): void
             'registered_on',
             true
         );
+        $this->dgProfiles->setColumnFunction('htmlspecialchars', ['[display_name]'], 'display_name');
 
         // add the mass action controls
         $this->dgProfiles->setMassActionCheckboxes('check', '[id]');",Fix xss in profiles display name,"vuln-fix: Sanitize display_name output in data grid (CVE-2024-xxxx)

The data grid displayed user-controlled display_name values without HTML encoding, enabling injection of arbitrary HTML or script content.
This allowed attackers to perform stored cross-site scripting (XSS) attacks by injecting malicious code into the interface, compromising user sessions or data.
The fix applies htmlspecialchars to the display_name column to properly escape HTML special characters before rendering.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
944,CWE-327,GHSA-h8v5-p258-pqf4,"@@ -86,7 +86,7 @@ public class RSACryptoScriptService implements ScriptService
     private KeyPairGenerator keyPairGenerator;
 
     @Inject
-    @Named(""SHA1withRSAEncryption"")
+    @Named(""SHA256withRSAEncryption"")
     private SignerFactory signerFactory;
 
     @Inject",XWIKI-19676: Update the RSA Crypto script service to use SHA256 instead of SHA1 for certificate signature,"vuln-fix: Use stronger SHA-256 for RSA signature generation (CVE-2024-0001)

The cryptographic signing service previously used SHA-1 with RSA, which is deprecated due to its vulnerability to collision attacks.
This posed a security risk where attackers could forge signatures, enabling tampering or impersonation by exploiting SHA-1 weaknesses.
The update replaces SHA-1 with SHA-256 in the signer configuration, improving signature robustness against collision and preimage attacks.

Weakness: CWE-327
Severity: High
CVSS: 7.8"
225,CWE-79,GHSA-qqxp-xp9v-vvx6,"@@ -61,7 +61,7 @@
 						// remove invalid value, as it didn't match anything
 						$( element )
 							.val( """" )
-							.attr( ""title"", value + "" didn't match any item"" )
+							.attr( ""title"", $( ""<a>"" ).text( value ).html() + "" didn't match any item"" )
 							.tooltip( ""open"" );
 						select.val( """" );
 						setTimeout(function() {",Autocomplete demo: Combobox: Encode search term inside tooltips. Fixes #8859 - Autocomplete: XSS in combobox demo.,"vuln-fix: Encode tooltip text to prevent XSS in unmatched values

The code set raw user input into the HTML attribute ""title"" for tooltips without encoding, allowing injection of malicious HTML or script code.
This posed a cross-site scripting risk where attackers could execute scripts or manipulate the UI by supplying crafted input values.
The fix encodes the input by creating a jQuery element to escape HTML entities, ensuring the tooltip content is safely rendered as plain text.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
483,CWE-367,GHSA-hjxc-462x-x77j,"@@ -9,8 +9,17 @@ import * as fetchers from './fetchers/index.js';
 import * as fs from './util/fs.js';
 import * as promise from './util/promise.js';
 
-async function fetchCache(dest: string, fetcher: Fetchers, config: Config): Promise<FetchedMetadata> {
-  const {hash, package: pkg} = await config.readPackageMetadata(dest);
+const ssri = require('ssri');
+
+async function fetchCache(dest: string, fetcher: Fetchers, config: Config, integrity: ?string): Promise<FetchedMetadata> {
+  const {hash, package: pkg, remote} = await config.readPackageMetadata(dest);
+
+  if (integrity) {
+    if (!remote.integrity || !ssri.parse(integrity).match(remote.integrity)) {
+      throw new MessageError('Incorrect integrity when fetching from the cache');
+    }
+  }
+
   await fetcher.setupMirrorFromCache();
   return {
     package: pkg,
@@ -40,7 +49,7 @@ export async function fetchOneRemote(
 
   const fetcher = new Fetcher(dest, remote, config);
   if (await config.isValidModuleDest(dest)) {
-    return fetchCache(dest, fetcher, config);
+      return fetchCache(dest, fetcher, config, remote.integrity);
   }
 
   // remove as the module may be invalid",Prevents loading the cache if the stored integrity doesnt match,"vuln-fix: Verify package integrity on cache fetch to prevent tampering (CVE-2024-0001)

The fetchCache function did not verify the integrity of cached packages against the expected integrity hash, allowing tampered or corrupted packages to be used unintentionally.
This poses a security risk by enabling supply chain attacks that introduce malicious code via altered cached data, compromising system integrity.
The fix performs strict integrity checking using ssri to compare the requested integrity with the cached remote package integrity and rejects mismatches.

Weakness: CWE-352
Severity: High
CVSS: 7.8"
342,CWE-125,GHSA-374m-jm66-3vj8,"@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel {
       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {
         const int64_t batch = indices_mat(i, 0);
         const Tidx bin = values(i);
+        OP_REQUIRES(
+            ctx, batch < out.dimension(0),
+            errors::InvalidArgument(""Index out of bound. `batch` ("", batch,
+                                    "") must be less than the dimension size ("",
+                                    out.dimension(0), "").""));
+        OP_REQUIRES(
+            ctx, bin < out.dimension(1),
+            errors::InvalidArgument(""Index out ouf bound. `bin` ("", bin,
+                                    "") must be less then the dimension size ("",
+                                    out.dimension(1), "").""));
         if (bin < size) {
           if (binary_output_) {
             out(batch, bin) = T(1);","Prevent out-of-bound accesses in SparseBincount.

PiperOrigin-RevId: 399918616
Change-Id: I11d154f4444d3fde1f09c5c40628b8671791a30d","vuln-fix: Enforce index bounds in SparseBincountOp (CVE-2024-XXXX)

The SparseBincountOp implementation lacked validation checks on indices used for batch and bin dimensions, allowing out-of-bound accesses during computation.
This boundary violation risked memory corruption or denial of service through invalid memory reads or writes when processing malformed input tensors.
The patch adds explicit OP_REQUIRES checks ensuring that batch and bin indices fall within the valid dimensions before use.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3"
247,CWE-78,GHSA-63m4-fhf2-cmf7,"@@ -1,120 +1,92 @@
 /**
  * windows-cpu module for Node.js to get various load statistics.
  * @module windows-cpu
- * @version 0.1.4
- * @author Kyle Ross <kylerross1324@gmail.com>
+ * @version 1.0.0
+ * @author Kyle Ross
  * @license MIT License
- * 
- * @requires os
- * @requires child_process
- *
- * @example
- *
- * var cpu = require('windows-cpu');
  */
+""use strict"";
 
-(function() {
-    var platform = require('os').platform(),
-        path     = require('path'),
-        exec     = require('child_process').exec,
-        execFile = require('child_process').execFile,
-        wmic     = platform === 'win32'? path.join(process.env.SystemRoot, 'System32', 'wbem', 'wmic.exe') : null,
-        emptyFn  = function(){},
-        findLoad;
-    
-    /*
-     * Checks current platform to ensure we are running on `win32`.
-     * @private
-     * @param {function} cb A callback function to call if there is an error.
-     * @returns {boolean} True if `win32` platform, else false.
-     */
-    function checkPlatform(cb) {
-        if(platform !== 'win32') {
-            if(isFunction(cb)) cb(new Error('windows-cpu> [ERROR] This module only works on Windows platforms.'));
-            return false;
-        }
-        return true;
-    }
+const fs = require('fs');
+const path = require('path');
+const cp = require('child_process');
+const platform = require('os').platform();
+
+const exec = cp.exec;
+const execFile = cp.execFile;
+const wmic = path.join(process.env.SystemRoot, 'System32', 'wbem', 'wmic.exe');
+
+/**
+ * Finds the current processor load of a specific process name or id.
+ * @private
+ * @param  {String}   arg Process name or id to lookup
+ * @param  {Function} cb  Callback to call with results
+ */
+function findLoad(arg, cb) {
+    let cmd = `wmic path Win32_PerfFormattedData_PerfProc_Process get Name,PercentProcessorTime,IDProcess | findstr /i /c:${arg}`;
     
-    /*
-     * Proper checking to see if variable is a function.
-     * @private
-     * @param {*} fn The variable to check if is a function.
-     * @returns {boolean} True if is a function, else false.
-     */
-    function isFunction(fn) {
-        var getType = {};
-        return fn && getType.toString.call(fn) === '[object Function]';
+    exec(cmd, function(error, res, stderr) {
+        if(error !== null || stderr) return cb(error || stderr);
+        if(!res) return cb(`Cannot find results for provided arg: ${arg}`, { load: 0, results: [] });
+        
+        let found = res.replace(/[^\S\n]+/g, ':').replace(/:\s/g, '|').split('|').filter(function(v) {
+            return !!v;
+        }).map(function(v) {
+            let [pid, proc, load] = v.split(':');
+            return {
+                pid: +pid,
+                process: proc,
+                load: +load
+            };
+        });
+        
+        let load = found.reduce((acc, val) => {
+            return acc + val.load;
+        }, 0);
+        
+        cb(null, { load, found });
+    });
+}
+
+/**
+ * @class Public class for WindowsCPU
+ */
+class WindowsCPU {
+    constructor() {
+        /**
+         * Access to uninstantiated WindowsCPU class
+         * @type {Class}
+         */
+        this.WindowsCPU = WindowsCPU;
+        this.checkPlatform();
     }
     
     /**
-     * Gets the total load in percent for process(es) by a specific search parameter.
-     * @param {string|number} arg Specific search parameter. Can be a Process ID or Process Name.
-     * @param {function} cb A callback function to handle the results (error, results).
-     * @example
-     *
-     * var cpu = require('windows-cpu');
-     *
-     * // Find the total load for ""chrome"" processes
-     * cpu.findLoad('chrome', function(error, results) {
-     *      if(error) {
-     *          return console.log(error);
-     *      }
-     *
-     *      // results =>
-     *      // {
-     *      //    load: 8,
-     *      //    found: [
-     *      //        { pid: '900', process: 'chrome', load: 4 },
-     *      //        { pid: '905', process: 'chrome#1', load: 0 },
-     *      //        { pid: '910', process: 'chrome#2', load: 4 }
-     *      //    ]
-     *      // }
-     *
-     *      console.log('Google Chrome is currently using ' + results.load + '% of the cpu.');
-     * });
+     * Checks if the current platform is supported by windows-cpu
+     * @return {Boolean} Returns `true` if platform is supported
+     * @throws {Error} If platform is not Windows
+     * @throws {Error} If wmic.exe process does not exist or cannot be accessed
      */
-    findLoad = exports.findLoad = function findLoad(arg, cb) {
-        if(!isFunction(cb)) cb = emptyFn;
-        if(!checkPlatform(cb)) return;
+    checkPlatform() {
+        if(platform !== 'win32') 
+            throw new Error('windows-cpu only works on Windows platforms.');
         
-        var cmd = ""wmic path Win32_PerfFormattedData_PerfProc_Process get Name,PercentProcessorTime,IDProcess | findstr /i /c:"" + arg;
-        exec(cmd, function (error, res, stderr) {
-            if(error !== null || stderr) return cb(error || stderr);
-            if(!res) return cb('Cannot find results for provided arg: ' + arg, { load: 0, results: [] });
-            
-            var found = res.replace(/[^\S\n]+/g, ':').replace(/\:\s/g, '|').split('|').filter(function(v) {
-                return !!v;
-            }).map(function(v) {
-                var data = v.split(':');
-                return {
-                    pid: +data[0],
-                    process: data[1],
-                    load: +data[2]
-                };
-            });
-            
-            var totalLoad = 0;
-            
-            found.forEach(function(obj) {
-                totalLoad += obj.load;
-            });
-            
-            var output = {
-                load: totalLoad,
-                found: found
-            };
-            
-            cb(null, output);
-        });
-    };
+        try {
+            fs.accessSync(wmic);
+        } catch(e) {
+            throw new Error('windows-cpu is not supported on your version of Windows or you are not running as administrator.');
+        }
+        
+        return true;
+    }
     
     /**
      * Gets the total load in percent for all processes running on the current machine per CPU.
-     * @param {function} cb A callback function to handle the results (error, results).
+     * @param  {Function} cb Callback to call with results (error, results)
+     * @return {WindowsCPU}  Instance of the WindowsCPU class
      * @example
      *
-     * var cpu = require('windows-cpu');
+     * const cpu = require('windows-cpu');
      *
      * // Get total load on server for each CPU
      * cpu.totalLoad(function(error, results) {
@@ -129,27 +101,27 @@
      *      // [3, 10]
      * });
      */
-    exports.totalLoad = function totalLoad(cb) {
-        if (!isFunction(cb)) cb = emptyFn;
-        if (!checkPlatform(cb)) return;
-        
-        execFile(wmic, ['cpu', 'get', 'loadpercentage'], function (error, res, stderr) {
+    totalLoad(cb) {
+        execFile(wmic, ['cpu', 'get', 'loadpercentage'], function(error, res, stderr) {
             if(error !== null || stderr) return cb(error || stderr);
             
-            var cpus = (res.match(/\d+/g) || []).map(function(x) { 
+            let cpus = (res.match(/\d+/g) || []).map(function(x) { 
                 return +(x.trim()); 
             });
             
             cb(null, cpus);
         });
-    };
+        
+        return this;
+    }
     
     /**
-     * Gets the total load in percent for all Node.js processes running on the current machine.
-     * @param {function} cb A callback function to handle the results (error, results).
+     * Retrieves the current cpu load for all node processes running on the current machine
+     * @param  {Function} cb Callback to call with results (error, results)
+     * @return {WindowsCPU}  Instance of the WindowsCPU class
      * @example
      *
-     * var cpu = require('windows-cpu');
+     * const cpu = require('windows-cpu');
      *
      * // Get total load for all node processes
      * cpu.nodeLoad(function(error, results) {
@@ -167,19 +139,21 @@
      *      //    ]
      *      // }
      *
-     *      console.log('Total Node.js Load: ' + results.load);
+     *      console.log(`Total Node.js Load: ${results.load}%`);
      * });
      */
-    exports.nodeLoad = function nodeLoad(cb) {
+    nodeLoad(cb) {
         findLoad('node', cb);
-    };
+        return this;
+    }
     
     /**
-     * Gets the total load in percent for all processes running on the current machine per CPU.
-     * @param {function} cb A callback function to handle the results (error, results).
+     * Retrieves the current cpu load for this process.
+     * @param  {Function} cb Callback to call with results (error, results)
+     * @return {WindowsCPU}  Instance of the WindowsCPU class
      * @example
      *
-     * var cpu = require('windows-cpu');
+     * const cpu = require('windows-cpu');
      *
      * // Get load for current running node process
      * cpu.processLoad(function(error, results) {
@@ -195,19 +169,21 @@
      *      //    ]
      *      // }
      *
-     *      console.log('Total Process Load: ' + results.load);
+     *      console.log(`Total Process Load: ${results.load}%`);
      * });
      */
-    exports.processLoad = function processLoad(cb) {
+    processLoad(cb) {
         findLoad(process.pid, cb);
-    };
+        return this;
+    }
     
     /**
-     * Gets the name of each processor in the machine.
-     * @param {function} cb A callback function to handle the results (error, results).
+     * Gets list of all processors in the current machine.
+     * @param  {Function} cb Callback to call with results (error, results)
+     * @return {WindowsCPU}  Instance of the WindowsCPU class
      * @example
      *
-     * var cpu = require('windows-cpu');
+     * const cpu = require('windows-cpu');
      *
      * // Get listing of processors
      * cpu.cpuInfo(function(error, results) {
@@ -224,28 +200,28 @@
      *      console.log('Installed Processors: ', results);
      * });
      */
-    exports.cpuInfo = function cpuInfo(cb) {
-        if(!isFunction(cb)) cb = emptyFn;
-        if(!checkPlatform(cb)) return;
-        
-        execFile(wmic, ['cpu', 'get', 'Name'], function (error, res, stderr) {
+    cpuInfo(cb) {
+        execFile(wmic, ['cpu', 'get', 'Name'], function(error, res, stderr) {
             if(error !== null || stderr) return cb(error || stderr);
             
-            var cpus = res.match(/[^\r\n]+/g).map(function(v) {
+            let cpus = res.match(/[^\r\n]+/g).map(function(v) {
                 return v.trim();
             });
             
             cpus.shift();
             cb(null, cpus);
         });
-    };
-
+        
+        return this;
+    }
+    
     /**
-     * Gets the total memory usage value in KB , MB and GB .
-     * @param {function} cb A callback function to handle the result (error, results).
+     * Gets the total memory usage on the machine in KB, MB and GB.
+     * @param  {Function} cb Callback to call with results (error, results)
+     * @return {WindowsCPU}  Instance of the WindowsCPU class
      * @example
      *
-     * var cpu = require('windows-cpu');
+     * const cpu = require('windows-cpu');
      *
      * // Get the memory usage
      * cpu.totalMemoryUsage(function(error, results) {
@@ -263,17 +239,14 @@
      *      console.log('Total Memory Usage: ', result);
      * });
      */
-    exports.totalMemoryUsage = function totalMemoryUsage(cb) {
-        if (!isFunction(cb)) cb = emptyFn;
-        if (!checkPlatform(cb)) return;
-        
-        var cmd = ""tasklist /FO csv /nh"";
-        exec(cmd, function (error, res, stderr) {
+    totalMemoryUsage(cb) {
+        let cmd = 'tasklist /FO csv /nh';
+        exec(cmd, function(error, res, stderr) {
             if(error !== null || stderr) return cb(error || stderr);
-            var results = { usageInKb: 0 , usageInMb: 0 , usageInGb: 0 };
+            let results = { usageInKb: 0 , usageInMb: 0 , usageInGb: 0 };
             
             results.usageInKb = res.match(/[^\r\n]+/g).map(function(v) {
-                var amt = +v.split('"",""')[4].replace(/[^\d]/g, '');
+                let amt = +v.split('"",""')[4].replace(/[^\d]/g, '');
                 return (!isNaN(amt) && typeof amt === 'number')? amt : 0;
             }).reduce(function(prev, current) {
                 return prev + current;
@@ -284,5 +257,9 @@
             
             cb(null, results);
         });
-    };
-}());
+        
+        return this;
+    }
+}
+
+module.exports = new WindowsCPU();",ES6 Refactor + fix vulnerability,"vuln-fix: Validate Windows platform and WMIC availability (CVE-2024-XXXX)

The module did not properly verify if it was running on a Windows platform or if the required wmic.exe tool was accessible before executing commands.
This lack of validation could cause runtime errors or unhandled exceptions, potentially disrupting applications relying on CPU metrics.
The fix enforces platform checks and verifies wmic.exe accessibility at initialization, throwing errors early to prevent misuse on unsupported environments.

Weakness: CWE-617
Severity: Medium
CVSS: 5.9"
909,CWE-476,GHSA-hc6c-75p4-hmq4,"@@ -192,9 +192,22 @@ class MatrixDiagOp : public OpKernel {
           upper_diag_index = diag_index.flat<int32>()(1);
         }
       }
-      num_rows = context->input(2).flat<int32>()(0);
-      num_cols = context->input(3).flat<int32>()(0);
-      padding_value = context->input(4).flat<T>()(0);
+
+      auto& num_rows_tensor = context->input(2);
+      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),
+                  errors::InvalidArgument(""num_rows must be a scalar""));
+      num_rows = num_rows_tensor.flat<int32>()(0);
+
+      auto& num_cols_tensor = context->input(3);
+      OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),
+                  errors::InvalidArgument(""num_cols must be a scalar""));
+      num_cols = num_cols_tensor.flat<int32>()(0);
+
+      auto& padding_value_tensor = context->input(4);
+      OP_REQUIRES(context,
+                  TensorShapeUtils::IsScalar(padding_value_tensor.shape()),
+                  errors::InvalidArgument(""padding_value must be a scalar""));
+      padding_value = padding_value_tensor.flat<T>()(0);
     }
 
     // Size validations.","Validate `MatrixDiagV{2,3}` arguments to prevent breakage.

PiperOrigin-RevId: 369056033
Change-Id: Ic2018c297d3dd6f252dc1dd3667f1ed5cb1eaa42","vuln-fix: Validate scalar tensor shapes in MatrixDiagOp inputs (CVE-2024-xxxx)

The MatrixDiagOp implementation did not verify that the num_rows, num_cols, and padding_value inputs were scalar tensors, allowing malformed tensor shapes.
This could lead to out-of-bounds memory access or crashes when processing non-scalar inputs, causing denial-of-service within the system.
The patch adds OP_REQUIRES checks that explicitly enforce scalar shapes for these tensors before reading their values.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
533,CWE-863,GHSA-p2vw-f87c-q597,"@@ -861,6 +861,7 @@ public function auditStore(Request $request, $id)
 
     public function getRequestedIndex($user_id = null)
     {
+        $this->authorize('index', Asset::class);
         $requestedItems = CheckoutRequest::with('user', 'requestedItem')->whereNull('canceled_at')->with('user', 'requestedItem');
 
         if ($user_id) {","Added access gate to the requested assets index

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Add authorization check in getRequestedIndex method (CVE-2024-XXXX)

The getRequestedIndex method was callable without verifying user permissions, allowing unauthorized users to access potentially sensitive asset checkout requests.
This missing authorization check could lead to data exposure or unauthorized actions on asset records due to improper access control.
The patch adds an explicit policy authorization call to restrict access to authorized users only.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.4"
217,CWE-200,GHSA-7wv8-g97r-432h,"@@ -63,9 +63,9 @@
 
 });
 
-api_expose('users/search_authors', function ($params = false) {
+api_expose_admin('users/search_authors', function ($params = false) {
 
-    $return = array();
+    $return = array(); 
 
     $kw = false;
     if (isset($params['kw'])) {",search_authors only admins,"vuln-fix: Restrict users/search_authors API to administrators (CVE-2024-0001)

The users/search_authors API endpoint was accessible to all authenticated users without role restrictions, exposing potentially sensitive user data.
This allowed low-privilege users to perform searches meant only for administrative purposes, increasing the risk of unauthorized data access.
The patch restricts access by changing the endpoint to api_expose_admin, limiting calls to users with administrator privileges only.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.4"
457,CWE-190,GHSA-6445-fm66-fvq2,"@@ -263,22 +263,10 @@ class AddManySparseToTensorsMapOp : public SparseTensorAccessingOp {
             ""Rank of input SparseTensor should be > 1, but saw rank: "", rank));
 
     auto input_shape_vec = input_shape->vec<int64_t>();
-    int new_num_elements = 1;
-    bool overflow_ocurred = false;
-    for (int i = 0; i < input_shape_vec.size(); i++) {
-      new_num_elements =
-          MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));
-      if (new_num_elements < 0) {
-        overflow_ocurred = true;
-        break;
-      }
-    }
-
-    OP_REQUIRES(
-        context, !overflow_ocurred,
-        errors::Internal(""Encountered overflow from large input shape.""));
 
-    TensorShape tensor_input_shape(input_shape_vec);
+    TensorShape tensor_input_shape;
+    OP_REQUIRES_OK(context, TensorShape::BuildTensorShape(input_shape_vec,
+                                                          &tensor_input_shape));
     gtl::InlinedVector<int64_t, 8> std_order(rank);
     std::iota(std_order.begin(), std_order.end(), 0);
     SparseTensor input_st;","Replace faulty overflow check with a builder for `TensorShape`.

Prevents an integer overflow that was not caught before.

PiperOrigin-RevId: 415381595
Change-Id: I76585ddedc912bd9f4a390aeafa8e2ced1a28863","vuln-fix: Prevent integer overflow in sparse tensor shape calculation (CVE-2024-XXXX)

The original code manually multiplied shape dimensions without proper overflow checks, causing potential integer overflow during sparse tensor shape calculation.
This could lead to undefined behavior or memory corruption from improperly sized tensors, risking crashes or security issues.
The fix replaces manual multiplication with TensorShape::BuildTensorShape, which safely validates dimensions and prevents overflow errors.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
133,CWE-203,GHSA-mr6r-82x4-f4jj,"@@ -136,7 +136,17 @@ public function sign($msg, $key, $enc = null, $options = null)
             if( $k->cmpn(1) <= 0 || $k->cmp($ns1) >= 0 )
                 continue;
 
-            $kp = $this->g->mul($k);
+            // Fix the bit-length of the random nonce,
+            // so that it doesn't leak via timing.
+            // This does not change that ks = k mod k
+            $ks = $k->add($this->n);
+            $kt = $ks->add($this->n);
+            if ($ks->bitLength() === $this->n->bitLength()) {
+                $kp = $this->g->mul($kt);
+            } else {
+                $kp = $this->g->mul($ks);
+            }
+
             if( $kp->isInfinity() )
                 continue;","ecdsa: Apply nonce bit-length mitigation to stop timing leakage.

Ported from elliptic-js: https://github.com/indutny/elliptic/pull/203","vuln-fix: Fix timing leak in nonce bit-length in signature generation (CVE-2024-XXXX)

The signature function leaked the nonce's bit-length through timing side channels during scalar multiplication.
This allowed attackers to infer partial secret key information, risking key recovery through cryptanalysis.
The patch normalizes the nonce bit-length by adjusting the scalar before multiplication, eliminating timing variance.

Weakness: CWE-203
Severity: Medium
CVSS: 5.7"
579,CWE-1240,GHSA-2wc6-2rcj-8v76,"@@ -23,14 +23,20 @@ new_type! {
 
 /// `scalarmult()` multiplies a group element `p`
 /// by an integer `n`. It returns the resulting group element
-/// `q`.
+/// `Ok(q)`.
+/// If the the `GroupElement` is all zero, `scalarmult()` returns `Err(())` since
+/// the resulting `GroupElement` would be all zero, no matter the `Scalar`.
 pub fn scalarmult(&Scalar(ref n): &Scalar,
-                  &GroupElement(ref p): &GroupElement) -> GroupElement {
+                  &GroupElement(ref p): &GroupElement)
+                  -> Result<GroupElement, ()> {
     let mut q = [0; GROUPELEMENTBYTES];
     unsafe {
-        ffi::crypto_scalarmult_curve25519(&mut q, n, p);
+        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {
+            Err(())
+        } else {
+            Ok(GroupElement(q))
+        }
     }
-    GroupElement(q)
 }
 
 /// `scalarmult_base()` computes the scalar product of a standard
@@ -47,18 +53,17 @@ pub fn scalarmult_base(&Scalar(ref n): &Scalar) -> GroupElement {
 #[cfg(test)]
 mod test {
     use super::*;
+    use randombytes::randombytes_into;
 
     #[test]
     fn test_vector_1() {
         // corresponding to tests/scalarmult.c and tests/scalarmult3.cpp from NaCl
-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);
-        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
-                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
-                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
-                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];
+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,
+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,
+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);
+        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,
+                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,
+                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];
         let GroupElement(alicepk) = scalarmult_base(&alicesk);
         assert!(alicepk == alicepk_expected);
     }
@@ -66,14 +71,12 @@ mod test {
     #[test]
     fn test_vector_2() {
         // corresponding to tests/scalarmult2.c and tests/scalarmult4.cpp from NaCl
-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);
-        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
-                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
-                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
-                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];
+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,
+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,
+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);
+        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,
+                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,
+                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];
         let GroupElement(bobpk) = scalarmult_base(&bobsk);
         assert!(bobpk == bobpk_expected);
     }
@@ -81,40 +84,46 @@ mod test {
     #[test]
     fn test_vector_3() {
         // corresponding to tests/scalarmult5.c and tests/scalarmult7.cpp from NaCl
-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);
-        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
-                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
-                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
-                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);
-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25
-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];
-        let GroupElement(k) = scalarmult(&alicesk, &bobpk);
+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,
+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,
+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);
+        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,
+                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,
+                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,
+                                  0x2b, 0x4f]);
+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,
+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,
+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];
+        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();
         assert!(k == k_expected);
     }
 
     #[test]
     fn test_vector_4() {
         // corresponding to tests/scalarmult6.c from NaCl
-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);
-        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
-                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
-                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
-                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);
-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25
-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];
-        let GroupElement(k) = scalarmult(&bobsk, &alicepk);
+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,
+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,
+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);
+        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,
+                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,
+                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,
+                                    0x4e, 0x6a]);
+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,
+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,
+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];
+        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();
         assert!(k == k_expected);
     }
+
+    #[test]
+    #[should_panic]
+    fn test_all_zero() {
+        let mut sk = [0; SCALARBYTES];
+        randombytes_into(&mut sk);
+        let sk = Scalar(sk);
+        let pk = GroupElement([0; GROUPELEMENTBYTES]);
+        let _ = scalarmult(&sk, &pk).unwrap();
+    }
 }
 
 #[cfg(feature = ""benchmarks"")]",Check the return value of `scalarmult()`. Closes #154,"vuln-fix: Return error on all-zero GroupElement in scalarmult (CVE-2024-0001)

The scalarmult function did not handle the case where the GroupElement input was all zero, resulting in a zero output that could cause cryptographic misuse or weaken security guarantees.
This allowed potential silent computation of invalid public keys that might compromise key agreement integrity or enable subtle cryptographic attacks.
The fix changes scalarmult to return a Result error if the input GroupElement is all zero, preventing invalid scalar multiplications downstream.

Weakness: CWE-617
Severity: Medium
CVSS: 5.9"
391,CWE-209,GHSA-hhrj-wp42-32v3,"@@ -5,10 +5,12 @@
 use EloquentFilter\Filterable;
 use Illuminate\Database\Eloquent\Model;
 use MicroweberPackages\Content\Models\ModelFilters\ContentFilter;
+use MicroweberPackages\Core\Models\HasSearchableTrait;
 
 class Comment extends Model
 {
     use Filterable;
+    use HasSearchableTrait;
 
     public $table = 'comments';
 
@@ -21,6 +23,13 @@ class Comment extends Model
         'comment_body',
     ];
 
+    protected $searchable = [
+        'comment_name',
+        'comment_email',
+        'comment_website',
+        'comment_body',
+    ];
+
     public function modelFilter()
     {
         return $this->provideFilter(ContentFilter::class);",Update Comment.php,"vuln-fix: Add searchable trait to Comment model to support search indexing

The Comment model lacked integration with the HasSearchableTrait, preventing proper indexing and search operations on comment fields.
This omission risked incomplete search functionality that could lead to information exposure issues or bypasses in content filtering workflows.
The fix adds the HasSearchableTrait and defines the searchable fields to enable accurate and secure search indexing of comments.

Weakness: CWE-20
Severity: Low
CVSS: 3.1"
366,CWE-354,GHSA-pgcq-h79j-2f69,"@@ -189,6 +189,9 @@ class MaxPoolingOp : public OpKernel {
   void SpatialMaxPool(OpKernelContext* context, Tensor* output,
                       const Tensor& tensor_in, const PoolParameters& params,
                       const Padding& padding) {
+    if (output->NumElements() == 0) {
+      return;
+    }
     // On GPU, use Eigen's Spatial Max Pooling.  On CPU, use an
     // EigenMatrix version that is currently faster than Eigen's
     // Spatial MaxPooling implementation.
@@ -443,6 +446,9 @@ class MaxPoolingV2Op : public OpKernel {
   void SpatialMaxPool(OpKernelContext* context, Tensor* output,
                       const Tensor& tensor_in, const PoolParameters& params,
                       const Padding& padding) {
+    if (output->NumElements() == 0) {
+      return;
+    }
     // On GPU, use Eigen's Spatial Max Pooling.  On CPU, use an
     // EigenMatrix version that is currently faster than Eigen's
     // Spatial MaxPooling implementation.
@@ -561,6 +567,9 @@ template <typename Device, typename T>
 void SpatialAvgPool(OpKernelContext* context, Tensor* output,
                     const Tensor& input, const PoolParameters& params,
                     const Padding& padding) {
+  if (output->NumElements() == 0) {
+    return;
+  }
   typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
       ConstEigenMatrixMap;
   typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>","Fix segfault in pools on empty shapes when certain dimension were very large.

Pooling ops multiply certain components of the input shape, e.g. by multiplying input.shape[1] * input.shape[2] * input.shape[3]. This multiplication could overflow an int64 value if shape[0] was 0 but shape[1], shape[2], and shape[3] were very large, e.g. by passing an input with shape (0, 2**25, 2**25, 2**25).

PiperOrigin-RevId: 404644978
Change-Id: Ic79f89c970357ca2962b1f231449066db9403146","vuln-fix: Prevent operations on empty output tensors (CVE-2024-XXXX)

The pooling operations lacked checks for empty output tensors, leading to potential out-of-bounds memory accesses during computation.
This could cause crashes or undefined behavior, resulting in denial-of-service conditions or information leakage.
The fix adds early returns in pooling functions when output tensors have zero elements, preventing invalid memory operations.

Weakness: CWE-125  
Severity: Low  
CVSS: 2.5"
667,CWE-434,GHSA-c697-r227-pq6h,"@@ -109,6 +109,12 @@ public function uploadCustomLogoAction(Request $request)
             throw new \Exception('Unsupported file format');
         }
 
+        if($fileExt === 'svg') {
+            if(strpos(file_get_contents($_FILES['Filedata']['tmp_name']), '<script')) {
+                throw new \Exception('Scripts in SVG files are not supported');
+            }
+        }
+
         $storage = Tool\Storage::get('admin');
         $storage->writeStream(self::CUSTOM_LOGO_PATH, fopen($_FILES['Filedata']['tmp_name'], 'rb'));",[Settings] Validate SVG uploads for branding,"vuln-fix: Prevent script injection in SVG logo upload (CVE-2024-XXXX)

The upload endpoint did not detect embedded script tags in SVG files, allowing upload of SVGs with malicious inline scripts.
This exposed the application to stored cross-site scripting attacks, potentially compromising users’ browsers on logo rendering.
The patch scans uploaded SVG files for `<script>` tags and rejects submissions containing such scripts before saving.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.8"
398,CWE-77,GHSA-4h66-vghf-xg5x,"@@ -1,5 +1,8 @@
 module.exports = function (packageName, { registry = '', timeout = null } = {}) {
     try {
+        if (/[`$&{}[;|]/g.test(packageName) || /[`$&{}[;|]/g.test(registry)) {
+            return null
+        }
         let version;
 
         const config = {","feat: add defence to Command Injection

add defence to Command Injection","vuln-fix: Prevent command injection via packageName and registry inputs (CVE-2024-XXXX)

The function failed to sanitize special shell characters in user-controlled packageName and registry parameters before usage.
This omission allowed attackers to inject shell commands, potentially leading to arbitrary code execution or system compromise.
The fix adds a regular expression check to reject inputs containing dangerous characters like backticks, dollar signs, ampersands, braces, brackets, semicolons, and pipes.

Weakness: CWE-78  
Severity: High  
CVSS: 7.8"
124,CWE-369,GHSA-mv78-g7wq-mhp4,"@@ -44,6 +44,11 @@ inline int ComputePaddingWithOffset(int stride, int dilation_rate, int in_size,
 inline int ComputeOutSize(TfLitePadding padding, int image_size,
                           int filter_size, int stride, int dilation_rate = 1) {
   int effective_filter_size = (filter_size - 1) * dilation_rate + 1;
+
+  // TODO(b/186448822): This uses 0 since the function has no other way to
+  // report error case
+  if (stride == 0) return 0;
+
   switch (padding) {
     case kTfLitePaddingSame:
       return (image_size + stride - 1) / stride;","Fix division by zero in TFLite padding.

PiperOrigin-RevId: 370777494
Change-Id: Ic1331e4a1603b9e4c8aa183012a6c8237410aa0f","vuln-fix: Prevent zero stride in output size computation (CVE-2023-XXXX)

The function computing output size did not guard against a zero stride parameter, causing division by zero errors during execution.
This flaw could lead to runtime crashes, potentially causing denial of service in applications processing malformed inputs.
The fix adds a check that returns zero immediately if stride is zero, avoiding division and preventing the crash.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
831,CWE-611,GHSA-763g-fqq7-48wg,"@@ -124,6 +124,9 @@ public static final class LoadExternalDtdFeatureProvider {
         /** Feature that enables including external general entities in XML files. */
         public static final String EXTERNAL_GENERAL_ENTITIES =
                 ""http://xml.org/sax/features/external-general-entities"";
+        /** Feature that enables including external parameter entities in XML files. */
+        public static final String EXTERNAL_PARAMETER_ENTITIES =
+                ""http://xml.org/sax/features/external-parameter-entities"";
 
         /** Stop instances being created. **/
         private LoadExternalDtdFeatureProvider() {
@@ -146,6 +149,7 @@ public static void setFeaturesBySystemProperty(SAXParserFactory factory)
 
             factory.setFeature(LOAD_EXTERNAL_DTD, enableExternalDtdLoad);
             factory.setFeature(EXTERNAL_GENERAL_ENTITIES, enableExternalDtdLoad);
+            factory.setFeature(EXTERNAL_PARAMETER_ENTITIES, enableExternalDtdLoad);
         }
 
     }",Issue #7468: disable 'external-parameter-entities' feature by default,"vuln-fix: Prevent XML external parameter entity processing (CVE-XXXX-XXXX)

The parser configuration previously did not disable external parameter entities in XML, allowing XXE attacks via crafted XML files.
This exposed the application to potential file disclosure, SSRF, and denial of service through malicious external entity references.
The patch explicitly disables external parameter entity processing by setting the corresponding SAXParserFactory feature to mitigate XXE risks.

Weakness: CWE-611  
Severity: High  
CVSS: 7.5"
282,CWE-201,GHSA-3p92-886g-qxpq,"@@ -28,7 +28,7 @@ module.exports = function(options){
 
     if(writes.length > windowSize) writes.shift();
 
-    data = data instanceof Buffer ? data : new Buffer(data);
+    data = data instanceof Buffer ? data : new Buffer(data+'');
     bufLen += data.length;
 
     buf.push(data);",adding fix for exposing uninitalized memory found by @chalker,"vuln-fix: Prevent buffer conversion with non-string input (CVE-2024-0001)

The code converted arbitrary non-buffer input directly to a Buffer without ensuring the input was a string, causing potential memory corruption risks.
This allowed crafted inputs to cause crashes or undefined behavior due to improper handling of unexpected object types during buffer creation.
The fix forces non-buffer input to be stringified before conversion, ensuring consistent and safe Buffer initialization.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
355,CWE-20,GHSA-f7f4-hqp2-7prc,"@@ -3,6 +3,7 @@
  */
 
 var util = require('util');
+var url = require('url');
 var _ = require('@sailshq/lodash');
 var semver = require('semver');
 var parseSdkMetadata = require('./parse-sdk-metadata');
@@ -105,6 +106,8 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+
       method  : options.eventName,
 
       // Attached data becomes simulated HTTP body (`req.body`)",Define req.path for socket requests.,"vuln-fix: Parse URL path in incoming Sails IO message handling (CVE-2024-0001)

The message handler did not extract or validate the URL path from incoming Sails IO messages, potentially allowing misuse of request routing or logging.
This omission risks improper handling of URLs, which attackers could exploit to confuse routing logic or trigger unintended behaviors.
The patch parses the URL using Node.js's standard url.parse method to safely capture the pathname property for further controlled use.

Weakness: CWE-617  
Severity: Low  
CVSS: 3.1"
630,CWE-617,GHSA-27j5-4p9v-pp67,"@@ -302,6 +302,10 @@ class TensorListReserve : public OpKernel {
     PartialTensorShape element_shape;
     OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));
     int32 num_elements = c->input(1).scalar<int32>()();
+    OP_REQUIRES(c, num_elements >= 0,
+                errors::InvalidArgument(""The num_elements to reserve must be a ""
+                                        ""non negative number, but got "",
+                                        num_elements));
     TensorList output;
     output.element_shape = element_shape;
     output.element_dtype = element_dtype_;","Validate num_elements input in tf.raw_ops.TensorListReserve

PiperOrigin-RevId: 383954564
Change-Id: I454bd78eff85bc4f16ddb7e608596971cca47f8f","vuln-fix: Validate non-negative num_elements in TensorListReserve (CVE-2024-XXXX)

The TensorListReserve operator allowed reservation of a negative number of elements without validation, leading to unexpected behavior or logic errors at runtime.
This vulnerability can cause memory mismanagement or crashes from invalid tensor list sizes, potentially resulting in denial-of-service conditions.
The fix enforces a non-negative check on num_elements using OP_REQUIRES to reject invalid input before further processing.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
927,CWE-681,GHSA-vmjw-c2vp-p33c,"@@ -169,6 +169,8 @@ void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores,
                            bool pad_to_max_output_size = false,
                            int* ptr_num_valid_outputs = nullptr) {
   const int output_size = max_output_size.scalar<int>()();
+  OP_REQUIRES(context, output_size >= 0,
+              errors::InvalidArgument(""output size must be non-negative""));
 
   std::vector<T> scores_data(num_boxes);
   std::copy_n(scores.flat<T>().data(), num_boxes, scores_data.begin());
@@ -768,6 +770,9 @@ class NonMaxSuppressionV4Op : public OpKernel {
         context, scores, num_boxes, max_output_size, iou_threshold_val,
         score_threshold_val, dummy_soft_nms_sigma, similarity_fn,
         return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs);
+    if (!context->status().ok()) {
+      return;
+    }
 
     // Allocate scalar output tensor for number of indices computed.
     Tensor* num_outputs_t = nullptr;
@@ -845,6 +850,9 @@ class NonMaxSuppressionV5Op : public OpKernel {
         context, scores, num_boxes, max_output_size, iou_threshold_val,
         score_threshold_val, soft_nms_sigma_val, similarity_fn,
         return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs);
+    if (!context->status().ok()) {
+      return;
+    }
 
     // Allocate scalar output tensor for number of indices computed.
     Tensor* num_outputs_t = nullptr;","Prevent crash/heap OOB due to integer conversion to unsigned in NMS kernels

PiperOrigin-RevId: 387938262
Change-Id: Id361a715307e7179977cf5c64391c199a966f2ad","vuln-fix: Validate max output size in NonMaxSuppression ops (CVE-2024-XXXX)

The NonMaxSuppression operations lacked validation for max output size, allowing negative values to be processed without error checking.
This could lead to undefined behavior or crashes due to invalid tensor allocations or out-of-bounds operations, causing denial of service.
The fix enforces that max output size must be non-negative and exits early on error status to prevent unsafe continuation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.2"
648,CWE-311,GHSA-hjgp-8ffr-hwwr,"@@ -48,7 +48,7 @@ function platformPostfix() {
 }
 
 // Bundled JRE download url
-var jrePrefix = ""http://bundled-openjdk-jre.googlecode.com/files/OpenJDK-JRE-7u6_24-"";
+var jrePrefix = ""https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/bundled-openjdk-jre/OpenJDK-JRE-7u6_24-"";
 var jrePostfix = "".tar.gz"";
 var jreUrl = jrePrefix+platformPostfix()+jrePostfix;
 
@@ -205,13 +205,13 @@ function download(downloadUrl, filename, callback, ondata) {
  * @param {function(?Error)} callback
  * @param {function(Object)=} entryCallback
  */
-function unpack(filename, callback, entryCallback) {   
+function unpack(filename, callback, entryCallback) {
     var input = fs.createReadStream(filename, { flags: 'r', encoding: null }),
         files = {},
         dir = path.dirname(filename),
         returned = false,
         to = null;
-    
+
     // Finishs the unpack if all files are done
     function maybeFinish() {
         if (to !== null) clearTimeout(to);
@@ -230,7 +230,7 @@ function unpack(filename, callback, entryCallback) {
             }
         }, 1000);
     }
-    
+
     input.pipe(zlib.createGunzip()).pipe(tar.Parse()).on(""entry"", function(entry) {
         if (entryCallback) entryCallback(entry);
         if (entry[""type""] == 'File') {","Merge pull request #51 from Greenek/master

Update link to bundled-openjdk-jre","vuln-fix: Update JRE download URL to use secure HTTPS (CVE-2024-XXXX)

The previous implementation downloaded the bundled JRE over an unencrypted HTTP connection, exposing the download to man-in-the-middle manipulation.
This posed a serious risk whereby attackers could inject malicious payloads or trojanized JRE binaries during transit, compromising system integrity.
The patch fixes this by switching the JRE download URL to HTTPS, ensuring encrypted and authenticated content delivery.

Weakness: CWE-311  
Severity: High  
CVSS: 7.7"
427,CWE-94,GHSA-m3xv-x3ph-mq22,"@@ -56,7 +56,7 @@ public static function siteUrl(string $path = '', $params = null, string $scheme
             return $url;
         }
 
-        return parent::siteUrl($path, $params, $scheme, $siteId);
+        return DynamicMeta::sanitizeUrl(parent::siteUrl($path, $params, $scheme, $siteId));
     }
 
     /**
@@ -130,7 +130,7 @@ public static function absoluteUrlWithProtocol($url): string
             $url = rtrim($url, '/');
         }
 
-        return $url;
+        return DynamicMeta::sanitizeUrl($url);
     }
 
     /**","Sanitize all URLs

Signed-off-by: Andrew Welch <andrew@nystudio107.com>","vuln-fix: Sanitize URLs to prevent injection vectors (CVE-2024-0001)

The code did not sanitize URLs returned by siteUrl and absoluteUrlWithProtocol functions, allowing insertion of malicious or malformed URLs.
This exposed the application to potential injection vulnerabilities that could lead to redirect attacks or other security issues.
The patch applies DynamicMeta::sanitizeUrl to all output URLs to ensure they are properly sanitized before use.

Weakness: CWE-601
Severity: Medium
CVSS: 5.4"
266,CWE-400,GHSA-57f3-gghm-9mhc,"@@ -630,7 +630,7 @@ import { atob, btoa } from ""../libs/AtobBtoa.js"";
     var result = null;
 
     if (dataUrlParts.length === 2) {
-      var extractedInfo = /^data:(\w*\/\w*);*(charset=[\w=-]*)*;*$/.exec(
+      var extractedInfo = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(
         dataUrlParts[0]
       );
       if (Array.isArray(extractedInfo)) {",fix ReDoS-vulnerable regexp in addImage (#3091),"vuln-fix: Fix regex to prevent malformed charset extraction (CVE-2024-0001)

The data URL parsing regex allowed multiple 'charset=' substrings to be matched incorrectly, leading to malformed extraction of charset parameters.
This could enable attackers to craft malformed data URLs causing unexpected parser behavior or downstream injection vulnerabilities.
The fix refines the regex to disallow repeated 'charset=' sequences, ensuring only a single, valid charset parameter is extracted.

Weakness: CWE-20  
Severity: Low  
CVSS: 3.1"
319,CWE-20,GHSA-hrg5-737c-2p56,"@@ -92,6 +92,9 @@ class UnsortedSegmentJoinOp : public OpKernel {
     const Tensor& num_segments_tensor = context->input(2);
     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
+    OP_REQUIRES(context,
+                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
+                errors::InvalidArgument(""Number of segments must be a scalar""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(","Fix tf.raw_ops.UnsortedSegmentJoin vulnerability with invalid num_segments.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445206880","vuln-fix: Enforce scalar constraint on segment count tensor (CVE-2024-XXXX)

The operation failed to verify that the number of segments tensor was a scalar, allowing malformed tensor input shapes to be processed incorrectly.  
This posed a risk of internal consistency errors or crashes due to unexpected tensor shapes leading to assertion failures or undefined behavior.  
The fix adds a check to ensure the number of segments tensor is scalar before processing, rejecting invalid shapes upfront.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
726,CWE-125,GHSA-9697-98pf-4rw7,"@@ -86,6 +86,10 @@ class UpperBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,
@@ -127,6 +131,10 @@ class LowerBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,","Prevent CHECK-fail/heap OOB in UpperBound and LowerBound

PiperOrigin-RevId: 387738073
Change-Id: Iee74de95ddad18440d052a75a5a1cb67544f490a","vuln-fix: Enforce minimum tensor rank in bound operations (CVE-2024-XXXX)

The UpperBoundOp and LowerBoundOp classes did not verify that input tensors had at least two dimensions before processing.
This lack of validation could lead to unexpected behavior or crashes due to operations on improperly shaped tensors, causing denial-of-service conditions.
The fix adds checks ensuring that the sorted input tensor is at least a matrix (2D) before continuing execution, rejecting invalid shapes early.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.4"
96,CWE-79,GHSA-q7q9-w24q-cpgh,"@@ -149,8 +149,16 @@ App.BreadcrumbItem = Em.Object.extend({
   createLabel() {
     let label = this.get('label');
     let labelBindingPath = this.get('labelBindingPath');
+    let formattedLabel;
+
+    if (labelBindingPath) {
+      formattedLabel = Ember.Handlebars.Utils.escapeExpression(App.get(_getLabelPathWithoutApp(labelBindingPath)));
+    } else{
+      formattedLabel = label;
+    }
+
+
 
-    let formattedLabel = labelBindingPath ? App.get(_getLabelPathWithoutApp(labelBindingPath)) : label;
     this.set('formattedLabel', this.labelPostFormat(formattedLabel));
   },
 
@@ -216,7 +224,9 @@ App.BreadcrumbsView = Em.View.extend({
       }
       currentState = currentState.get('parentState');
     }
-    items = items.reverse().map(item => App.BreadcrumbItem.extend(item).create());
+    items.reverse();
+    items.slice(1).forEach(item => item.label = Ember.Handlebars.Utils.escapeExpression(item.label));
+    items = items.map(item => App.BreadcrumbItem.extend(item).create());
     if (items.length) {
       items.get('lastObject').setProperties({
         disabled: true,",AMBARI-25329. Ambari breadcrumbs xss vulnerability,"vuln-fix: Escape breadcrumb labels to prevent XSS (CVE-2024-0001)

The breadcrumb labels were rendered without proper escaping, allowing crafted label inputs with HTML or script content to execute in the browser context.
This constitutes a cross-site scripting vulnerability, risking session theft, malicious actions, and UI manipulation for users viewing the breadcrumb.
The fix escapes breadcrumb label strings using Ember's escapeExpression function before rendering them in the UI.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
80,CWE-1321,GHSA-pc58-wgmc-hfjr,"@@ -4,6 +4,10 @@ define(['./namespace'], function (namespace) {
      * set ""nested"" object property
      */
     function set(obj, prop, val){
+        // prototype pollution mitigation
+        if(prop.includes('__proto__') || prop.includes('prototype') || prop.includes('constructor')) {
+            return false;
+        }
         var parts = (/^(.+)\.(.+)$/).exec(prop);
         if (parts){
             namespace(obj, parts[1])[parts[2]] = val;","Merge pull request #270 from 418sec/1-npm-mout

Security Fix for Prototype Pollution - huntr.dev","vuln-fix: Prevent prototype pollution in set function (CVE-2024-XXXXX)

The set function lacked checks against prototype pollution by allowing keys like __proto__, prototype, or constructor to be set on objects.
This vulnerability could enable attackers to manipulate the prototype chain, causing unexpected behavior or escalating privileges in the application.
The fix adds explicit filtering to reject property names containing those prototype-related keywords, mitigating prototype pollution attacks.

Weakness: CWE-471
Severity: High
CVSS: 7.5"
851,CWE-79,GHSA-vcfc-9wcp-j623,"@@ -90,12 +90,13 @@ public async Task SerializeToStreamAsync(IRequest req, object response, Stream o
             {
                 // Serialize then escape any potential script tags to avoid XSS when displaying as HTML
                 var json = JsonDataContractSerializer.Instance.SerializeToString(dto) ?? ""null"";
-                json = json.Replace(""<"", ""&lt;"").Replace("">"", ""&gt;"");
+                json = json.HtmlEncode();
 
                 var url = req.ResolveAbsoluteUrl()
                     .Replace(""format=html"", """")
                     .Replace(""format=shtm"", """")
-                    .TrimEnd('?', '&');
+                    .TrimEnd('?', '&')
+                    .HtmlEncode();
 
                 url += url.Contains(""?"") ? ""&"" : ""?"";",HtmlEncode Raw URL in HtmlFormat snapshot,"vuln-fix: Encode JSON and URL output to prevent XSS (CVE-2024-0001)

The serialization function emitted JSON and URLs without proper HTML encoding, allowing script tags to be rendered directly in HTML contexts.
This created a cross-site scripting vulnerability where attackers could inject malicious scripts that execute in users’ browsers, risking data theft or session hijacking.
The patch replaces manual angle bracket replacement with comprehensive HtmlEncode calls on JSON and URL strings to securely escape all HTML special characters.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
784,CWE-352,GHSA-g6vq-wc8w-4g69,"@@ -213,7 +213,7 @@ static function () {
     ['middleware' => 'user-full-auth', 'namespace' => 'FireflyIII\Http\Controllers', 'prefix' => 'subscriptions', 'as' => 'subscriptions.'],
     static function () {
         Route::get('', ['uses' => 'Bill\IndexController@index', 'as' => 'index']);
-        Route::get('rescan/{bill}', ['uses' => 'Bill\ShowController@rescan', 'as' => 'rescan']);
+        Route::post('rescan/{bill}', ['uses' => 'Bill\ShowController@rescan', 'as' => 'rescan']);
         Route::get('create', ['uses' => 'Bill\CreateController@create', 'as' => 'create']);
         Route::get('edit/{bill}', ['uses' => 'Bill\EditController@edit', 'as' => 'edit']);
         Route::get('delete/{bill}', ['uses' => 'Bill\DeleteController@delete', 'as' => 'delete']);
@@ -649,7 +649,7 @@ static function () {
         Route::get('rate/{fromCurrencyCode}/{toCurrencyCode}/{date}', ['uses' => 'Json\ExchangeController@getRate', 'as' => 'rate']);
 
         // intro things:
-        Route::any('intro/finished/{route}/{specificPage?}', ['uses' => 'Json\IntroController@postFinished', 'as' => 'intro.finished']);
+        Route::post('intro/finished/{route}/{specificPage?}', ['uses' => 'Json\IntroController@postFinished', 'as' => 'intro.finished']);
         Route::post('intro/enable/{route}/{specificPage?}', ['uses' => 'Json\IntroController@postEnable', 'as' => 'intro.enable']);
         Route::get('intro/{route}/{specificPage?}', ['uses' => 'Json\IntroController@getIntroSteps', 'as' => 'intro']);
     }
@@ -726,14 +726,15 @@ static function () {
         Route::post('enable2FA', ['uses' => 'ProfileController@enable2FA', 'as' => 'enable2FA']);
         Route::get('2fa/code', ['uses' => 'ProfileController@code', 'as' => 'code']);
         Route::post('2fa/code', ['uses' => 'ProfileController@postCode', 'as' => 'code.store']);
-        Route::get('/delete-code', ['uses' => 'ProfileController@deleteCode', 'as' => 'delete-code']);
-        Route::get('2fa/new-codes', ['uses' => 'ProfileController@newBackupCodes', 'as' => 'new-backup-codes']);
+        Route::post('/delete-code', ['uses' => 'ProfileController@deleteCode', 'as' => 'delete-code']);
+        Route::post('2fa/new-codes', ['uses' => 'ProfileController@newBackupCodes', 'as' => 'new-backup-codes']);
 
     }
 );
 
 /**
  * Recurring Transactions Controller.
+ * 
  */
 Route::group(
     ['middleware' => 'user-full-auth', 'namespace' => 'FireflyIII\Http\Controllers', 'prefix' => 'recurring', 'as' => 'recurring.'],
@@ -1078,7 +1079,7 @@ static function () {
 // See reference nr. 6
         Route::post('store/{tj}', ['uses' => 'LinkController@store', 'as' => 'store']);
         Route::get('delete/{journalLink}', ['uses' => 'LinkController@delete', 'as' => 'delete']);
-        Route::get('switch/{journalLink}', ['uses' => 'LinkController@switchLink', 'as' => 'switch']);
+        Route::post('switch/{journalLink}', ['uses' => 'LinkController@switchLink', 'as' => 'switch']);
 
         Route::post('destroy/{journalLink}', ['uses' => 'LinkController@destroy', 'as' => 'destroy']);
     }",Fix CSRF issues,"vuln-fix: Enforce POST methods for state-changing routes (CVE-2024-0001)

Several routes previously allowed state-changing actions via HTTP GET requests, enabling attackers to perform unintended modifications through CSRF or malicious link clicks.
Using GET for sensitive operations poses security risks because it breaks the expectation that GET is safe and idempotent, increasing attack surface for CSRF and unauthorized state changes.
The patch converts these routes to use POST methods exclusively, aligning with best practices to protect mutating endpoints from unintended or unauthorized invocation.

Weakness: CWE-352  
Severity: Medium  
CVSS: 5.9"
40,CWE-79,GHSA-whv6-rj84-2vh2,"@@ -60,6 +60,9 @@ import Action from 'nextcloud-vue/dist/Components/Action'
 import Avatar from 'nextcloud-vue/dist/Components/Avatar'
 import Tooltip from 'nextcloud-vue/dist/Directives/Tooltip'
 
+Tooltip.options.defaultHtml = false
+
+
 export default {
 	name: 'CollectionListItem',
 	components: {","Force defaultHtml setting of v-tooltip to be disabled

Signed-off-by: Julius Härtl <jus@bitgrid.net>","vuln-fix: Disable default HTML rendering in Tooltip directive (CVE-2024-XXXX)

The Tooltip component rendered HTML content by default, allowing unescaped user input to be interpreted as HTML and potentially enabling cross-site scripting attacks.
This presents a security risk by permitting attackers to inject malicious scripts that execute in victims' browsers, compromising confidentiality and session integrity.
The patch disables default HTML rendering by setting Tooltip's option defaultHtml to false, enforcing safer plain-text rendering for user-controlled content.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
498,CWE-79,GHSA-xw79-hhv6-578c,"@@ -4,7 +4,7 @@
     <meta charset=""utf-8"">
     <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
 
-    <title>Files within {{=it.directory}}</title>
+    <title>Files within {{!it.directory}}</title>
 
 	<style>
 		body {
@@ -187,7 +187,7 @@
           <i>Index of&nbsp;</i>
 
           {{~it.paths :value:index}}
-            <a href=""/{{=value.url}}"">{{=value.name}}</a>
+            <a href=""/{{!value.url}}"">{{!value.name}}</a>
           {{~}}
         </h1>
 
@@ -197,9 +197,9 @@
       <ul id=""files"">
         {{~it.files :value:index}}
           <li>
-            <a href=""{{=value.relative}}"" title=""{{=value.title}}"" class=""{{=value.ext}}"">{{=value.base}}</a>
+            <a href=""{{!value.relative}}"" title=""{{!value.title}}"" class=""{{!value.ext}}"">{{!value.base}}</a>
 			{{? value.size}}
-				<i>{{=value.size}}</i>
+				<i>{{!value.size}}</i>
 			{{?}}
           </li>
         {{~}}",Interpolate template variables correctly (#64),"vuln-fix: Escape HTML in directory listing output (CVE-2024-0001)

The template rendered directory and file names without escaping, allowing user-controlled content to be included as raw HTML.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in users' browsers.
The fix escapes all relevant variables in the directory listing template using the template engine's HTML escaping mechanism.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
836,"CWE-835', 'CWE-674",GHSA-cwv3-863g-39vx,"@@ -138,6 +138,8 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
   auto* subgraphs = this_subgraph->GetSubgraphs();
   TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
   TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
+  TF_LITE_ENSURE(context,
+                 op_data->cond_subgraph_index != op_data->body_subgraph_index);
 
   Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
   Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();","Prevent infinite loop/stack overflow in TFLite `while` op.

PiperOrigin-RevId: 370800333
Change-Id: I6a2e4ff849da339545c449db2af7e11ce6ff02c3","vuln-fix: Prevent identical subgraph indices in loop operation (CVE-2024-0001)

The loop operation preparation did not check if cond_subgraph_index and body_subgraph_index were identical, allowing internal inconsistencies.
This could cause undefined behavior or crashes due to overlapping subgraph references, leading to potential denial-of-service conditions.
The fix enforces a check preventing these indices from being equal by using TF_LITE_ENSURE validation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
548,CWE-79,GHSA-5pg2-qg87-vmj7,"@@ -336,9 +336,12 @@
 // Make sure the fileName is unique but only if chunking is disabled
 if ($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
     $ext = strrpos($fileName, '.');
+
     $fileName_a = substr($fileName, 0, $ext);
     $fileName_b = substr($fileName, $ext);
 
+    $fileName_b = strtolower($fileName_b);
+
     $count = 1;
     while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b)) {
         ++$count;
@@ -500,7 +503,7 @@
 
     if (is_file($filePath) and !$chunks || $chunk == $chunks - 1) {
         $ext = get_file_extension($filePath);
-
+        $ext = strtolower($ext);
         if (function_exists('finfo_open') and function_exists('finfo_file')) {
             $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension
             $mime = @finfo_file($finfo, $filePath);",update,"vuln-fix: Normalize file extensions for consistent file handling (CVE-2024-0001)

The file upload logic inconsistently handled file extensions with varying case sensitivity, risking bypass of duplicate detection and MIME type checks.
This inconsistency could allow attackers to upload malicious files with confusing extensions, potentially enabling overwriting or misclassification of files.
The patch converts all file extensions to lowercase before checks and comparisons, ensuring uniform and secure handling of uploaded files.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
816,CWE-613,GHSA-7ggw-h8pp-r95r,"@@ -686,7 +686,7 @@ public function logout()
 
         $this->user = null;
 
-        Session::flush();
+        Session::invalidate();
         Cookie::queue(Cookie::forget($this->sessionKey));
     }","Invalidate the session ID to prevent reuse

1. Good logs in
2. Bad captures Good's session cookie
3. Good logs out
4. Session cookie no longer works
5. Good logs in a second time
6. ORIGINAL session cookie works (Bad is also signed in)","vuln-fix: Invalidate session on logout to prevent session fixation (CVE-2024-XXXX)

The logout function previously cleared session data with Session::flush(), which did not properly invalidate the session ID, risking session fixation attacks.
This vulnerability could allow an attacker to reuse a valid session ID after logout, potentially gaining unauthorized access or impersonating a user.
The fix replaces Session::flush() with Session::invalidate() to ensure the session is fully terminated and the session ID regenerated.

Weakness: CWE-384
Severity: Medium
CVSS: 5.8"
871,CWE-401,GHSA-fq6p-6334-8gr4,"@@ -18,6 +18,8 @@ limitations under the License.
 #include <cstdint>
 #include <memory>
 
+#include ""tensorflow/core/lib/gtl/cleanup.h""
+
 #define EIGEN_USE_THREADS
 
 #include ""absl/strings/escaping.h""
@@ -326,6 +328,16 @@ class DecodeImageV2Op : public OpKernel {
         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),
         errors::InvalidArgument(""Invalid PNG. Failed to initialize decoder.""));
 
+    // If we reach this point, then there is data in `decode` which must be
+    // freed by the time we end execution in this function. We cannot call
+    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if
+    // `OP_REQUIRES` constraint is satisfied then the data would be freed
+    // prematurely. Instead, let's use a `Cleanup` object.
+    auto cleanup = gtl::MakeCleanup([&decode]() {
+      std::cerr << ""Cleanup called...\n"";
+      png::CommonFreeDecode(&decode);
+    });
+
     // Verify that width and height are not too large:
     // - verify width and height don't overflow int.
     // - width can later be multiplied by channels_ and sizeof(uint16), so","Prevent memory leak in decoding PNG images.

PiperOrigin-RevId: 409300653
Change-Id: I6182124c545989cef80cefd439b659095920763b","vuln-fix: Manage PNG decode resource cleanup to prevent memory leaks (CVE-2024-XXXX)

The patch addresses missing cleanup of PNG decode data that could lead to memory leaks if errors occur after initialization.
Unreleased resources in image decoding expose the system to potential denial-of-service due to increased memory consumption over time.
The fix adds a gtl::Cleanup object ensuring png::CommonFreeDecode is called automatically upon function exit, preventing resource leaks.

Weakness: CWE-401
Severity: Medium
CVSS: 5.0"
616,CWE-79,GHSA-5vr6-hm68-5j9p,"@@ -44,5 +44,5 @@
 if (! empty($ok)) {
     exit(""$ok"");
 } else {
-    exit(""ERROR: $error"");
+    exit(""ERROR: "".htmlspecialchars($error));;
 }",fix XSS vulnerability in poller-groups.inc.php,"vuln-fix: Sanitize error messages to prevent HTML injection (CVE-2024-XXXX)

The error output function directly embedded error messages without encoding, allowing injection of HTML or JavaScript content.
This created a risk of reflected cross-site scripting (XSS) by rendering untrusted content in client browsers.
The fix applies htmlspecialchars() to escape special characters, mitigating XSS by encoding potentially dangerous input.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
439,CWE-119,GHSA-grmf-4fq6-2r79,"@@ -168,7 +168,7 @@ aubio_tempo_t * new_aubio_tempo (const char_t * tempo_mode,
     uint_t buf_size, uint_t hop_size, uint_t samplerate)
 {
   aubio_tempo_t * o = AUBIO_NEW(aubio_tempo_t);
-  char_t specdesc_func[20];
+  char_t specdesc_func[PATH_MAX];
   o->samplerate = samplerate;
   // check parameters are valid
   if ((sint_t)hop_size < 1) {
@@ -203,9 +203,10 @@ aubio_tempo_t * new_aubio_tempo (const char_t * tempo_mode,
   o->pp       = new_aubio_peakpicker();
   aubio_peakpicker_set_threshold (o->pp, o->threshold);
   if ( strcmp(tempo_mode, ""default"") == 0 ) {
-    strcpy(specdesc_func, ""specflux"");
+    strncpy(specdesc_func, ""specflux"", PATH_MAX - 1);
   } else {
-    strcpy(specdesc_func, tempo_mode);
+    strncpy(specdesc_func, tempo_mode, PATH_MAX - 1);
+    specdesc_func[PATH_MAX - 1] = '\0';
   }
   o->od       = new_aubio_specdesc(specdesc_func,buf_size);
   o->of       = new_fvec(1);",[tempo] fix buffer overflow in method parser,"vuln-fix: Prevent buffer overflow in tempo mode string copy (CVE-2024-XXXX)

The original code used strcpy to copy tempo_mode strings into a fixed-size buffer of 20 bytes, risking buffer overflow if tempo_mode exceeded this length.
This could lead to memory corruption, crashes, or potential control over program execution through out-of-bounds writes.
The fix replaces strcpy with strncpy using PATH_MAX as the buffer size and enforces null termination to prevent buffer overflows.

Weakness: CWE-787  
Severity: High  
CVSS: 7.4"
545,CWE-22,GHSA-hwv5-w8gm-fq9f,"@@ -29,6 +29,7 @@
 import typing
 
 import flask
+import werkzeug.exceptions
 
 app = flask.Flask(""xmpp-http-upload"")
 app.config.from_envvar(""XMPP_HTTP_UPLOAD_CONFIG"")
@@ -39,16 +40,11 @@
     CORS(app)
 
 
-def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:
-    result = (root / path).absolute()
-    if not str(result).startswith(str(root) + ""/""):
-        raise ValueError(""resulting path is outside root"")
-    return result
-
-
-def get_paths(base_path: pathlib.Path):
-    data_file = pathlib.Path(str(base_path) + "".data"")
-    metadata_file = pathlib.Path(str(base_path) + "".meta"")
+def get_paths(root: str, sub_path: str) \
+        -> typing.Tuple[pathlib.Path, pathlib.Path]:
+    base_path = flask.safe_join(root, sub_path)
+    data_file = pathlib.Path(base_path + "".data"")
+    metadata_file = pathlib.Path(base_path + "".meta"")
 
     return data_file, metadata_file
 
@@ -58,15 +54,10 @@ def load_metadata(metadata_file):
         return json.load(f)
 
 
-def get_info(path: str, root: pathlib.Path) -> typing.Tuple[
+def get_info(path: str) -> typing.Tuple[
         pathlib.Path,
         dict]:
-    dest_path = sanitized_join(
-        path,
-        pathlib.Path(app.config[""DATA_ROOT""]),
-    )
-
-    data_file, metadata_file = get_paths(dest_path)
+    data_file, metadata_file = get_paths(app.config[""DATA_ROOT""], path)
 
     return data_file, load_metadata(metadata_file)
 
@@ -104,11 +95,8 @@ def stream_file(src, dest, nbytes):
 @app.route(""/<path:path>"", methods=[""PUT""])
 def put_file(path):
     try:
-        dest_path = sanitized_join(
-            path,
-            pathlib.Path(app.config[""DATA_ROOT""]),
-        )
-    except ValueError:
+        data_file, metadata_file = get_paths(app.config[""DATA_ROOT""], path)
+    except werkzeug.exceptions.NotFound:
         return flask.Response(
             ""Not Found"",
             404,
@@ -134,8 +122,7 @@ def put_file(path):
         ""application/octet-stream"",
     )
 
-    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)
-    data_file, metadata_file = get_paths(dest_path)
+    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)
 
     try:
         with write_file(data_file) as fout:
@@ -189,13 +176,10 @@ def generate_headers(response_headers, metadata_headers):
 @app.route(""/<path:path>"", methods=[""HEAD""])
 def head_file(path):
     try:
-        data_file, metadata = get_info(
-            path,
-            pathlib.Path(app.config[""DATA_ROOT""])
-        )
+        data_file, metadata = get_info(path)
 
         stat = data_file.stat()
-    except (OSError, ValueError):
+    except (OSError, werkzeug.exceptions.NotFound):
         return flask.Response(
             ""Not Found"",
             404,
@@ -214,11 +198,8 @@ def head_file(path):
 @app.route(""/<path:path>"", methods=[""GET""])
 def get_file(path):
     try:
-        data_file, metadata = get_info(
-            path,
-            pathlib.Path(app.config[""DATA_ROOT""])
-        )
-    except (OSError, ValueError):
+        data_file, metadata = get_info(path)
+    except (OSError, werkzeug.exceptions.NotFound):
         return flask.Response(
             ""Not Found"",
             404,","Simplify path handling, use safe_join

The current implementation of sanitized_join did not handle
"".."" properly. The problem is, that .absolute() does not do
what .resolve() does, but .resolve() does not work on non
existant paths.

Anyway, flask has a function exactly for this: safe_join.

So let's use that one.

While at it, simplified the whole path handling a bit.","vuln-fix: Prevent path traversal with secure file path joining (CVE-2024-0001)

The service previously constructed file paths by concatenating user input without robust sanitization, permitting path traversal and unauthorized file access.
This vulnerability allowed attackers to read or modify files outside the intended directory, leading to data exposure or system compromise.
The patch replaces manual path joining with Flask’s safe_join function, which enforces safe path resolution and blocks traversal outside the data root.

Weakness: CWE-22  
Severity: High  
CVSS: 7.8"
27,"CWE-434', 'CWE-79",GHSA-5q5w-mqp6-g2gh,"@@ -20,7 +20,9 @@ public function rules()
             'quantity' => ['required', 'integer', 'min:0'],
             'price' => ['required', 'numeric', 'min:0'],
             'sale_price' => ['nullable', 'numeric'],
-            'weight' => ['nullable', 'numeric', 'min:0']
+            'weight' => ['nullable', 'numeric', 'min:0'],
+            'image' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
+            'cover' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
         ];
     }
 }",Fix vulnerability report from hunter.dev,"vuln-fix: Add image file validation to product input rules (CVE-2024-XXXX)

The product input rules previously lacked validation for uploaded image files, allowing unsupported or malicious file types to be accepted without restriction.
This posed a risk of arbitrary file uploads that could lead to server compromise or stored cross-site scripting attacks through crafted images.
The patch enforces strict image type, format, and size validation by requiring specific MIME types and maximum file sizes for the image and cover fields.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
234,CWE-787,GHSA-2wwc-w2gw-4329,"@@ -3603,7 +3603,7 @@ GlobOpt::OptSrc(IR::Opnd *opnd, IR::Instr * *pInstr, Value **indirIndexValRef, I
 
         opnd->SetValueType(valueType);
 
-        if(!IsLoopPrePass() && opnd->IsSymOpnd() && valueType.IsDefinite())
+        if(!IsLoopPrePass() && opnd->IsSymOpnd() && (valueType.IsDefinite() || valueType.IsNotTaggedValue()))
         {
             if (opnd->AsSymOpnd()->m_sym->IsPropertySym())
             {",CVE-2019-1366,"vuln-fix: Extend type check to cover non-tagged values in optimization (CVE-2024-XXXX)

The optimization pass did not consider non-tagged value types as definite, leading to incorrect assumptions about operand types in symbolic operands.
This caused potential internal state inconsistencies which could result in assertion failures or incorrect code generation, creating a denial-of-service risk.
The fix broadens type checks to include non-tagged value states, ensuring safer, more accurate type handling during optimization passes.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
475,CWE-311,GHSA-9p47-w5xp-f4xr,"@@ -2,7 +2,7 @@ var pythonMirror = process.env.npm_config_python_mirror || process.env.PYTHON_MI
 
 var buildTools = {
   installerName: 'BuildTools_Full.exe',
-  installerUrl: 'http://download.microsoft.com/download/5/f/7/5f7acaeb-8363-451f-9425-68a90f98b238/visualcppbuildtools_full.exe',
+  installerUrl: 'https://download.microsoft.com/download/5/f/7/5f7acaeb-8363-451f-9425-68a90f98b238/visualcppbuildtools_full.exe',
   logName: 'build-tools-log.txt'
 }",:wrench: Use HTTPS - Thanks to @grander,"vuln-fix: Use HTTPS for Visual C++ Build Tools installer URL (CVE-2024-0001)

The original installer URL used an unencrypted HTTP connection, exposing the download process to man-in-the-middle tampering or interception.
This created a risk where attackers could serve malicious installer binaries, leading to remote code execution or system compromise.
The patch replaces the installer URL with HTTPS, ensuring the installer is fetched securely over an encrypted channel.

Weakness: CWE-311
Severity: Medium
CVSS: 5.6"
43,CWE-400,GHSA-394c-5j6w-4xmx,"@@ -222,7 +222,7 @@
 
             // Presto based
             /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
-            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
+            /(opera\s[mobiletab]{3,6}).+version\/([\w\.-]+)/i,                  // Opera Mobi/Tablet
             /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
             /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
             ], [NAME, VERSION], [
@@ -252,7 +252,7 @@
             /(konqueror)\/([\w\.]+)/i                                           // Konqueror
             ], [[NAME, 'Konqueror'], VERSION], [
 
-            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
+            /(trident).+rv[:\s]([\w\.]{1,9}).+like\sgecko/i                     // IE11
             ], [[NAME, 'IE'], VERSION], [
 
             /(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i                          // Microsoft Edge
@@ -362,13 +362,13 @@
             /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
             ], [VERSION, [NAME, 'Firefox']], [
 
-            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
+            /version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i                      // Mobile Safari
             ], [VERSION, [NAME, 'Mobile Safari']], [
 
-            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
+            /version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i                   // Safari & Safari Mobile
             ], [VERSION, NAME], [
 
-            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
+            /webkit.+?(gsa)\/([\w\.]+)\s.*(mobile\s?safari|safari)(\/[\w\.]+)/i // Google Search Appliance on iOS
             ], [[NAME, 'GSA'], VERSION], [
 
             /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
@@ -387,7 +387,7 @@
 
                                                                                 // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
             /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,                       // Other Firefox-based
-            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla
+            /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,                        // Mozilla
 
             // Other
             /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
@@ -487,7 +487,7 @@
             /(sprint\s(\w+))/i                                                  // Sprint Phones
             ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [
 
-            /(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,                        // HTC
+            /(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,                    // HTC
             /(zte)-(\w*)/i,                                                     // ZTE
             /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                 // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
@@ -591,13 +591,13 @@
             ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [
 
             /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
-            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
-            /android.+(redmi[\s\-_]*(?:note|k)?(?:[\s_]?[\w\s]+))(?:\s+build|\))/i,      
+            /android.+(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,                // Xiaomi Hongmi
+            /android.+(redmi[\s\-_]?(?:note|k)?(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i,      
                                                                                 // Xiaomi Redmi
-            /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i    
+            /android.+(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i    
                                                                                 // Xiaomi Mi
             ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
-            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))(?:\s+build|\))/i     // Mi Pad tablets
+            /android.+(mi[\s\-_]?(?:pad)(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i     // Mi Pad tablets
             ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
             /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
             ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
@@ -611,7 +611,7 @@
             /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
             ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
 
-            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
+            /android.+[;\/\s](Venue[\d\s]{2,7})\s+build/i                       // Dell Venue Tablets
             ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
 
             /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
@@ -669,8 +669,8 @@
             /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
             ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
 
-            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
-            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
+            //android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
+            //], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
 
             /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
             ], [VENDOR, MODEL, [TYPE, TABLET]], [",Fix ReDoS vulnerabilities reported by Snyk,"vuln-fix: Correct regex patterns for user-agent parsing (CVE-2024-XXXX)

The user-agent parser used imprecise regular expressions allowing malformed or unexpected inputs to misclassify or bypass correct device identification.
This may cause downstream components relying on accurate user-agent data to misapply security or functionality policies, possibly exposing the system to incorrect trust or compatibility assumptions.
The patch refines regex quantifiers and spacing to accurately match intended user-agent strings, preventing misinterpretation and improving input validation fidelity.

Weakness: CWE-617
Severity: Medium
CVSS: 5.9"
810,CWE-400,GHSA-f8m6-h2c7-8h9x,"@@ -266,7 +266,6 @@ def word_tokenize(self, s):
         return self._word_tokenizer_re().findall(s)
 
     _period_context_fmt = r""""""
-        \S*                          # some word material
         %(SentEndChars)s             # a potential sentence ending
         (?=(?P<after_tok>
             %(NonWord)s              # either other punctuation
@@ -1284,8 +1283,7 @@ def debug_decisions(self, text):
         See format_debug_decision() to help make this output readable.
         """"""
 
-        for match in self._lang_vars.period_context_re().finditer(text):
-            decision_text = match.group() + match.group(""after_tok"")
+        for match, decision_text in self._match_potential_end_contexts(text):
             tokens = self._tokenize_words(decision_text)
             tokens = list(self._annotate_first_pass(tokens))
             while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):
@@ -1333,10 +1331,68 @@ def sentences_from_text(self, text, realign_boundaries=True):
         """"""
         return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]
 
+    def _match_potential_end_contexts(self, text):
+        """"""
+        Given a text, find the matches of potential sentence breaks,
+        alongside the contexts surrounding these sentence breaks.
+
+        Since the fix for the ReDOS discovered in issue #2866, we no longer match
+        the word before a potential end of sentence token. Instead, we use a separate
+        regex for this. As a consequence, `finditer`'s desire to find non-overlapping
+        matches no longer aids us in finding the single longest match.
+        Where previously, we could use::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +SKIP
+            [<re.Match object; span=(9, 18), match='acting!!!'>]
+
+        Now we have to find the word before (i.e. 'acting') separately, and `finditer`
+        returns::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +NORMALIZE_WHITESPACE
+            [<re.Match object; span=(15, 16), match='!'>,
+            <re.Match object; span=(16, 17), match='!'>,
+            <re.Match object; span=(17, 18), match='!'>]
+
+        So, we need to find the word before the match from right to left, and then manually remove
+        the overlaps. That is what this method does::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> pst._match_potential_end_contexts(text)
+            [(<re.Match object; span=(17, 18), match='!'>, 'acting!!! I')]
+
+        :param text: String of one or more sentences
+        :type text: str
+        :return: List of match-context tuples.
+        :rtype: List[Tuple[re.Match, str]]
+        """"""
+        before_words = {}
+        matches = []
+        for match in reversed(list(self._lang_vars.period_context_re().finditer(text))):
+            # Ignore matches that have already been captured by matches to the right of this match
+            if matches and match.end() > before_start:
+                continue
+            # Find the word before the current match
+            split = text[: match.start()].rsplit(maxsplit=1)
+            before_start = len(split[0]) if len(split) == 2 else 0
+            before_words[match] = split[-1]
+            matches.append(match)
+
+        return [
+            (
+                match,
+                before_words[match] + match.group() + match.group(""after_tok""),
+            )
+            for match in matches[::-1]
+        ]
+
     def _slices_from_text(self, text):
         last_break = 0
-        for match in self._lang_vars.period_context_re().finditer(text):
-            context = match.group() + match.group(""after_tok"")
+        for match, context in self._match_potential_end_contexts(text):
             if self.text_contains_sentbreak(context):
                 yield slice(last_break, match.end())
                 if match.group(""next_tok""):","Resolved serious ReDoS in PunktSentenceTokenizer (#2869)

* Resolved serious ReDOS in PunktSentenceTokenizer

* Improve performance by relying on string split instead of re.search

* Solved issue if sentence contains just one token","vuln-fix: Fix ReDOS vulnerability in sentence boundary matching (CVE-2024-XXXX)

The previous implementation used a single regex to match sentence-ending contexts causing catastrophic backtracking on crafted input.
This allowed an attacker to trigger excessive CPU usage, resulting in a denial-of-service condition via regular expression denial-of-service (ReDOS).
The fix separates the matching process, iterates matches in reverse to avoid overlaps, and constructs contexts with linear complexity to prevent ReDOS.

Weakness: CWE-400
Severity: Medium
CVSS: 5.5"
419,CWE-306,GHSA-35g4-qx3c-vjhx,"@@ -145,6 +145,13 @@ export class RoomUpgradeHandler {
     private async onJoinedNewRoom(oldRoomId: string, newRoomId: string) {
         log.debug(`Joined ${newRoomId}`);
         const intent = this.bridge.getIntent();
+        const { predecessor } = await intent.getStateEvent(newRoomId, 'm.room.create');
+        if (predecessor.room_id !== oldRoomId) {
+            log.error(
+    `Room doesn't have a matching predecessor (expected: ${oldRoomId}, got: ${predecessor.room_id}), not bridging.`
+            );
+            return false;
+        }
         const asBot = this.bridge.getBot();
         if (this.opts.migrateStoreEntries) {
             const success = await this.migrateStoreEntries(oldRoomId, newRoomId);",Check m.room.create event on room upgrade,"vuln-fix: Verify room predecessor when handling room upgrades (CVE-2024-0001)

The room upgrade handler did not verify that the new room's predecessor matched the expected old room ID, allowing potential logic errors in room bridging.
This mismatch could cause incorrect event bridging or unauthorized message forwarding between unrelated rooms, risking data integrity and information leaks.
The fix adds a check that compares the predecessor room ID from the new room’s creation event to the old room ID and aborts bridging if they do not match.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
115,"CWE-787', 'CWE-120",GHSA-wcv5-qrj6-9pfm,"@@ -239,6 +239,20 @@ class Conv3DBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -346,6 +360,20 @@ class Conv3DCustomBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -696,6 +724,20 @@ class Conv3DBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(
@@ -808,6 +850,20 @@ class Conv3DCustomBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(","Validate some shape requirements for `Conv3DBackpropFilter*` and `Conv3DBackpropInput*` ops.

Older versions of Eigen might otherwise crash / produce OOB read on specially crafted inputs.

PiperOrigin-RevId: 369293977
Change-Id: I58f51445a93936d7cf8e616f75de17677df36718","vuln-fix: Validate channel dimensions in 3D convolution backprop ops (CVE-2024-2745)

The convolution backpropagation operators lacked checks ensuring channel dimensions matched between input, filter, and output tensors.
This allowed internal dimension mismatches that could lead to assertion failures, crashes, or undefined behavior during kernel execution.
The fix adds OP_REQUIRES validations to verify that input and output tensors have compatible channel counts with filter shapes before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.4"
90,CWE-307,GHSA-56cx-wf47-hx7w,"@@ -29,6 +29,7 @@
 use FireflyIII\Providers\RouteServiceProvider;
 use Illuminate\Contracts\View\Factory;
 use Illuminate\Foundation\Auth\AuthenticatesUsers;
+use Illuminate\Foundation\Auth\ThrottlesLogins;
 use Illuminate\Http\JsonResponse;
 use Illuminate\Http\RedirectResponse;
 use Illuminate\Http\Request;
@@ -47,7 +48,7 @@
  */
 class LoginController extends Controller
 {
-    use AuthenticatesUsers;
+    use AuthenticatesUsers, ThrottlesLogins;
 
     /**
      * Where to redirect users after login.",Add missing rate limiter.,"vuln-fix: Add login throttling to prevent brute force attacks (CVE-2024-XXXX)

The login controller previously allowed unlimited authentication attempts without throttling, enabling attackers to conduct brute force password guessing.
This posed a security risk by potentially allowing unauthorized access through repeated automated login attempts.
The patch integrates Laravel’s ThrottlesLogins trait to limit the rate of login attempts, mitigating brute force risks.

Weakness: CWE-307
Severity: Medium
CVSS: 5.9"
808,CWE-269,GHSA-v6vg-pxvv-g5cq,"@@ -184,6 +184,7 @@ public function destroy($supplierId)
      */
     public function show($supplierId = null)
     {
+        $this->authorize('view', Supplier::class);
         $supplier = Supplier::find($supplierId);
 
         if (isset($supplier->id)) {","Merge pull request #10665 from snipe/fixes/adds_gate_to_supplier_view

Adds gate to supplier","vuln-fix: Add authorization check in supplier show method (CVE-2024-XXXXX)

The show method for supplier details lacked an authorization check, allowing unauthorized users to view sensitive supplier data.  
This created an improper authorization vulnerability where attackers could access supplier information without permission.  
The patch adds a call to authorize the 'view' permission on the Supplier model to restrict access appropriately.

Weakness: CWE-285  
Severity: High  
CVSS: 7.7"
255,CWE-79,GHSA-vpwq-6cp4-ffqc,"@@ -309,6 +309,8 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".aspx"")
 			|| $isDangerStr($filename , "".xsd"")
 			|| $isDangerStr($filename , "".asa"")
+			|| $isDangerStr($filename , "".cshtml"")
+			|| $isDangerStr($filename , "".axd"")
 		) {
 			return true;
 		}",bug,"vuln-fix: Extend dangerous filename checks to include .cshtml and .axd extensions (CVE-2024-XXXX)

Filename validation missed potentially dangerous extensions like .cshtml and .axd, enabling unsafe files to bypass filtering mechanisms.
This increased the risk of uploading or handling files that could execute server-side code or expose internal resources, leading to possible remote code execution or information disclosure.
The patch adds these extensions to the denylist in the isDangerFilename function to improve validation coverage and reduce attack surface.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
511,CWE-22,GHSA-8rmh-55h4-93h5,"@@ -2003,12 +2003,14 @@ public static String unzip(File zipfile, String destDir) throws IOException {
         if (destinationDir == null){
         	destinationDir = tempWorkDir;
         }
+        log.debug(""Using directory "" + destinationDir + "" for zip extraction. (destDir arg is "" + destDir +
+                "", tempWorkDir is "" + tempWorkDir + "")"");
 
         File tempdir = new File(destinationDir);
         if (!tempdir.isDirectory())
         {
-            log.error(""'"" + ConfigurationManager.getProperty(""org.dspace.app.itemexport.work.dir"") +
-                    ""' as defined by the key 'org.dspace.app.itemexport.work.dir' in dspace.cfg "" +
+            log.error(""'"" + ConfigurationManager.getProperty(""org.dspace.app.batchitemimport.work.dir"") +
+                    ""' as defined by the key 'org.dspace.app.batchitemimport.work.dir' in dspace.cfg "" +
                     ""is not a valid directory"");
         }
 
@@ -2016,9 +2018,15 @@ public static String unzip(File zipfile, String destDir) throws IOException {
         {
             log.error(""Unable to create temporary directory: "" + tempdir.getAbsolutePath());
         }
-        String sourcedir = destinationDir + System.getProperty(""file.separator"") + zipfile.getName();
-        String zipDir = destinationDir + System.getProperty(""file.separator"") + zipfile.getName() + System.getProperty(""file.separator"");
 
+        if(!destinationDir.endsWith(System.getProperty(""file.separator""))) {
+            destinationDir += System.getProperty(""file.separator"");
+        }
+
+        String sourcedir = destinationDir + zipfile.getName();
+        String zipDir = destinationDir + zipfile.getName() + System.getProperty(""file.separator"");
+
+        log.debug(""zip directory to use is "" + zipDir);
 
         // 3
         String sourceDirForZip = sourcedir;
@@ -2028,11 +2036,26 @@ public static String unzip(File zipfile, String destDir) throws IOException {
         while (entries.hasMoreElements())
         {
             entry = entries.nextElement();
+            // Check that the true path to extract files is never outside allowed temp directories
+            // without creating any actual files on disk
+            log.debug(""Inspecting entry name: "" + entry.getName() + "" for path traversal security"");
+            File potentialExtract = new File(zipDir + entry.getName());
+            String canonicalPath = potentialExtract.getCanonicalPath();
+            log.debug(""Canonical path to potential File is "" + canonicalPath);
+            if(!canonicalPath.startsWith(zipDir)) {
+                log.error(""Rejecting zip file: "" + zipfile.getName() + "" as it contains an entry that would be extracted "" +
+                        ""outside the temporary unzip directory: "" + canonicalPath);
+                throw new IOException(""Error extracting "" + zipfile + "": Canonical path of zip entry: "" +
+                        entry.getName() + "" ("" + canonicalPath + "") does not start with permissible temp "" +
+                        ""unzip directory ("" + destinationDir + "")"");
+            }
             if (entry.isDirectory())
             {
-                if (!new File(zipDir + entry.getName()).mkdir())
-                {
+                // Log error and throw IOException if a directory entry could not be created
+                File newDir = new File(zipDir + entry.getName());
+                if (!newDir.mkdirs()) {
                     log.error(""Unable to create contents directory: "" + zipDir + entry.getName());
+                    throw new IOException(""Unable to create contents directory: "" + zipDir + entry.getName());
                 }
             }
             else
@@ -2074,6 +2097,7 @@ public static String unzip(File zipfile, String destDir) throws IOException {
                 byte[] buffer = new byte[1024];
                 int len;
                 InputStream in = zf.getInputStream(entry);
+                log.debug(""Reading "" + zipDir + entry.getName() + "" into InputStream"");
                 BufferedOutputStream out = new BufferedOutputStream(
                         new FileOutputStream(zipDir + entry.getName()));
                 while((len = in.read(buffer)) >= 0)",[DS-4131] Better path handling in ItemImport zips,"vuln-fix: Prevent zip slip path traversal in unzip method (CVE-2024-0001)

The unzip method lacked validation of extracted file paths, allowing crafted zip entries to escape the target directory and write arbitrary files.
This posed a critical path traversal risk enabling attackers to overwrite sensitive files or execute code outside intended folders.
The fix validates each zip entry’s canonical path is confined within the extraction directory, throwing an exception if it attempts directory traversal.

Weakness: CWE-22  
Severity: Critical  
CVSS: 9.1"
