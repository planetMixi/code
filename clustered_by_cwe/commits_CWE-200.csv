vuln_id,code_diff,cwe_id
CVE-2017-16994,"From 373c4557d2aa362702c4c2d41288fb1e54990b7c Mon Sep 17 00:00:00 2001
From: Jann Horn <jannh@google.com>
Date: Tue, 14 Nov 2017 01:03:44 +0100
Subject: [PATCH] mm/pagewalk.c: report holes in hugetlb ranges

This matters at least for the mincore syscall, which will otherwise copy
uninitialized memory from the page allocator to userspace.  It is
probably also a correctness error for /proc/$pid/pagemap, but I haven't
tested that.

Removing the `walk->hugetlb_entry` condition in walk_hugetlb_range() has
no effect because the caller already checks for that.

This only reports holes in hugetlb ranges to callers who have specified
a hugetlb_entry callback.

This issue was found using an AFL-based fuzzer.

v2:
 - don't crash on ->pte_hole==NULL (Andrew Morton)
 - add Cc stable (Andrew Morton)

Fixes: 1e25a271c8ac (""mincore: apply page table walker on do_mincore()"")
Signed-off-by: Jann Horn <jannh@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
---
 mm/pagewalk.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/mm/pagewalk.c b/mm/pagewalk.c
index 8bd4afa83cb89f..23a3e415ac2ce5 100644
--- a/mm/pagewalk.c
+++ b/mm/pagewalk.c
@@ -188,8 +188,12 @@ static int walk_hugetlb_range(unsigned long addr, unsigned long end,
 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);
-		if (pte && walk->hugetlb_entry)
+
+		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
+		else if (walk->pte_hole)
+			err = walk->pte_hole(addr, next, walk);
+
 		if (err)
 			break;
 	} while (addr = next, addr != end);",CWE-200
CVE-2012-6544,"From 792039c73cf176c8e39a6e8beef2c94ff46522ed Mon Sep 17 00:00:00 2001
From: Mathias Krause <minipli@googlemail.com>
Date: Wed, 15 Aug 2012 11:31:51 +0000
Subject: [PATCH] Bluetooth: L2CAP - Fix info leak via getsockname()

The L2CAP code fails to initialize the l2_bdaddr_type member of struct
sockaddr_l2 and the padding byte added for alignment. It that for leaks
two bytes kernel stack via the getsockname() syscall. Add an explicit
memset(0) before filling the structure to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/bluetooth/l2cap_sock.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index b94abd30e6f948..1497edd191a2e0 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -245,6 +245,7 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
+	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);",CWE-200
CVE-2015-1342,"From a8b6c3e0537e90fba3c55910fd1b7229d54a60a7 Mon Sep 17 00:00:00 2001
From: Serge Hallyn <serge.hallyn@ubuntu.com>
Date: Fri, 13 Nov 2015 17:07:36 -0600
Subject: [PATCH] Fix checking of parent directories

Taken from the justification in the launchpad bug:

To a task in freezer cgroup /a/b/c/d, it should appear that there are no
cgroups other than its descendents. Since this is a filesystem, we must have
the parent directories, but each parent cgroup should only contain the child
which the task can see.

So, when this task looks at /a/b, it should see only directory 'c' and no
files. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already
exists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x
exists or not. Opening /a/b/tasks should result in -ENOENT.

The caller_may_see_dir checks specifically whether a task may see a cgroup
directory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing
opendir('/a/b/c/d').

caller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at
/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the
task in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)
directory which he can see in the path - 'c'.

Beyond this, regular DAC permissions should apply, with the
root-in-user-namespace privilege over its mapped uids being respected. The
fc_may_access check does this check for both directories and files.

This is CVE-2015-1342 (LP: #1508481)

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
---
 Makefile.am               |   8 +-
 lxcfs.c                   | 137 ++++++++----
 tests/test_confinement.sh |  96 ++++++++
 tests/test_syscalls.c     | 451 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 646 insertions(+), 46 deletions(-)
 create mode 100644 tests/test_confinement.sh
 create mode 100644 tests/test_syscalls.c

diff --git a/Makefile.am b/Makefile.am
index 7dda776a..cc19ce7c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -29,11 +29,12 @@ endif
 
 TEST_READ: tests/test-read.c
 	$(CC) -o tests/test-read tests/test-read.c
-
 TEST_CPUSET: tests/cpusetrange.c cpuset.c
 	$(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c
+TEST_SYSCALLS: tests/test_syscalls.c
+	$(CC) -o tests/test_syscalls tests/test_syscalls.c
 
-tests: TEST_READ TEST_CPUSET
+tests: TEST_READ TEST_CPUSET TEST_SYSCALLS
 
 distclean:
 	rm -rf .deps/ \
@@ -60,4 +61,5 @@ distclean:
 		lxcfs.o \
 		m4/ \
 		missing \
-		stamp-h1
+		stamp-h1 \
+		tests/test_syscalls
diff --git a/lxcfs.c b/lxcfs.c
index e2ccc5e8..2c5aca4e 100644
--- a/lxcfs.c
+++ b/lxcfs.c
@@ -235,6 +235,12 @@ static bool perms_include(int fmode, mode_t req_mode)
 	return ((fmode & r) == r);
 }
 
+
+/*
+ * taskcg is  a/b/c
+ * querycg is /a/b/c/d/e
+ * we return 'd'
+ */
 static char *get_next_cgroup_dir(const char *taskcg, const char *querycg)
 {
 	char *start, *end;
@@ -378,53 +384,71 @@ static void prune_init_slice(char *cg)
  */
 static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)
 {
-	char fnam[PROCLEN];
-	FILE *f;
 	bool answer = false;
-	char *line = NULL;
-	size_t len = 0;
-	int ret;
+	char *c2 = get_pid_cgroup(pid, contrl);
+	char *linecmp;
 
-	ret = snprintf(fnam, PROCLEN, ""/proc/%d/cgroup"", pid);
-	if (ret < 0 || ret >= PROCLEN)
-		return false;
-	if (!(f = fopen(fnam, ""r"")))
+	if (!c2)
 		return false;
+	prune_init_slice(c2);
 
-	while (getline(&line, &len, f) != -1) {
-		char *c1, *c2, *linecmp;
-		if (!line[0])
-			continue;
-		c1 = strchr(line, ':');
-		if (!c1)
-			goto out;
-		c1++;
-		c2 = strchr(c1, ':');
-		if (!c2)
-			goto out;
-		*c2 = '\0';
-		if (strcmp(c1, contrl) != 0)
-			continue;
-		c2++;
-		stripnewline(c2);
-		prune_init_slice(c2);
-		/*
-		 * callers pass in '/' for root cgroup, otherwise they pass
-		 * in a cgroup without leading '/'
-		 */
-		linecmp = *cg == '/' ? c2 : c2+1;
-		if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {
-			if (nextcg)
-				*nextcg = get_next_cgroup_dir(linecmp, cg);
-			goto out;
+	/*
+	 * callers pass in '/' for root cgroup, otherwise they pass
+	 * in a cgroup without leading '/'
+	 */
+	linecmp = *cg == '/' ? c2 : c2+1;
+	if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {
+		if (nextcg) {
+			*nextcg = get_next_cgroup_dir(linecmp, cg);
 		}
+		goto out;
+	}
+	answer = true;
+
+out:
+	free(c2);
+	return answer;
+}
+
+/*
+ * If caller is in /a/b/c, he may see that /a exists, but not /b or /a/c.
+ */
+static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)
+{
+	bool answer = false;
+	char *c2, *task_cg;
+	size_t target_len, task_len;
+
+	if (strcmp(cg, ""/"") == 0)
+		return true;
+
+	c2 = get_pid_cgroup(pid, contrl);
+
+	if (!c2)
+		return false;
+
+	task_cg = c2 + 1;
+	target_len = strlen(cg);
+	task_len = strlen(task_cg);
+	if (strcmp(cg, task_cg) == 0) {
 		answer = true;
 		goto out;
 	}
+	if (target_len < task_len) {
+		/* looking up a parent dir */
+		if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')
+			answer = true;
+		goto out;
+	}
+	if (target_len > task_len) {
+		/* looking up a child dir */
+		if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')
+			answer = true;
+		goto out;
+	}
 
 out:
-	fclose(f);
-	free(line);
+	free(c2);
 	return answer;
 }
 
@@ -552,6 +576,10 @@ static int cg_getattr(const char *path, struct stat *sb)
 	 * cgroup, or cgdir if fpath is a file */
 
 	if (is_child_cgroup(controller, path1, path2)) {
+		if (!caller_may_see_dir(fc->pid, controller, cgroup)) {
+			ret = -ENOENT;
+			goto out;
+		}
 		if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
 			/* this is just /cgroup/controller, return it as a dir */
 			sb->st_mode = S_IFDIR | 00555;
@@ -630,8 +658,11 @@ static int cg_opendir(const char *path, struct fuse_file_info *fi)
 		}
 	}
 
-	if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
-		return -EACCES;
+	if (cgroup) {
+		if (!caller_may_see_dir(fc->pid, controller, cgroup))
+			return -ENOENT;
+		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))
+			return -EACCES;
 	}
 
 	/* we'll free this at cg_releasedir */
@@ -780,6 +811,10 @@ static int cg_open(const char *path, struct fuse_file_info *fi)
 	}
 	free_key(k);
 
+	if (!caller_may_see_dir(fc->pid, controller, path1)) {
+		ret = -ENOENT;
+		goto out;
+	}
 	if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {
 		// should never get here
 		ret = -EACCES;
@@ -1563,7 +1598,7 @@ int cg_chmod(const char *path, mode_t mode)
 int cg_mkdir(const char *path, mode_t mode)
 {
 	struct fuse_context *fc = fuse_get_context();
-	char *fpath = NULL, *path1, *cgdir = NULL, *controller;
+	char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;
 	const char *cgroup;
 	int ret;
 
@@ -1585,6 +1620,14 @@ int cg_mkdir(const char *path, mode_t mode)
 	else
 		path1 = cgdir;
 
+	if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {
+		if (fpath && strcmp(next, fpath) == 0)
+			ret = -EEXIST;
+		else
+			ret = -ENOENT;
+		goto out;
+	}
+
 	if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {
 		ret = -EACCES;
 		goto out;
@@ -1599,13 +1642,14 @@ int cg_mkdir(const char *path, mode_t mode)
 
 out:
 	free(cgdir);
+	free(next);
 	return ret;
 }
 
 static int cg_rmdir(const char *path)
 {
 	struct fuse_context *fc = fuse_get_context();
-	char *fpath = NULL, *cgdir = NULL, *controller;
+	char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;
 	const char *cgroup;
 	int ret;
 
@@ -1626,8 +1670,14 @@ static int cg_rmdir(const char *path)
 		goto out;
 	}
 
-	fprintf(stderr, ""rmdir: verifying access to %s:%s (req path %s)\n"",
-			controller, cgdir, path);
+	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {
+		if (!fpath || strcmp(next, fpath) == 0)
+			ret = -EBUSY;
+		else
+			ret = -ENOENT;
+		goto out;
+	}
+
 	if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
 		ret = -EACCES;
 		goto out;
@@ -1646,6 +1696,7 @@ static int cg_rmdir(const char *path)
 
 out:
 	free(cgdir);
+	free(next);
 	return ret;
 }
 
diff --git a/tests/test_confinement.sh b/tests/test_confinement.sh
new file mode 100644
index 00000000..8f5f484b
--- /dev/null
+++ b/tests/test_confinement.sh
@@ -0,0 +1,96 @@
+#!/bin/bash
+
+set -ex
+
+[ $(id -u) -eq 0 ]
+
+d=$(mktemp -t -d tmp.XXX)
+d2=$(mktemp -t -d tmp.XXX)
+
+pid=-1
+cleanup() {
+	[ $pid -ne -1 ] && kill -9 $pid
+	umount -l $d || true
+	umount -l $d2 || true
+	rm -rf $d $d2
+}
+
+cmdline=$(realpath $0)
+dirname=$(dirname ${cmdline})
+topdir=$(dirname ${dirname})
+
+trap cleanup EXIT HUP INT TERM
+
+${topdir}/lxcfs $d &
+pid=$!
+
+# put ourselves into x1
+cgm movepidabs freezer / $$
+cgm create freezer x1
+cgm movepid freezer x1 $$
+
+mount -t cgroup -o freezer freezer $d2
+sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true
+sudo rmdir $d2/lxcfs_test_a1 || true
+
+echo ""Making sure root cannot mkdir""
+bad=0
+mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+
+echo ""Making sure root cannot rmdir""
+mkdir $d2/lxcfs_test_a1
+mkdir $d2/lxcfs_test_a1/lxcfs_test_a2
+rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+[ -d $d2/lxcfs_test_a1 ]
+rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+[ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]
+
+echo ""Making sure root cannot read/write""
+sleep 200 &
+p=$!
+echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1
+if [ ""${bad}"" -eq 1 ]; then
+	false
+fi
+
+# make sure things like truncate and access don't leak info about
+# the /lxcfs_test_a1 cgroup which we shouldn't be able to reach
+echo ""Testing other system calls""
+${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1
+${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2
+
+echo ""Making sure root can act on descendents""
+mycg=$(cgm getpidcgroupabs freezer $$)
+newcg=${mycg}/lxcfs_test_a1
+rmdir $d2/$newcg || true  # cleanup previosu run
+mkdir $d/cgroup/freezer/$newcg
+echo $p > $d/cgroup/freezer/$newcg/tasks
+cat $d/cgroup/freezer/$newcg/tasks
+kill -9 $p
+while [ `wc -l $d/cgroup/freezer/$newcg/tasks | awk '{ print $1 }'` -ne 0 ]; do
+	sleep 1
+done
+rmdir $d/cgroup/freezer/$newcg
+
+echo ""All tests passed!""
diff --git a/tests/test_syscalls.c b/tests/test_syscalls.c
new file mode 100644
index 00000000..8561cfcd
--- /dev/null
+++ b/tests/test_syscalls.c
@@ -0,0 +1,451 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/un.h>
+#include <attr/xattr.h>
+#include <utime.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <errno.h>
+
+
+void test_open(const char *path)
+{
+	int fd = open(path, O_RDONLY);
+	if (fd >= 0) {
+		fprintf(stderr, ""leak at open of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT) {
+		fprintf(stderr, ""leak at open of %s: errno was %d\n"", path, errno);
+		exit(1);
+	}
+}
+
+void test_stat(const char *path)
+{
+	struct stat sb;
+	if (stat(path, &sb) >= 0) {
+		fprintf(stderr, ""leak at stat of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT) {
+		fprintf(stderr, ""leak at stat of %s: errno was %d\n"", path, errno);
+		exit(1);
+	}
+}
+
+void test_access(const char *path)
+{
+	if (access(path, O_RDONLY) >= 0) {
+		fprintf(stderr, ""leak at access of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT) {
+		fprintf(stderr, ""leak at access of %s: errno was %d\n"", path, errno);
+		exit(1);
+	}
+}
+
+void test_bind(const char *path)
+{
+	int sfd;
+	struct sockaddr_un my_addr, peer_addr;
+
+	sfd = socket(AF_UNIX, SOCK_STREAM, 0);
+
+	if (sfd < 0) {
+		fprintf(stderr, ""Failed to open a socket for bind test\n"");
+		exit(1);
+	}
+	memset(&my_addr, 0, sizeof(struct sockaddr_un));
+	my_addr.sun_family = AF_UNIX;
+	strncpy(my_addr.sun_path, path,
+			sizeof(my_addr.sun_path) - 1);
+	if (bind(sfd, (struct sockaddr *) &my_addr,
+				sizeof(struct sockaddr_un)) != -1) {
+		fprintf(stderr, ""leak at bind of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at bind of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+	close(sfd);
+}
+
+void test_bindmount(const char *path)
+{
+	if (mount(path, path, ""none"", MS_BIND, NULL) == 0) {
+		fprintf(stderr, ""leak at bind mount of %s\n"", path);
+		exit(1);
+	}
+}
+
+void test_truncate(const char *path)
+{
+	if (truncate(path, 0) == 0) {
+		fprintf(stderr, ""leak at truncate of %s\n"", path);
+		exit(1);
+	}
+}
+
+void test_chdir(const char *path)
+{
+	if (chdir(path) == 0) {
+		fprintf(stderr, ""leak at chdir to %s\n"", path);
+		exit(1);
+	}
+}
+
+void test_rename(const char *path)
+{
+	char *d = strdupa(path), *tmpname;
+	d = dirname(d);
+	size_t len = strlen(path) + 30;
+
+	tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/%d"", d, (int)getpid());
+	if (rename(path, tmpname) == 0 || errno != ENOENT) {
+		fprintf(stderr, ""leak at rename of %s\n"", path);
+		exit(1);
+	}
+}
+
+void test_mkdir(const char *path)
+{
+	size_t len = strlen(path) + 30;
+	char *tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/%d"", path, (int)getpid());
+
+	if (mkdir(path, 0755) == 0) {
+		fprintf(stderr, ""leak at mkdir of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT) {
+		fprintf(stderr, ""leak at mkdir of %s, errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+	if (mkdir(tmpname, 0755) == 0) {
+		fprintf(stderr, ""leak at mkdir of %s\n"", tmpname);
+		exit(1);
+	}
+	if (errno != ENOENT) {
+		fprintf(stderr, ""leak at mkdir of %s, errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_rmdir(const char *path)
+{
+	size_t len = strlen(path) + 30;
+	char *tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/%d"", path, (int)getpid());
+
+	if (rmdir(path) == 0 || errno != ENOENT) {
+		fprintf(stderr, ""leak at rmdir of %s\n"", path);
+		exit(1);
+	}
+	if (rmdir(tmpname) == 0 || errno != ENOENT) {
+		fprintf(stderr, ""leak at rmdir of %s\n"", tmpname);
+		exit(1);
+	}
+}
+
+void test_creat(const char *path)
+{
+	if (creat(path, 0755) >= 0) {
+		fprintf(stderr, ""leak at creat of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at creat of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_link(const char *path)
+{
+	char *d = strdupa(path), *tmpname;
+	d = dirname(d);
+	size_t len = strlen(path) + 30;
+	tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/%d"", d, (int)getpid());
+
+	if (link(path, tmpname) == 0) {
+		fprintf(stderr, ""leak at link of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at link of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+
+	if (link(tmpname, path) == 0) {
+		fprintf(stderr, ""leak at link (2) of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at link (2) of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_unlink(const char *path)
+{
+	if (unlink(path) == 0) {
+		fprintf(stderr, ""leak at unlink of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at unlink of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_symlink(const char *path)
+{
+	char *d = strdupa(path), *tmpname;
+	d = dirname(d);
+	size_t len = strlen(path) + 30;
+	tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/%d"", d, (int)getpid());
+
+	if (symlink(tmpname, path) == 0) {
+		fprintf(stderr, ""leak at symlink of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at symlink of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+	if (symlink(path, tmpname) == 0) {
+		fprintf(stderr, ""leak at symlink (2) of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at symlink (2) of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_readlink(const char *path)
+{
+	char *dest = alloca(2 * strlen(path));
+
+	if (readlink(path, dest, 2 * strlen(path)) >= 0) {
+		fprintf(stderr, ""leak at readlink of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at readlink of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_chmod(const char *path)
+{
+	if (chmod(path, 0755) == 0) {
+		fprintf(stderr, ""leak at chmod of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at chmod of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_chown(const char *path)
+{
+	if (chown(path, 0, 0) == 0) {
+		fprintf(stderr, ""leak at chown of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at chown of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_lchown(const char *path)
+{
+	if (lchown(path, 0, 0) == 0) {
+		fprintf(stderr, ""leak at lchown of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at lchown of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_mknod(const char *path)
+{
+	if (mknod(path, 0755, makedev(0, 0)) == 0) {
+		fprintf(stderr, ""leak at mknod of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at mknod of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_chroot(const char *path)
+{
+	if (chroot(path) == 0) {
+		fprintf(stderr, ""leak at chroot of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at chroot of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_xattrs(const char *path)
+{
+	/*
+	 * might consider doing all of:
+	 *  setxattr
+	 *  lsetxattr
+	 *  getxattr
+	 *  lgetxattr
+	 *  listxattr
+	 *  llistxattr
+	 *  removexattr
+	 *  lremovexattr
+	 */
+	 char value[200];
+	 if (getxattr(path, ""security.selinux"", value, 200) >= 0) {
+		fprintf(stderr, ""leak at getxattr of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at getxattr of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_utimes(const char *path)
+{
+	struct utimbuf times;
+	times.actime = 0;
+	times.modtime = 0;
+
+	if (utime(path, &times) == 0) {
+		fprintf(stderr, ""leak at utime of %s\n"", path);
+		exit(1);
+	}
+	if (errno != ENOENT && errno != ENOSYS) {
+		fprintf(stderr, ""leak at utime of %s: errno was %s\n"", path, strerror(errno));
+		exit(1);
+	}
+}
+
+void test_openat(const char *path)
+{
+	char *d = strdupa(path), *f, *tmpname;
+	int fd, fd2;
+	f = basename(d);
+	d = dirname(d);
+	fd = open(d, O_RDONLY);
+	if (fd < 0) {
+		fprintf(stderr, ""Error in openat test: could not open parent dir\n"");
+		fprintf(stderr, ""(this is expected on the second run)\n"");
+		return;
+	}
+	fd2 = openat(fd, f, O_RDONLY);
+	if (fd2 >= 0 || errno != ENOENT) {
+		fprintf(stderr, ""leak at openat of %s\n"", f);
+		exit(1);
+	}
+	size_t len = strlen(path) + strlen(""/cgroup.procs"") + 1;
+	tmpname = alloca(len);
+	snprintf(tmpname, len, ""%s/cgroup.procs"", f);
+	fd2 = openat(fd, tmpname, O_RDONLY);
+	if (fd2 >= 0 || errno != ENOENT) {
+		fprintf(stderr, ""leak at openat of %s\n"", tmpname);
+		exit(1);
+	}
+	close(fd);
+}
+
+int main(int argc, char *argv[])
+{
+	char *procspath;
+	size_t len;
+
+	if (geteuid() != 0) {
+		fprintf(stderr, ""Run me as root\n"");
+		exit(1);
+	}
+
+	if (argc != 2)  {
+		fprintf(stderr, ""Usage: %s [lxcfs_test_cgroup_path]\n"", argv[0]);
+		exit(1);
+	}
+
+	/* Try syscalls on the directory and on $directory/cgroup.procs */
+	len = strlen(argv[1]) + strlen(""/cgroup.procs"") + 1;
+	procspath = alloca(len);
+	snprintf(procspath, len, ""%s/cgroup.procs"", argv[1]);
+
+	test_open(argv[1]);
+	test_open(procspath);
+	test_stat(argv[1]);
+	test_stat(procspath);
+	test_access(argv[1]);
+	test_access(procspath);
+
+	test_bind(argv[1]);
+	test_bind(procspath);
+	test_bindmount(argv[1]);
+	test_bindmount(procspath);
+	test_truncate(argv[1]);
+	test_truncate(procspath);
+	test_chdir(argv[1]);
+	test_chdir(procspath);
+	test_rename(argv[1]);
+	test_rename(procspath);
+	test_mkdir(argv[1]);
+	test_mkdir(procspath);
+	test_rmdir(argv[1]);
+	test_rmdir(procspath);
+	test_creat(argv[1]);
+	test_creat(procspath);
+	test_link(argv[1]);
+	test_link(procspath);
+	test_unlink(argv[1]);
+	test_unlink(procspath);
+	test_symlink(argv[1]);
+	test_symlink(procspath);
+	test_readlink(argv[1]);
+	test_readlink(procspath);
+	test_chmod(argv[1]);
+	test_chmod(procspath);
+	test_chown(argv[1]);
+	test_chown(procspath);
+	test_lchown(argv[1]);
+	test_lchown(procspath);
+	test_mknod(argv[1]);
+	test_mknod(procspath);
+	test_chroot(argv[1]);
+	test_chroot(procspath);
+	test_xattrs(argv[1]);
+	test_xattrs(procspath);
+	test_utimes(argv[1]);
+	test_utimes(procspath);
+
+	test_openat(argv[1]);
+	// meh...  linkat etc?
+
+	printf(""All tests passed\n"");
+	return 0;
+}",CWE-200
CVE-2020-22783,"From 53f126082a8b3d094e48b159f0f0bc8a5db4b2f4 Mon Sep 17 00:00:00 2001
From: John McLear <john@mclear.co.uk>
Date: Sun, 29 Mar 2020 09:35:20 +0000
Subject: [PATCH] SessionStore: replace password with PASSWORD_HIDDEN when
 storing in db

Fixes #3421.
---
 src/node/db/SessionStore.js | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/node/db/SessionStore.js b/src/node/db/SessionStore.js
index 647cbbc8d9f..263c7d6eefe 100644
--- a/src/node/db/SessionStore.js
+++ b/src/node/db/SessionStore.js
@@ -38,6 +38,11 @@ SessionStore.prototype.get = function(sid, fn) {
 SessionStore.prototype.set = function(sid, sess, fn) {
   messageLogger.debug('SET ' + sid);
 
+  // don't store passwords in DB
+  if (sess.user && sess.user.password) {
+    sess.user.password = ""PASSWORD_HIDDEN"";
+  }
+
   db.set(""sessionstorage:"" + sid, sess);
   if (fn) {
     process.nextTick(fn);",CWE-200
CVE-2016-5739,"From 2f4950828ec241e8cbdcf13090c2582a6fa620cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michal=20=C4=8Ciha=C5=99?= <michal@cihar.com>
Date: Mon, 20 Jun 2016 10:46:51 +0200
Subject: [PATCH] Update referrer <meta> to match current standards
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Michal Čihař <michal@cihar.com>
---
 libraries/Header.php | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/Header.php b/libraries/Header.php
index c20dfeb35ce6..93d05ca4bf83 100644
--- a/libraries/Header.php
+++ b/libraries/Header.php
@@ -639,7 +639,7 @@ private function _getHtmlStart()
     private function _getMetaTags()
     {
         $retval  = '<meta charset=""utf-8"" />';
-        $retval .= '<meta name=""referrer"" content=""none"" />';
+        $retval .= '<meta name=""referrer"" content=""no-referrer"" />';
         $retval .= '<meta name=""robots"" content=""noindex,nofollow"" />';
         $retval .= '<meta http-equiv=""X-UA-Compatible"" content=""IE=Edge"">';
         if (! $GLOBALS['cfg']['AllowThirdPartyFraming']) {",CWE-200
CVE-2016-4309,"From b329a14adc40868965076a77210452e396243dcd Mon Sep 17 00:00:00 2001
From: nitriques <nico@nitriques.com>
Date: Mon, 23 May 2016 14:09:34 -0400
Subject: [PATCH] Better php.ini overrides for insecure setups

This change is to protect our users against a poorly setup server. PHP
can allow pretty scary things security-wise, so it's best to make sure
things that can only have one valid setting should be enforced.

Thanks to @hyp3rlinx for this.
---
 symphony/lib/core/class.session.php | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/symphony/lib/core/class.session.php b/symphony/lib/core/class.session.php
index c0075a166..dedb526fa 100644
--- a/symphony/lib/core/class.session.php
+++ b/symphony/lib/core/class.session.php
@@ -58,6 +58,9 @@ public static function start($lifetime = 0, $path = '/', $domain = null, $httpOn
 
             if (session_id() == '') {
                 ini_set('session.save_handler', 'user');
+                ini_set('session.use_trans_sid', '0');
+                ini_set('session.use_strict_mode', '1');
+                ini_set('session.use_only_cookies', '1');
                 ini_set('session.gc_maxlifetime', $lifetime);
                 ini_set('session.gc_probability', '1');
                 ini_set('session.gc_divisor', Symphony::Configuration()->get('session_gc_divisor', 'symphony'));",CWE-200
