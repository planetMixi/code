vuln_id,code_diff,cwe_id
CVE-2017-8065,"From 3b30460c5b0ed762be75a004e924ec3f8711e032 Mon Sep 17 00:00:00 2001
From: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date: Mon, 27 Feb 2017 15:30:56 +0000
Subject: [PATCH] crypto: ccm - move cbcmac input off the stack

Commit f15f05b0a5de (""crypto: ccm - switch to separate cbcmac driver"")
refactored the CCM driver to allow separate implementations of the
underlying MAC to be provided by a platform. However, in doing so, it
moved some data from the linear region to the stack, which violates the
SG constraints when the stack is virtually mapped.

So move idata/odata back to the request ctx struct, of which we can
reasonably expect that it has been allocated using kmalloc() et al.

Reported-by: Johannes Berg <johannes@sipsolutions.net>
Fixes: f15f05b0a5de (""crypto: ccm - switch to separate cbcmac driver"")
Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Tested-by: Johannes Berg <johannes@sipsolutions.net>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
---
 crypto/ccm.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/crypto/ccm.c b/crypto/ccm.c
index 442848807a52b1..1ce37ae0ce565a 100644
--- a/crypto/ccm.c
+++ b/crypto/ccm.c
@@ -45,6 +45,7 @@ struct crypto_rfc4309_req_ctx {
 
 struct crypto_ccm_req_priv_ctx {
 	u8 odata[16];
+	u8 idata[16];
 	u8 auth_tag[16];
 	u32 flags;
 	struct scatterlist src[3];
@@ -183,8 +184,8 @@ static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,
 	AHASH_REQUEST_ON_STACK(ahreq, ctx->mac);
 	unsigned int assoclen = req->assoclen;
 	struct scatterlist sg[3];
-	u8 odata[16];
-	u8 idata[16];
+	u8 *odata = pctx->odata;
+	u8 *idata = pctx->idata;
 	int ilen, err;
 
 	/* format control data for input */",CWE-119
OSV-2020-263,"From b534f03eecd8a109db2b085ab24d419b6486de97 Mon Sep 17 00:00:00 2001
From: ""Victor M. Alvarez"" <vmalvarez@virustotal.com>
Date: Mon, 16 Dec 2019 10:27:17 +0100
Subject: [PATCH] Fix buffer overrun in ""dotnet"" module. (#1173)

Credits to OSS-Fuzz.
---
 libyara/modules/dotnet/dotnet.c                   |   3 +++
 ...tcase-minimized-dotnet_fuzzer-5195285818507264 | Bin 0 -> 993 bytes
 2 files changed, 3 insertions(+)
 create mode 100644 tests/oss-fuzz/dotnet_fuzzer_corpus/clusterfuzz-testcase-minimized-dotnet_fuzzer-5195285818507264

diff --git a/libyara/modules/dotnet/dotnet.c b/libyara/modules/dotnet/dotnet.c
index 2cfc82da0d..3e49acbaa0 100644
--- a/libyara/modules/dotnet/dotnet.c
+++ b/libyara/modules/dotnet/dotnet.c
@@ -795,6 +795,9 @@ void dotnet_parse_tilde_2(
 
             // Now follow the Class index into the TypeRef table.
             typeref_row = typeref_ptr + (typeref_row_size * class_index);
+              
+            if (!fits_in_pe(pe, typeref_row, typeref_row_size))
+              break;
 
             // Skip over the ResolutionScope and check the Name field,
             // which is an index into the Strings heap.
diff --git a/tests/oss-fuzz/dotnet_fuzzer_corpus/clusterfuzz-testcase-minimized-dotnet_fuzzer-5195285818507264 b/tests/oss-fuzz/dotnet_fuzzer_corpus/clusterfuzz-testcase-minimized-dotnet_fuzzer-5195285818507264
new file mode 100644
index 0000000000000000000000000000000000000000..0d308e15c61503629d93c3a7b3efb806ca674187
GIT binary patch
literal 993
zcmeZ`+Q`7nQWC7f00dGA3<0hn1_J{VgWdU^|9#zbbv+oIg1ww#8<^fRaQ@?D0m^Lw
zD=1+Q0Me=s4Gau#7#LU>OhBTZE<oY{GXujJAg%0_lb^)J!l|dD05%?^!0yw|{~#I(
z{6JzeJY-{FDAPS^Zf2-wpl57U3Iw)h<{%ZU3^^c*@9+OzKxzde(EK_E1`#F(hAAL+
za7j^SUV1SD12YH1^8Y|k6RjK?%)ptFUs9x943Y%tCJ2Da^HPDTR54Xj$5(2D%vYHH
zL=^!=vJnG=_>Jv~z+hg@pvNH15C<f=f#gI6VK7^pp^m|l!2nHG4@uU{(7+VcTudJI
zY_c>rGBGwZGO#>vU}0`*VaZ?!b{fdZ$c{3EiX%J(l4Ssjg1ig#Eglb90s{p#Fpy0)
pGBZIkn;U2=s?F$u#Y`?hGuFuH>X{Q~4UEk!Oij#zJ~yyn004O;igy42

literal 0
HcmV?d00001",CWE-119
GHSA-mc22-5q92-8v85,"From 1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e Mon Sep 17 00:00:00 2001
From: Matthias Wahl <mwahl@wayfair.com>
Date: Wed, 15 Sep 2021 13:40:23 +0200
Subject: [PATCH] Remove patch and merge in_place optimizations.

They are too dangerous and can lead to memory unsafety.

Also added proper state handling to script based tests.

Signed-off-by: Matthias Wahl <mwahl@wayfair.com>
---
 tests/script.rs                               |   5 +-
 tests/script_runtime_error.rs                 |   6 +-
 .../error.txt                                 |   0
 .../in                                        |   0
 .../script.tremor                             |   0
 .../error.txt                                 |   0
 .../in                                        |   0
 .../script.tremor                             |   0
 tests/scripts/merge_assign_target_state/in    |   2 +
 tests/scripts/merge_assign_target_state/out   |   2 +
 .../merge_assign_target_state/script.tremor   |   8 ++
 .../in                                        |   0
 .../out                                       |   0
 .../script.tremor                             |   0
 tremor-script/src/ast.rs                      |   4 -
 tremor-script/src/ast/base_expr.rs            |   2 -
 tremor-script/src/ast/raw.rs                  |  48 +++-----
 tremor-script/src/ast/to_static.rs            |   2 -
 tremor-script/src/interpreter/expr.rs         | 113 +-----------------
 19 files changed, 40 insertions(+), 152 deletions(-)
 rename tests/script_runtime_errors/{merge_in_place_new_no_object => merge_assign_target_new_no_object}/error.txt (100%)
 rename tests/script_runtime_errors/{merge_in_place_new_no_object => merge_assign_target_new_no_object}/in (100%)
 rename tests/script_runtime_errors/{merge_in_place_new_no_object => merge_assign_target_new_no_object}/script.tremor (100%)
 rename tests/script_runtime_errors/{merge_in_place_target_no_object => merge_assign_target_target_no_object}/error.txt (100%)
 rename tests/script_runtime_errors/{merge_in_place_target_no_object => merge_assign_target_target_no_object}/in (100%)
 rename tests/script_runtime_errors/{merge_in_place_target_no_object => merge_assign_target_target_no_object}/script.tremor (100%)
 create mode 100644 tests/scripts/merge_assign_target_state/in
 create mode 100644 tests/scripts/merge_assign_target_state/out
 create mode 100644 tests/scripts/merge_assign_target_state/script.tremor
 rename tests/scripts/{patch_in_place => patch_assign_target}/in (100%)
 rename tests/scripts/{patch_in_place => patch_assign_target}/out (100%)
 rename tests/scripts/{patch_in_place => patch_assign_target}/script.tremor (100%)

diff --git a/tests/script.rs b/tests/script.rs
index 0e437e73cb..a435cb8de5 100644
--- a/tests/script.rs
+++ b/tests/script.rs
@@ -51,6 +51,7 @@ macro_rules! test_cases {
                 out_json.reverse();
 
                 let mut results = Vec::new();
+                let mut state = Value::null();
                 for (id, mut json) in in_json.into_iter().enumerate() {
                     let uri = EventOriginUri{
                         host: ""test"".into(),
@@ -62,7 +63,6 @@ macro_rules! test_cases {
                     };
                     let context = EventContext::new(id as u64, Some(&uri));
                     let mut meta = Value::from(Object::default());
-                    let mut state = Value::null();
                     match script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta)? {
                         Return::Drop => (),
                         Return::EmitEvent{..} => results.push(json),
@@ -154,6 +154,7 @@ test_cases!(
     // TODO
     // const_in_const_lookup,
     // INSERT
+    merge_assign_target_state,
     expr_path,
     patch_default,
     patch_default_key,
@@ -186,7 +187,7 @@ test_cases!(
     heredoc_quoted_curly,
     string_interpolation_import,
     string_interpolation_prefix,
-    patch_in_place,
+    patch_assign_target,
     tuple_pattern,
     pattern_cmp,
     pass_args,
diff --git a/tests/script_runtime_error.rs b/tests/script_runtime_error.rs
index 7989fa39e6..e97ef9add5 100644
--- a/tests/script_runtime_error.rs
+++ b/tests/script_runtime_error.rs
@@ -105,10 +105,10 @@ macro_rules! ignore_cases {
                 file.read_to_string(&mut err)?;
                 let _err = err.trim();
 
+                let mut state = Value::null();
                 if let Some(mut json) =  in_json.pop() {
                     let context = EventContext::new(0, None);
                     let mut meta = Value::object();
-                    let mut state = Value::null();
                     let s = script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta);
                     if let Err(e) = s {
                         let mut h = Dumb::new();
@@ -144,8 +144,8 @@ test_cases!(
     function_error_n,
     match_bad_guard_type,
     match_no_clause_hit,
-    merge_in_place_new_no_object,
-    merge_in_place_target_no_object,
+    merge_assign_target_new_no_object,
+    merge_assign_target_target_no_object,
     merge_new_no_object,
     merge_target_no_object,
     missing_local,
diff --git a/tests/script_runtime_errors/merge_in_place_new_no_object/error.txt b/tests/script_runtime_errors/merge_assign_target_new_no_object/error.txt
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_new_no_object/error.txt
rename to tests/script_runtime_errors/merge_assign_target_new_no_object/error.txt
diff --git a/tests/script_runtime_errors/merge_in_place_new_no_object/in b/tests/script_runtime_errors/merge_assign_target_new_no_object/in
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_new_no_object/in
rename to tests/script_runtime_errors/merge_assign_target_new_no_object/in
diff --git a/tests/script_runtime_errors/merge_in_place_new_no_object/script.tremor b/tests/script_runtime_errors/merge_assign_target_new_no_object/script.tremor
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_new_no_object/script.tremor
rename to tests/script_runtime_errors/merge_assign_target_new_no_object/script.tremor
diff --git a/tests/script_runtime_errors/merge_in_place_target_no_object/error.txt b/tests/script_runtime_errors/merge_assign_target_target_no_object/error.txt
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_target_no_object/error.txt
rename to tests/script_runtime_errors/merge_assign_target_target_no_object/error.txt
diff --git a/tests/script_runtime_errors/merge_in_place_target_no_object/in b/tests/script_runtime_errors/merge_assign_target_target_no_object/in
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_target_no_object/in
rename to tests/script_runtime_errors/merge_assign_target_target_no_object/in
diff --git a/tests/script_runtime_errors/merge_in_place_target_no_object/script.tremor b/tests/script_runtime_errors/merge_assign_target_target_no_object/script.tremor
similarity index 100%
rename from tests/script_runtime_errors/merge_in_place_target_no_object/script.tremor
rename to tests/script_runtime_errors/merge_assign_target_target_no_object/script.tremor
diff --git a/tests/scripts/merge_assign_target_state/in b/tests/scripts/merge_assign_target_state/in
new file mode 100644
index 0000000000..dc573f65e1
--- /dev/null
+++ b/tests/scripts/merge_assign_target_state/in
@@ -0,0 +1,2 @@
+{""foo"": ""bar""}
+{""snot"": ""badger"", ""foo"": ""grmpf""}
\ No newline at end of file
diff --git a/tests/scripts/merge_assign_target_state/out b/tests/scripts/merge_assign_target_state/out
new file mode 100644
index 0000000000..d6d4097966
--- /dev/null
+++ b/tests/scripts/merge_assign_target_state/out
@@ -0,0 +1,2 @@
+{""foo"":""bar""}
+{""foo"":""grmpf"",""snot"":""badger""}
\ No newline at end of file
diff --git a/tests/scripts/merge_assign_target_state/script.tremor b/tests/scripts/merge_assign_target_state/script.tremor
new file mode 100644
index 0000000000..9d1b25eadf
--- /dev/null
+++ b/tests/scripts/merge_assign_target_state/script.tremor
@@ -0,0 +1,8 @@
+# initialize state to record, so we can do the merge
+let state = match state of
+	case null => {}
+	default => state
+end;
+
+let state = merge state of event end;
+emit state
diff --git a/tests/scripts/patch_in_place/in b/tests/scripts/patch_assign_target/in
similarity index 100%
rename from tests/scripts/patch_in_place/in
rename to tests/scripts/patch_assign_target/in
diff --git a/tests/scripts/patch_in_place/out b/tests/scripts/patch_assign_target/out
similarity index 100%
rename from tests/scripts/patch_in_place/out
rename to tests/scripts/patch_assign_target/out
diff --git a/tests/scripts/patch_in_place/script.tremor b/tests/scripts/patch_assign_target/script.tremor
similarity index 100%
rename from tests/scripts/patch_in_place/script.tremor
rename to tests/scripts/patch_assign_target/script.tremor
diff --git a/tremor-script/src/ast.rs b/tremor-script/src/ast.rs
index d49fcc447a..0fe7d60da8 100644
--- a/tremor-script/src/ast.rs
+++ b/tremor-script/src/ast.rs
@@ -961,10 +961,6 @@ pub enum Expr<'script> {
     Match(Box<Match<'script, Self>>),
     /// IfElse style match expression
     IfElse(Box<IfElse<'script, Self>>),
-    /// In place patch expression
-    PatchInPlace(Box<Patch<'script>>),
-    /// In place merge expression
-    MergeInPlace(Box<Merge<'script>>),
     /// Assignment expression
     Assign {
         /// Id
diff --git a/tremor-script/src/ast/base_expr.rs b/tremor-script/src/ast/base_expr.rs
index 5e2425bab9..237a025eb8 100644
--- a/tremor-script/src/ast/base_expr.rs
+++ b/tremor-script/src/ast/base_expr.rs
@@ -248,8 +248,6 @@ impl<'script> BaseExpr for Expr<'script> {
             Expr::Emit(e) => e.mid(),
             Expr::Imut(e) => e.mid(),
             Expr::Match(e) => e.mid(),
-            Expr::MergeInPlace(e) => e.mid(),
-            Expr::PatchInPlace(e) => e.mid(),
             Expr::IfElse(e) => e.mid(),
         }
     }
diff --git a/tremor-script/src/ast/raw.rs b/tremor-script/src/ast/raw.rs
index a6bf0d3496..f0f9503304 100644
--- a/tremor-script/src/ast/raw.rs
+++ b/tremor-script/src/ast/raw.rs
@@ -18,14 +18,14 @@
 
 use crate::{
     ast::{
-        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,
-        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,
-        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,
-        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,
-        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,
-        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,
-        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,
-        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,
+        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,
+        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,
+        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,
+        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,
+        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,
+        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,
+        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,
+        TuplePattern, UnaryExpr, UnaryOpKind,
     },
     errors::{
         err_generic, error_generic, error_missing_effector, error_oops, Error, ErrorKind, Result,
@@ -646,28 +646,16 @@ impl<'script> Upable<'script> for ExprRaw<'script> {
                 let path = a.path.up(helper)?;
                 let mid = helper.add_meta(a.start, a.end);
                 match a.expr.up(helper)? {
-                    Expr::Imut(ImutExprInt::Merge(m)) => {
-                        if path.ast_eq(&m.target) {
-                            Expr::MergeInPlace(Box::new(*m))
-                        } else {
-                            Expr::Assign {
-                                mid,
-                                path,
-                                expr: Box::new(ImutExprInt::Merge(m).into()),
-                            }
-                        }
-                    }
-                    Expr::Imut(ImutExprInt::Patch(m)) => {
-                        if path.ast_eq(&m.target) {
-                            Expr::PatchInPlace(Box::new(*m))
-                        } else {
-                            Expr::Assign {
-                                mid,
-                                path,
-                                expr: Box::new(ImutExprInt::Patch(m).into()),
-                            }
-                        }
-                    }
+                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {
+                        mid,
+                        path,
+                        expr: Box::new(ImutExprInt::Merge(m).into()),
+                    },
+                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {
+                        mid,
+                        path,
+                        expr: Box::new(ImutExprInt::Patch(m).into()),
+                    },
                     expr => Expr::Assign {
                         mid,
                         path,
diff --git a/tremor-script/src/ast/to_static.rs b/tremor-script/src/ast/to_static.rs
index cc3f1803ac..77195e841b 100644
--- a/tremor-script/src/ast/to_static.rs
+++ b/tremor-script/src/ast/to_static.rs
@@ -159,8 +159,6 @@ impl<'script> Expr<'script> {
         match self {
             Expr::Match(e) => Expr::Match(Box::new(e.into_static())),
             Expr::IfElse(e) => Expr::IfElse(Box::new(e.into_static())),
-            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),
-            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),
             Expr::Assign { mid, path, expr } => Expr::Assign {
                 mid,
                 path: path.into_static(),
diff --git a/tremor-script/src/interpreter/expr.rs b/tremor-script/src/interpreter/expr.rs
index 40038780c5..fcc86edca8 100644
--- a/tremor-script/src/interpreter/expr.rs
+++ b/tremor-script/src/interpreter/expr.rs
@@ -13,24 +13,23 @@
 // limitations under the License.
 
 use super::{
-    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,
-    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,
+    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,
+    LocalStack, NULL,
 };
 use crate::errors::{
     error_assign_array, error_assign_to_const, error_bad_key_err, error_invalid_assign_target,
-    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,
+    error_need_obj_err, error_no_clause_hit, Result,
 };
 use crate::prelude::*;
 use crate::registry::RECUR_PTR;
 use crate::{
     ast::{
         BaseExpr, ClauseGroup, ClausePreCondition, Comprehension, DefaultCase, EmitExpr, EventPath,
-        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,
+        Expr, IfElse, ImutExprInt, Match, Path, Segment,
     },
     errors::error_oops_err,
 };
 use crate::{stry, Value};
-use matches::matches;
 use std::mem;
 use std::{
     borrow::{Borrow, Cow},
@@ -219,104 +218,6 @@ impl<'script> Expr<'script> {
         }
     }
 
-    fn patch_in_place<'run, 'event>(
-        opts: ExecOpts,
-        env: &'run Env<'run, 'event>,
-        event: &'run Value<'event>,
-        state: &'run Value<'static>,
-        meta: &'run Value<'event>,
-        local: &'run LocalStack<'event>,
-        expr: &'run Patch<'event>,
-    ) -> Result<Cow<'run, Value<'event>>> {
-        // This function is called when we encounter code that consumes a value
-        // to patch it. So the following code:
-        // ```tremor
-        // let event = patch event of insert ""key"" => ""value"" end
-        // ```
-        // When executed on it's own would clone the event, add a key and
-        // overwrite original event.
-        //
-        // We optimise this as:
-        // ```
-        // patch_in_place event of insert ""key"" => ""value"" end
-        // ```
-        //
-        // This code is generated in impl Upable for ExprRaw where the following
-        // checks are performed:
-        //
-        // 1) the patch is on the RHS of an assignment
-        // 2) the path of the assigned value and the path of the patched
-        //    expression are identical.
-        //
-        // In turn this guarantees (at compile time):
-        //
-        // 1) The target (`expr`) is a path lookup
-        // 2) The target is not a known constant as otherwise the assignment
-        //    will complan
-        // 3) this leave the `expr` to be either a local, the event, the state,
-        //    metadata or a subkey thereof.
-        //
-        // And the following guarantees at run time:
-        //
-        // 1) the `expr` is an existing key of the mentioned categories,
-        //    otherwise `expr.target.run` will error.
-        // 2) `value` will never be owned (however the resolve function is
-        //    generic so it needs to return a Cow)
-
-        let value: Cow<'run, Value<'event>> =
-            stry!(expr.target.run(opts, env, event, state, meta, local));
-        debug_assert!(
-            !matches!(value, Cow::Owned(_)),
-            ""We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local""
-        );
-        let v: &Value<'event> = value.borrow();
-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032
-        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]
-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032
-        let v: &mut Value<'event> = unsafe { mem::transmute(v) };
-        stry!(patch_value(opts, env, event, state, meta, local, v, expr));
-        Ok(value)
-    }
-
-    fn merge_in_place<'run, 'event>(
-        &'run self,
-        opts: ExecOpts,
-        env: &'run Env<'run, 'event>,
-        event: &'run mut Value<'event>,
-        state: &'run mut Value<'static>,
-        meta: &'run mut Value<'event>,
-        local: &'run mut LocalStack<'event>,
-        expr: &'run Merge<'event>,
-    ) -> Result<Cow<'run, Value<'event>>> {
-        // Please see the soundness reasoning in `patch_in_place` for details
-        // those functions perform the same function just with slighty different
-        // operations.
-        let value_cow: Cow<'run, Value<'event>> =
-            stry!(expr.target.run(opts, env, event, state, meta, local));
-        debug_assert!(
-            !matches!(value_cow, Cow::Owned(_)),
-            ""We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local""
-        );
-
-        if value_cow.is_object() {
-            let value: &Value<'event> = value_cow.borrow();
-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032
-            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]
-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032
-            let value: &mut Value<'event> = unsafe { mem::transmute(value) };
-            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));
-
-            if replacement.is_object() {
-                stry!(merge_values(self, &expr.expr, value, &replacement));
-                Ok(value_cow)
-            } else {
-                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)
-            }
-        } else {
-            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)
-        }
-    }
-
     // TODO: Quite some overlap with `ImutExprInt::comprehension`
     fn comprehension<'run, 'event>(
         &'run self,
@@ -641,12 +542,6 @@ impl<'script> Expr<'script> {
             }
             Expr::Match(ref expr) => self.match_expr(opts, env, event, state, meta, local, expr),
             Expr::IfElse(ref expr) => self.if_expr(opts, env, event, state, meta, local, expr),
-            Expr::MergeInPlace(ref expr) => self
-                .merge_in_place(opts, env, event, state, meta, local, expr)
-                .map(Cont::Cont),
-            Expr::PatchInPlace(ref expr) => {
-                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)
-            }
             Expr::Comprehension(ref expr) => {
                 self.comprehension(opts, env, event, state, meta, local, expr)
             }",CWE-119
OSV-2021-1797,"From 5ee01b547418efb8b90702d8b8ec5d05d1f28015 Mon Sep 17 00:00:00 2001
From: Aaron Boxer <boxerab@gmail.com>
Date: Fri, 7 Jan 2022 18:09:43 -0500
Subject: [PATCH] cie : fix heab-buffer overflow in cieToRGB method

https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=43161&sort=-opened&can=1&q=proj%3Agrok
---
 src/lib/jp2/util/GrkImage_Conversion.cpp | 86 ++++++++++++++----------
 1 file changed, 51 insertions(+), 35 deletions(-)

diff --git a/src/lib/jp2/util/GrkImage_Conversion.cpp b/src/lib/jp2/util/GrkImage_Conversion.cpp
index 9ed3bac0e9..0fd10e1ad4 100644
--- a/src/lib/jp2/util/GrkImage_Conversion.cpp
+++ b/src/lib/jp2/util/GrkImage_Conversion.cpp
@@ -1282,6 +1282,12 @@ bool GrkImage::cieLabToRGB(void)
 	// sanity checks
 	if(numcomps == 0 || !allComponentsSanityCheck(true))
 		return false;
+	if (numcomps < 3){
+		GRK_WARN(""cieLabToRGB: there must be at least three components"");
+		return false;
+	}
+	if (numcomps > 3)
+		GRK_WARN(""cieLabToRGB: there are more than three components : extra components will be ignored."");
 	if(!meta)
 		return false;
 	size_t i;
@@ -1290,16 +1296,18 @@ bool GrkImage::cieLabToRGB(void)
 		auto comp0 = comps;
 		auto compi = comps + i;
 
-		if(comp0->prec != compi->prec)
+		if(comp0->stride != compi->stride)
 			break;
-		if(comp0->sgnd != compi->sgnd)
+
+		if(comp0->w != compi->w)
 			break;
-		if(comp0->stride != compi->stride)
+
+		if(comp0->h != compi->h)
 			break;
 	}
 	if(i != numcomps)
 	{
-		GRK_WARN(""All components must have same precision, sign and stride"");
+		GRK_WARN(""cieLabToRGB: all components must have same dimensions, precision and sign"");
 		return false;
 	}
 
@@ -1317,16 +1325,10 @@ bool GrkImage::cieLabToRGB(void)
 	cmsCIExyY WhitePoint;
 	defaultType = row[1] == GRK_DEFAULT_CIELAB_SPACE;
 	int32_t *L, *a, *b, *red, *green, *blue;
-	int32_t *src[3], *dst[3];
 	// range, offset and precision for L,a and b coordinates
 	double r_L, o_L, r_a, o_a, r_b, o_b, prec_L, prec_a, prec_b;
 	double minL, maxL, mina, maxa, minb, maxb;
 	cmsUInt16Number RGB[3];
-	auto dest_img = createRGB(3, comps[0].w, comps[0].h,
-												  comps[0].prec);
-	if(!dest_img)
-		return false;
-
 	prec_L = (double)comps[0].prec;
 	prec_a = (double)comps[1].prec;
 	prec_b = (double)comps[2].prec;
@@ -1393,14 +1395,11 @@ bool GrkImage::cieLabToRGB(void)
 	cmsCloseProfile(in);
 	cmsCloseProfile(out);
 	if(transform == nullptr)
-	{
-		grk_object_unref(&dest_img->obj);
 		return false;
-	}
 
-	L = src[0] = comps[0].data;
-	a = src[1] = comps[1].data;
-	b = src[2] = comps[2].data;
+	L = comps[0].data;
+	a = comps[1].data;
+	b = comps[2].data;
 
 	if(!L || !a || !b)
 	{
@@ -1408,16 +1407,17 @@ bool GrkImage::cieLabToRGB(void)
 		return false;
 	}
 
-	red = dst[0] = dest_img->comps[0].data;
-	green = dst[1] = dest_img->comps[1].data;
-	blue = dst[2] = dest_img->comps[2].data;
+	auto dest_img = createRGB(3, comps[0].w, comps[0].h,
+												  comps[0].prec);
+	if(!dest_img)
+		return false;
 
-	dest_img->comps[0].data = nullptr;
-	dest_img->comps[1].data = nullptr;
-	dest_img->comps[2].data = nullptr;
+	red   = dest_img->comps[0].data;
+	green = dest_img->comps[1].data;
+	blue  = dest_img->comps[2].data;
 
-	grk_object_unref(&dest_img->obj);
-	dest_img = nullptr;
+	uint32_t src_stride_diff = comps[0].stride - comps[0].w;
+	uint32_t dest_stride_diff = dest_img->comps[0].stride - dest_img->comps[0].w;
 
 	minL = -(r_L * o_L) / (pow(2, prec_L) - 1);
 	maxL = minL + r_L;
@@ -1428,7 +1428,6 @@ bool GrkImage::cieLabToRGB(void)
 	minb = -(r_b * o_b) / (pow(2, prec_b) - 1);
 	maxb = minb + r_b;
 
-	uint32_t stride_diff = comps[0].stride - comps[0].w;
 	size_t dest_index = 0;
 	for(uint32_t j = 0; j < comps[0].h; ++j)
 	{
@@ -1449,24 +1448,41 @@ bool GrkImage::cieLabToRGB(void)
 			blue[dest_index] = RGB[2];
 			dest_index++;
 		}
-		dest_index += stride_diff;
-		L += stride_diff;
-		a += stride_diff;
-		b += stride_diff;
+		dest_index += dest_stride_diff;
+		L += src_stride_diff;
+		a += src_stride_diff;
+		b += src_stride_diff;
 	}
 	cmsDeleteTransform(transform);
-	for(i = 0; i < 3; ++i)
+
+	for(i = 0; i < numcomps; ++i)
 	{
-		auto comp = comps + i;
-		grk_image_single_component_data_free(comp);
-		comp->data = dst[i];
-		comp->prec = 16;
+		auto srcComp = comps + i;
+		grk_image_single_component_data_free(srcComp);
+		srcComp->data = nullptr;
 	}
+	numcomps = 3;
+	for(i = 0; i < numcomps; ++i)
+	{
+		auto srcComp = comps + i;
+		auto destComp = dest_img->comps + i;
+
+		srcComp->prec = 16;
+		srcComp->stride = destComp->stride;
+		srcComp->data = destComp->data;
+	}
+
+	// clean up dest image
+	dest_img->comps[0].data = nullptr;
+	dest_img->comps[1].data = nullptr;
+	dest_img->comps[2].data = nullptr;
+	grk_object_unref(&dest_img->obj);
+	dest_img = nullptr;
+
 	color_space = GRK_CLRSPC_SRGB;
 
 	return true;
 }
 
 
-
 } // namespace grk",CWE-119
OSV-2020-39,"From 29d9c2d2c80289f31278f8717959a5718a2e6ce1 Mon Sep 17 00:00:00 2001
From: Luca Deri <deri@ntop.org>
Date: Mon, 1 Jun 2020 09:54:05 +0200
Subject: [PATCH] Reworked HTTP header processing workflow

---
 src/lib/protocols/http.c | 29 ++++++++++++++++-------------
 1 file changed, 16 insertions(+), 13 deletions(-)

diff --git a/src/lib/protocols/http.c b/src/lib/protocols/http.c
index 9f2a59fc4ec..7b83b91e707 100644
--- a/src/lib/protocols/http.c
+++ b/src/lib/protocols/http.c
@@ -119,7 +119,7 @@ static ndpi_protocol_category_t ndpi_http_check_content(struct ndpi_detection_mo
 
 	if(cmp_mimes != NULL) {
 	  u_int8_t i;
-	  
+
 	  for(i = 0; cmp_mimes[i] != NULL; i++) {
 	    if(strncasecmp(app, cmp_mimes[i], app_len_avail) == 0) {
 	      flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
@@ -141,20 +141,23 @@ static ndpi_protocol_category_t ndpi_http_check_content(struct ndpi_detection_mo
 
 	if(filename_len > ATTACHMENT_LEN) {
 	  attachment_len += filename_len-ATTACHMENT_LEN-1;
-	  
-	  for(int i = 0; binary_file_ext[i] != NULL; i++) {    
-	    if(strncmp((const char*)&packet->content_disposition_line.ptr[attachment_len],
-		      binary_file_ext[i], ATTACHMENT_LEN) == 0) {
-	      flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
-	      NDPI_SET_BIT(flow->risk, NDPI_BINARY_APPLICATION_TRANSFER);
-	      NDPI_LOG_INFO(ndpi_struct, ""found executable HTTP transfer"");
-	      return(flow->category);
+
+	  if((attachment_len+ATTACHMENT_LEN) <= packet->content_disposition_line.len) {
+	    for(int i = 0; binary_file_ext[i] != NULL; i++) {
+	      /* Use memcmp in case content-disposition contains binary data */
+	      if(memcmp((const char*)&packet->content_disposition_line.ptr[attachment_len],
+			 binary_file_ext[i], ATTACHMENT_LEN) == 0) {
+		flow->guessed_category = flow->category = NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT;
+		NDPI_SET_BIT(flow->risk, NDPI_BINARY_APPLICATION_TRANSFER);
+		NDPI_LOG_INFO(ndpi_struct, ""found executable HTTP transfer"");
+		return(flow->category);
+	      }
 	    }
 	  }
 	}
       }
     }
-    
+
     switch(packet->content_line.ptr[0]) {
     case 'a':
       if(strncasecmp((const char *)packet->content_line.ptr, ""audio"",
@@ -193,7 +196,6 @@ static void ndpi_int_http_add_connection(struct ndpi_detection_module_struct *nd
   if((flow->guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN) || (http_protocol != NDPI_PROTOCOL_HTTP))
     flow->guessed_host_protocol_id = http_protocol;
 
-  category = ndpi_http_check_content(ndpi_struct, flow);
   ndpi_int_reset_protocol(flow);
   ndpi_set_detected_protocol(ndpi_struct, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_HTTP);
 
@@ -201,7 +203,7 @@ static void ndpi_int_http_add_connection(struct ndpi_detection_module_struct *nd
   flow->check_extra_packets = 1;
   flow->max_extra_packets_to_check = 5;
   flow->extra_packets_func = ndpi_search_http_tcp_again;
-  flow->http_detected = 1, flow->guessed_category = flow->category = category;
+  flow->http_detected = 1;
 }
 
 /* ************************************************************* */
@@ -532,7 +534,8 @@ static void check_content_type_and_change_protocol(struct ndpi_detection_module_
 	strncpy(flow->http.content_type, (char*)packet->content_line.ptr,
 		packet->content_line.len);
 	flow->http.content_type[packet->content_line.len] = '\0';
-      }
+
+	flow->guessed_category = flow->category = ndpi_http_check_content(ndpi_struct, flow);}
     }
 
     if(flow->http_detected) {",CWE-119
