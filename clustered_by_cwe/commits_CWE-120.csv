vuln_id,code_diff,cwe_id
CVE-2019-11935,"From 1c518555dba6ceb45d5ba61845b96e261219c3b7 Mon Sep 17 00:00:00 2001
From: Shaunak Kishore <kshaunak@fb.com>
Date: Mon, 28 Oct 2019 20:20:37 -0700
Subject: [PATCH] Fix buffer overflow in mb_ereg_replace

Summary:
This diff has already been landed to release and to open-source branches. We're now landing it on master.

CVE-2019-11935

Reviewed By: jjergus

Differential Revision: D18177934

fbshipit-source-id: d108a59e38c67f5f5e835febd7255307605ba62c
---
 hphp/runtime/ext/mbstring/ext_mbstring.cpp            | 11 ++++++++---
 .../mbstring/mb_ereg_replace_invalid_replacement.php  |  7 +++++++
 .../mb_ereg_replace_invalid_replacement.php.expectf   |  7 +++++++
 3 files changed, 22 insertions(+), 3 deletions(-)
 create mode 100644 hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php
 create mode 100644 hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php.expectf

diff --git a/hphp/runtime/ext/mbstring/ext_mbstring.cpp b/hphp/runtime/ext/mbstring/ext_mbstring.cpp
index b6f9940829a2e..0766bfd210e72 100644
--- a/hphp/runtime/ext/mbstring/ext_mbstring.cpp
+++ b/hphp/runtime/ext/mbstring/ext_mbstring.cpp
@@ -3609,8 +3609,9 @@ static Variant _php_mb_regex_ereg_replace_exec(const Variant& pattern,
       while (i < replacement.size()) {
         int fwd = (int)php_mb_mbchar_bytes_ex(p, enc);
         n = -1;
-        if ((replacement.size() - i) >= 2 && fwd == 1 &&
-          p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
+        auto const remaining = replacement.size() - i;
+        if (remaining >= 2 && fwd == 1 &&
+            p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
           n = p[1] - '0';
         }
         if (n >= 0 && n < regs->num_regs) {
@@ -3621,10 +3622,14 @@ static Variant _php_mb_regex_ereg_replace_exec(const Variant& pattern,
           }
           p += 2;
           i += 2;
-        } else {
+        } else if (remaining >= fwd) {
           out_buf.append(p, fwd);
           p += fwd;
           i += fwd;
+        } else {
+          raise_warning(""Replacement ends with unterminated %s: 0x%hhx"",
+                        enc->name, *p);
+          break;
         }
       }
       n = regs->end[0];
diff --git a/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php b/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php
new file mode 100644
index 0000000000000..949e7d8c90a7b
--- /dev/null
+++ b/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php
@@ -0,0 +1,7 @@
+<?hh
+
+<<__EntryPoint>>
+function main(): void {
+  var_dump(mb_ereg_replace("""", ""\xf1"", """", """"));
+  throw new Error(""done"");
+}
diff --git a/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php.expectf b/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php.expectf
new file mode 100644
index 0000000000000..9b91fa9bca3a7
--- /dev/null
+++ b/hphp/test/zend/good/ext/mbstring/mb_ereg_replace_invalid_replacement.php.expectf
@@ -0,0 +1,7 @@
+Warning: Replacement ends with unterminated UTF-8: 0xf1 in %s/mb_ereg_replace_invalid_replacement.php on line 5
+string(0) """"
+
+Fatal error: Uncaught Error: done in %s/mb_ereg_replace_invalid_replacement.php:6
+Stack trace:
+#0 (): main()
+#1 {main}",CWE-120
OSV-2022-439,"From d1a3039c350bf081cae132d6ffc1781d01fd55c6 Mon Sep 17 00:00:00 2001
From: Veronika Hanulikova <vhanulik@redhat.com>
Date: Fri, 1 Jul 2022 11:16:48 +0200
Subject: [PATCH] Fix buffer overflow

Thank oss-fuzz
https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=47676
---
 src/tools/pkcs15-tool.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/tools/pkcs15-tool.c b/src/tools/pkcs15-tool.c
index fff93ab782..20fcba7804 100644
--- a/src/tools/pkcs15-tool.c
+++ b/src/tools/pkcs15-tool.c
@@ -1961,8 +1961,11 @@ static int test_update(sc_card_t *in_card)
 			}
 			/* other tag */
 			i += 2 + rbuf[2+i+1]; /* length of this tag*/
+			if (2+i+1 >= apdu.resplen) {
+				break;
+			}
 		}
-		if (rbuf[2+i+1] < 9 || 2+i+2+9 > apdu.resplen) {
+		if (2+i+1 >= apdu.resplen || rbuf[2+i+1] < 9 || 2+i+2+9 > apdu.resplen) {
 			printf(""select file returned short fci\n"");
 			goto bad_fci;
 		}",CWE-120
CVE-2021-46225,"From 8cd68c54e0647c0030ae4506a225ad4a2655c316 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lo=C3=AFc=20Mar=C3=A9chal?= <loic.marechal@inria.fr>
Date: Fri, 7 Jan 2022 14:25:30 +0100
Subject: [PATCH] Removed a potential buffer overflow crash in GmfOpenMesh and
 debugged the test_libmeshb_block_pipeline.f that crashed

---
 examples/test_libmeshb_block_pipeline.f |  9 +++++----
 sources/libmeshb7.c                     | 10 +++++-----
 2 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/examples/test_libmeshb_block_pipeline.f b/examples/test_libmeshb_block_pipeline.f
index 940d634..e54a85c 100644
--- a/examples/test_libmeshb_block_pipeline.f
+++ b/examples/test_libmeshb_block_pipeline.f
@@ -1,5 +1,5 @@
 
-c     libmeshb example : transform a quadrilateral mesh into a triangular one
+c     libmeshb example: transform a quadrilateral mesh into a triangular one
 c     using fast block transfer and pipelined post processing
 
       include 'libmeshb7.ins'
@@ -39,14 +39,15 @@
 
 c     Read the vertices
       res = gmfgetblock(InpMsh, GmfVertices, 1_8, NmbVer,
-     +                  movver, 1, VerTab,
+     +                  0, %val(0), movver, 1, VerTab,
      +                  GmfDouble, VerTab(1,1), VerTab(1,2),
      +                  GmfDouble, VerTab(2,1), VerTab(2,2),
      +                  GmfDouble, VerTab(3,1), VerTab(3,2),
      +                  GmfInt,    RefTab(1),   RefTab(2))
 
 c     Read the quads
-      res = gmfgetblock(InpMsh, GmfQuadrilaterals, 1_8, NmbQad,0,
+      res = gmfgetblock(InpMsh, GmfQuadrilaterals, 1_8, NmbQad,
+     +                  0, %val(0), %val(0),
      +                  GmfInt, QadTab(1,1), QadTab(1,2),
      +                  GmfInt, QadTab(2,1), QadTab(2,2),
      +                  GmfInt, QadTab(3,1), QadTab(3,2),
@@ -79,7 +80,7 @@
 c     Write the triangles
       res = gmfsetkwd(OutMsh, GmfTriangles, 2*NmbQad, 0, 0)
       res = gmfsetblock(OutMsh, GmfTriangles, 1_8, 2*NmbQad,
-     +                  0,%val(0),%val(0),
+     +                  0,%val(0),
      +                  qad2tri, 2, QadTab, TriTab,
      +                  GmfInt, TriTab(1,1), TriTab(1,2),
      +                  GmfInt, TriTab(2,1), TriTab(2,2),
diff --git a/sources/libmeshb7.c b/sources/libmeshb7.c
index 8aab88e..a808b4e 100644
--- a/sources/libmeshb7.c
+++ b/sources/libmeshb7.c
@@ -2,14 +2,14 @@
 
 /*----------------------------------------------------------------------------*/
 /*                                                                            */
-/*                               LIBMESHB V7.61                               */
+/*                               LIBMESHB V7.62                               */
 /*                                                                            */
 /*----------------------------------------------------------------------------*/
 /*                                                                            */
 /*   Description:        handles .meshb file format I/O                       */
 /*   Author:             Loic MARECHAL                                        */
 /*   Creation date:      dec 09 1999                                          */
-/*   Last modification:  sep 27 2021                                          */
+/*   Last modification:  jan 07 2022                                          */
 /*                                                                            */
 /*----------------------------------------------------------------------------*/
 
@@ -655,7 +655,7 @@ int64_t GmfOpenMesh(const char *FilNam, int mod, ...)
 
          do
          {
-            res = fscanf(msh->hdl, ""%s"", str);
+            res = fscanf(msh->hdl, ""%100s"", str);
          }while( (res != EOF) && strcmp(str, ""MeshVersionFormatted"") );
 
          if(res == EOF)
@@ -668,7 +668,7 @@ int64_t GmfOpenMesh(const char *FilNam, int mod, ...)
 
          do
          {
-            res = fscanf(msh->hdl, ""%s"", str);
+            res = fscanf(msh->hdl, ""%100s"", str);
          }while( (res != EOF) && strcmp(str, ""Dimension"") );
 
          if(res == EOF)
@@ -2539,7 +2539,7 @@ static int ScaKwdTab(GmfMshSct *msh)
    if(msh->typ & Asc)
    {
       // Scan each string in the file until the end
-      while(fscanf(msh->hdl, ""%s"", str) != EOF)
+      while(fscanf(msh->hdl, ""%100s"", str) != EOF)
       {
          // Fast test in order to reject quickly the numeric values
          if(isalpha(str[0]))",CWE-120
CVE-2018-20761,"From 35ab4475a7df9b2a4bcab235e379c0c3ec543658 Mon Sep 17 00:00:00 2001
From: Aurelien David <aurelien.david@telecom-paristech.fr>
Date: Fri, 11 Jan 2019 11:32:54 +0100
Subject: [PATCH] fix some overflows due to strcpy

fixes #1184, #1186, #1187 among other things
---
 applications/mp4box/fileimport.c  | 20 +++++++++++++++++++
 applications/mp4client/main.c     | 33 +++++++++++++++++++++++++++----
 modules/ffmpeg_in/ffmpeg_demux.c  |  7 +++++--
 src/scene_manager/scene_manager.c |  4 ++++
 4 files changed, 58 insertions(+), 6 deletions(-)

diff --git a/applications/mp4box/fileimport.c b/applications/mp4box/fileimport.c
index a1bc80b9d2..d3c878a854 100644
--- a/applications/mp4box/fileimport.c
+++ b/applications/mp4box/fileimport.c
@@ -2356,17 +2356,33 @@ GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Do
 	cat_enum.align_timelines = align_timelines;
 	cat_enum.allow_add_in_command = allow_add_in_command;
 
+	if (strlen(fileName) >= sizeof(cat_enum.szPath)) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
+		return GF_NOT_SUPPORTED;
+	}
 	strcpy(cat_enum.szPath, fileName);
 	sep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);
 	if (!sep) sep = strrchr(cat_enum.szPath, '/');
 	if (!sep) {
 		strcpy(cat_enum.szPath, ""."");
+		if (strlen(fileName) >= sizeof(cat_enum.szRad1)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
+			return GF_NOT_SUPPORTED;
+		}
 		strcpy(cat_enum.szRad1, fileName);
 	} else {
+		if (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
+			return GF_NOT_SUPPORTED;
+		}
 		strcpy(cat_enum.szRad1, sep+1);
 		sep[0] = 0;
 	}
 	sep = strchr(cat_enum.szRad1, '*');
+	if (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
+		return GF_NOT_SUPPORTED;
+	}
 	strcpy(cat_enum.szRad2, sep+1);
 	sep[0] = 0;
 	sep = strchr(cat_enum.szRad2, '%');
@@ -2374,6 +2390,10 @@ GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Do
 	if (!sep) sep = strchr(cat_enum.szRad2, ':');
 	strcpy(cat_enum.szOpt, """");
 	if (sep) {
+		if (strlen(sep) >= sizeof(cat_enum.szOpt)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Invalid option: %s.\n"", sep));
+			return GF_NOT_SUPPORTED;
+		}
 		strcpy(cat_enum.szOpt, sep);
 		sep[0] = 0;
 	}
diff --git a/applications/mp4client/main.c b/applications/mp4client/main.c
index bda694d276..46404ff985 100644
--- a/applications/mp4client/main.c
+++ b/applications/mp4client/main.c
@@ -910,7 +910,8 @@ Bool GPAC_EventProc(void *ptr, GF_Event *evt)
 		break;
 	case GF_EVENT_NAVIGATE:
 		if (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {
-			strcpy(the_url, evt->navigate.to_url);
+			strncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);
+			the_url[sizeof(the_url) - 1] = 0;
 			fprintf(stderr, ""Navigating to URL %s\n"", the_url);
 			gf_term_navigate_to(term, evt->navigate.to_url);
 			return 1;
@@ -1099,6 +1100,11 @@ void set_cfg_option(char *opt_string)
 	}
 	{
 		const size_t sepIdx = sep - opt_string;
+		if (sepIdx >= sizeof(szSec)) {
+			fprintf(stderr, ""Badly formatted option %s - Section name is too long\n"", opt_string);
+			return;
+		}
+
 		strncpy(szSec, opt_string, sepIdx);
 		szSec[sepIdx] = 0;
 	}
@@ -1110,8 +1116,16 @@ void set_cfg_option(char *opt_string)
 	}
 	{
 		const size_t sepIdx = sep2 - sep;
+		if (sepIdx >= sizeof(szKey)) {
+			fprintf(stderr, ""Badly formatted option %s - key name is too long\n"", opt_string);
+			return;
+		}
 		strncpy(szKey, sep, sepIdx);
 		szKey[sepIdx] = 0;
+		if (strlen(sep2 + 1) >= sizeof(szVal)) {
+			fprintf(stderr, ""Badly formatted option %s - value is too long\n"", opt_string);
+			return;
+		}
 		strcpy(szVal, sep2+1);
 	}
 
@@ -1680,7 +1694,14 @@ int mp4client_main(int argc, char **argv)
 	else if (!gui_mode && url_arg) {
 		char *ext;
 
-		strcpy(the_url, url_arg);
+		if (strlen(url_arg) >= sizeof(the_url)) {
+			fprintf(stderr, ""Input url %s is too long, truncating to %d chars.\n"", url_arg, (int)(sizeof(the_url) - 1));
+			strncpy(the_url, url_arg, sizeof(the_url)-1);
+			the_url[sizeof(the_url) - 1] = 0;
+		}
+		else {
+			strcpy(the_url, url_arg);
+		}
 		ext = strrchr(the_url, '.');
 		if (ext && (!stricmp(ext, "".m3u"") || !stricmp(ext, "".pls""))) {
 			GF_Err e = GF_OK;
@@ -1692,7 +1713,10 @@ int mp4client_main(int argc, char **argv)
 				GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);
 				if (sess) {
 					e = gf_dm_sess_process(sess);
-					if (!e) strcpy(the_url, gf_dm_sess_get_cache_name(sess));
+					if (!e) {
+						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
+						the_url[sizeof(the_cfg) - 1] = 0;
+					}
 					gf_dm_sess_del(sess);
 				}
 			}
@@ -1715,7 +1739,8 @@ int mp4client_main(int argc, char **argv)
 		fprintf(stderr, ""Hit 'h' for help\n\n"");
 		str = gf_cfg_get_key(cfg_file, ""General"", ""StartupFile"");
 		if (str) {
-			strcpy(the_url, ""MP4Client ""GPAC_FULL_VERSION);
+			strncpy(the_url, ""MP4Client ""GPAC_FULL_VERSION , sizeof(the_url)-1);
+			the_url[sizeof(the_url) - 1] = 0;
 			gf_term_connect(term, str);
 			startup_file = 1;
 			is_connected = 1;
diff --git a/modules/ffmpeg_in/ffmpeg_demux.c b/modules/ffmpeg_in/ffmpeg_demux.c
index 7acdae38ad..fbd61af9f2 100644
--- a/modules/ffmpeg_in/ffmpeg_demux.c
+++ b/modules/ffmpeg_in/ffmpeg_demux.c
@@ -227,7 +227,7 @@ static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 	AVFormatContext *ctx;
 	AVOutputFormat *fmt_out;
 	Bool ret = GF_FALSE;
-	char *ext, szName[1000], szExt[20];
+	char *ext, szName[1024], szExt[20];
 	const char *szExtList;
 	FFDemux *ffd;
 	if (!plug || !url)
@@ -243,6 +243,9 @@ static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 
 	ffd = (FFDemux*)plug->priv;
 
+	if (strlen(url) >= sizeof(szName))
+		return GF_FALSE;
+
 	strcpy(szName, url);
 	ext = strrchr(szName, '#');
 	if (ext) ext[0] = 0;
@@ -252,7 +255,7 @@ static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 	ext = strrchr(szName, '.');
 	if (ext && strlen(ext) > 19) ext = NULL;
 
-	if (ext && strlen(ext) > 1) {
+	if (ext && strlen(ext) > 1 && strlen(ext) <= sizeof(szExt)) {
 		strcpy(szExt, &ext[1]);
 		strlwr(szExt);
 #ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS
diff --git a/src/scene_manager/scene_manager.c b/src/scene_manager/scene_manager.c
index ed44b0a9f3..0b21a400db 100644
--- a/src/scene_manager/scene_manager.c
+++ b/src/scene_manager/scene_manager.c
@@ -646,6 +646,10 @@ GF_Err gf_sm_load_init(GF_SceneLoader *load)
 				ext[0] = '.';
 				ext = anext;
 			}
+			if (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (""[Scene Manager] invalid extension in file name %s\n"", load->fileName));
+				return GF_NOT_SUPPORTED;
+			}
 			strcpy(szExt, &ext[1]);
 			strlwr(szExt);
 			if (strstr(szExt, ""bt"")) load->type = GF_SM_LOAD_BT;",CWE-120
CVE-2016-10064,"From 63302366a63602acbaad5c8223a105811b2adddd Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Wed, 6 Jul 2016 08:18:50 -0400
Subject: [PATCH] Improve buffer overflow sanity check

---
 coders/tiff.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/coders/tiff.c b/coders/tiff.c
index 8acce45d04e..969de709380 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -65,6 +65,7 @@
 #include ""MagickCore/log.h""
 #include ""MagickCore/magick.h""
 #include ""MagickCore/memory_.h""
+#include ""MagickCore/memory-private.h""
 #include ""MagickCore/module.h""
 #include ""MagickCore/monitor.h""
 #include ""MagickCore/monitor-private.h""
@@ -1902,14 +1903,13 @@ RestoreMSCWarning
           }
         (void) SetImageStorageClass(image,DirectClass,exception);
         number_pixels=(MagickSizeType) columns*rows;
-        if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)
-            (number_pixels*sizeof(uint32))))
+        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
-        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,
-          rows*sizeof(*tile_pixels));
+        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
+          sizeof(*tile_pixels));
         if (tile_pixels == (uint32 *) NULL)
           {
             TIFFClose(tiff);
@@ -2010,8 +2010,7 @@ RestoreMSCWarning
           Convert TIFF image to DirectClass MIFF image.
         */
         number_pixels=(MagickSizeType) image->columns*image->rows;
-        if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)
-            (number_pixels*sizeof(uint32))))
+        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
@@ -2024,8 +2023,8 @@ RestoreMSCWarning
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
-        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,
-          (uint32) image->rows,(uint32 *) pixels,0);
+        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
+          image->rows,(uint32 *) pixels,0);
         /*
           Convert image to DirectClass pixel packets.
         */",CWE-120
GHSA-qw5h-7f53-xrp6,"From e07e1c3d26492c06f078c7e5bf2d138043e199c1 Mon Sep 17 00:00:00 2001
From: Laura Pak <lpak@google.com>
Date: Fri, 23 Apr 2021 10:33:00 -0700
Subject: [PATCH] Prevent memory overflow in ParseAttrValue from nested
 tensors.

PiperOrigin-RevId: 370108442
Change-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889
---
 tensorflow/core/framework/attr_value_util.cc | 58 +++++++++++++++++++-
 1 file changed, 57 insertions(+), 1 deletion(-)

diff --git a/tensorflow/core/framework/attr_value_util.cc b/tensorflow/core/framework/attr_value_util.cc
index 712e205c587c84..76fe36e7f1e2a6 100644
--- a/tensorflow/core/framework/attr_value_util.cc
+++ b/tensorflow/core/framework/attr_value_util.cc
@@ -38,6 +38,9 @@ namespace {
 // Do not construct large tensors to compute their hash or compare for equality.
 constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb
 
+// Limit nesting of tensors to 100 deep to prevent memory overflow.
+constexpr int kMaxTensorNestDepth = 100;
+
 // Return the size of the tensor represented by this TensorProto. If shape is
 // not fully defined return -1.
 int64 TensorByteSize(const TensorProto& t) {
@@ -224,6 +227,54 @@ string SummarizeFunc(const NameAttrList& func) {
   return strings::StrCat(func.name(), ""["", absl::StrJoin(entries, "", ""), ""]"");
 }
 
+bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {
+  int nests = 0;
+  int maxed_out = to_parse.length();
+  int open_curly = to_parse.find('{');
+  int open_bracket = to_parse.find('<');
+  int close_curly = to_parse.find('}');
+  int close_bracket = to_parse.find('>');
+  if (open_curly == -1) {
+    open_curly = maxed_out;
+  }
+  if (open_bracket == -1) {
+    open_bracket = maxed_out;
+  }
+  int min = std::min(open_curly, open_bracket);
+  do {
+    if (open_curly == maxed_out && open_bracket == maxed_out) {
+      return true;
+    }
+    if (min == open_curly) {
+      nests += 1;
+      open_curly = to_parse.find('{', open_curly + 1);
+      if (open_curly == -1) {
+        open_curly = maxed_out;
+      }
+    } else if (min == open_bracket) {
+      nests += 1;
+      open_bracket = to_parse.find('<', open_bracket + 1);
+      if (open_bracket == -1) {
+        open_bracket = maxed_out;
+      }
+    } else if (min == close_curly) {
+      nests -= 1;
+      close_curly = to_parse.find('}', close_curly + 1);
+      if (close_curly == -1) {
+        close_curly = maxed_out;
+      }
+    } else if (min == close_bracket) {
+      nests -= 1;
+      close_bracket = to_parse.find('>', close_bracket + 1);
+      if (close_bracket == -1) {
+        close_bracket = maxed_out;
+      }
+    }
+    min = std::min({open_curly, open_bracket, close_curly, close_bracket});
+  } while (nests < 100);
+  return false;
+}
+
 }  // namespace
 
 string SummarizeAttrValue(const AttrValue& attr_value) {
@@ -448,7 +499,12 @@ bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {
   } else {
     to_parse = strings::StrCat(field_name, "": "", text);
   }
-
+  if (field_name == ""tensor"") {
+    if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,
+                                                    to_parse)) {
+      return false;
+    }
+  }
   return ProtoParseFromString(to_parse, out);
 }",CWE-120
