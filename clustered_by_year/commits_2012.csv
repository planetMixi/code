vuln_id,code_diff
CVE-2012-2101,"From 8c8735a73afb16d5856f0aa6088e9ae406c52beb Mon Sep 17 00:00:00 2001
From: Dan Prince <dprince@redhat.com>
Date: Wed, 11 Apr 2012 16:21:29 -0400
Subject: [PATCH] Implement quotas for security groups.

Fixes LP Bug #969545 for Diablo.

Change-Id: Ibc02256b6debd29c56307320acc48e9cfae85ba9
---
 nova/api/ec2/cloud.py                         | 12 +++++
 nova/api/openstack/contrib/quotas.py          |  5 ++-
 nova/api/openstack/contrib/security_groups.py | 12 +++++
 nova/db/api.py                                | 10 +++++
 nova/db/sqlalchemy/api.py                     | 19 ++++++++
 nova/quota.py                                 | 32 ++++++++++++++
 .../api/openstack/contrib/test_quotas.py      | 16 +++++--
 .../openstack/contrib/test_security_groups.py | 44 +++++++++++++++++++
 nova/tests/test_cloud.py                      | 25 +++++++++++
 nova/tests/test_quota.py                      | 32 +++++++++++++-
 10 files changed, 201 insertions(+), 6 deletions(-)

diff --git a/nova/api/ec2/cloud.py b/nova/api/ec2/cloud.py
index 64fce0c2b54..cd41921ba24 100644
--- a/nova/api/ec2/cloud.py
+++ b/nova/api/ec2/cloud.py
@@ -42,6 +42,7 @@
 from nova import log as logging
 from nova import network
 from nova import rpc
+from nova import quota
 from nova import utils
 from nova import volume
 from nova.api.ec2 import ec2utils
@@ -856,6 +857,13 @@ def authorize_security_group_ingress(self, context, group_name=None,
                     raise exception.ApiError(_(err) % values_for_rule)
                 postvalues.append(values_for_rule)
 
+        allowed = quota.allowed_security_group_rules(context,
+                                                   security_group['id'],
+                                                   1)
+        if allowed < 1:
+            msg = _(""Quota exceeded, too many security group rules."")
+            raise exception.ApiError(msg)
+
         for values_for_rule in postvalues:
             security_group_rule = db.security_group_rule_create(
                     context,
@@ -908,6 +916,10 @@ def create_security_group(self, context, group_name, group_description):
         if db.security_group_exists(context, context.project_id, group_name):
             raise exception.ApiError(_('group %s already exists') % group_name)
 
+        if quota.allowed_security_groups(context, 1) < 1:
+            msg = _(""Quota exceeded, too many security groups."")
+            raise exception.ApiError(msg)
+
         group = {'user_id': context.user_id,
                  'project_id': context.project_id,
                  'name': group_name,
diff --git a/nova/api/openstack/contrib/quotas.py b/nova/api/openstack/contrib/quotas.py
index 459b71dfdb7..16883269325 100644
--- a/nova/api/openstack/contrib/quotas.py
+++ b/nova/api/openstack/contrib/quotas.py
@@ -40,6 +40,8 @@ def _format_quota_set(self, project_id, quota_set):
             'instances': quota_set['instances'],
             'injected_files': quota_set['injected_files'],
             'cores': quota_set['cores'],
+            'security_groups': quota_set['security_groups'],
+            'security_group_rules': quota_set['security_group_rules'],
         }}
 
     def show(self, req, id):
@@ -56,7 +58,8 @@ def update(self, req, id, body):
         project_id = id
         resources = ['metadata_items', 'injected_file_content_bytes',
                 'volumes', 'gigabytes', 'ram', 'floating_ips', 'instances',
-                'injected_files', 'cores']
+                'injected_files', 'cores', 'security_groups',
+                'security_group_rules']
         for key in body['quota_set'].keys():
             if key in resources:
                 value = int(body['quota_set'][key])
diff --git a/nova/api/openstack/contrib/security_groups.py b/nova/api/openstack/contrib/security_groups.py
index e8f1f2ca680..78d4881251f 100644
--- a/nova/api/openstack/contrib/security_groups.py
+++ b/nova/api/openstack/contrib/security_groups.py
@@ -26,6 +26,7 @@
 from nova import log as logging
 from nova import rpc
 from nova import utils
+from nova import quota
 from nova.api.openstack import common
 from nova.api.openstack import extensions
 from nova.api.openstack import wsgi
@@ -136,6 +137,10 @@ def create(self, req, body):
         group_name = group_name.strip()
         group_description = group_description.strip()
 
+        if quota.allowed_security_groups(context, 1) < 1:
+            msg = _(""Quota exceeded, too many security groups."")
+            raise exc.HTTPBadRequest(explanation=msg)
+
         LOG.audit(_(""Create Security Group %s""), group_name, context=context)
         self.compute_api.ensure_default_security_group(context)
         if db.security_group_exists(context, context.project_id, group_name):
@@ -219,6 +224,13 @@ def create(self, req, body):
             msg = _('This rule already exists in group %s') % parent_group_id
             raise exc.HTTPBadRequest(explanation=msg)
 
+        allowed = quota.allowed_security_group_rules(context,
+                                                   parent_group_id,
+                                                   1)
+        if allowed < 1:
+            msg = _(""Quota exceeded, too many security group rules."")
+            raise exc.HTTPBadRequest(explanation=msg)
+
         security_group_rule = db.security_group_rule_create(context, values)
 
         self.compute_api.trigger_security_group_rules_refresh(context,
diff --git a/nova/db/api.py b/nova/db/api.py
index c0e44d2e7b7..7d241e54ce2 100644
--- a/nova/db/api.py
+++ b/nova/db/api.py
@@ -1098,6 +1098,11 @@ def security_group_destroy_all(context):
     return IMPL.security_group_destroy_all(context)
 
 
+def security_group_count_by_project(context, project_id):
+    """"""Count number of security groups in a project.""""""
+    return IMPL.security_group_count_by_project(context, project_id)
+
+
 ####################
 
 
@@ -1129,6 +1134,11 @@ def security_group_rule_get(context, security_group_rule_id):
     return IMPL.security_group_rule_get(context, security_group_rule_id)
 
 
+def security_group_rule_count_by_group(context, security_group_id):
+    """"""Count rules in a given security group.""""""
+    return IMPL.security_group_rule_count_by_group(context, security_group_id)
+
+
 ###################
 
 
diff --git a/nova/db/sqlalchemy/api.py b/nova/db/sqlalchemy/api.py
index 610858513d6..b06092675f3 100644
--- a/nova/db/sqlalchemy/api.py
+++ b/nova/db/sqlalchemy/api.py
@@ -2803,6 +2803,16 @@ def security_group_destroy_all(context, session=None):
                         'updated_at': literal_column('updated_at')})
 
 
+@require_context
+def security_group_count_by_project(context, project_id):
+    authorize_project_context(context, project_id)
+    session = get_session()
+    return session.query(models.SecurityGroup).\
+                         filter_by(deleted=False).\
+                         filter_by(project_id=project_id).\
+                         count()
+
+
 ###################
 
 
@@ -2884,6 +2894,15 @@ def security_group_rule_destroy(context, security_group_rule_id):
         security_group_rule.delete(session=session)
 
 
+@require_context
+def security_group_rule_count_by_group(context, security_group_id):
+    session = get_session()
+    return session.query(models.SecurityGroupIngressRule).\
+                         filter_by(deleted=False).\
+                         filter_by(parent_group_id=security_group_id).\
+                         count()
+
+
 ###################
 
 
diff --git a/nova/quota.py b/nova/quota.py
index 771477747e0..d491f4a42b1 100644
--- a/nova/quota.py
+++ b/nova/quota.py
@@ -44,6 +44,10 @@
                      'number of bytes allowed per injected file')
 flags.DEFINE_integer('quota_max_injected_file_path_bytes', 255,
                      'number of bytes allowed per injected file path')
+flags.DEFINE_integer('quota_security_groups', 10,
+                     'number of security groups per project')
+flags.DEFINE_integer('quota_security_group_rules', 20,
+                     'number of security rules per security group')
 
 
 def _get_default_quotas():
@@ -58,6 +62,8 @@ def _get_default_quotas():
         'injected_files': FLAGS.quota_max_injected_files,
         'injected_file_content_bytes':
             FLAGS.quota_max_injected_file_content_bytes,
+        'security_groups': FLAGS.quota_security_groups,
+        'security_group_rules': FLAGS.quota_security_group_rules,
     }
     # -1 in the quota flags means unlimited
     for key in defaults.keys():
@@ -134,6 +140,32 @@ def allowed_floating_ips(context, requested_floating_ips):
     return min(requested_floating_ips, allowed_floating_ips)
 
 
+def allowed_security_groups(context, requested_security_groups):
+    """"""Check quota and return min(requested, allowed) security groups.""""""
+    project_id = context.project_id
+    context = context.elevated()
+    used_sec_groups = db.security_group_count_by_project(context, project_id)
+    quota = get_project_quotas(context, project_id)
+    allowed_sec_groups = _get_request_allotment(requested_security_groups,
+                                                  used_sec_groups,
+                                                  quota['security_groups'])
+    return min(requested_security_groups, allowed_sec_groups)
+
+
+def allowed_security_group_rules(context, security_group_id,
+        requested_rules):
+    """"""Check quota and return min(requested, allowed) sec group rules.""""""
+    project_id = context.project_id
+    context = context.elevated()
+    used_rules = db.security_group_rule_count_by_group(context,
+                                                            security_group_id)
+    quota = get_project_quotas(context, project_id)
+    allowed_rules = _get_request_allotment(requested_rules,
+                                              used_rules,
+                                              quota['security_group_rules'])
+    return min(requested_rules, allowed_rules)
+
+
 def _calculate_simple_quota(context, resource, requested):
     """"""Check quota for resource; return min(requested, allowed).""""""
     quota = get_project_quotas(context, context.project_id)
diff --git a/nova/tests/api/openstack/contrib/test_quotas.py b/nova/tests/api/openstack/contrib/test_quotas.py
index e391e5fa091..fe0a165eda2 100644
--- a/nova/tests/api/openstack/contrib/test_quotas.py
+++ b/nova/tests/api/openstack/contrib/test_quotas.py
@@ -29,7 +29,8 @@ def quota_set(id):
     return {'quota_set': {'id': id, 'metadata_items': 128, 'volumes': 10,
             'gigabytes': 1000, 'ram': 51200, 'floating_ips': 10,
             'instances': 10, 'injected_files': 5, 'cores': 20,
-            'injected_file_content_bytes': 10240}}
+            'injected_file_content_bytes': 10240,
+            'security_groups': 10, 'security_group_rules': 20}}
 
 
 def quota_set_list():
@@ -60,7 +61,9 @@ def test_format_quota_set(self):
             'metadata_items': 128,
             'gigabytes': 1000,
             'injected_files': 5,
-            'injected_file_content_bytes': 10240}
+            'injected_file_content_bytes': 10240,
+            'security_groups': 10,
+            'security_group_rules': 20}
 
         quota_set = QuotaSetsController()._format_quota_set('1234',
                                                             raw_quota_set)
@@ -95,7 +98,9 @@ def test_quotas_defaults(self):
                     'floating_ips': 10,
                     'metadata_items': 128,
                     'injected_files': 5,
-                    'injected_file_content_bytes': 10240}}
+                    'injected_file_content_bytes': 10240,
+                    'security_groups': 10,
+                    'security_group_rules': 20}}
 
         self.assertEqual(json.loads(res.body), expected)
 
@@ -123,7 +128,10 @@ def test_quotas_update_as_admin(self):
                              'cores': 50, 'ram': 51200, 'volumes': 10,
                              'gigabytes': 1000, 'floating_ips': 10,
                              'metadata_items': 128, 'injected_files': 5,
-                             'injected_file_content_bytes': 10240}}
+                             'injected_file_content_bytes': 10240,
+                             'security_groups': 40,
+                             'security_group_rules': 80
+                             }}
 
         req = webob.Request.blank('/v1.1/fake/os-quota-sets/update_me')
         req.method = 'PUT'
diff --git a/nova/tests/api/openstack/contrib/test_security_groups.py b/nova/tests/api/openstack/contrib/test_security_groups.py
index d0b25e05655..839f44246e7 100644
--- a/nova/tests/api/openstack/contrib/test_security_groups.py
+++ b/nova/tests/api/openstack/contrib/test_security_groups.py
@@ -22,10 +22,13 @@
 from xml.dom import minidom
 
 from nova import exception
+from nova import flags
 from nova import test
 from nova.api.openstack.contrib import security_groups
 from nova.tests.api.openstack import fakes
 
+FLAGS = flags.FLAGS
+
 
 def _get_create_request_json(body_dict):
     req = webob.Request.blank('/v1.1/fake/os-security-groups')
@@ -257,6 +260,19 @@ def test_create_security_group_non_string_description_json(self):
         response = _create_security_group_json(security_group)
         self.assertEquals(response.status_int, 400)
 
+    def test_create_security_group_quota_limit(self):
+        security_group = {}
+        for num in range(1, FLAGS.quota_security_groups):
+            security_group['name'] = ""test%i"" % num
+            security_group['description'] = ""test%i"" % num
+            response = _create_security_group_json(security_group)
+            self.assertEquals(response.status_int, 200)
+
+        security_group['name'] = ""test_to_many""
+        security_group['description'] = ""test_to_many""
+        response = _create_security_group_json(security_group)
+        self.assertEquals(response.status_int, 400)
+
     def test_get_security_group_list(self):
         security_group = {}
         security_group['name'] = ""test""
@@ -918,6 +934,34 @@ def test_create_rule_with_same_group_parent_id_json(self):
         response = self._create_security_group_rule_json(rules)
         self.assertEquals(response.status_int, 400)
 
+    def test_create_rule_quota_limit(self):
+        #NOTE: subtract 1 because we create 1 rule in setup
+        for num in range(100, (100 + FLAGS.quota_security_group_rules) - 1):
+            rule = {
+                      ""security_group_rule"": {
+                            ""ip_protocol"": ""tcp"",
+                            ""from_port"": num,
+                            ""to_port"": num,
+                            ""parent_group_id"": ""%s""
+                                       % self.parent_security_group['id'],
+                         }
+                      }
+            response = self._create_security_group_rule_json(rule)
+            print response.body
+            self.assertEquals(response.status_int, 200)
+
+        rule = {
+                  ""security_group_rule"": {
+                        ""ip_protocol"": ""tcp"",
+                        ""from_port"": ""121"",
+                        ""to_port"": ""121"",
+                        ""parent_group_id"": ""%s""
+                                   % self.parent_security_group['id'],
+                     }
+                  }
+        response = self._create_security_group_rule_json(rule)
+        self.assertEquals(response.status_int, 400)
+
     def test_delete(self):
         response = self._delete_security_group_rule(
                                   self.security_group_rule['id'])
diff --git a/nova/tests/test_cloud.py b/nova/tests/test_cloud.py
index fa4597422fe..c6fe41b84b4 100644
--- a/nova/tests/test_cloud.py
+++ b/nova/tests/test_cloud.py
@@ -256,6 +256,31 @@ def test_delete_security_group_no_params(self):
         delete = self.cloud.delete_security_group
         self.assertRaises(exception.ApiError, delete, self.context)
 
+    def test_security_group_ingress_quota_limit(self):
+        self.flags(quota_security_group_rules=20)
+        kwargs = {'project_id': self.context.project_id, 'name': 'test'}
+        sec_group = db.security_group_create(self.context, kwargs)
+        authz = self.cloud.authorize_security_group_ingress
+        for i in range(100, 120):
+            kwargs = {'to_port': i, 'from_port': i, 'ip_protocol': 'tcp'}
+            authz(self.context, group_id=sec_group['id'], **kwargs)
+
+        kwargs = {'to_port': 121, 'from_port': 121, 'ip_protocol': 'tcp'}
+        self.assertRaises(exception.ApiError, authz, self.context,
+                              group_id=sec_group['id'], **kwargs)
+
+    def test_security_group_quota_limit(self):
+        self.flags(quota_security_groups=10)
+        for i in range(1, 10):
+            name = 'test name %i' % i
+            descript = 'test description %i' % i
+            create = self.cloud.create_security_group
+            result = create(self.context, name, descript)
+
+        # 11'th group should fail
+        self.assertRaises(exception.ApiError,
+                          create, self.context, 'foo', 'bar')
+
     def test_authorize_security_group_ingress(self):
         kwargs = {'project_id': self.context.project_id, 'name': 'test'}
         sec = db.security_group_create(self.context, kwargs)
diff --git a/nova/tests/test_quota.py b/nova/tests/test_quota.py
index f4b481ebe49..9541a13b26c 100644
--- a/nova/tests/test_quota.py
+++ b/nova/tests/test_quota.py
@@ -43,7 +43,9 @@ def setUp(self):
                    quota_cores=4,
                    quota_volumes=2,
                    quota_gigabytes=20,
-                   quota_floating_ips=1)
+                   quota_floating_ips=1,
+                   quota_security_groups=10,
+                   quota_security_group_rules=20)
 
         self.network = self.network = self.start_service('network')
         self.user_id = 'admin'
@@ -185,6 +187,34 @@ def test_unlimited_floating_ips(self):
         floating_ips = quota.allowed_floating_ips(self.context, 101)
         self.assertEqual(floating_ips, 101)
 
+    def test_unlimited_security_groups(self):
+        self.flags(quota_security_groups=10)
+        security_groups = quota.allowed_security_groups(self.context, 100)
+        self.assertEqual(security_groups, 10)
+        db.quota_create(self.context, self.project_id, 'security_groups', None)
+        security_groups = quota.allowed_security_groups(self.context, 100)
+        self.assertEqual(security_groups, 100)
+        security_groups = quota.allowed_security_groups(self.context, 101)
+        self.assertEqual(security_groups, 101)
+
+    def test_unlimited_security_group_rules(self):
+
+        def fake_security_group_rule_count_by_group(context, sec_group_id):
+            return 0
+
+        self.stubs.Set(db, 'security_group_rule_count_by_group',
+                       fake_security_group_rule_count_by_group)
+
+        self.flags(quota_security_group_rules=20)
+        rules = quota.allowed_security_group_rules(self.context, 1234, 100)
+        self.assertEqual(rules, 20)
+        db.quota_create(self.context, self.project_id, 'security_group_rules',
+                        None)
+        rules = quota.allowed_security_group_rules(self.context, 1234, 100)
+        self.assertEqual(rules, 100)
+        rules = quota.allowed_security_group_rules(self.context, 1234, 101)
+        self.assertEqual(rules, 101)
+
     def test_unlimited_metadata_items(self):
         self.flags(quota_metadata_items=10)
         items = quota.allowed_metadata_items(self.context, 100)"
CVE-2012-6544,"From 792039c73cf176c8e39a6e8beef2c94ff46522ed Mon Sep 17 00:00:00 2001
From: Mathias Krause <minipli@googlemail.com>
Date: Wed, 15 Aug 2012 11:31:51 +0000
Subject: [PATCH] Bluetooth: L2CAP - Fix info leak via getsockname()

The L2CAP code fails to initialize the l2_bdaddr_type member of struct
sockaddr_l2 and the padding byte added for alignment. It that for leaks
two bytes kernel stack via the getsockname() syscall. Add an explicit
memset(0) before filling the structure to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/bluetooth/l2cap_sock.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index b94abd30e6f948..1497edd191a2e0 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -245,6 +245,7 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
+	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);"
CVE-2012-6536,"From ecd7918745234e423dd87fcc0c077da557909720 Mon Sep 17 00:00:00 2001
From: Mathias Krause <minipli@googlemail.com>
Date: Thu, 20 Sep 2012 10:01:49 +0000
Subject: [PATCH] xfrm_user: ensure user supplied esn replay window is valid

The current code fails to ensure that the netlink message actually
contains as many bytes as the header indicates. If a user creates a new
state or updates an existing one but does not supply the bytes for the
whole ESN replay window, the kernel copies random heap bytes into the
replay bitmap, the ones happen to follow the XFRMA_REPLAY_ESN_VAL
netlink attribute. This leads to following issues:

1. The replay window has random bits set confusing the replay handling
   code later on.

2. A malicious user could use this flaw to leak up to ~3.5kB of heap
   memory when she has access to the XFRM netlink interface (requires
   CAP_NET_ADMIN).

Known users of the ESN replay window are strongSwan and Steffen's
iproute2 patch (<http://patchwork.ozlabs.org/patch/85962/>). The latter
uses the interface with a bitmap supplied while the former does not.
strongSwan is therefore prone to run into issue 1.

To fix both issues without breaking existing userland allow using the
XFRMA_REPLAY_ESN_VAL netlink attribute with either an empty bitmap or a
fully specified one. For the former case we initialize the in-kernel
bitmap with zero, for the latter we copy the user supplied bitmap. For
state updates the full bitmap must be supplied.

To prevent overflows in the bitmap length calculation the maximum size
of bmp_len is limited to 128 by this patch -- resulting in a maximum
replay window of 4096 packets. This should be sufficient for all real
life scenarios (RFC 4303 recommends a default replay window size of 64).

Cc: Steffen Klassert <steffen.klassert@secunet.com>
Cc: Martin Willi <martin@revosec.ch>
Cc: Ben Hutchings <bhutchings@solarflare.com>
Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 include/linux/xfrm.h |  2 ++
 net/xfrm/xfrm_user.c | 31 +++++++++++++++++++++++++------
 2 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/include/linux/xfrm.h b/include/linux/xfrm.h
index 22e61fdf75a2bd..28e493b5b94c9b 100644
--- a/include/linux/xfrm.h
+++ b/include/linux/xfrm.h
@@ -84,6 +84,8 @@ struct xfrm_replay_state {
 	__u32	bitmap;
 };
 
+#define XFRMA_REPLAY_ESN_MAX	4096
+
 struct xfrm_replay_state_esn {
 	unsigned int	bmp_len;
 	__u32		oseq;
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 8024b3dea8c2d8..5927065e97cf97 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -123,9 +123,21 @@ static inline int verify_replay(struct xfrm_usersa_info *p,
 				struct nlattr **attrs)
 {
 	struct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];
+	struct xfrm_replay_state_esn *rs;
 
-	if ((p->flags & XFRM_STATE_ESN) && !rt)
-		return -EINVAL;
+	if (p->flags & XFRM_STATE_ESN) {
+		if (!rt)
+			return -EINVAL;
+
+		rs = nla_data(rt);
+
+		if (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)
+			return -EINVAL;
+
+		if (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&
+		    nla_len(rt) != sizeof(*rs))
+			return -EINVAL;
+	}
 
 	if (!rt)
 		return 0;
@@ -370,14 +382,15 @@ static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es
 					 struct nlattr *rp)
 {
 	struct xfrm_replay_state_esn *up;
+	int ulen;
 
 	if (!replay_esn || !rp)
 		return 0;
 
 	up = nla_data(rp);
+	ulen = xfrm_replay_state_esn_len(up);
 
-	if (xfrm_replay_state_esn_len(replay_esn) !=
-			xfrm_replay_state_esn_len(up))
+	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
 		return -EINVAL;
 
 	return 0;
@@ -388,22 +401,28 @@ static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn
 				       struct nlattr *rta)
 {
 	struct xfrm_replay_state_esn *p, *pp, *up;
+	int klen, ulen;
 
 	if (!rta)
 		return 0;
 
 	up = nla_data(rta);
+	klen = xfrm_replay_state_esn_len(up);
+	ulen = nla_len(rta) >= klen ? klen : sizeof(*up);
 
-	p = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
+	p = kzalloc(klen, GFP_KERNEL);
 	if (!p)
 		return -ENOMEM;
 
-	pp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
+	pp = kzalloc(klen, GFP_KERNEL);
 	if (!pp) {
 		kfree(p);
 		return -ENOMEM;
 	}
 
+	memcpy(p, up, ulen);
+	memcpy(pp, up, ulen);
+
 	*replay_esn = p;
 	*preplay_esn = pp;"
CVE-2012-5339,"From cfd688d2512df9827a8ecc0412fc264fc5bcb186 Mon Sep 17 00:00:00 2001
From: Dieter Adriaenssens <ruleant@users.sourceforge.net>
Date: Wed, 3 Oct 2012 20:22:25 +0200
Subject: [PATCH] triggers, routines, events : escape sql queries in error
 messages

---
 libraries/rte/rte_events.lib.php   | 35 +++++++++++++++++------
 libraries/rte/rte_routines.lib.php | 45 ++++++++++++++++++++++--------
 libraries/rte/rte_triggers.lib.php | 27 +++++++++++++-----
 3 files changed, 80 insertions(+), 27 deletions(-)

diff --git a/libraries/rte/rte_events.lib.php b/libraries/rte/rte_events.lib.php
index c8619a00000b..41fd467395b9 100644
--- a/libraries/rte/rte_events.lib.php
+++ b/libraries/rte/rte_events.lib.php
@@ -99,13 +99,21 @@ function PMA_EVN_handleEditor()
                 $drop_item = ""DROP EVENT "" . PMA_backquote($_REQUEST['item_original_name']) . "";\n"";
                 $result = PMA_DBI_try_query($drop_item);
                 if (! $result) {
-                    $errors[] = sprintf(__('The following query has failed: ""%s""'), $drop_item) . '<br />'
-                                      . __('MySQL said: ') . PMA_DBI_getError(null);
+                    $errors[] = sprintf(
+                        __('The following query has failed: ""%s""'),
+                        htmlspecialchars($drop_item)
+                    )
+                    . '<br />'
+                    . __('MySQL said: ') . PMA_DBI_getError(null);
                 } else {
                     $result = PMA_DBI_try_query($item_query);
                     if (! $result) {
-                        $errors[] = sprintf(__('The following query has failed: ""%s""'), $item_query) . '<br />'
-                                          . __('MySQL said: ') . PMA_DBI_getError(null);
+                        $errors[] = sprintf(
+                            __('The following query has failed: ""%s""'),
+                            htmlspecialchars($item_query)
+                        )
+                        . '<br />'
+                        . __('MySQL said: ') . PMA_DBI_getError(null);
                         // We dropped the old item, but were unable to create the new one
                         // Try to restore the backup query
                         $result = PMA_DBI_try_query($create_item);
@@ -113,9 +121,14 @@ function PMA_EVN_handleEditor()
                             // OMG, this is really bad! We dropped the query, failed to create a new one
                             // and now even the backup query does not execute!
                             // This should not happen, but we better handle this just in case.
-                            $errors[] = __('Sorry, we failed to restore the dropped event.') . '<br />'
-                                              . __('The backed up query was:') . ""\""$create_item\"""" . '<br />'
-                                              . __('MySQL said: ') . PMA_DBI_getError(null);
+                            $errors[] = __(
+                                'Sorry, we failed to restore the dropped event.'
+                            )
+                            . '<br />'
+                            . __('The backed up query was:')
+                            . ""\"""" . htmlspecialchars($create_item) . ""\""""
+                            . '<br />'
+                            . __('MySQL said: ') . PMA_DBI_getError(null);
                         }
                     } else {
                         $message = PMA_Message::success(__('Event %1$s has been modified.'));
@@ -127,8 +140,12 @@ function PMA_EVN_handleEditor()
                 // 'Add a new item' mode
                 $result = PMA_DBI_try_query($item_query);
                 if (! $result) {
-                    $errors[] = sprintf(__('The following query has failed: ""%s""'), $item_query) . '<br /><br />'
-                                      . __('MySQL said: ') . PMA_DBI_getError(null);
+                    $errors[] = sprintf(
+                        __('The following query has failed: ""%s""'),
+                        htmlspecialchars($item_query)
+                    )
+                    . '<br /><br />'
+                    . __('MySQL said: ') . PMA_DBI_getError(null);
                 } else {
                     $message = PMA_Message::success(__('Event %1$s has been created.'));
                     $message->addParam(PMA_backquote($_REQUEST['item_name']));
diff --git a/libraries/rte/rte_routines.lib.php b/libraries/rte/rte_routines.lib.php
index 01652c2ee7f5..414cbc2d70e4 100644
--- a/libraries/rte/rte_routines.lib.php
+++ b/libraries/rte/rte_routines.lib.php
@@ -249,13 +249,21 @@ function PMA_RTN_handleEditor()
                     $drop_routine = ""DROP {$_REQUEST['item_original_type']} "" . PMA_backquote($_REQUEST['item_original_name']) . "";\n"";
                     $result = PMA_DBI_try_query($drop_routine);
                     if (! $result) {
-                        $errors[] = sprintf(__('The following query has failed: ""%s""'), $drop_routine) . '<br />'
-                                          . __('MySQL said: ') . PMA_DBI_getError(null);
+                        $errors[] = sprintf(
+                            __('The following query has failed: ""%s""'),
+                            htmlspecialchars($drop_routine)
+                        )
+                        . '<br />'
+                        . __('MySQL said: ') . PMA_DBI_getError(null);
                     } else {
                         $result = PMA_DBI_try_query($routine_query);
                         if (! $result) {
-                            $errors[] = sprintf(__('The following query has failed: ""%s""'), $routine_query) . '<br />'
-                                              . __('MySQL said: ') . PMA_DBI_getError(null);
+                            $errors[] = sprintf(
+                                __('The following query has failed: ""%s""'),
+                                htmlspecialchars($routine_query)
+                            )
+                            . '<br />'
+                            . __('MySQL said: ') . PMA_DBI_getError(null);
                             // We dropped the old routine, but were unable to create the new one
                             // Try to restore the backup query
                             $result = PMA_DBI_try_query($create_routine);
@@ -263,9 +271,14 @@ function PMA_RTN_handleEditor()
                                 // OMG, this is really bad! We dropped the query, failed to create a new one
                                 // and now even the backup query does not execute!
                                 // This should not happen, but we better handle this just in case.
-                                $errors[] = __('Sorry, we failed to restore the dropped routine.') . '<br />'
-                                                  . __('The backed up query was:') . ""\""$create_routine\"""" . '<br />'
-                                                  . __('MySQL said: ') . PMA_DBI_getError(null);
+                                $errors[] = __(
+                                    'Sorry, we failed to restore the dropped routine.'
+                                )
+                                . '<br />'
+                                . __('The backed up query was:')
+                                . ""\"""" . htmlspecialchars($create_routine) . ""\""""
+                                . '<br />'
+                                . __('MySQL said: ') . PMA_DBI_getError(null);
                             }
                         } else {
                             $message = PMA_Message::success(__('Routine %1$s has been modified.'));
@@ -278,8 +291,12 @@ function PMA_RTN_handleEditor()
                 // 'Add a new routine' mode
                 $result = PMA_DBI_try_query($routine_query);
                 if (! $result) {
-                    $errors[] = sprintf(__('The following query has failed: ""%s""'), $routine_query) . '<br /><br />'
-                                      . __('MySQL said: ') . PMA_DBI_getError(null);
+                    $errors[] = sprintf(
+                        __('The following query has failed: ""%s""'),
+                        htmlspecialchars($routine_query)
+                    )
+                    . '<br /><br />'
+                    . __('MySQL said: ') . PMA_DBI_getError(null);
                 } else {
                     $message = PMA_Message::success(__('Routine %1$s has been created.'));
                     $message->addParam(PMA_backquote($_REQUEST['item_name']));
@@ -1251,8 +1268,14 @@ function PMA_RTN_handleExecute()
                 }
             } else {
                 $output = '';
-                $message = PMA_message::error(sprintf(__('The following query has failed: ""%s""'), $query) . '<br /><br />'
-                                                    . __('MySQL said: ') . PMA_DBI_getError(null));
+                $message = PMA_message::error(
+                    sprintf(
+                        __('The following query has failed: ""%s""'),
+                        htmlspecialchars($query)
+                    )
+                    . '<br /><br />'
+                    . __('MySQL said: ') . PMA_DBI_getError(null)
+                );
             }
             // Print/send output
             if ($GLOBALS['is_ajax_request']) {
diff --git a/libraries/rte/rte_triggers.lib.php b/libraries/rte/rte_triggers.lib.php
index 4e344ce474df..cc76685f0429 100644
--- a/libraries/rte/rte_triggers.lib.php
+++ b/libraries/rte/rte_triggers.lib.php
@@ -72,13 +72,21 @@ function PMA_TRI_handleEditor()
                 $drop_item = $trigger['drop'] . ';';
                 $result = PMA_DBI_try_query($drop_item);
                 if (! $result) {
-                    $errors[] = sprintf(__('The following query has failed: ""%s""'), $drop_item) . '<br />'
-                                      . __('MySQL said: ') . PMA_DBI_getError(null);
+                    $errors[] = sprintf(
+                        __('The following query has failed: ""%s""'),
+                        htmlspecialchars($drop_item)
+                    )
+                    . '<br />'
+                    . __('MySQL said: ') . PMA_DBI_getError(null);
                 } else {
                     $result = PMA_DBI_try_query($item_query);
                     if (! $result) {
-                        $errors[] = sprintf(__('The following query has failed: ""%s""'), $item_query) . '<br />'
-                                          . __('MySQL said: ') . PMA_DBI_getError(null);
+                        $errors[] = sprintf(
+                            __('The following query has failed: ""%s""'),
+                            htmlspecialchars($item_query)
+                        )
+                        . '<br />'
+                        . __('MySQL said: ') . PMA_DBI_getError(null);
                         // We dropped the old item, but were unable to create the new one
                         // Try to restore the backup query
                         $result = PMA_DBI_try_query($create_item);
@@ -86,9 +94,14 @@ function PMA_TRI_handleEditor()
                             // OMG, this is really bad! We dropped the query, failed to create a new one
                             // and now even the backup query does not execute!
                             // This should not happen, but we better handle this just in case.
-                            $errors[] = __('Sorry, we failed to restore the dropped trigger.') . '<br />'
-                                              . __('The backed up query was:') . ""\""$create_item\"""" . '<br />'
-                                              . __('MySQL said: ') . PMA_DBI_getError(null);
+                            $errors[] = __(
+                                'Sorry, we failed to restore the dropped trigger.'
+                            )
+                            . '<br />'
+                            . __('The backed up query was:')
+                            . ""\"""" . htmlspecialchars($create_item) . ""\""""
+                            . '<br />'
+                            . __('MySQL said: ') . PMA_DBI_getError(null);
                         }
                     } else {
                         $message = PMA_Message::success(__('Trigger %1$s has been modified.'));"
CVE-2012-3468,"From fdb48d15283eba57305c1299bdf3548a9c0db4aa Mon Sep 17 00:00:00 2001
From: Robbie Mackay <rm@robbiemackay.com>
Date: Mon, 30 Jul 2012 19:13:24 +1200
Subject: [PATCH] Fix potential SQLi in alerts/verify #645

---
 application/controllers/alerts.php | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/application/controllers/alerts.php b/application/controllers/alerts.php
index cecaf1ed63..4a1ef9f83a 100644
--- a/application/controllers/alerts.php
+++ b/application/controllers/alerts.php
@@ -224,11 +224,11 @@ public function verify()
 		{
 			if (isset($_POST['alert_mobile']) AND ! empty($_POST['alert_mobile']))
 			{
-				$filter = ""alert.alert_type=1 AND alert_code='"".utf8::strtoupper($_POST['alert_code']).""' AND alert_recipient='"".$_POST['alert_mobile'].""' "";
+				$filter = ""alert.alert_type=1 AND alert_code='"".Database::instance()->escape_str(utf8::strtoupper($_POST['alert_code'])).""' AND alert_recipient='"".Database::instance()->escape_str($_POST['alert_mobile']).""' "";
 			}
 			elseif (isset($_POST['alert_email']) AND ! empty($_POST['alert_email']))
 			{
-				$filter = ""alert.alert_type=2 AND alert_code='"".$_POST['alert_code'].""' AND alert_recipient='"".$_POST['alert_email'].""' "";
+				$filter = ""alert.alert_type=2 AND alert_code='"".Database::instance()->escape_str($_POST['alert_code']).""' AND alert_recipient='"".Database::instance()->escape_str($_POST['alert_email']).""' "";
 			}
 			else
 			{
@@ -243,7 +243,7 @@ public function verify()
 			}
 			else
 			{
-				$filter = ""alert.alert_type=2 AND alert_code='"".$code.""' AND alert_recipient='"".$email.""' "";
+				$filter = ""alert.alert_type=2 AND alert_code='"".Database::instance()->escape_str($code).""' AND alert_recipient='"".Database::instance()->escape_str($email).""' "";
 			}
 		}"
CVE-2012-5368,"From a547f3d3e2cf36c6a904fa3e053fd8bddd3fbbb0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michal=20=C4=8Ciha=C5=99?= <mcihar@suse.cz>
Date: Mon, 3 Sep 2012 14:57:59 +0200
Subject: [PATCH] Escape json reply received from server

---
 js/functions.js | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/js/functions.js b/js/functions.js
index ad2e39c8cd7d..b9fad9e9ee1d 100644
--- a/js/functions.js
+++ b/js/functions.js
@@ -132,9 +132,9 @@ function PMA_current_version(data)
 {
     var current = parseVersionString(pmaversion);
     var latest = parseVersionString(data['version']);
-    var version_information_message = PMA_messages['strLatestAvailable'] + ' ' + data['version'];
+    var version_information_message = PMA_messages['strLatestAvailable'] + ' ' + escapeHtml(data['version']);
     if (latest > current) {
-        var message = $.sprintf(PMA_messages['strNewerVersion'], data['version'], data['date']);
+        var message = $.sprintf(PMA_messages['strNewerVersion'], escapeHtml(data['version']), escapeHtml(data['date']));
         if (Math.floor(latest / 10000) == Math.floor(current / 10000)) {
             /* Security update */
             klass = 'error';"
CVE-2012-3508,"From 5ef8e4ad9d3ee8689d2b83750aa65395b7cd59ee Mon Sep 17 00:00:00 2001
From: Aleksander Machniak <alec@alec.pl>
Date: Wed, 15 Aug 2012 10:12:18 +0200
Subject: [PATCH] Fix XSS issue with href=""javascript:"" not being removed
 (#1488613)

---
 CHANGELOG               | 1 +
 program/lib/washtml.php | 8 ++++++--
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index 4e2b22a4af9..93268064550 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,6 +1,7 @@
 CHANGELOG Roundcube Webmail
 ===========================
 
+- Fix XSS issue with href=""javascript:"" not being removed (#1488613)
 - Fix impossible to create message with empty plain text part (#1488610)
 - Fix stripped apostrophes when replying in plain text to HTML message (#1488606)
 - Fix inactive Save search option after advanced search (#1488607)
diff --git a/program/lib/washtml.php b/program/lib/washtml.php
index c12315fecee..98ae5ed5a8b 100644
--- a/program/lib/washtml.php
+++ b/program/lib/washtml.php
@@ -214,8 +214,11 @@ private function wash_attribs($node)
       $key = strtolower($key);
       $value = $node->getAttribute($key);
       if (isset($this->_html_attribs[$key]) ||
-         ($key == 'href' && preg_match('!^([a-z][a-z0-9.+-]+:|//|#).+!i', $value)))
+         ($key == 'href' && !preg_match('!^javascript!i', $value)
+           && preg_match('!^([a-z][a-z0-9.+-]+:|//|#).+!i', $value))
+      ) {
         $t .= ' ' . $key . '=""' . htmlspecialchars($value, ENT_QUOTES) . '""';
+      }
       else if ($key == 'style' && ($style = $this->wash_style($value))) {
         $quot = strpos($style, '""') !== false ? ""'"" : '""';
         $t .= ' style=' . $quot . $style . $quot;
@@ -237,7 +240,8 @@ private function wash_attribs($node)
         else if (preg_match('/^data:.+/i', $value)) { // RFC2397
           $t .= ' ' . $key . '=""' . htmlspecialchars($value, ENT_QUOTES) . '""';
         }
-      } else
+      }
+      else
         $washed .= ($washed?' ':'') . $key;
     }
     return $t . ($washed && $this->config['show_washed']?' x-washed=""'.$washed.'""':'');"
CVE-2012-4396,"From e817504569dce49fd7a677fa510e500394af0c48 Mon Sep 17 00:00:00 2001
From: Bjoern Schiessle <schiessle@owncloud.com>
Date: Tue, 5 Jun 2012 10:46:28 +0200
Subject: [PATCH] xss vulnerability fixed

---
 apps/media/lib_scanner.php | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/apps/media/lib_scanner.php b/apps/media/lib_scanner.php
index dc2a8a9beb4a..82170e5ca82e 100644
--- a/apps/media/lib_scanner.php
+++ b/apps/media/lib_scanner.php
@@ -79,19 +79,19 @@ public static function scanFile($path){
 			OCP\Util::writeLog('media',""error reading artist tag in '$file'"",OCP\Util::WARN);
 			$artist='unknown';
 		}else{
-			$artist=stripslashes($data['comments']['artist'][0]);
+			$artist=strip_tags(stripslashes($data['comments']['artist'][0]));
 		}
 		if(!isset($data['comments']['album'])){
 			OCP\Util::writeLog('media',""error reading album tag in '$file'"",OCP\Util::WARN);
 			$album='unknown';
 		}else{
-			$album=stripslashes($data['comments']['album'][0]);
+			$album=strip_tags(stripslashes($data['comments']['album'][0]));
 		}
 		if(!isset($data['comments']['title'])){
 			OCP\Util::writeLog('media',""error reading title tag in '$file'"",OCP\Util::WARN);
 			$title='unknown';
 		}else{
-			$title=stripslashes($data['comments']['title'][0]);
+			$title=strip_tags(stripslashes($data['comments']['title'][0]));
 		}
 		$size=$data['filesize'];
 		if (isset($data['comments']['track']))"
CVE-2012-6647,"From 6f7b0a2a5c0fb03be7c25bd1745baa50582348ef Mon Sep 17 00:00:00 2001
From: Darren Hart <dvhart@linux.intel.com>
Date: Fri, 20 Jul 2012 11:53:31 -0700
Subject: [PATCH] futex: Forbid uaddr == uaddr2 in futex_wait_requeue_pi()

If uaddr == uaddr2, then we have broken the rule of only requeueing
from a non-pi futex to a pi futex with this call. If we attempt this,
as the trinity test suite manages to do, we miss early wakeups as
q.key is equal to key2 (because they are the same uaddr). We will then
attempt to dereference the pi_mutex (which would exist had the futex_q
been properly requeued to a pi futex) and trigger a NULL pointer
dereference.

Signed-off-by: Darren Hart <dvhart@linux.intel.com>
Cc: Dave Jones <davej@redhat.com>
Cc: stable@vger.kernel.org
Link: http://lkml.kernel.org/r/ad82bfe7f7d130247fbe2b5b4275654807774227.1342809673.git.dvhart@linux.intel.com
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 kernel/futex.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/kernel/futex.c b/kernel/futex.c
index 5551adaf7cdfda..3717e7b306e08c 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -2231,11 +2231,11 @@ int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,
  * @uaddr2:	the pi futex we will take prior to returning to user-space
  *
  * The caller will wait on uaddr and will be requeued by futex_requeue() to
- * uaddr2 which must be PI aware.  Normal wakeup will wake on uaddr2 and
- * complete the acquisition of the rt_mutex prior to returning to userspace.
- * This ensures the rt_mutex maintains an owner when it has waiters; without
- * one, the pi logic wouldn't know which task to boost/deboost, if there was a
- * need to.
+ * uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
+ * on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
+ * userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
+ * without one, the pi logic would not know which task to boost/deboost, if
+ * there was a need to.
  *
  * We call schedule in futex_wait_queue_me() when we enqueue and return there
  * via the following:
@@ -2272,6 +2272,9 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	struct futex_q q = futex_q_init;
 	int res, ret;
 
+	if (uaddr == uaddr2)
+		return -EINVAL;
+
 	if (!bitset)
 		return -EINVAL;"
CVE-2012-6116,"From 65f1e42b7bda0f3410931c50598540d944d8bf0d Mon Sep 17 00:00:00 2001
From: Marek Hulan <ares@igloonet.cz>
Date: Tue, 22 Jan 2013 12:48:10 +0100
Subject: [PATCH] 877387 - Candlepin CA certificate mode in RPM

File mode is set to 0644 when RPM is generated.
---
 katello-configure/modules/certs/manifests/config.pp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/katello-configure/modules/certs/manifests/config.pp b/katello-configure/modules/certs/manifests/config.pp
index b9a6807628e..dce2b8991a3 100644
--- a/katello-configure/modules/certs/manifests/config.pp
+++ b/katello-configure/modules/certs/manifests/config.pp
@@ -112,7 +112,7 @@
 
   exec { ""generate-candlepin-consumer-certificate"":
     cwd       => ""${katello_www_pub_dir}"",
-    command   => ""gen-rpm.sh --name '${candlepin_consumer_name}' --version 1.0 --release 1 --packager None --vendor None --group 'Applications/System' --summary '${candlepin_consumer_summary}' --description '${candlepin_consumer_description}' --requires subscription-manager --post ${ssl_build_path}/rhsm-katello-reconfigure /etc/rhsm/ca/candlepin-local.pem:666=${ssl_build_path}/$candlepin_cert_name.crt 2>>${katello::params::configure_log_base}/certificates.log && /sbin/restorecon ./*rpm"",
+    command   => ""gen-rpm.sh --name '${candlepin_consumer_name}' --version 1.0 --release 1 --packager None --vendor None --group 'Applications/System' --summary '${candlepin_consumer_summary}' --description '${candlepin_consumer_description}' --requires subscription-manager --post ${ssl_build_path}/rhsm-katello-reconfigure /etc/rhsm/ca/candlepin-local.pem:644=${ssl_build_path}/$candlepin_cert_name.crt 2>>${katello::params::configure_log_base}/certificates.log && /sbin/restorecon ./*rpm"",
     path      => ""/usr/share/katello/certs:/usr/bin:/bin"",
     creates   => ""${katello_www_pub_dir}/${candlepin_consumer_name}-1.0-1.noarch.rpm"",
     require   => [Exec[""generate-candlepin-certificate""], File[""${ssl_build_path}/rhsm-katello-reconfigure""], File[""${katello::params::configure_log_base}""]]"
CVE-2012-1597,"From 58854564c7b8672090c25c4b1677d08620d870f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andre=CC=81=20R?= <ar@ez.no>
Date: Wed, 9 May 2012 12:17:22 +0200
Subject: [PATCH] Fixed #019245: XSS exploit on eZJSCore RUN command

---
 classes/ezjscajaxcontent.php | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/classes/ezjscajaxcontent.php b/classes/ezjscajaxcontent.php
index bab1cf92..97610b16 100644
--- a/classes/ezjscajaxcontent.php
+++ b/classes/ezjscajaxcontent.php
@@ -127,7 +127,7 @@ public static function textEncode( $mix )
         if ( is_array( $mix ) )
             return implode(',', array_map( array('ezjscAjaxContent', 'textEncode'), array_filter( $mix ) ) );
 
-        return $mix;
+        return htmlspecialchars( $mix );
     }
 
     /**"
CVE-2012-4968,"From 0085876495f0f8dda5dc58cb24a8f2220e7baf1e Mon Sep 17 00:00:00 2001
From: Ingo Schommer <ingo@silverstripe.com>
Date: Tue, 31 Jan 2012 01:07:24 +0100
Subject: [PATCH] BUGFIX Casting return values on text helper methods in
 StringField, Text, Varchar

---
 core/model/fieldtypes/HTMLText.php    | 21 +++++++++++++++++++-
 core/model/fieldtypes/StringField.php |  6 ++++++
 core/model/fieldtypes/Text.php        | 14 +++++++++++++-
 core/model/fieldtypes/Varchar.php     |  5 +++++
 tests/fieldtypes/HTMLTextTest.php     | 28 +++++++++++++++++++++++++++
 tests/fieldtypes/TextTest.php         | 26 ++++++++++++++++++++++++-
 6 files changed, 97 insertions(+), 3 deletions(-)

diff --git a/core/model/fieldtypes/HTMLText.php b/core/model/fieldtypes/HTMLText.php
index 47fea31c441..3f4ee9e50ee 100755
--- a/core/model/fieldtypes/HTMLText.php
+++ b/core/model/fieldtypes/HTMLText.php
@@ -28,6 +28,25 @@ function LimitCharacters($limit = 20, $add = ""..."") {
 		return (strlen($value) > $limit) ? substr($value, 0, $limit) . $add : $value;
 	}
 
+	static $casting = array(
+		""AbsoluteLinks"" => ""HTMLText"",
+		""BigSummary"" => ""HTMLText"",
+		""ContextSummary"" => ""HTMLText"",
+		""FirstParagraph"" => ""HTMLText"",
+		""FirstSentence"" => ""HTMLText"",
+		""LimitCharacters"" => ""HTMLText"",
+		""LimitSentences"" => ""HTMLText"",
+		""Lower"" => ""HTMLText"",
+		""LowerCase"" => ""HTMLText"",
+		""Summary"" => ""HTMLText"",
+		""Upper"" => ""HTMLText"",
+		""UpperCase"" => ""HTMLText"",
+		'EscapeXML' => 'HTMLText',
+		'LimitWordCount' => 'HTMLText',
+		'LimitWordCountXML' => 'HTMLText',
+		'NoHTML' => 'Text',
+	);
+
 	/**
 	 * Create a summary of the content. This will be some section of the first paragraph, limited by
 	 * $maxWords. All internal tags are stripped out - the return value is a string
@@ -133,4 +152,4 @@ public function scaffoldSearchField($title = null) {
 
 }
 
-?>
\ No newline at end of file
+?>
diff --git a/core/model/fieldtypes/StringField.php b/core/model/fieldtypes/StringField.php
index 50c6ffd071c..51429b126aa 100644
--- a/core/model/fieldtypes/StringField.php
+++ b/core/model/fieldtypes/StringField.php
@@ -9,6 +9,12 @@
 abstract class StringField extends DBField {
 	protected $nullifyEmpty = true;
 
+	static $casting = array(
+		""LimitCharacters"" => ""Text"",
+		""Lower"" => ""Text"",
+		""Upper"" => ""Text"",
+	);
+
 	/**
 	 * Construct a string type field with a set of optional parameters
 	 * @param $name string The name of the field
diff --git a/core/model/fieldtypes/Text.php b/core/model/fieldtypes/Text.php
index 7ace59ae571..df231a47b21 100644
--- a/core/model/fieldtypes/Text.php
+++ b/core/model/fieldtypes/Text.php
@@ -17,8 +17,20 @@
  * @subpackage model
  */
 class Text extends StringField {
+
 	static $casting = array(
-		""AbsoluteLinks"" => ""HTMLText"",
+		""AbsoluteLinks"" => ""Text"",
+		""BigSummary"" => ""Text"",
+		""ContextSummary"" => ""Text"",
+		""FirstParagraph"" => ""Text"",
+		""FirstSentence"" => ""Text"",
+		""LimitCharacters"" => ""Text"",
+		""LimitSentences"" => ""Text"",
+		""Summary"" => ""Text"",
+		'EscapeXML' => 'Text',
+		'LimitWordCount' => 'Text',
+		'LimitWordCountXML' => 'HTMLText',
+		'NoHTML' => 'Text',
 	);
 	
  	/**
diff --git a/core/model/fieldtypes/Varchar.php b/core/model/fieldtypes/Varchar.php
index 1d308638c4a..707926c8c1b 100644
--- a/core/model/fieldtypes/Varchar.php
+++ b/core/model/fieldtypes/Varchar.php
@@ -10,6 +10,11 @@
  * @subpackage model
  */
 class Varchar extends StringField {
+
+	static $casting = array(
+		""Initial"" => ""Text"",
+		""URL"" => ""Text"",
+	);
 	
 	protected $size;
 	 
diff --git a/tests/fieldtypes/HTMLTextTest.php b/tests/fieldtypes/HTMLTextTest.php
index 9303ba6bb5b..6a3ba05920e 100644
--- a/tests/fieldtypes/HTMLTextTest.php
+++ b/tests/fieldtypes/HTMLTextTest.php
@@ -102,5 +102,33 @@ function testFirstSentence() {
 			$this->assertEquals($match, $textObj->FirstSentence());
 		}
 	}	
+
+	public function testRAW() {
+		$data = DBField::create('HTMLText', 'This &amp; This');
+		$this->assertEquals($data->RAW(), 'This &amp; This');
+
+		$data = DBField::create('HTMLText', 'This & This');
+		$this->assertEquals($data->RAW(), 'This & This');
+	}
+	
+	public function testXML() {
+		$data = DBField::create('HTMLText', 'This & This');
+		$this->assertEquals($data->XML(), 'This &amp; This');
+	}
+
+	public function testHTML() {
+		$data = DBField::create('HTMLText', 'This & This');
+		$this->assertEquals($data->HTML(), 'This &amp; This');
+	}
+
+	public function testJS() {
+		$data = DBField::create('HTMLText', '""this is a test""');
+		$this->assertEquals($data->JS(), '\""this is a test\""');
+	}
+
+	public function testATT() {
+		$data = DBField::create('HTMLText', '""this is a test""');
+		$this->assertEquals($data->ATT(), '&quot;this is a test&quot;');
+	}
 }
 ?>
\ No newline at end of file
diff --git a/tests/fieldtypes/TextTest.php b/tests/fieldtypes/TextTest.php
index b4e29b6c34c..97a280441c9 100644
--- a/tests/fieldtypes/TextTest.php
+++ b/tests/fieldtypes/TextTest.php
@@ -142,6 +142,30 @@ function testContextSummary() {
 			'A dog <span class=""highlight"">ate</span> a cat while looking at a Foobar',
 			$textObj->ContextSummary(100, $testKeyword3a)
 		);
-		
 	}	
+
+	public function testRAW() {
+		$data = DBField::create('Text', 'This &amp; This');
+		$this->assertEquals($data->RAW(), 'This &amp; This');
+	}
+	
+	public function testXML() {
+		$data = DBField::create('Text', 'This & This');
+		$this->assertEquals($data->XML(), 'This &amp; This');
+	}
+
+	public function testHTML() {
+		$data = DBField::create('Text', 'This & This');
+		$this->assertEquals($data->HTML(), 'This &amp; This');
+	}
+
+	public function testJS() {
+		$data = DBField::create('Text', '""this is a test""');
+		$this->assertEquals($data->JS(), '\""this is a test\""');
+	}
+
+	public function testATT() {
+		$data = DBField::create('Text', '""this is a test""');
+		$this->assertEquals($data->ATT(), '&quot;this is a test&quot;');
+	}
 }
\ No newline at end of file"
CVE-2012-2673,"From 83231d0ab5ed60015797c3d1ad9056295ac3b2bb Mon Sep 17 00:00:00 2001
From: Hans Boehm <Hans.Boehm@hp.com>
Date: Thu, 15 Mar 2012 21:09:05 +0400
Subject: [PATCH] Speedup calloc size overflow check by preventing division if
 small values

* malloc.c (GC_SQRT_SIZE_MAX): New macro.
* malloc.c (calloc): Add fast initial size overflow check to avoid
integer division for reasonably small values passed.
---
 malloc.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/malloc.c b/malloc.c
index cb49a5cf4..c9b9eb6a8 100644
--- a/malloc.c
+++ b/malloc.c
@@ -381,9 +381,12 @@ void * malloc(size_t lb)
 # define GC_SIZE_MAX (~(size_t)0)
 #endif
 
+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)
+
 void * calloc(size_t n, size_t lb)
 {
-    if (lb && n > GC_SIZE_MAX / lb)
+    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial test */
+        && lb && n > GC_SIZE_MAX / lb)
       return NULL;
 #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */
         /* libpthread allocated some memory that is only pointed to by  */"
CVE-2012-6545,"From f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a Mon Sep 17 00:00:00 2001
From: Mathias Krause <minipli@googlemail.com>
Date: Wed, 15 Aug 2012 11:31:49 +0000
Subject: [PATCH] Bluetooth: RFCOMM - Fix info leak in ioctl(RFCOMMGETDEVLIST)

The RFCOMM code fails to initialize the two padding bytes of struct
rfcomm_dev_list_req inserted for alignment before copying it to
userland. Additionally there are two padding bytes in each instance of
struct rfcomm_dev_info. The ioctl() that for disclosures two bytes plus
dev_num times two bytes uninitialized kernel heap memory.

Allocate the memory using kzalloc() to fix this issue.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/bluetooth/rfcomm/tty.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
index cb960773c002ef..56f182393c4c7d 100644
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -456,7 +456,7 @@ static int rfcomm_get_dev_list(void __user *arg)
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
-	dl = kmalloc(size, GFP_KERNEL);
+	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;"
CVE-2012-0787,"From b8de6a8c5cfffb007149036ffa561ced4d11c462 Mon Sep 17 00:00:00 2001
From: Dominic Cleal <dcleal@redhat.com>
Date: Sun, 25 Mar 2012 17:07:54 +0100
Subject: [PATCH] Prevent cross-mountpoint attacks via .augsave during saving

Previously Augeas would open PATH.augsave for writing if a rename from PATH to
PATH.augsave failed, then write the file contents in.  Now if the rename fails,
it tries to unlink PATH.augsave and open it with O_EXCL first.

Mountpoints remain permitted at either PATH or PATH.augnew provided
/augeas/save/copy_if_rename_fails exists.

* src/transform.c (clone_file):
    add argument to perform unlink and O_EXCL on destination filename after a
    rename failure to prevent PATH.augsave being a mountpoint
* src/transform.c (transform_save, remove_file):
    always try to unlink PATH.augsave if rename fails, only allowing PATH to be
    a mountpoint; allow PATH or PATH.augnew to be mountpoints
* tests/
    test-put-mount: check PATH being a mountpoint is supported
    test-put-mount-augnew.sh: check PATH.augnew being a mountpoint is supported
    test-put-mount-augsave.sh: check unlink error when PATH.augsave is a mount

Fixes BZ 772261
---
 src/transform.c                 | 40 ++++++++++++++++---
 tests/Makefile.am               |  5 ++-
 tests/test-put-mount-augnew.sh  | 69 +++++++++++++++++++++++++++++++++
 tests/test-put-mount-augsave.sh | 62 +++++++++++++++++++++++++++++
 tests/test-put-mount.sh         | 55 ++++++++++++++++++++++++++
 5 files changed, 223 insertions(+), 8 deletions(-)
 create mode 100755 tests/test-put-mount-augnew.sh
 create mode 100755 tests/test-put-mount-augsave.sh
 create mode 100755 tests/test-put-mount.sh

diff --git a/src/transform.c b/src/transform.c
index 6ebcbd695..62563e2cf 100644
--- a/src/transform.c
+++ b/src/transform.c
@@ -27,6 +27,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <selinux/selinux.h>
 #include <stdbool.h>
@@ -844,14 +845,21 @@ static int transfer_file_attrs(FILE *from, FILE *to,
  * means that FROM or TO is a bindmounted file), and COPY_IF_RENAME_FAILS
  * is true, copy the contents of FROM into TO and delete FROM.
  *
+ * If COPY_IF_RENAME_FAILS and UNLINK_IF_RENAME_FAILS are true, and the above
+ * copy mechanism is used, it will unlink the TO path and open with O_EXCL
+ * to ensure we only copy *from* a bind mount rather than into an attacker's
+ * mount placed at TO (e.g. for .augsave).
+ *
  * Return 0 on success (either rename succeeded or we copied the contents
  * over successfully), -1 on failure.
  */
 static int clone_file(const char *from, const char *to,
-                      const char **err_status, int copy_if_rename_fails) {
+                      const char **err_status, int copy_if_rename_fails,
+                      int unlink_if_rename_fails) {
     FILE *from_fp = NULL, *to_fp = NULL;
     char buf[BUFSIZ];
     size_t len;
+    int to_fd = -1, to_oflags, r;
     int result = -1;
 
     if (rename(from, to) == 0)
@@ -867,10 +875,23 @@ static int clone_file(const char *from, const char *to,
         goto done;
     }
 
-    if (!(to_fp = fopen(to, ""w""))) {
+    if (unlink_if_rename_fails) {
+        r = unlink(to);
+        if (r < 0) {
+            *err_status = ""clone_unlink_dst"";
+            goto done;
+        }
+    }
+
+    to_oflags = unlink_if_rename_fails ? O_EXCL : O_TRUNC;
+    if ((to_fd = open(to, O_WRONLY|O_CREAT|to_oflags, S_IRUSR|S_IWUSR)) < 0) {
         *err_status = ""clone_open_dst"";
         goto done;
     }
+    if (!(to_fp = fdopen(to_fd, ""w""))) {
+        *err_status = ""clone_fdopen_dst"";
+        goto done;
+    }
 
     if (transfer_file_attrs(from_fp, to_fp, err_status) < 0)
         goto done;
@@ -897,8 +918,15 @@ static int clone_file(const char *from, const char *to,
  done:
     if (from_fp != NULL)
         fclose(from_fp);
-    if (to_fp != NULL && fclose(to_fp) != 0)
+    if (to_fp != NULL) {
+        if (fclose(to_fp) != 0) {
+            *err_status = ""clone_fclose_dst"";
+            result = -1;
+        }
+    } else if (to_fd >= 0 && close(to_fd) < 0) {
+        *err_status = ""clone_close_dst"";
         result = -1;
+    }
     if (result != 0)
         unlink(to);
     if (result == 0)
@@ -1132,7 +1160,7 @@ int transform_save(struct augeas *aug, struct tree *xfm,
                 goto done;
             }
 
-            r = clone_file(augorig_canon, augsave, &err_status, 1);
+            r = clone_file(augorig_canon, augsave, &err_status, 1, 1);
             if (r != 0) {
                 dyn_err_status = strappend(err_status, ""_augsave"");
                 goto done;
@@ -1140,7 +1168,7 @@ int transform_save(struct augeas *aug, struct tree *xfm,
         }
     }
 
-    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails);
+    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails, 0);
     if (r != 0) {
         dyn_err_status = strappend(err_status, ""_augtemp"");
         goto done;
@@ -1298,7 +1326,7 @@ int remove_file(struct augeas *aug, struct tree *tree) {
                 goto error;
         }
 
-        r = clone_file(augorig_canon, augsave, &err_status, 1);
+        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);
         if (r != 0) {
             dyn_err_status = strappend(err_status, ""_augsave"");
             goto error;
diff --git a/tests/Makefile.am b/tests/Makefile.am
index f6645378a..d4697649d 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -184,8 +184,9 @@ check_SCRIPTS = \
   $(lens_tests) \
   test-get.sh test-augtool.sh \
   test-put-symlink.sh test-put-symlink-augnew.sh \
-  test-put-symlink-augsave.sh test-put-symlink-augtemp.sh test-save-empty.sh \
-  test-bug-1.sh test-idempotent.sh test-preserve.sh \
+  test-put-symlink-augsave.sh test-put-symlink-augtemp.sh \
+  test-put-mount.sh test-put-mount-augnew.sh test-put-mount-augsave.sh \
+  test-save-empty.sh test-bug-1.sh test-idempotent.sh test-preserve.sh \
   test-events-saved.sh test-save-mode.sh test-unlink-error.sh \
   test-augtool-empty-line.sh test-augtool-modify-root.sh
 
diff --git a/tests/test-put-mount-augnew.sh b/tests/test-put-mount-augnew.sh
new file mode 100755
index 000000000..cb95bdacd
--- /dev/null
+++ b/tests/test-put-mount-augnew.sh
@@ -0,0 +1,69 @@
+#! /bin/bash
+
+# Test that we can write into a bind mount placed at PATH.augnew with the
+# copy_if_rename_fails flag.
+# This requires that EXDEV or EBUSY is returned from rename(2) to activate the
+# code path, so set up a bind mount on Linux.
+
+if [ $UID -ne 0 -o ""$(uname -s)"" != ""Linux"" ]; then
+    echo ""Test can only be run as root on Linux to create bind mounts""
+    exit 77
+fi
+
+ROOT=$abs_top_builddir/build/test-put-mount-augnew
+LENSES=$abs_top_srcdir/lenses
+
+HOSTS=$ROOT/etc/hosts
+HOSTS_AUGNEW=${HOSTS}.augnew
+TARGET=$ROOT/other/real_hosts
+
+rm -rf $ROOT
+mkdir -p $(dirname $HOSTS)
+mkdir -p $(dirname $TARGET)
+
+echo 127.0.0.1 localhost > $HOSTS
+touch $TARGET $HOSTS_AUGNEW
+
+mount --bind $TARGET $HOSTS_AUGNEW
+Exit() {
+    umount $HOSTS_AUGNEW
+    exit $1
+}
+
+HOSTS_SUM=$(sum $HOSTS)
+
+augtool --nostdinc -I $LENSES -r $ROOT --new <<EOF
+set /augeas/save/copy_if_rename_fails 1
+set /files/etc/hosts/1/alias myhost
+save
+print /augeas//error
+EOF
+
+if [ ! -f $HOSTS ] ; then
+    echo ""/etc/hosts is no longer a regular file""
+    Exit 1
+fi
+if [ ! ""x${HOSTS_SUM}"" = ""x$(sum $HOSTS)"" ]; then
+    echo ""/etc/hosts has changed""
+    Exit 1
+fi
+if [ ! ""x${HOSTS_SUM}"" = ""x$(sum $HOSTS)"" ]; then
+    echo ""/etc/hosts has changed""
+    Exit 1
+fi
+
+if [ ! -s $HOSTS_AUGNEW ]; then
+    echo ""/etc/hosts.augnew is empty""
+    Exit 1
+fi
+if [ ! -s $TARGET ]; then
+    echo ""/other/real_hosts is empty""
+    Exit 1
+fi
+
+if ! grep myhost $TARGET >/dev/null; then
+    echo ""/other/real_hosts does not contain the modification""
+    Exit 1
+fi
+
+Exit 0
diff --git a/tests/test-put-mount-augsave.sh b/tests/test-put-mount-augsave.sh
new file mode 100755
index 000000000..31fcfca6b
--- /dev/null
+++ b/tests/test-put-mount-augsave.sh
@@ -0,0 +1,62 @@
+#! /bin/bash
+
+# Test that we don't follow bind mounts when writing to .augsave.
+# This requires that EXDEV or EBUSY is returned from rename(2) to activate the
+# code path, so set up a bind mount on Linux.
+
+if [ $UID -ne 0 -o ""$(uname -s)"" != ""Linux"" ]; then
+    echo ""Test can only be run as root on Linux to create bind mounts""
+    exit 77
+fi
+
+actual() {
+    (augtool --nostdinc -I $LENSES -r $ROOT --backup | grep ^/augeas) <<EOF
+    set /augeas/save/copy_if_rename_fails 1
+    set /files/etc/hosts/1/alias myhost
+    save
+    print /augeas//error
+EOF
+}
+
+expected() {
+    cat <<EOF
+/augeas/files/etc/hosts/error = ""clone_unlink_dst_augsave""
+/augeas/files/etc/hosts/error/message = ""Device or resource busy""
+EOF
+}
+
+ROOT=$abs_top_builddir/build/test-put-mount-augsave
+LENSES=$abs_top_srcdir/lenses
+
+HOSTS=$ROOT/etc/hosts
+HOSTS_AUGSAVE=${HOSTS}.augsave
+
+ATTACK_FILE=$ROOT/other/attack
+
+rm -rf $ROOT
+mkdir -p $(dirname $HOSTS)
+mkdir -p $(dirname $ATTACK_FILE)
+
+echo 127.0.0.1 localhost > $HOSTS
+touch $ATTACK_FILE $HOSTS_AUGSAVE
+
+mount --bind $ATTACK_FILE $HOSTS_AUGSAVE
+Exit() {
+    umount $HOSTS_AUGSAVE
+    exit $1
+}
+
+ACTUAL=$(actual)
+EXPECTED=$(expected)
+if [ ""$ACTUAL"" != ""$EXPECTED"" ]; then
+    echo ""No error when trying to unlink augsave (a bind mount):""
+    echo ""$ACTUAL""
+    exit 1
+fi
+
+if [ -s $ATTACK_FILE ]; then
+    echo ""/other/attack now contains data, should be blank""
+    Exit 1
+fi
+
+Exit 0
diff --git a/tests/test-put-mount.sh b/tests/test-put-mount.sh
new file mode 100755
index 000000000..210bc10ac
--- /dev/null
+++ b/tests/test-put-mount.sh
@@ -0,0 +1,55 @@
+#! /bin/bash
+
+# Test that we can write into a bind mount with the copy_if_rename_fails flag.
+# This requires that EXDEV or EBUSY is returned from rename(2) to activate the
+# code path, so set up a bind mount on Linux.
+
+if [ $UID -ne 0 -o ""$(uname -s)"" != ""Linux"" ]; then
+    echo ""Test can only be run as root on Linux to create bind mounts""
+    exit 77
+fi
+
+ROOT=$abs_top_builddir/build/test-put-mount
+LENSES=$abs_top_srcdir/lenses
+
+HOSTS=$ROOT/etc/hosts
+TARGET=$ROOT/other/real_hosts
+
+rm -rf $ROOT
+mkdir -p $(dirname $HOSTS)
+mkdir -p $(dirname $TARGET)
+
+echo 127.0.0.1 localhost > $TARGET
+touch $HOSTS
+
+mount --bind $TARGET $HOSTS
+Exit() {
+    umount $HOSTS
+    exit $1
+}
+
+HOSTS_SUM=$(sum $HOSTS)
+
+augtool --nostdinc -I $LENSES -r $ROOT <<EOF
+set /augeas/save/copy_if_rename_fails 1
+set /files/etc/hosts/1/alias myhost
+save
+print /augeas//error
+EOF
+
+if [ ! ""x${HOSTS_SUM}"" != ""x$(sum $HOSTS)"" ]; then
+    echo ""/etc/hosts hasn't changed""
+    Exit 1
+fi
+
+if [ ! ""x${HOSTS_SUM}"" != ""x$(sum $TARGET)"" ]; then
+    echo ""/other/real_hosts hasn't changed""
+    Exit 1
+fi
+
+if ! grep myhost $TARGET >/dev/null; then
+    echo ""/other/real_hosts does not contain the modification""
+    Exit 1
+fi
+
+Exit 0"
CVE-2012-3540,"From 35eada8a27323c0f83c400177797927aba6bc99b Mon Sep 17 00:00:00 2001
From: Paul McMillan <paul.mcmillan@nebula.com>
Date: Wed, 22 Aug 2012 12:15:40 -0700
Subject: [PATCH] Fix open redirect in Horizon.

LP 1039077. Disallow login redirects to anywhere other than the same origin.

Change-Id: I36e8e4f30cf440ecc73534af38fcd8d2a111a603
---
 horizon/views/auth_forms.py | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/horizon/views/auth_forms.py b/horizon/views/auth_forms.py
index 2ebecfcdadc..abf08803329 100644
--- a/horizon/views/auth_forms.py
+++ b/horizon/views/auth_forms.py
@@ -28,6 +28,7 @@
 from django.conf import settings
 from django.contrib import messages
 from django.contrib.auth import REDIRECT_FIELD_NAME
+from django.utils.http import same_origin
 from django.utils.translation import ugettext as _
 from keystoneclient import exceptions as keystone_exceptions
 
@@ -94,7 +95,13 @@ def handle(self, request, data):
         request.session['region_endpoint'] = endpoint
         request.session['region_name'] = region_name
 
-        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, """")
+        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, None)
+        # Make sure the requested redirect matches the protocol,
+        # domain, and port of this request
+        if redirect_to and not same_origin(
+                request.build_absolute_uri(redirect_to),
+                request.build_absolute_uri()):
+            redirect_to = None
 
         if data.get('tenant', None):
             try:"
CVE-2012-2094,"From 7f8c788aa70db98ac904f37fa4197fcabb802942 Mon Sep 17 00:00:00 2001
From: ""J. Daniel Schmidt"" <jdsn@suse.de>
Date: Tue, 10 Apr 2012 14:56:37 +0200
Subject: [PATCH] html escape the console log in refresh

fixes bug 977944

(cherry picked from commit ab2e27522aaeb0268fcc121bd3eff5a4485f313c)

Change-Id: Ic6135ebc58b6c45d6336f0833717086e43d7cccb
---
 horizon/static/horizon/js/horizon.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/horizon/static/horizon/js/horizon.js b/horizon/static/horizon/js/horizon.js
index 8cf2be56c6f..c47364a34ac 100644
--- a/horizon/static/horizon/js/horizon.js
+++ b/horizon/static/horizon/js/horizon.js
@@ -284,7 +284,7 @@ var Horizon = function() {
         data: data,
         method: 'get',
         success: function(response_body) {
-          $('pre.logs').html(response_body);
+          $('pre.logs').text(response_body);
         },
         error: function(response) {
           if(via_user_submit) {"
CVE-2012-0207,"From a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27 Mon Sep 17 00:00:00 2001
From: Ben Hutchings <ben@decadent.org.uk>
Date: Mon, 9 Jan 2012 14:06:46 -0800
Subject: [PATCH] igmp: Avoid zero delay when receiving odd mixture of IGMP
 queries

Commit 5b7c84066733c5dfb0e4016d939757b38de189e4 ('ipv4: correct IGMP
behavior on v3 query during v2-compatibility mode') added yet another
case for query parsing, which can result in max_delay = 0.  Substitute
a value of 1, as in the usual v3 case.

Reported-by: Simon McVittie <smcv@debian.org>
References: http://bugs.debian.org/654876
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/ipv4/igmp.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index fa057d105befea..5104bc0bbdbe73 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -880,6 +880,8 @@ static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,
 		 * to be intended in a v3 query.
 		 */
 		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);
+		if (!max_delay)
+			max_delay = 1;	/* can't mod w/ 0 */
 	} else { /* v3 */
 		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))
 			return;"
CVE-2012-1123,"From f5106be52cf6aa72c521f388e4abb5f0de1f1d7f Mon Sep 17 00:00:00 2001
From: root <root@paul.shroudbox.com>
Date: Thu, 16 Feb 2012 09:41:56 +0000
Subject: [PATCH] Fix 0013901: SOAP API allows invoking methods without proper
 authentication

Note: only applied to 1.2.x not 'next', as the code is changing anyway
---
 api/soap/mc_api.php | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/api/soap/mc_api.php b/api/soap/mc_api.php
index 507680f490..a81781ae1b 100644
--- a/api/soap/mc_api.php
+++ b/api/soap/mc_api.php
@@ -51,6 +51,11 @@ function mci_check_login( $p_username, $p_password ) {
 
 		# do not use password validation.
 		$p_password = null;
+	} else {
+		if( is_blank( $p_password ) ) {
+			# require password for authenticated access
+			return false;
+		}
 	}
 
 	if( false === auth_attempt_script_login( $p_username, $p_password ) ) {"
CVE-2012-4391,"From 5192eecce239a0b7ade1e60a6cf03075e5cfc188 Mon Sep 17 00:00:00 2001
From: Lukas Reschke <lukas@statuscode.ch>
Date: Fri, 10 Aug 2012 00:11:04 +0200
Subject: [PATCH] Added XSRF check

---
 core/ajax/appconfig.php | 1 +
 1 file changed, 1 insertion(+)

diff --git a/core/ajax/appconfig.php b/core/ajax/appconfig.php
index 84e0710c74a5..bf749be3e30d 100644
--- a/core/ajax/appconfig.php
+++ b/core/ajax/appconfig.php
@@ -7,6 +7,7 @@
 
 require_once (""../../lib/base.php"");
 OC_Util::checkAdminUser();
+OCP\JSON::callCheck();
 
 $action=isset($_POST['action'])?$_POST['action']:$_GET['action'];
 $result=false;"
CVE-2012-0033,"From 11508aa72efab4fad0dbd8292b9614d9371b20a9 Mon Sep 17 00:00:00 2001
From: Alexey Sokolov <alexey@asokolov.org>
Date: Sun, 1 Jan 2012 00:47:01 +0700
Subject: [PATCH] Fix crash in bouncedcc module.

It happens when DCC RESUME is received.
Affected ZNC versions: 0.200, 0.202.

Thanks to howeyc for reporting this and providing the patch.
---
 modules/bouncedcc.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/modules/bouncedcc.cpp b/modules/bouncedcc.cpp
index c91ca37bd4..d06ecf0e92 100644
--- a/modules/bouncedcc.cpp
+++ b/modules/bouncedcc.cpp
@@ -238,7 +238,7 @@ class CBounceDCCMod : public CModule {
 					CDCCBounce* pSock = (CDCCBounce*) *it;
 
 					if (pSock->GetLocalPort() == uResumePort) {
-						m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pClient->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetUserPort()) + "" "" + sMessage.Token(4) + ""\001"");
+						m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pUser->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetUserPort()) + "" "" + sMessage.Token(4) + ""\001"");
 					}
 				}
 			} else if (sType.Equals(""ACCEPT"")) {
@@ -248,7 +248,7 @@ class CBounceDCCMod : public CModule {
 					CDCCBounce* pSock = (CDCCBounce*) *it;
 
 					if (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {
-						m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pClient->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetLocalPort()) + "" "" + sMessage.Token(4) + ""\001"");
+						m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pUser->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetLocalPort()) + "" "" + sMessage.Token(4) + ""\001"");
 					}
 				}
 			}"
CVE-2012-3430,"From 06b6a1cf6e776426766298d055bb3991957d90a7 Mon Sep 17 00:00:00 2001
From: Weiping Pan <wpan@redhat.com>
Date: Mon, 23 Jul 2012 10:37:48 +0800
Subject: [PATCH] rds: set correct msg_namelen

Jay Fenlason (fenlason@redhat.com) found a bug,
that recvfrom() on an RDS socket can return the contents of random kernel
memory to userspace if it was called with a address length larger than
sizeof(struct sockaddr_in).
rds_recvmsg() also fails to set the addr_len paramater properly before
returning, but that's just a bug.
There are also a number of cases wher recvfrom() can return an entirely bogus
address. Anything in rds_recvmsg() that returns a non-negative value but does
not go through the ""sin = (struct sockaddr_in *)msg->msg_name;"" code path
at the end of the while(1) loop will return up to 128 bytes of kernel memory
to userspace.

And I write two test programs to reproduce this bug, you will see that in
rds_server, fromAddr will be overwritten and the following sock_fd will be
destroyed.
Yes, it is the programmer's fault to set msg_namelen incorrectly, but it is
better to make the kernel copy the real length of address to user space in
such case.

How to run the test programs ?
I test them on 32bit x86 system, 3.5.0-rc7.

1 compile
gcc -o rds_client rds_client.c
gcc -o rds_server rds_server.c

2 run ./rds_server on one console

3 run ./rds_client on another console

4 you will see something like:
server is waiting to receive data...
old socket fd=3
server received data from client:data from client
msg.msg_namelen=32
new socket fd=-1067277685
sendmsg()
: Bad file descriptor

/***************** rds_client.c ********************/

int main(void)
{
	int sock_fd;
	struct sockaddr_in serverAddr;
	struct sockaddr_in toAddr;
	char recvBuffer[128] = ""data from client"";
	struct msghdr msg;
	struct iovec iov;

	sock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);
	if (sock_fd < 0) {
		perror(""create socket error\n"");
		exit(1);
	}

	memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
	serverAddr.sin_port = htons(4001);

	if (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
		perror(""bind() error\n"");
		close(sock_fd);
		exit(1);
	}

	memset(&toAddr, 0, sizeof(toAddr));
	toAddr.sin_family = AF_INET;
	toAddr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
	toAddr.sin_port = htons(4000);
	msg.msg_name = &toAddr;
	msg.msg_namelen = sizeof(toAddr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_iov->iov_base = recvBuffer;
	msg.msg_iov->iov_len = strlen(recvBuffer) + 1;
	msg.msg_control = 0;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	if (sendmsg(sock_fd, &msg, 0) == -1) {
		perror(""sendto() error\n"");
		close(sock_fd);
		exit(1);
	}

	printf(""client send data:%s\n"", recvBuffer);

	memset(recvBuffer, '\0', 128);

	msg.msg_name = &toAddr;
	msg.msg_namelen = sizeof(toAddr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_iov->iov_base = recvBuffer;
	msg.msg_iov->iov_len = 128;
	msg.msg_control = 0;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;
	if (recvmsg(sock_fd, &msg, 0) == -1) {
		perror(""recvmsg() error\n"");
		close(sock_fd);
		exit(1);
	}

	printf(""receive data from server:%s\n"", recvBuffer);

	close(sock_fd);

	return 0;
}

/***************** rds_server.c ********************/

int main(void)
{
	struct sockaddr_in fromAddr;
	int sock_fd;
	struct sockaddr_in serverAddr;
	unsigned int addrLen;
	char recvBuffer[128];
	struct msghdr msg;
	struct iovec iov;

	sock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);
	if(sock_fd < 0) {
		perror(""create socket error\n"");
		exit(0);
	}

	memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
	serverAddr.sin_port = htons(4000);
	if (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
		perror(""bind error\n"");
		close(sock_fd);
		exit(1);
	}

	printf(""server is waiting to receive data...\n"");
	msg.msg_name = &fromAddr;

	/*
	 * I add 16 to sizeof(fromAddr), ie 32,
	 * and pay attention to the definition of fromAddr,
	 * recvmsg() will overwrite sock_fd,
	 * since kernel will copy 32 bytes to userspace.
	 *
	 * If you just use sizeof(fromAddr), it works fine.
	 * */
	msg.msg_namelen = sizeof(fromAddr) + 16;
	/* msg.msg_namelen = sizeof(fromAddr); */
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_iov->iov_base = recvBuffer;
	msg.msg_iov->iov_len = 128;
	msg.msg_control = 0;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	while (1) {
		printf(""old socket fd=%d\n"", sock_fd);
		if (recvmsg(sock_fd, &msg, 0) == -1) {
			perror(""recvmsg() error\n"");
			close(sock_fd);
			exit(1);
		}
		printf(""server received data from client:%s\n"", recvBuffer);
		printf(""msg.msg_namelen=%d\n"", msg.msg_namelen);
		printf(""new socket fd=%d\n"", sock_fd);
		strcat(recvBuffer, ""--data from server"");
		if (sendmsg(sock_fd, &msg, 0) == -1) {
			perror(""sendmsg()\n"");
			close(sock_fd);
			exit(1);
		}
	}

	close(sock_fd);
	return 0;
}

Signed-off-by: Weiping Pan <wpan@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/rds/recv.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/net/rds/recv.c b/net/rds/recv.c
index 5c6e9f1320266c..9f0f17cf6bf9b1 100644
--- a/net/rds/recv.c
+++ b/net/rds/recv.c
@@ -410,6 +410,8 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 
 	rdsdebug(""size %zu flags 0x%x timeo %ld\n"", size, msg_flags, timeo);
 
+	msg->msg_namelen = 0;
+
 	if (msg_flags & MSG_OOB)
 		goto out;
 
@@ -485,6 +487,7 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 			sin->sin_port = inc->i_hdr.h_sport;
 			sin->sin_addr.s_addr = inc->i_saddr;
 			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+			msg->msg_namelen = sizeof(*sin);
 		}
 		break;
 	}"
PYSEC-2012-7,"From b45c377f8f488955e0c7069cad3f3dd21910b071 Mon Sep 17 00:00:00 2001
From: Preston Holmes <preston@ptone.com>
Date: Wed, 17 Oct 2012 14:43:08 -0700
Subject: [PATCH] Fixed a security issue related to password resets

Full disclosure and new release are forthcoming

backport from master
---
 django/contrib/auth/tests/urls.py  |  1 +
 django/contrib/auth/tests/views.py | 39 ++++++++++++++++++++++++++++++
 django/contrib/auth/views.py       |  2 +-
 django/http/__init__.py            |  5 ++++
 4 files changed, 46 insertions(+), 1 deletion(-)

diff --git a/django/contrib/auth/tests/urls.py b/django/contrib/auth/tests/urls.py
index 3d76a4e44394..c01964f83324 100644
--- a/django/contrib/auth/tests/urls.py
+++ b/django/contrib/auth/tests/urls.py
@@ -19,6 +19,7 @@ def remote_user_auth_view(request):
     (r'^logout/next_page/$', 'django.contrib.auth.views.logout', dict(next_page='/somewhere/')),
     (r'^remote_user/$', remote_user_auth_view),
     (r'^password_reset_from_email/$', 'django.contrib.auth.views.password_reset', dict(from_email='staffmember@example.com')),
+    (r'^admin_password_reset/$', 'django.contrib.auth.views.password_reset', dict(is_admin_site=True)),
     (r'^login_required/$', login_required(password_reset)),
     (r'^login_required_login_url/$', login_required(password_reset, login_url='/somewhere/')),
 )
diff --git a/django/contrib/auth/tests/views.py b/django/contrib/auth/tests/views.py
index b03489c7d205..046d00da0be9 100644
--- a/django/contrib/auth/tests/views.py
+++ b/django/contrib/auth/tests/views.py
@@ -9,6 +9,7 @@
 from django.contrib.auth.models import User
 from django.test import TestCase
 from django.core import mail
+from django.core.exceptions import SuspiciousOperation
 from django.core.urlresolvers import reverse
 from django.http import QueryDict
 
@@ -69,6 +70,44 @@ def test_email_found_custom_from(self):
         self.assertEqual(len(mail.outbox), 1)
         self.assertEqual(""staffmember@example.com"", mail.outbox[0].from_email)
 
+    def test_admin_reset(self):
+        ""If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.""
+        response = self.client.post('/admin_password_reset/',
+            {'email': 'staffmember@example.com'},
+            HTTP_HOST='adminsite.com'
+        )
+        self.assertEqual(response.status_code, 302)
+        self.assertEqual(len(mail.outbox), 1)
+        self.assertTrue(""http://adminsite.com"" in mail.outbox[0].body)
+        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)
+
+    def test_poisoned_http_host(self):
+        ""Poisoned HTTP_HOST headers can't be used for reset emails""
+        # This attack is based on the way browsers handle URLs. The colon
+        # should be used to separate the port, but if the URL contains an @,
+        # the colon is interpreted as part of a username for login purposes,
+        # making 'evil.com' the request domain. Since HTTP_HOST is used to
+        # produce a meaningful reset URL, we need to be certain that the
+        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()
+        # is invoked, but we check here as a practical consequence.
+        def test_host_poisoning():
+            self.client.post('/password_reset/',
+                {'email': 'staffmember@example.com'},
+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
+            )
+        self.assertRaises(SuspiciousOperation, test_host_poisoning)
+        self.assertEqual(len(mail.outbox), 0)
+
+    def test_poisoned_http_host_admin_site(self):
+        ""Poisoned HTTP_HOST headers can't be used for reset emails on admin views""
+        def test_host_poisoning():
+            self.client.post('/admin_password_reset/',
+                {'email': 'staffmember@example.com'},
+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
+            )
+        self.assertRaises(SuspiciousOperation, test_host_poisoning)
+        self.assertEqual(len(mail.outbox), 0)
+
     def _test_confirm_start(self):
         # Start by creating the email
         response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})
diff --git a/django/contrib/auth/views.py b/django/contrib/auth/views.py
index eba83a269e52..727e9162bd5c 100644
--- a/django/contrib/auth/views.py
+++ b/django/contrib/auth/views.py
@@ -151,7 +151,7 @@ def password_reset(request, is_admin_site=False,
                 'request': request,
             }
             if is_admin_site:
-                opts = dict(opts, domain_override=request.META['HTTP_HOST'])
+                opts = dict(opts, domain_override=request.get_host())
             form.save(**opts)
             return HttpResponseRedirect(post_reset_redirect)
     else:
diff --git a/django/http/__init__.py b/django/http/__init__.py
index 2dfe12ee4bee..dddd9a89c472 100644
--- a/django/http/__init__.py
+++ b/django/http/__init__.py
@@ -165,6 +165,11 @@ def get_host(self):
             server_port = str(self.META['SERVER_PORT'])
             if server_port != (self.is_secure() and '443' or '80'):
                 host = '%s:%s' % (host, server_port)
+
+        # Disallow potentially poisoned hostnames.
+        if set(';/?@&=+$,').intersection(host):
+            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)
+
         return host
 
     def get_full_path(self):"
CVE-2012-3468,"From 4764792d628d40d061f910102135b33ae2123c81 Mon Sep 17 00:00:00 2001
From: Robbie Mackay <rm@robbiemackay.com>
Date: Fri, 6 Jul 2012 13:36:17 +1200
Subject: [PATCH] Fix SQLi in settings::save_all() Closes #680

---
 application/models/settings.php | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/application/models/settings.php b/application/models/settings.php
index c9296f9305..723a4944cf 100644
--- a/application/models/settings.php
+++ b/application/models/settings.php
@@ -102,6 +102,9 @@ public static function save_all(Validation $settings)
 		$values = array();
 		$keys = array();
 		
+		// Modification date
+		$settings['date_modify'] = date(""Y-m-d H:i:s"",time());
+		
 		// List of value to skip
 		$skip = array('api_live');
 		foreach ($settings as $key => $value)
@@ -116,19 +119,17 @@ public static function save_all(Validation $settings)
 			{
 				$value = NULL;
 			}
+			
 
-			$keys[] = sprintf(""'%s'"", $key);
-			$values[] = sprintf(""WHEN '%s' THEN '%s' "", $key, $value);
+			$keys[] = Database::instance()->escape($key);
+			$values[] = sprintf(""WHEN %s THEN %s "", Database::instance()->escape($key), Database::instance()->escape($value));
 		}
 		
-		// Modification date
-		$keys[] = ""'date_modify'"";
-		$values[] = sprintf(""WHEN 'date_modify' THEN '%s' "", date(""Y-m-d H:i:s"",time()));
-		
 		// Construct the final query
 		$query .= implode("" "", $values).""END WHERE `key` IN (%s)"";
 		$query = sprintf($query, implode("","", $keys));
 		
+
 		// Performa batch update
 		Database::instance()->query($query);
 	}"
CVE-2012-4573,"From efd7e75b1f419a52c7103c7840e24af8e5deb29d Mon Sep 17 00:00:00 2001
From: Brian Waldon <bcwaldon@gmail.com>
Date: Wed, 7 Nov 2012 10:06:43 -0500
Subject: [PATCH] Ensure image owned by user before delayed_deletion

Fixes bug 1065187.

Change-Id: Icf2f117a094c712bad645ef5f297e9f7da994c84
---
 glance/api/v1/images.py | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/glance/api/v1/images.py b/glance/api/v1/images.py
index 9bedf204df..1a8eac8b54 100644
--- a/glance/api/v1/images.py
+++ b/glance/api/v1/images.py
@@ -727,6 +727,15 @@ def delete(self, req, id):
                                 content_type=""text/plain"")
 
         image = self.get_image_meta_or_404(req, id)
+
+        if not (req.context.is_admin
+                or image['owner'] == None
+                or image['owner'] == req.context.owner):
+            msg = _(""Unable to delete image you do not own"")
+            logger.debug(msg)
+            raise HTTPForbidden(msg, request=req,
+                                content_type=""text/plain"")
+
         if image['protected']:
             msg = _(""Image is protected"")
             logger.debug(msg)"
CVE-2012-5517,"From 08dff7b7d629807dbb1f398c68dd9cd58dd657a1 Mon Sep 17 00:00:00 2001
From: Jiang Liu <jiang.liu@huawei.com>
Date: Tue, 31 Jul 2012 16:43:30 -0700
Subject: [PATCH] mm/hotplug: correctly add new zone to all other nodes' zone
 lists

When online_pages() is called to add new memory to an empty zone, it
rebuilds all zone lists by calling build_all_zonelists().  But there's a
bug which prevents the new zone to be added to other nodes' zone lists.

online_pages() {
	build_all_zonelists()
	.....
	node_set_state(zone_to_nid(zone), N_HIGH_MEMORY)
}

Here the node of the zone is put into N_HIGH_MEMORY state after calling
build_all_zonelists(), but build_all_zonelists() only adds zones from
nodes in N_HIGH_MEMORY state to the fallback zone lists.
build_all_zonelists()

    ->__build_all_zonelists()
	->build_zonelists()
	    ->find_next_best_node()
		->for_each_node_state(n, N_HIGH_MEMORY)

So memory in the new zone will never be used by other nodes, and it may
cause strange behavor when system is under memory pressure.  So put node
into N_HIGH_MEMORY state before calling build_all_zonelists().

Signed-off-by: Jianguo Wu <wujianguo@huawei.com>
Signed-off-by: Jiang Liu <liuj97@gmail.com>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Michal Hocko <mhocko@suse.cz>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Rusty Russell <rusty@rustcorp.com.au>
Cc: Yinghai Lu <yinghai@kernel.org>
Cc: Tony Luck <tony.luck@intel.com>
Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Keping Chen <chenkeping@huawei.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
---
 mm/memory_hotplug.c | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index b8731040b9f929..597d371329d390 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -512,19 +512,20 @@ int __ref online_pages(unsigned long pfn, unsigned long nr_pages)
 
 	zone->present_pages += onlined_pages;
 	zone->zone_pgdat->node_present_pages += onlined_pages;
-	if (need_zonelists_rebuild)
-		build_all_zonelists(NULL, zone);
-	else
-		zone_pcp_update(zone);
+	if (onlined_pages) {
+		node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
+		if (need_zonelists_rebuild)
+			build_all_zonelists(NULL, zone);
+		else
+			zone_pcp_update(zone);
+	}
 
 	mutex_unlock(&zonelists_mutex);
 
 	init_per_zone_wmark_min();
 
-	if (onlined_pages) {
+	if (onlined_pages)
 		kswapd_run(zone_to_nid(zone));
-		node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
-	}
 
 	vm_total_pages = nr_free_pagecache_pages();"
PYSEC-2012-7,"From 9305c0e12d43c4df999c3301a1f0c742264a657e Mon Sep 17 00:00:00 2001
From: Preston Holmes <preston@ptone.com>
Date: Wed, 17 Oct 2012 14:36:41 -0700
Subject: [PATCH] Fixed a security issue related to password resets

Full disclosure and new release are forthcoming
---
 django/contrib/auth/tests/urls.py  |  1 +
 django/contrib/auth/tests/views.py | 37 ++++++++++++++++++++++++++++++
 django/contrib/auth/views.py       |  2 +-
 django/http/__init__.py            |  5 ++++
 4 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/django/contrib/auth/tests/urls.py b/django/contrib/auth/tests/urls.py
index 8f9e848aa952..4b498ceaf0a7 100644
--- a/django/contrib/auth/tests/urls.py
+++ b/django/contrib/auth/tests/urls.py
@@ -55,6 +55,7 @@ def userpage(request):
     (r'^logout/next_page/$', 'django.contrib.auth.views.logout', dict(next_page='/somewhere/')),
     (r'^remote_user/$', remote_user_auth_view),
     (r'^password_reset_from_email/$', 'django.contrib.auth.views.password_reset', dict(from_email='staffmember@example.com')),
+    (r'^admin_password_reset/$', 'django.contrib.auth.views.password_reset', dict(is_admin_site=True)),
     (r'^login_required/$', login_required(password_reset)),
     (r'^login_required_login_url/$', login_required(password_reset, login_url='/somewhere/')),
 
diff --git a/django/contrib/auth/tests/views.py b/django/contrib/auth/tests/views.py
index 5727dc289f77..bb17576d3146 100644
--- a/django/contrib/auth/tests/views.py
+++ b/django/contrib/auth/tests/views.py
@@ -5,6 +5,7 @@
 from django.contrib.sites.models import Site, RequestSite
 from django.contrib.auth.models import User
 from django.core import mail
+from django.core.exceptions import SuspiciousOperation
 from django.core.urlresolvers import reverse, NoReverseMatch
 from django.http import QueryDict
 from django.utils.encoding import force_text
@@ -103,6 +104,42 @@ def test_email_found_custom_from(self):
         self.assertEqual(len(mail.outbox), 1)
         self.assertEqual(""staffmember@example.com"", mail.outbox[0].from_email)
 
+    def test_admin_reset(self):
+        ""If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.""
+        response = self.client.post('/admin_password_reset/',
+            {'email': 'staffmember@example.com'},
+            HTTP_HOST='adminsite.com'
+        )
+        self.assertEqual(response.status_code, 302)
+        self.assertEqual(len(mail.outbox), 1)
+        self.assertTrue(""http://adminsite.com"" in mail.outbox[0].body)
+        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)
+
+    def test_poisoned_http_host(self):
+        ""Poisoned HTTP_HOST headers can't be used for reset emails""
+        # This attack is based on the way browsers handle URLs. The colon
+        # should be used to separate the port, but if the URL contains an @,
+        # the colon is interpreted as part of a username for login purposes,
+        # making 'evil.com' the request domain. Since HTTP_HOST is used to
+        # produce a meaningful reset URL, we need to be certain that the
+        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()
+        # is invoked, but we check here as a practical consequence.
+        with self.assertRaises(SuspiciousOperation):
+            self.client.post('/password_reset/',
+                {'email': 'staffmember@example.com'},
+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
+            )
+        self.assertEqual(len(mail.outbox), 0)
+
+    def test_poisoned_http_host_admin_site(self):
+        ""Poisoned HTTP_HOST headers can't be used for reset emails on admin views""
+        with self.assertRaises(SuspiciousOperation):
+            self.client.post('/admin_password_reset/',
+                {'email': 'staffmember@example.com'},
+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
+            )
+        self.assertEqual(len(mail.outbox), 0)
+
     def _test_confirm_start(self):
         # Start by creating the email
         response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})
diff --git a/django/contrib/auth/views.py b/django/contrib/auth/views.py
index 747b5c0991d5..d27e2f5aba51 100644
--- a/django/contrib/auth/views.py
+++ b/django/contrib/auth/views.py
@@ -163,7 +163,7 @@ def password_reset(request, is_admin_site=False,
                 'request': request,
             }
             if is_admin_site:
-                opts = dict(opts, domain_override=request.META['HTTP_HOST'])
+                opts = dict(opts, domain_override=request.get_host())
             form.save(**opts)
             return HttpResponseRedirect(post_reset_redirect)
     else:
diff --git a/django/http/__init__.py b/django/http/__init__.py
index ecb39129addf..b385b450eeed 100644
--- a/django/http/__init__.py
+++ b/django/http/__init__.py
@@ -180,6 +180,11 @@ def get_host(self):
             server_port = str(self.META['SERVER_PORT'])
             if server_port != ('443' if self.is_secure() else '80'):
                 host = '%s:%s' % (host, server_port)
+
+        # Disallow potentially poisoned hostnames.
+        if set(';/?@&=+$,').intersection(host):
+            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)
+
         return host
 
     def get_full_path(self):"
CVE-2012-1836,"From a6a07de0daa353bcd29056a4535a9c4784c113c8 Mon Sep 17 00:00:00 2001
From: William Pitcock <nenolod@dereferenced.org>
Date: Tue, 20 Mar 2012 17:48:45 -0500
Subject: [PATCH 1/4] dns: iterators which are integer should always be
 unsigned, else an integer underflow is possible.

Signed-off-by: William Pitcock <nenolod@dereferenced.org>
---
 src/dns.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dns.cpp b/src/dns.cpp
index 945e1fb15c..abdd0a54cf 100644
--- a/src/dns.cpp
+++ b/src/dns.cpp
@@ -690,7 +690,7 @@ DNSResult DNS::GetResult()
 /** A result is ready, process it */
 DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 {
-	int i = 0;
+	unsigned i = 0;
 	int q = 0;
 	int curanswer, o;
 	ResourceRecord rr;

From 9aa28f3730fb3dd69c1e06f78bb2bbc43d36c684 Mon Sep 17 00:00:00 2001
From: William Pitcock <nenolod@dereferenced.org>
Date: Tue, 20 Mar 2012 18:31:14 -0500
Subject: [PATCH 2/4] dns: reject messages with lengths larger than DNSHeader
 with prejudice

This also includes when decompressing name entries.
---
 src/dns.cpp | 43 +++++++++++++++++++++++++++++++++----------
 1 file changed, 33 insertions(+), 10 deletions(-)

diff --git a/src/dns.cpp b/src/dns.cpp
index abdd0a54cf..2bfa0be20d 100644
--- a/src/dns.cpp
+++ b/src/dns.cpp
@@ -38,6 +38,8 @@ looks like this, walks like this or tastes like this.
 #include ""configreader.h""
 #include ""socket.h""
 
+#define DN_COMP_BITMASK	0xC000		/* highest 6 bits in a DN label header */
+
 /** Masks to mask off the responses we get from the DNSRequest methods
  */
 enum QueryInfo
@@ -161,7 +163,10 @@ int CachedQuery::CalcTTLRemaining()
 /* Allocate the processing buffer */
 DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)
 {
-	res = new unsigned char[512];
+	/* hardening against overflow here:  make our work buffer twice the theoretical
+	 * maximum size so that hostile input doesn't screw us over.
+	 */
+	res = new unsigned char[sizeof(DNSHeader) * 2];
 	*res = 0;
 	orig = original;
 	RequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);
@@ -690,9 +695,9 @@ DNSResult DNS::GetResult()
 /** A result is ready, process it */
 DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 {
-	unsigned i = 0;
+	unsigned i = 0, o;
 	int q = 0;
-	int curanswer, o;
+	int curanswer;
 	ResourceRecord rr;
  	unsigned short ptr;
 
@@ -717,7 +722,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 	/* Subtract the length of the header from the length of the packet */
 	length -= 12;
 
-	while ((unsigned int)q < header.qdcount && i < length)
+	while ((unsigned int)q < header.qdcount && i < (unsigned) length)
 	{
 		if (header.payload[i] > 63)
 		{
@@ -738,7 +743,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 	while ((unsigned)curanswer < header.ancount)
 	{
 		q = 0;
-		while (q == 0 && i < length)
+		while (q == 0 && i < (unsigned) length)
 		{
 			if (header.payload[i] > 63)
 			{
@@ -755,7 +760,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 				else i += header.payload[i] + 1; /* skip length and label */
 			}
 		}
-		if (length - i < 10)
+		if ((unsigned) length - i < 10)
 			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
 
 		/* XXX: We actually initialise 'rr' here including its ttl field */
@@ -790,17 +795,31 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 
 	switch (rr.type)
 	{
+		/*
+		 * CNAME and PTR are compressed.  We need to decompress them.
+		 */
 		case DNS_QUERY_CNAME:
-			/* CNAME and PTR have the same processing code */
 		case DNS_QUERY_PTR:
 			o = 0;
 			q = 0;
-			while (q == 0 && i < length && o + 256 < 1023)
+			while (q == 0 && i < (unsigned) length && o + 256 < 1023)
 			{
+				/* DN label found (byte over 63) */
 				if (header.payload[i] > 63)
 				{
 					memcpy(&ptr,&header.payload[i],2);
-					i = ntohs(ptr) - 0xC000 - 12;
+
+					i = ntohs(ptr);
+
+					/* check that highest two bits are set. if not, we've been had */
+					if (!(i & DN_COMP_BITMASK))
+						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
+
+					/* mask away the two highest bits. */
+					i &= ~DN_COMP_BITMASK;
+
+					/* and decrease length by 12 bytes. */
+					i =- 12;
 				}
 				else
 				{
@@ -813,7 +832,11 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 						res[o] = 0;
 						if (o != 0)
 							res[o++] = '.';
-						memcpy(&res[o],&header.payload[i + 1],header.payload[i]);
+
+						if (o + header.payload[i] > sizeof(DNSHeader))
+							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");
+
+						memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
 						o += header.payload[i];
 						i += header.payload[i] + 1;
 					}

From 84ab0478f9dd7f7f8dc92aa1edaf6b71fe28035b Mon Sep 17 00:00:00 2001
From: William Pitcock <nenolod@dereferenced.org>
Date: Tue, 20 Mar 2012 18:38:13 -0500
Subject: [PATCH 3/4] dns: more hardening

- don't trust rr.rdlength
- don't accept replies we know are impossible for AAAA/A records
- don't try to process record types we do not know about specifically
  (this behaviour just leads to disaster)
---
 src/dns.cpp | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/dns.cpp b/src/dns.cpp
index 2bfa0be20d..21b0d9e39f 100644
--- a/src/dns.cpp
+++ b/src/dns.cpp
@@ -845,16 +845,21 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 			res[o] = 0;
 		break;
 		case DNS_QUERY_AAAA:
+			if (rr.rdlength != sizeof(struct in6_addr))
+				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");
+
 			memcpy(res,&header.payload[i],rr.rdlength);
 			res[rr.rdlength] = 0;
 		break;
 		case DNS_QUERY_A:
+			if (rr.rdlength != sizeof(struct in_addr))
+				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");
+
 			memcpy(res,&header.payload[i],rr.rdlength);
 			res[rr.rdlength] = 0;
 		break;
 		default:
-			memcpy(res,&header.payload[i],rr.rdlength);
-			res[rr.rdlength] = 0;
+			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
 		break;
 	}
 	return std::make_pair(res,""No error"");

From eac05f8d05ce2e3878ac4a51675b11e64831adac Mon Sep 17 00:00:00 2001
From: William Pitcock <nenolod@dereferenced.org>
Date: Tue, 20 Mar 2012 18:41:09 -0500
Subject: [PATCH 4/4] dns: cleanup ResultIsReady() prototype

---
 src/dns.cpp | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/dns.cpp b/src/dns.cpp
index 21b0d9e39f..2e1c751c4c 100644
--- a/src/dns.cpp
+++ b/src/dns.cpp
@@ -100,7 +100,7 @@ class DNSRequest
 
 	DNSRequest(DNS* dns, int id, const std::string &original);
 	~DNSRequest();
-	DNSInfo ResultIsReady(DNSHeader &h, int length);
+	DNSInfo ResultIsReady(DNSHeader &h, unsigned length);
 	int SendRequests(const DNSHeader *header, const int length, QueryType qt);
 };
 
@@ -693,7 +693,7 @@ DNSResult DNS::GetResult()
 }
 
 /** A result is ready, process it */
-DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
+DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 {
 	unsigned i = 0, o;
 	int q = 0;
@@ -722,7 +722,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 	/* Subtract the length of the header from the length of the packet */
 	length -= 12;
 
-	while ((unsigned int)q < header.qdcount && i < (unsigned) length)
+	while ((unsigned int)q < header.qdcount && i < length)
 	{
 		if (header.payload[i] > 63)
 		{
@@ -743,7 +743,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 	while ((unsigned)curanswer < header.ancount)
 	{
 		q = 0;
-		while (q == 0 && i < (unsigned) length)
+		while (q == 0 && i < length)
 		{
 			if (header.payload[i] > 63)
 			{
@@ -760,7 +760,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 				else i += header.payload[i] + 1; /* skip length and label */
 			}
 		}
-		if ((unsigned) length - i < 10)
+		if (length - i < 10)
 			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
 
 		/* XXX: We actually initialise 'rr' here including its ttl field */
@@ -802,7 +802,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 		case DNS_QUERY_PTR:
 			o = 0;
 			q = 0;
-			while (q == 0 && i < (unsigned) length && o + 256 < 1023)
+			while (q == 0 && i < length && o + 256 < 1023)
 			{
 				/* DN label found (byte over 63) */
 				if (header.payload[i] > 63)"
CVE-2012-2691,"From 175d973105fe9f03a37ced537b742611631067e0 Mon Sep 17 00:00:00 2001
From: Damien Regad <damien.regad@merckgroup.com>
Date: Mon, 4 Jun 2012 00:29:44 +0200
Subject: [PATCH] mc_issue_note_update passing wrong param to access check
 function

Commit edc8142bb8ac0ac0df1a3824d78c15f4015d959e introduced proper logic
to avoid unauthorized update of bugnotes, but was passing incorrect
parameters to access_has_bugnote_level() so unprivileged users could
still update them.

Fixes #14340
---
 api/soap/mc_issue_api.php | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/api/soap/mc_issue_api.php b/api/soap/mc_issue_api.php
index 6acf17352f..251b12d855 100644
--- a/api/soap/mc_issue_api.php
+++ b/api/soap/mc_issue_api.php
@@ -1113,7 +1113,7 @@ function mc_issue_note_update( $p_username, $p_password, $p_note ) {
 	# Check if the user has an access level beyond update_bugnote_threshold for the
 	# project containing the bugnote to update.
 	$t_update_bugnote_threshold = config_get( 'update_bugnote_threshold', null, $t_user_id, $t_project_id );
-	if ( !$t_user_owns_the_bugnote && !access_has_bugnote_level( $t_update_bugnote_threshold, $t_user_id, $t_project_id ) ) {
+	if ( !$t_user_owns_the_bugnote && !access_has_bugnote_level( $t_update_bugnote_threshold, $t_issue_note_id, $t_user_id ) ) {
 		return mci_soap_fault_access_denied( $t_user_id );
 	}"
