id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message,original_message_score,original_message_entities,generated_secom_message_score,generated_secom_message_entities
0,{'CWE-79'},GHSA-wcm2-9c89-wmfm,"@@ -352,14 +352,21 @@ $.widget(""ui.dialog"", {
 		uiDialogTitle = $( ""<span>"" )
 			.uniqueId()
 			.addClass( ""ui-dialog-title"" )
-			.html( this.options.title || ""&#160;"" )
 			.prependTo( this.uiDialogTitlebar );
+		this._title( uiDialogTitle );
 
 		this.uiDialog.attr({
 			""aria-labelledby"": uiDialogTitle.attr( ""id"" )
 		});
 	},
 
+	_title: function( title ) {
+		if ( !this.options.title ) {
+			title.html( ""&#160;"" );
+		}
+		title.text( this.options.title );
+	},
+
 	_createButtonPane: function() {
 		var uiDialogButtonPane = ( this.uiDialogButtonPane = $( ""<div>"" ) )
 			.addClass( ""ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"" );
@@ -600,9 +607,7 @@ $.widget(""ui.dialog"", {
 		}
 
 		if ( key === ""title"" ) {
-			// convert whatever was passed in to a string, for html() to not throw up
-			$( "".ui-dialog-title"", this.uiDialogTitlebar )
-				.html( """" + ( value || ""&#160;"" ) );
+			this._title( this.uiDialogTitlebar.find( "".ui-dialog-title"" ) );
 		}
 	},","Dialog: Extract setting the title into a _title method, use .text() to prevent XSS. Fixes #6016 - Dialog: Title XSS Vulnerability.","vuln-fix: Prevent XSS by escaping dialog title content

The dialog title was previously set using html() with unescaped input, allowing injection of arbitrary HTML or scripts into the dialog header. This posed a cross-site scripting risk by enabling attackers to execute malicious code in users’ browsers. The fix replaces html() with text() to safely escape the title content, preventing injection of executable code.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('fixes', 'ACTION', ''), ('#6016', 'ISSUE', ''), ('xss', 'secword', ''), ('vulnerability', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious code', 'secword', ''), ('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,{'CWE-79'},GHSA-q26w-wjj2-22vv,"@@ -87,11 +87,16 @@ class HtmlUtils {
 			return tagStack[tagStack.length - 1];
 		};
 
-		// The BASE tag allows changing the base URL from which files are loaded, and
-		// that can break several plugins, such as Katex (which needs to load CSS
-		// files using a relative URL). For that reason it is disabled.
-		// More info: https://github.com/laurent22/joplin/issues/3021
-		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed'];
+		// The BASE tag allows changing the base URL from which files are
+		// loaded, and that can break several plugins, such as Katex (which
+		// needs to load CSS files using a relative URL). For that reason
+		// it is disabled. More info:
+		// https://github.com/laurent22/joplin/issues/3021
+		//
+		// ""link"" can be used to escape the parser and inject JavaScript.
+		// Adding ""meta"" too for the same reason as it shouldn't be used in
+		// notes anyway.
+		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed', 'link', 'meta'];
 
 		const parser = new htmlparser2.Parser({","All: Security: Remove ""link"" and ""meta"" tags from notes to prevent XSS","vuln-fix: Prevent XSS via disallowed HTML tags in note content

The vulnerability allowed injection of malicious JavaScript through ""link"" and ""meta"" tags in notes, enabling cross-site scripting attacks. This is a security risk because attackers could execute arbitrary scripts in the user's context, compromising data and application integrity. The fix adds ""link"" and ""meta"" tags to the disallowed list, preventing their use and blocking potential script injection vectors.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('security', 'SECWORD', ''), ('remove', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,{'CWE-79'},GHSA-4p8f-mmfj-r45g,"@@ -17,7 +17,7 @@ def tags_for_index(model)
       elsif !query.include?(hashtag)
         query += "" #{hashtag}""
       end
-      out << link_to_function(tag, ""crm.search_tagged('#{query}', '#{model.class.to_s.tableize}')"", title: tag)
+      out << link_to_function(tag, ""crm.search_tagged('#{escape_javascript(query)}', '#{model.class.to_s.tableize}')"", title: tag)
     end
   end",Context-sensitive XSS bugfix.,"vuln-fix: Prevent JavaScript injection in tag search links

The vulnerability allowed unescaped user input to be embedded directly into JavaScript event handlers, enabling potential cross-site scripting (XSS) attacks. This posed a security risk by allowing attackers to execute arbitrary scripts in users' browsers, compromising user data and session integrity. The fix applies proper JavaScript escaping to the query parameter before embedding it in the event handler, mitigating injection risks.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('sensitive', 'SECWORD', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,{'CWE-79'},GHSA-cx2r-mf6x-55rx,"@@ -29,6 +29,7 @@
 use PrestaShopBundle\Form\Admin\Type\TranslatorAwareType;
 use Symfony\Component\Form\Extension\Core\Type\TextType;
 use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints as Assert;
 
 class CustomUrlType extends TranslatorAwareType
 {
@@ -45,6 +46,7 @@ public function buildForm(FormBuilderInterface $builder, array $options)
             ->add('url', TextType::class, [
                 'label' => $this->trans('URL', 'Modules.Linklist.Admin'),
                 'required' => true,
+                'constraints' => [new Assert\Url()],
             ])
         ;
     }","Merge pull request from GHSA-cx2r-mf6x-55rx

The custom url field must be a valid url","vuln-fix: Validate URL input to prevent malformed data submission

The URL field lacked proper validation, allowing malformed or potentially malicious URLs to be submitted through the form. This posed a security risk by enabling injection attacks or improper data handling downstream. The fix enforces URL format validation using Symfony's built-in URL constraint to ensure only valid URLs are accepted.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-20', 'CWEID', ''), ('improper input validation', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
4,{'CWE-79'},GHSA-5qjq-69w6-fg57,"similarity index 86%
rename from js/src/common/Translator.ts
rename to js/src/common/Translator.tsx
@@ -48,12 +48,23 @@ export default class Translator {
     // future there should be a hook here to inspect the user and change the
     // translation key. This will allow a gender property to determine which
     // translation key is used.
+
     if ('user' in parameters) {
       const user = extract(parameters, 'user');
 
       if (!parameters.username) parameters.username = username(user);
     }
-    return parameters;
+
+    const escapedParameters: TranslatorParameters = {};
+
+    for (const param in parameters) {
+      const paramValue = parameters[param];
+
+      if (typeof paramValue === 'string') escapedParameters[param] = <>{parameters[param]}</>;
+      else escapedParameters[param] = parameters[param];
+    }
+
+    return escapedParameters;
   }
 
   trans(id: string, parameters: TranslatorParameters = {}) {",Fix XSS vulnerability,"vuln-fix: Prevent XSS by escaping translation parameters

The vulnerability involved unescaped user-controlled input being directly inserted into translation parameters, enabling potential cross-site scripting attacks. This is a security risk because malicious scripts could execute in users’ browsers, leading to data theft or session hijacking. The fix escapes all string parameters before rendering, ensuring that injected scripts are neutralized and cannot execute. 

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('malicious', 'SECWORD', ''), ('theft', 'secword', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,{'CWE-79'},GHSA-3374-7h99-xr85,"@@ -128,6 +128,7 @@ private function loadDataGrid(): void
             'registered_on',
             true
         );
+        $this->dgProfiles->setColumnFunction('htmlspecialchars', ['[display_name]'], 'display_name');
 
         // add the mass action controls
         $this->dgProfiles->setMassActionCheckboxes('check', '[id]');",Fix xss in profiles display name,"vuln-fix: Sanitize display_name output to prevent XSS

The display_name field was output directly without escaping, allowing injection of malicious HTML or JavaScript code into the rendered page.
This posed a cross-site scripting (XSS) risk, enabling attackers to execute arbitrary scripts in users' browsers and compromise session integrity.
The fix applies htmlspecialchars to the display_name column, ensuring all special characters are properly escaped before rendering.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,{'CWE-79'},GHSA-qqxp-xp9v-vvx6,"@@ -61,7 +61,7 @@
 						// remove invalid value, as it didn't match anything
 						$( element )
 							.val( """" )
-							.attr( ""title"", value + "" didn't match any item"" )
+							.attr( ""title"", $( ""<a>"" ).text( value ).html() + "" didn't match any item"" )
 							.tooltip( ""open"" );
 						select.val( """" );
 						setTimeout(function() {",Autocomplete demo: Combobox: Encode search term inside tooltips. Fixes #8859 - Autocomplete: XSS in combobox demo.,"vuln-fix: Prevent XSS in autocomplete invalid value tooltip

The vulnerability was caused by directly inserting user input into HTML attributes without escaping, allowing injection of malicious scripts.
This is a security risk because attackers could execute arbitrary JavaScript in the context of the affected page, leading to cross-site scripting attacks.
The fix escapes the user input by converting it to text and then to HTML entities before insertion, preventing script execution in the tooltip attribute.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)
Severity: Medium
CVSS: 6.1",0.058823529411764705,"[('encode', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#8859', 'ISSUE', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
7,{'CWE-79'},GHSA-q7q9-w24q-cpgh,"@@ -149,8 +149,16 @@ App.BreadcrumbItem = Em.Object.extend({
   createLabel() {
     let label = this.get('label');
     let labelBindingPath = this.get('labelBindingPath');
+    let formattedLabel;
+
+    if (labelBindingPath) {
+      formattedLabel = Ember.Handlebars.Utils.escapeExpression(App.get(_getLabelPathWithoutApp(labelBindingPath)));
+    } else{
+      formattedLabel = label;
+    }
+
+
 
-    let formattedLabel = labelBindingPath ? App.get(_getLabelPathWithoutApp(labelBindingPath)) : label;
     this.set('formattedLabel', this.labelPostFormat(formattedLabel));
   },
 
@@ -216,7 +224,9 @@ App.BreadcrumbsView = Em.View.extend({
       }
       currentState = currentState.get('parentState');
     }
-    items = items.reverse().map(item => App.BreadcrumbItem.extend(item).create());
+    items.reverse();
+    items.slice(1).forEach(item => item.label = Ember.Handlebars.Utils.escapeExpression(item.label));
+    items = items.map(item => App.BreadcrumbItem.extend(item).create());
     if (items.length) {
       items.get('lastObject').setProperties({
         disabled: true,",AMBARI-25329. Ambari breadcrumbs xss vulnerability,"vuln-fix: Escape breadcrumb labels to prevent XSS attacks

Breadcrumb labels were not properly escaped before rendering, allowing injection of malicious scripts via crafted label inputs.
This posed a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in users’ browsers and compromise session integrity.
The fix applies proper escaping to all breadcrumb labels derived from dynamic sources before rendering, mitigating script injection vulnerabilities.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('xss', 'secword', ''), ('vulnerability', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('escaped', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,{'CWE-79'},GHSA-vcfc-9wcp-j623,"@@ -90,12 +90,13 @@ public async Task SerializeToStreamAsync(IRequest req, object response, Stream o
             {
                 // Serialize then escape any potential script tags to avoid XSS when displaying as HTML
                 var json = JsonDataContractSerializer.Instance.SerializeToString(dto) ?? ""null"";
-                json = json.Replace(""<"", ""&lt;"").Replace("">"", ""&gt;"");
+                json = json.HtmlEncode();
 
                 var url = req.ResolveAbsoluteUrl()
                     .Replace(""format=html"", """")
                     .Replace(""format=shtm"", """")
-                    .TrimEnd('?', '&');
+                    .TrimEnd('?', '&')
+                    .HtmlEncode();
 
                 url += url.Contains(""?"") ? ""&"" : ""?"";",HtmlEncode Raw URL in HtmlFormat snapshot,"vuln-fix: Prevent XSS by encoding JSON and URL output

The vulnerability involved insufficient escaping of JSON and URL output, which could allow injection of malicious scripts in HTML contexts. This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user data and session integrity. The fix applies comprehensive HTML encoding to both JSON content and URLs before rendering, ensuring all special characters are safely escaped.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('htmlencode', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,{'CWE-79'},GHSA-whv6-rj84-2vh2,"@@ -60,6 +60,9 @@ import Action from 'nextcloud-vue/dist/Components/Action'
 import Avatar from 'nextcloud-vue/dist/Components/Avatar'
 import Tooltip from 'nextcloud-vue/dist/Directives/Tooltip'
 
+Tooltip.options.defaultHtml = false
+
+
 export default {
 	name: 'CollectionListItem',
 	components: {","Force defaultHtml setting of v-tooltip to be disabled

Signed-off-by: Julius Härtl <jus@bitgrid.net>","vuln-fix: Disable default HTML rendering in tooltip directive

The tooltip directive previously allowed rendering HTML content by default, which could enable injection of malicious scripts through user-controlled input.
This posed a cross-site scripting (XSS) risk by allowing attackers to execute arbitrary JavaScript in the context of the application.
The fix disables default HTML rendering in the tooltip directive, ensuring that content is treated as plain text and preventing script injection.
  
Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('signed', 'secword', ''), ('jus@bitgrid.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,{'CWE-79'},GHSA-xw79-hhv6-578c,"@@ -4,7 +4,7 @@
     <meta charset=""utf-8"">
     <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
 
-    <title>Files within {{=it.directory}}</title>
+    <title>Files within {{!it.directory}}</title>
 
 	<style>
 		body {
@@ -187,7 +187,7 @@
           <i>Index of&nbsp;</i>
 
           {{~it.paths :value:index}}
-            <a href=""/{{=value.url}}"">{{=value.name}}</a>
+            <a href=""/{{!value.url}}"">{{!value.name}}</a>
           {{~}}
         </h1>
 
@@ -197,9 +197,9 @@
       <ul id=""files"">
         {{~it.files :value:index}}
           <li>
-            <a href=""{{=value.relative}}"" title=""{{=value.title}}"" class=""{{=value.ext}}"">{{=value.base}}</a>
+            <a href=""{{!value.relative}}"" title=""{{!value.title}}"" class=""{{!value.ext}}"">{{!value.base}}</a>
 			{{? value.size}}
-				<i>{{=value.size}}</i>
+				<i>{{!value.size}}</i>
 			{{?}}
           </li>
         {{~}}",Interpolate template variables correctly (#64),"vuln-fix: Prevent XSS by escaping template output in HTML

Unescaped template variables in HTML attributes and content allowed injection of malicious scripts via directory, path, and file data.
This posed a critical cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in users’ browsers and compromise security.
The fix applies proper HTML escaping to all dynamic template outputs, ensuring special characters are safely encoded and scripts cannot be injected.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: Critical  
CVSS: 9.8",0.11764705882352941,"[('#64', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('critical', 'SEVERITY', ''), ('cross-site scripting', 'secword', ''), ('attackers', 'FLAW', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
11,{'CWE-79'},GHSA-5pg2-qg87-vmj7,"@@ -336,9 +336,12 @@
 // Make sure the fileName is unique but only if chunking is disabled
 if ($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
     $ext = strrpos($fileName, '.');
+
     $fileName_a = substr($fileName, 0, $ext);
     $fileName_b = substr($fileName, $ext);
 
+    $fileName_b = strtolower($fileName_b);
+
     $count = 1;
     while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b)) {
         ++$count;
@@ -500,7 +503,7 @@
 
     if (is_file($filePath) and !$chunks || $chunk == $chunks - 1) {
         $ext = get_file_extension($filePath);
-
+        $ext = strtolower($ext);
         if (function_exists('finfo_open') and function_exists('finfo_file')) {
             $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension
             $mime = @finfo_file($finfo, $filePath);",update,"vuln-fix: Normalize file extensions to prevent case-sensitive bypasses

File extension comparisons were case-sensitive, allowing attackers to bypass file type restrictions by using uppercase or mixed-case extensions.
This could lead to unauthorized file uploads or execution of malicious files due to inconsistent validation.
The fix converts file extensions to lowercase before checks, ensuring consistent and secure handling of file types.

Weakness: Improper Neutralization of Case Variations (CWE-179)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('malicious files', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper neutralization', 'secword', ''), ('cwe-179', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
12,{'CWE-79'},GHSA-5vr6-hm68-5j9p,"@@ -44,5 +44,5 @@
 if (! empty($ok)) {
     exit(""$ok"");
 } else {
-    exit(""ERROR: $error"");
+    exit(""ERROR: "".htmlspecialchars($error));;
 }",fix XSS vulnerability in poller-groups.inc.php,"vuln-fix: Sanitize error output to prevent XSS in exit message

The vulnerability was that error messages were output directly without escaping, allowing injection of malicious HTML or JavaScript code in the response. This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user data or session integrity. The fix applies htmlspecialchars to the error message before output, ensuring special characters are escaped and preventing script execution.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('poller-groups.inc.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('error', 'FLAW', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,"{'CWE-434', 'CWE-79'}",GHSA-5q5w-mqp6-g2gh,"@@ -20,7 +20,9 @@ public function rules()
             'quantity' => ['required', 'integer', 'min:0'],
             'price' => ['required', 'numeric', 'min:0'],
             'sale_price' => ['nullable', 'numeric'],
-            'weight' => ['nullable', 'numeric', 'min:0']
+            'weight' => ['nullable', 'numeric', 'min:0'],
+            'image' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
+            'cover' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
         ];
     }
 }",Fix vulnerability report from hunter.dev,"vuln-fix: Add image upload validation to prevent unsafe file types

The vulnerability was the lack of validation on image and cover file uploads, allowing potentially malicious files to be uploaded to the server. This posed a security risk by enabling attackers to upload executable or harmful files that could compromise the system. The fix enforces strict image type and size validation, restricting uploads to safe image formats and limiting file size to 2MB. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('hunter.dev', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('server', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,{'CWE-79'},GHSA-vpwq-6cp4-ffqc,"@@ -309,6 +309,8 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".aspx"")
 			|| $isDangerStr($filename , "".xsd"")
 			|| $isDangerStr($filename , "".asa"")
+			|| $isDangerStr($filename , "".cshtml"")
+			|| $isDangerStr($filename , "".axd"")
 		) {
 			return true;
 		}",bug,"vuln-fix: Prevent dangerous file extensions in upload validation

The file upload validation missed blocking certain dangerous extensions like .cshtml and .axd, which can contain executable code or sensitive handlers. Allowing these files poses a risk of remote code execution or unauthorized access to server internals. The fix adds checks to reject filenames with .cshtml and .axd extensions, enhancing upload security by preventing potentially harmful files.

Weakness: CWE-434 - Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('remote code execution', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('security', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
15,{'CWE-79'},GHSA-j6p2-cx3w-6jcp,"@@ -1079,7 +1079,7 @@
 
   // Helper function to escape a string for HTML rendering.
   var escapeHTML = function(string) {
-    return string.replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+    return string.replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
   };
 
 }).call(this);","Fixed escapeHTML function
to skip not only &***;, but also &#***; and &x***;","vuln-fix: Improve HTML escaping to prevent XSS via numeric entities

The HTML escaping function did not properly encode numeric character references, allowing crafted input with numeric entities to bypass escaping and inject malicious HTML or scripts. This posed a cross-site scripting risk by enabling attackers to insert executable code into rendered pages. The fix extends the escape pattern to recognize and encode numeric decimal and hexadecimal entities, ensuring all special characters are safely escaped.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('fixed', 'ACTION', ''), ('escapehtml', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('bypass', 'secword', ''), ('escaping', 'secword', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escape', 'secword', ''), ('encode', 'secword', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,{'CWE-79'},GHSA-h4mx-xv96-2jgm,"@@ -9,7 +9,7 @@
         {f:translate(
         key: 'forgot_validate_reset_password_html',
         extensionName: 'felogin',
-        arguments: '{ 0: receiverName, 1: recoveryLink, 2: validUntil }'
+        arguments: '{ 0: ""{receiverName -> f:format.htmlspecialchars()}"", 1: recoveryLink, 2: validUntil }'
         ) -> f:format.html()}
     </f:spaceless>
 </f:section>","[SECURITY] Avoid HTML injection in password recovery mail

The `receiverName` variable used in the password recovery mail of the
Extbase felogin plugin was susceptible to HTML injection due to
missing sanitization. The variable is now passed thru the
`f:format.htmlspecialchars` ViewHelper.

Resolves: #96559
Releases: main, 11.5, 10.4
Change-Id: I60e23c161f7f2fcc87b8870345b10a4c31d7b8db
Security-Bulletin: TYPO3-CORE-SA-2022-004
Security-References: CVE-2022-31049
Reviewed-on: https://review.typo3.org/c/Packages/TYPO3.CMS/+/74904
Tested-by: Oliver Hader <oliver.hader@typo3.org>
Reviewed-by: Oliver Hader <oliver.hader@typo3.org>","vuln-fix: Escape user input in password reset email template

The vulnerability was caused by unescaped user input in the password reset email template, allowing injection of malicious HTML or scripts. This poses a security risk by enabling cross-site scripting (XSS) attacks that could compromise user accounts or session data. The fix applies HTML escaping to the receiverName variable to prevent injection of executable code in the email content.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('security', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('password', 'secword', ''), ('password', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('sanitization', 'secword', ''), ('format.htmlspecialchars', 'SECWORD', ''), ('#96559', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('password', 'secword', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('password', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
17,{'CWE-79'},GHSA-wx69-rvg3-x7fc,"@@ -15,11 +15,12 @@ uploads.upload = async function (socket, data) {
 		'user.updateCover': socketUser.updateCover,
 		'groups.cover.update': socketGroup.cover.update,
 	};
-	if (!socket.uid || !data || !data.chunk || !data.params || !data.params.method || !methodToFunc[data.params.method]) {
+	if (!socket.uid || !data || !data.chunk ||
+		!data.params || !data.params.method || !methodToFunc.hasOwnProperty(data.params.method)) {
 		throw new Error('[[error:invalid-data]]');
 	}
 
-	inProgress[socket.id] = inProgress[socket.id] || {};
+	inProgress[socket.id] = inProgress[socket.id] || Object.create(null);
 	const socketUploads = inProgress[socket.id];
 	const { method } = data.params;",fix: guard against prototype pollution,"vuln-fix: Prevent prototype pollution in upload method validation

The vulnerability allowed attackers to bypass method validation by exploiting inherited properties on the methodToFunc object, leading to potential unauthorized function execution. This posed a security risk by enabling attackers to invoke unintended methods through prototype pollution. The fix enforces a safer property check using hasOwnProperty and initializes inProgress with a null-prototype object to prevent prototype chain attacks.

Weakness: Prototype Pollution (CWE-1321)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('exploiting', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('prototype pollution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('initializes', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,{'CWE-79'},GHSA-95hx-62rh-gg96,"@@ -317,7 +317,7 @@ public function getWidgetVariables($hookName = null, array $configuration = [])
             }
         }
         $this->contact['contacts'] = $this->getTemplateVarContact();
-        $this->contact['message'] = html_entity_decode(Tools::getValue('message'));
+        $this->contact['message'] = Tools::getValue('message');
         $this->contact['allow_file_upload'] = (bool) Configuration::get('PS_CUSTOMER_SERVICE_FILE_UPLOAD');
 
         if (!(bool)Configuration::isCatalogMode()) {
@@ -388,9 +388,10 @@ public function getTemplateVarOrders()
     {
         $orders = [];
 
-        if (!isset($this->customer_thread['id_order'])
+        if (empty($this->customer_thread['id_order'])
             && isset($this->context->customer)
-            && $this->context->customer->isLogged()) {
+            && $this->context->customer->isLogged()
+        ) {
             $customer_orders = Order::getCustomerOrders($this->context->customer->id);
 
             foreach ($customer_orders as $customer_order) {
@@ -401,7 +402,7 @@ public function getTemplateVarOrders()
                     $orders[$customer_order['id_order']]['products'] = $myOrder->getProducts();
                 }
             }
-        } elseif (isset($this->customer_thread['id_order']) && (int)$this->customer_thread['id_order'] > 0) {
+        } elseif (isset($this->customer_thread['id_order']) && (int) $this->customer_thread['id_order'] > 0) {
             $myOrder = new Order($this->customer_thread['id_order']);
 
             if (Validate::isLoadedObject($myOrder)) {
@@ -411,13 +412,13 @@ public function getTemplateVarOrders()
             }
         }
 
-        if (isset($this->customer_thread['id_product'])) {
+        if (!empty($this->customer_thread['id_product'])) {
             $id_order = isset($this->customer_thread['id_order']) ?
-                      (int)$this->customer_thread['id_order'] :
+                      (int) $this->customer_thread['id_order'] :
                       0;
 
             $orders[$id_order]['products'][(int)$this->customer_thread['id_product']] = $this->context->controller->objectPresenter->present(
-                new Product((int)$this->customer_thread['id_product'])
+                new Product((int) $this->customer_thread['id_product'])
             );
         }
 
@@ -584,7 +585,7 @@ public function sendMessage()
                 $var_list = [
                     '{order_name}' => '-',
                     '{attached_file}' => '-',
-                    '{message}' => Tools::nl2br(Tools::stripslashes($message)),
+                    '{message}' => Tools::nl2br(Tools::htmlentitiesUTF8(Tools::stripslashes($message))),
                     '{email}' =>  $from,
                     '{product_name}' => '',
                 ];","Merge pull request from GHSA-95hx-62rh-gg96

Do not unescape form message data","vuln-fix: Sanitize contact form message to prevent XSS attacks

The contact form message input was not properly sanitized, allowing raw HTML entities to be decoded and potentially executed in the output context. This posed a security risk by enabling cross-site scripting (XSS) attacks through malicious user input. The fix applies UTF-8 HTML entity encoding to the message content before rendering, ensuring that any HTML tags are safely escaped and not executed.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('ghsa-95hx-62rh', 'VULNID', 'GHSA'), ('unescape', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('sanitized', 'SECWORD', ''), ('decoded', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,{'CWE-79'},GHSA-82j4-vr25-x394,"@@ -304,6 +304,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
 			|| $isDangerStr($filename , "".xxhtml"")
+			|| $isDangerStr($filename , "".aspx"")			
 		) {
 			return true;
 		}","Merge pull request #1629 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Prevent dangerous .aspx files from being accepted as safe filenames

The vulnerability allowed .aspx files to bypass filename danger checks, enabling potentially unsafe file uploads.
This poses a security risk as .aspx files can contain executable server-side code, leading to remote code execution.
The fix adds .aspx to the list of dangerous filename extensions, blocking such files from being accepted.


Weakness: CWE-434: Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('#1629', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('safe', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('danger', 'secword', ''), ('unsafe', 'SECWORD', ''), ('security', 'SECWORD', ''), ('server', 'SECWORD', ''), ('remote code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
20,{'CWE-79'},GHSA-m52x-29pq-w3vv,"@@ -1726,7 +1726,7 @@ function createHotSpot(hs) {
         if (config.basePath && !absoluteURL(imgp))
             imgp = config.basePath + imgp;
         a = document.createElement('a');
-        a.href = sanitizeURL(hs.URL ? hs.URL : imgp);
+        a.href = sanitizeURL(hs.URL ? hs.URL : imgp, true);
         a.target = '_blank';
         span.appendChild(a);
         var image = document.createElement('img');
@@ -1738,7 +1738,7 @@ function createHotSpot(hs) {
         span.style.maxWidth = 'initial';
     } else if (hs.URL) {
         a = document.createElement('a');
-        a.href = sanitizeURL(hs.URL);
+        a.href = sanitizeURL(hs.URL, true);
         if (hs.attributes) {
             for (var key in hs.attributes) {
                 a.setAttribute(key, hs.attributes[key]);
@@ -2012,7 +2012,7 @@ function processOptions(isPreview) {
                 var authorText = escapeHTML(config[key]);
                 if (config.authorURL) {
                     var authorLink = document.createElement('a');
-                    authorLink.href = sanitizeURL(config['authorURL']);
+                    authorLink.href = sanitizeURL(config['authorURL'], true);
                     authorLink.target = '_blank';
                     authorLink.innerHTML = escapeHTML(config[key]);
                     authorText = authorLink.outerHTML;
@@ -2023,7 +2023,7 @@ function processOptions(isPreview) {
             
             case 'fallback':
                 var link = document.createElement('a');
-                link.href = sanitizeURL(config[key]);
+                link.href = sanitizeURL(config[key], true);
                 link.target = '_blank';
                 link.textContent = 'Click here to view this panorama in an alternative viewer.';
                 var message = document.createElement('p');
@@ -2389,10 +2389,17 @@ function escapeHTML(s) {
  * The URL cannot be of protocol 'javascript'.
  * @private
  * @param {string} url - URL to sanitize
+ * @param {boolean} href - True if URL is for link (blocks data URIs)
  * @returns {string} Sanitized URL
  */
-function sanitizeURL(url) {
-    if (url.trim().toLowerCase().indexOf('javascript:') === 0) {
+function sanitizeURL(url, href) {
+    if (url.trim().toLowerCase().indexOf('javascript:') === 0 ||
+        url.trim().toLowerCase().indexOf('vbscript:') === 0) {
+        console.log('Script URL removed.');
+        return 'about:blank';
+    }
+    if (href && url.trim().toLowerCase().indexOf('data:') === 0) {
+        console.log('Data URI removed from link.');
         return 'about:blank';
     }
     return url;","Merge pull request from GHSA-m52x-29pq-w3vv

Fix potential XSS vulnerability","vuln-fix: Prevent unsafe URLs in links to mitigate script injection

The vulnerability allowed unsafe URLs with javascript:, vbscript:, or data: schemes in link href attributes, enabling potential cross-site scripting attacks. This is a security risk because malicious URLs can execute arbitrary scripts in users' browsers, compromising user data and application integrity. The fix enforces stricter URL sanitization by blocking these schemes specifically for link hrefs, replacing them with safe placeholders to prevent script execution.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)
Severity: High
CVSS: 7.5",0.23529411764705882,"[('ghsa-m52x-29pq', 'VULNID', 'GHSA'), ('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('mitigate', 'ACTION', ''), ('injection', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unsafe', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
21,{'CWE-79'},GHSA-xg72-6c83-ghh4,"@@ -563,17 +563,25 @@
                 }
 
             } else if ($ext === 'svg') {
-
+                $valid = false;
                 if (is_file($filePath)) {
                     $sanitizer = new \enshrined\svgSanitize\Sanitizer();
                     // Load the dirty svg
                     $dirtySVG = file_get_contents($filePath);
                      // Pass it to the sanitizer and get it back clean
-                    $cleanSVG = $sanitizer->sanitize($dirtySVG);
-                    file_put_contents($filePath, $cleanSVG);
+                    try {
+                        $cleanSVG = $sanitizer->sanitize($dirtySVG);
+                        $valid = true;
+                    } catch (\Exception $e) {
+                        $valid = false;
+                    }
+
+                    if ($valid) {
+                        file_put_contents($filePath, $cleanSVG);
+                    }
 
                 }
-               $valid = true;
+
 
             } else {
                 $valid = false;",update,"vuln-fix: Prevent unhandled exceptions during SVG sanitization

The vulnerability occurs because exceptions thrown during SVG sanitization were not caught, potentially causing application crashes or bypassing file validation. This is a security risk as it may allow malicious SVG files to be processed without proper sanitization or disrupt normal application flow. The fix adds exception handling around the sanitization process and only writes sanitized content if no errors occur, ensuring robust validation and stability.

Weakness: Improper Exception Handling (CWE-754)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('sanitization', 'secword', ''), ('bypassing', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('sanitization', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('sanitization', 'secword', ''), ('sanitized', 'SECWORD', ''), ('errors', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-754', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,{'CWE-79'},GHSA-hc72-vj3g-5g2g,"@@ -11,13 +11,16 @@
 using ZKEACMS.Common.Models;
 using Easy;
 using Microsoft.EntityFrameworkCore;
+using ZKEACMS.Safety;
 
 namespace ZKEACMS.Common.Service
 {
     public class NavigationService : ServiceBase<NavigationEntity, CMSDbContext>, INavigationService
     {
-        public NavigationService(IApplicationContext applicationContext, CMSDbContext dbContext) : base(applicationContext, dbContext)
+        private readonly IHtmlSanitizer _htmlSanitizer;
+        public NavigationService(IApplicationContext applicationContext, CMSDbContext dbContext, IHtmlSanitizer htmlSanitizer) : base(applicationContext, dbContext)
         {
+            _htmlSanitizer = htmlSanitizer;
         }
         public override DbSet<NavigationEntity> CurrentDbSet => DbContext.Navigation;
         public override ServiceResult<NavigationEntity> Add(NavigationEntity item)
@@ -27,8 +30,34 @@ public override ServiceResult<NavigationEntity> Add(NavigationEntity item)
                 item.ParentId = ""#"";
             }
             item.ID = Guid.NewGuid().ToString(""N"");
+            Santize(item);
             return base.Add(item);
         }
+
+        public override ServiceResult<NavigationEntity> AddRange(params NavigationEntity[] items)
+        {
+            foreach (var item in items)
+            {
+                Santize(item);
+            }
+            return base.AddRange(items);
+        }
+
+        public override ServiceResult<NavigationEntity> Update(NavigationEntity item)
+        {
+            Santize(item);
+            return base.Update(item);
+        }
+
+        public override ServiceResult<NavigationEntity> UpdateRange(params NavigationEntity[] items)
+        {
+            foreach (var item in items)
+            {
+                Santize(item);
+            }
+            return base.UpdateRange(items);
+        }
+
         public override void Remove(NavigationEntity item)
         {
             Remove(m => m.ParentId == item.ID);
@@ -73,5 +102,11 @@ public void Move(string id, string parentId, int position, int oldPosition)
             }
             Update(nav);
         }
+
+        private void Santize(NavigationEntity item)
+        {
+            item.Title = _htmlSanitizer.Sanitize(item.Title);
+            item.Html = _htmlSanitizer.Sanitize(item.Html);
+        }
     }
 }
\ No newline at end of file","Sanitize Html

#457","vuln-fix: Sanitize HTML input in NavigationService to prevent XSS

The vulnerability was that HTML content in navigation entities was not sanitized, allowing malicious scripts to be stored and executed in the application context. This posed a critical security risk by enabling cross-site scripting (XSS) attacks that could compromise user data and application integrity. The fix applies HTML sanitization to all input fields before adding or updating navigation entities, ensuring unsafe content is removed.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)
Severity: Critical
CVSS: 9.8",0.23529411764705882,"[('sanitize', 'secword', ''), ('#457', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('vulnerability', 'secword', ''), ('sanitized', 'SECWORD', ''), ('malicious', 'secword', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('adding', 'ACTION', ''), ('updating', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('removed', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('critical', 'SEVERITY', '')]"
23,{'CWE-79'},GHSA-8xqr-4cpm-wx7g,"@@ -10,7 +10,7 @@ export default class ReactSVG extends React.Component {
   static defaultProps = {
     callback: () => {},
     className: null,
-    evalScripts: 'once',
+    evalScripts: 'never',
     style: {},
     wrapperClassName: null
   }",Changed default evalScripts prop to match documentation.,"vuln-fix: Disable script evaluation in ReactSVG component by default

Allowing script evaluation in SVGs can lead to cross-site scripting attacks if malicious scripts are embedded within SVG content. This poses a significant security risk by enabling attackers to execute arbitrary code in the context of the application. The fix changes the default evalScripts property to 'never', preventing automatic script execution in SVGs unless explicitly enabled.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('changed', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,{'CWE-79'},GHSA-h3gg-7wx2-cq3h,"@@ -21,7 +21,8 @@ export default function addStickyControl() {
       if (firstPost) {
         const excerpt = truncate(firstPost.contentPlain(), 175);
 
-        items.add('excerpt', m.trust(excerpt), -100);
+        // Wrapping in <div> because ItemList entries need to be vnodes
+        items.add('excerpt', <div>{excerpt}</div>, -100);
       }
     }
   });",Fix evaluation of post content by m.trust() (#24),"vuln-fix: Prevent XSS by wrapping excerpt in a safe vnode container

The vulnerability was caused by directly trusting and injecting raw HTML content into the UI without proper containment, allowing potential cross-site scripting attacks. This is a security risk because malicious scripts could execute in users' browsers, compromising user data and session integrity. The fix wraps the excerpt in a React vnode <div> element, ensuring safer rendering and preventing untrusted HTML from executing as script. 

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('m.trust', 'URL', ''), ('#24', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('safe', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('untrusted', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,{'CWE-79'},GHSA-h6wm-mr85-4h9g,"@@ -287,7 +287,7 @@ private function userAuth()
         }
 
         $this->ipWarning();
-        ToolBox::i18nLog()->warning('login-user-not-found', ['%nick%' => $nick]);
+        ToolBox::i18nLog()->warning('login-user-not-found', ['%nick%' => htmlspecialchars($nick)]);
         return false;
     }","Sanitized username when showing user not found message.
------
Saneado nombre de usuario al mostrar el mensaje de usuario no encontrado.","vuln-fix: Sanitize user input in login warning log

The login warning log previously included raw user input without sanitization, allowing potential injection of malicious HTML or scripts. This posed a security risk by enabling cross-site scripting (XSS) attacks through log output rendering. The fix applies HTML escaping to the user nickname before logging, preventing injection of executable code in logs.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: Medium  
CVSS: 5.4",0.11764705882352941,"[('sanitized', 'SECWORD', ''), ('found', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('login', 'secword', ''), ('warning', 'FLAW', ''), ('login', 'secword', ''), ('warning', 'FLAW', ''), ('sanitization', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,{'CWE-79'},GHSA-pxpf-v376-7xx5,"@@ -101,7 +101,7 @@ Tagify.prototype = {
 
         _s.disabled = input.hasAttribute('disabled')
         _s.readonly = _s.readonly || input.hasAttribute('readonly')
-        _s.placeholder = input.getAttribute('placeholder') || _s.placeholder || """"
+        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || """")
         _s.required = input.hasAttribute('required')
 
         for( let name in _s.classNames )",fixes #989 - fix XSS,"vuln-fix: Escape placeholder attribute to prevent XSS

The placeholder attribute was assigned directly from user input without sanitization, allowing injection of malicious HTML or scripts.  
This poses a security risk as attackers could execute arbitrary JavaScript in the context of the application, leading to cross-site scripting attacks.  
The fix applies HTML escaping to the placeholder value before assignment, ensuring any injected code is rendered harmless.  

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fixes', 'ACTION', ''), ('#989', 'ISSUE', ''), ('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitization', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,{'CWE-79'},GHSA-6hjc-m38h-7jhh,"@@ -96,7 +96,7 @@ public function actionSeoFileLink($url, $robots = '', $canonical = '', $inline =
             if (($ext = pathinfo($fileName, PATHINFO_EXTENSION)) !== '') {
                 $ext = strtolower($ext);
             }
-            if ($ext === '' || !in_array($ext, $allowedExtensions, true)) {
+            if ($ext === '' || $ext === 'svg' || !in_array($ext, $allowedExtensions, true)) {
                 throw new ServerErrorHttpException(Craft::t('seomatic', 'File format not allowed.'));
             }
             // Send the file as a stream, so it can exist anywhere",Disallow SVGs,"vuln-fix: Prevent SVG file extension in SEO file link handler

The vulnerability allowed SVG files to bypass the allowed extensions check, enabling potentially unsafe file types to be processed and served by the application. This poses a security risk because SVG files can contain malicious scripts or code that lead to cross-site scripting (XSS) or other client-side attacks. The fix explicitly blocks the 'svg' extension by adding it to the disallowed condition, preventing SVG files from being accepted or served. 

Weakness: CWE-434: Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('bypass', 'secword', ''), ('unsafe', 'secword', ''), ('security', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adding', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
28,{'CWE-79'},GHSA-9g3v-j3cr-6fc6,"@@ -75,6 +75,10 @@ classes: 'table table-responsive table-no-bordered',
                 export: 'fa-download',
                 clearSearch: 'fa-times'
             },
+            exportOptions: {
+                htmlContent: true,
+            },
+
             exportTypes: ['csv', 'excel', 'doc', 'txt','json', 'xml', 'pdf'],
             onLoadSuccess: function () {
                 $('[data-toggle=""tooltip""]').tooltip(); // Needed to attach tooltips after ajax call","Fixes possible XSS on all-file-types export

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent HTML content export to mitigate XSS risk

The export feature allowed HTML content to be included in exported files, which could embed malicious scripts. This posed a security risk by enabling cross-site scripting attacks when users opened exported documents. The fix disables exporting raw HTML content by removing the htmlContent option, ensuring only safe data formats are exported.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('fixes', 'ACTION', ''), ('xss', 'secword', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('xss', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,{'CWE-79'},GHSA-6qcc-whgp-pjj2,"@@ -79,8 +79,8 @@ pimcore.document.pages.settings = Class.create(pimcore.document.settings_abstrac
             var updateSerpPreview = function () {
 
                 var metaPanel = this.layout.getComponent(""metaDataPanel"");
-                var title = metaPanel.getComponent(""title"").getValue();
-                var description = metaPanel.getComponent(""description"").getValue();
+                var title = htmlspecialchars(metaPanel.getComponent(""title"").getValue());
+                var description = htmlspecialchars(metaPanel.getComponent(""description"").getValue());
 
                 var truncate = function( text, n ){
                     if (text.length <= n) { return text; }",escaping fields in SERP preview,"vuln-fix: Sanitize metadata inputs to prevent XSS in page settings

User-provided metadata fields like title and description were not properly escaped before rendering, allowing injection of malicious HTML or scripts. This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or site integrity. The fix applies htmlspecialchars encoding to these inputs, ensuring special characters are safely escaped before use in the UI.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('escaping', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaped', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,{'CWE-79'},GHSA-4fc4-4p5g-6w89,"@@ -50,17 +50,18 @@
 		htmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );
 
 		editor.on( 'toHtml', function( evt ) {
-			var evtData = evt.data,
+			var randomNumber = generateRandomNumber(),
+				evtData = evt.data,
 				data = evtData.dataValue,
 				fixBodyTag;
 
 			// Before we start protecting markup, make sure there are no externally injected
 			// protection keywords.
-			data = removeReservedKeywords( data );
+			data = removeReservedKeywords( data, randomNumber );
 
 			// The source data is already HTML, but we need to clean
 			// it up and apply the filter.
-			data = protectSource( data, editor );
+			data = protectSource( data, editor, randomNumber );
 
 			// Protect content of textareas. (https://dev.ckeditor.com/ticket/9995)
 			// Do this before protecting attributes to avoid breaking:
@@ -70,7 +71,7 @@
 			// Before anything, we must protect the URL attributes as the
 			// browser may changing them when setting the innerHTML later in
 			// the code.
-			data = protectAttributes( data );
+			data = protectAttributes( data, randomNumber );
 
 			// Protect elements than can't be set inside a DIV. E.g. IE removes
 			// style tags from innerHTML. (https://dev.ckeditor.com/ticket/3710)
@@ -90,7 +91,7 @@
 
 			// There are attributes which may execute JavaScript code inside fixBin.
 			// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (https://dev.ckeditor.com/ticket/10)
-			data = protectInsecureAttributes( data );
+			data = protectInsecureAttributes( data, randomNumber );
 
 			var fixBin = evtData.context || editor.editable().getName(),
 				isPre;
@@ -110,7 +111,7 @@
 			data = el.getHtml().substr( 1 );
 
 			// Restore shortly protected attribute names.
-			data = data.replace( new RegExp( 'data-cke-' + CKEDITOR.rnd + '-', 'ig' ), '' );
+			data = data.replace( new RegExp( 'data-cke-' + randomNumber + '-', 'ig' ), '' );
 
 			isPre && ( data = data.replace( /^<pre>|<\/pre>$/gi, '' ) );
 
@@ -838,13 +839,13 @@
 
 	var protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\/?>(?!\s*<\/cke:\1)/gi;
 
-	function protectAttributes( html ) {
+	function protectAttributes( html, randomNumber ) {
 		return html.replace( protectElementRegex, function( element, tag, attributes ) {
 			return '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {
 				// Avoid corrupting the inline event attributes (https://dev.ckeditor.com/ticket/7243).
 				// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (https://dev.ckeditor.com/ticket/5218)
 				if ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )
-					return ' data-cke-saved-' + fullAttr + ' data-cke-' + CKEDITOR.rnd + '-' + fullAttr;
+					return ' data-cke-saved-' + fullAttr + ' data-cke-' + randomNumber + '-' + fullAttr;
 
 				return fullAttr;
 			} ) + '>';
@@ -897,8 +898,8 @@
 	// * opening tags - e.g. `<onfoo`,
 	// * closing tags - e.g. </onfoo> (tested in ""false positive 1""),
 	// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.
-	function protectInsecureAttributes( html ) {
-		return html.replace( /([^a-z0-9<\-])(on\w{3,})(?!>)/gi, '$1data-cke-' + CKEDITOR.rnd + '-$2' );
+	function protectInsecureAttributes( html, randomNumber ) {
+		return html.replace( /([^a-z0-9<\-])(on\w{3,})(?!>)/gi, '$1data-cke-' + randomNumber + '-$2' );
 	}
 
 	function unprotectRealComments( html ) {
@@ -917,11 +918,11 @@
 		} );
 	}
 
-	function protectSource( data, editor ) {
+	function protectSource( data, editor, randomNumber ) {
 		var protectedHtml = [],
 			protectRegexes = editor.config.protectedSource,
 			store = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),
-			tempRegex = /<\!--\{cke_temp(comment)?\}(\d*?)-->/g;
+			tempRegex = new RegExp('<\\!--\\{cke_temp_' + randomNumber + '(comment)?\\}(\\d*?)-->', 'g' );
 
 		var regexes = [
 			// Script tags will also be forced to be protected, otherwise
@@ -940,7 +941,7 @@
 		// Note that we use a different tag for comments, as we need to
 		// transform them when applying filters.
 		data = data.replace( ( /<!--[\s\S]*?-->/g ), function( match ) {
-			return '<!--{cke_tempcomment}' + ( protectedHtml.push( match ) - 1 ) + '-->';
+			return '<!--{cke_temp_' + randomNumber + 'comment}' + ( protectedHtml.push( match ) - 1 ) + '-->';
 		} );
 
 		for ( var i = 0; i < regexes.length; i++ ) {
@@ -951,7 +952,8 @@
 				} );
 
 				// Avoid protecting over protected, e.g. /\{.*?\}/
-				return ( /cke_temp(comment)?/ ).test( match ) ? match : '<!--{cke_temp}' + ( protectedHtml.push( match ) - 1 ) + '-->';
+				return ( tempRegex ).test( match ) ? match : '<!--{cke_temp_' + randomNumber + '}' +
+					( protectedHtml.push( match ) - 1 ) + '-->';
 			} );
 		}
 		data = data.replace( tempRegex, function( $, isComment, id ) {
@@ -1107,6 +1109,16 @@
 			};
 		}
 	} )();
+
+	function generateRandomNumber() {
+		var cryptoApi = window.crypto || window.msCrypto;
+
+		if ( cryptoApi ) {
+			return cryptoApi.getRandomValues( new Uint32Array( 1 ) )[ 0 ];
+		}
+
+		return Math.floor( Math.random() *  9000000000 + 1000000000 );
+	}
 } )();
 
 /**",Code refactoring.,"vuln-fix: Use per-instance random tokens to protect HTML attributes

The vulnerability was that static or global tokens were used to protect HTML attributes, allowing attackers to predict and bypass protection mechanisms in the editor's output.
This posed a security risk by enabling injection or manipulation of protected attributes, potentially leading to cross-site scripting or data corruption.
The fix generates a unique random number per event to namespace protection tokens, preventing attackers from guessing or reusing them across requests.

Weakness: CWE-330: Use of Insufficiently Random Values  
Severity: High  
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('protect', 'secword', ''), ('vulnerability', 'secword', ''), ('protect', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('protection', 'SECWORD', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('protected', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('fix', 'ACTION', ''), ('protection', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-330', 'CWEID', ''), ('high', 'SEVERITY', '')]"
31,{'CWE-79'},GHSA-fp76-f299-v3hj,"@@ -127,8 +127,7 @@ public function getFile(): bool
         $allowedFolders = ['node_modules', 'vendor', 'Dinamic', 'Core', 'Plugins', 'MyFiles/Public'];
         foreach ($allowedFolders as $folder) {
             if ('/' . $folder === substr($uri, 0, 1 + strlen($folder))) {
-                header('Content-Type: ' . $this->getMime($filePath));
-                readfile($filePath);
+                $this->download($filePath);
                 return true;
             }
         }
@@ -137,14 +136,7 @@ public function getFile(): bool
         $token = filter_input(INPUT_GET, 'myft');
         $fixedFilePath = substr(urldecode($uri), 1);
         if ('/MyFiles/' === substr($uri, 0, 9) && $token && MyFilesToken::validate($fixedFilePath, $token)) {
-            header('Content-Type: ' . $this->getMime($filePath));
-
-            // disable the buffer if enabled
-            if (ob_get_contents()) {
-                ob_end_flush();
-            }
-
-            readfile($filePath);
+            $this->download($filePath);
             return true;
         }
 
@@ -205,6 +197,23 @@ private function deploy()
         }
     }
 
+    private function download(string $filePath)
+    {
+        header('Content-Type: ' . $this->getMime($filePath));
+
+        // disable the buffer if enabled
+        if (ob_get_contents()) {
+            ob_end_flush();
+        }
+
+        // force to download svg files to prevent XSS attacks
+        if (strpos($filePath, '.svg') !== false) {
+            header('Content-Disposition: attachment; filename=""' . basename($filePath) . '""');
+        }
+
+        readfile($filePath);
+    }
+
     /**
      * Return the mime type from given file.
      *","Force to download SVG files to prevent security problems.
------
Forzamos a descargar los archivos SVG para evitar problemas de seguridad.","vuln-fix: Prevent XSS by forcing SVG file download

The vulnerability allowed SVG files to be served inline, enabling potential cross-site scripting (XSS) attacks when malicious SVG content was executed in the browser context. Serving SVG files inline is a security risk because it can lead to script execution and compromise user data or session integrity. The fix centralizes file delivery and forces SVG files to be downloaded as attachments, preventing inline rendering and mitigating XSS risks.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('prevent', 'ACTION', ''), ('security', 'secword', ''), ('problems', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('xss', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
32,{'CWE-79'},GHSA-mxvc-fwgx-j778,"@@ -16,7 +16,7 @@
 <div>
     <h1>Error</h1>
     <p>
-        {{ error_message|safe }}
+        {{ error_message }}
     </p>
     <hr>
     <p>","Render error message w/o `safe` filter

The error message shown in the error template does not need to be
rendered using the safe filter, and furthermore opens up an XSS
vulnerability.","vuln-fix: Prevent XSS by removing unsafe error message rendering

The error message was rendered using a template filter that allowed raw HTML, enabling injection of malicious scripts into the page.
This posed a cross-site scripting risk, potentially compromising user sessions and data confidentiality.
The fix removes the unsafe filter, ensuring error messages are properly escaped before rendering in the template.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('error', 'FLAW', ''), ('safe', 'secword', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('safe', 'secword', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('removing', 'ACTION', ''), ('unsafe', 'secword', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('unsafe', 'secword', ''), ('ensuring', 'ACTION', ''), ('error', 'FLAW', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
33,{'CWE-79'},GHSA-c65v-p733-9796,"@@ -93,15 +93,15 @@ public function transformAsset(Asset $asset)
                     $value = (Gate::allows('superadmin')) ? $decrypted : strtoupper(trans('admin/custom_fields/general.encrypted'));
 
                     $fields_array[$field->name] = [
-                            'field' => $field->convertUnicodeDbSlug(),
-                            'value' => $value,
+                            'field' => e($field->convertUnicodeDbSlug()),
+                            'value' => e($value),
                             'field_format' => $field->format,
                         ];
 
                 } else {
                     $fields_array[$field->name] = [
-                        'field' => $field->convertUnicodeDbSlug(),
-                        'value' => $asset->{$field->convertUnicodeDbSlug()},
+                        'field' => e($field->convertUnicodeDbSlug()),
+                        'value' => e($asset->{$field->convertUnicodeDbSlug()}),
                         'field_format' => $field->format,
                     ];
 
@@ -134,7 +134,7 @@ public function transformAsset(Asset $asset)
                         
                             'id' => $component->id,
                             'pivot_id' => $component->pivot->id,
-                            'name' => $component->name,
+                            'name' => e($component->name),
                             'qty' => $component->pivot->assigned_qty,
                             'price_cost' => $component->purchase_cost,
                             'purchase_total' => $component->purchase_cost * $component->pivot->assigned_qty,","Merge pull request #10315 from snipe/fixes/escape_custom_fields_in_api_response

Escape custom field values in API response","vuln-fix: Escape output to prevent cross-site scripting vulnerabilities

The code was outputting unescaped user-controlled or database-derived strings directly into views, allowing injection of malicious scripts.
This posed a security risk by enabling attackers to execute arbitrary JavaScript in users’ browsers, potentially stealing sensitive data or hijacking sessions.
The fix applies proper HTML escaping to all dynamic fields before rendering, mitigating cross-site scripting attacks by neutralizing harmful input. 

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('#10315', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('escape_custom_fields_in_api_response', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
34,{'CWE-79'},GHSA-m8rp-q82r-c5mf,"@@ -91,7 +91,6 @@
             <hr class=""thin"" />
             <div class=""row"">
 
-
                 <?php
                 $iformVr=0;
                 foreach ($form_values_formated as $form_values_row) {
@@ -106,12 +105,12 @@
                             <?php if (!is_array($val1)){ ?>
                                 <div>
                                     <small class=""text-muted""><?php echo str_replace('_', ' ', $key); ?>:</small>
-                                    <p><?php print $val1; ?></p>
+                                    <p><?php print htmlentities($val1); ?></p>
                                 </div>
                             <?php } else { ?>
                                 <small class=""text-muted""><?php echo str_replace('_', ' ', $key); ?>:</small>
                                 <?php foreach ($val1 as $val1_1){ ?>
-                                    <p><?php print $val1_1 . '<br />'; ?></p>
+                                    <p><?php print htmlentities($val1_1) . '<br />'; ?></p>
                                 <?php }?>
                             <?php } ?>
                         <?php } ?>",xss on contact form fix,"vuln-fix: Prevent XSS by encoding output in form display

User-submitted form values were output directly into HTML without encoding, allowing injection of malicious scripts into the page content. This posed a critical risk of cross-site scripting attacks, enabling attackers to execute arbitrary JavaScript in users' browsers. The fix applies htmlentities() to all displayed form values, ensuring special characters are safely encoded and scripts cannot be injected.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: Critical  
CVSS: 8.8",0.11764705882352941,"[('xss', 'secword', ''), ('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('critical', 'SEVERITY', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
35,{'CWE-79'},GHSA-3j58-p785-f27x,"@@ -17,9 +17,6 @@
 class ApiController  extends FrontendController
 {
 
-
-
-
     public function api_html()
     {
         if (!defined('MW_API_HTML_OUTPUT')) {
@@ -609,12 +606,14 @@ public function module()
 
         $request_data = array_merge($_GET, $_POST);
 
-
         // sanitize attributes
         if($request_data){
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
+
+                $v = $antixss->xss_clean($v);
+
                 if(is_string($k)){
                     $k = $antixss->xss_clean($k);
                     if($k){
@@ -623,6 +622,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
+                
             }
             $request_data = $request_data_new;
         }",fix xss on module api call in value parameters,"vuln-fix: Sanitize all request data keys and values to prevent XSS

The vulnerability was that user input keys and values were not consistently sanitized, allowing malicious scripts to be injected via request parameters.
This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or execute arbitrary code in the browser.
The fix applies XSS cleaning to both keys and values of all request data before further processing, ensuring no unsanitized input is used. 

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('keys', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('unsanitized', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
36,{'CWE-79'},GHSA-7c82-mp33-r854,"@@ -1,6 +1,128 @@
 (function ($) {
   'use strict';
 
+  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
+
+  var uriAttrs = [
+    'background',
+    'cite',
+    'href',
+    'itemtype',
+    'longdesc',
+    'poster',
+    'src',
+    'xlink:href'
+  ];
+
+  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
+
+  var DefaultWhitelist = {
+    // Global attributes allowed on any supplied element below.
+    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],
+    a: ['target', 'href', 'title', 'rel'],
+    area: [],
+    b: [],
+    br: [],
+    col: [],
+    code: [],
+    div: [],
+    em: [],
+    hr: [],
+    h1: [],
+    h2: [],
+    h3: [],
+    h4: [],
+    h5: [],
+    h6: [],
+    i: [],
+    img: ['src', 'alt', 'title', 'width', 'height'],
+    li: [],
+    ol: [],
+    p: [],
+    pre: [],
+    s: [],
+    small: [],
+    span: [],
+    sub: [],
+    sup: [],
+    strong: [],
+    u: [],
+    ul: []
+  }
+
+  /**
+   * A pattern that recognizes a commonly useful subset of URLs that are safe.
+   *
+   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
+   */
+  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
+
+  /**
+   * A pattern that matches safe data URLs. Only matches image, video and audio types.
+   *
+   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
+   */
+  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;
+
+  function allowedAttribute (attr, allowedAttributeList) {
+    var attrName = attr.nodeName.toLowerCase()
+
+    if ($.inArray(attrName, allowedAttributeList) !== -1) {
+      if ($.inArray(attrName, uriAttrs) !== -1) {
+        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN))
+      }
+
+      return true
+    }
+
+    var regExp = $(allowedAttributeList).filter(function (index, value) {
+      return value instanceof RegExp
+    })
+
+    // Check if a regular expression validates the attribute.
+    for (var i = 0, l = regExp.length; i < l; i++) {
+      if (attrName.match(regExp[i])) {
+        return true
+      }
+    }
+
+    return false
+  }
+
+  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {
+    if (sanitizeFn && typeof sanitizeFn === 'function') {
+      return sanitizeFn(unsafeElements);
+    }
+
+    var whitelistKeys = Object.keys(whiteList);
+
+    for (var i = 0, len = unsafeElements.length; i < len; i++) {
+      var elements = unsafeElements[i].querySelectorAll('*');
+
+      for (var j = 0, len2 = elements.length; j < len2; j++) {
+        var el = elements[j];
+        var elName = el.nodeName.toLowerCase();
+
+        if (whitelistKeys.indexOf(elName) === -1) {
+          el.parentNode.removeChild(el);
+
+          continue;
+        }
+
+        var attributeList = [].slice.call(el.attributes);
+        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
+
+        for (var k = 0, len3 = attributeList.length; k < len3; k++) {
+          var attr = attributeList[k];
+
+          if (!allowedAttribute(attr, whitelistedAttributes)) {
+            el.removeAttribute(attr.nodeName);
+          }
+        }
+      }
+    }
+  }
+
   // Polyfill for browsers with no classList support
   // Remove in v2
   if (!('classList' in document.createElement('_'))) {
@@ -745,7 +867,10 @@
     dropdownAlignRight: false,
     windowPadding: 0,
     virtualScroll: 600,
-    display: false
+    display: false,
+    sanitize: true,
+    sanitizeFn: null,
+    whiteList: DefaultWhitelist
   };
 
   if (version.major === '4') {
@@ -1100,13 +1225,35 @@
                 emptyMenu = menuInner.firstChild.cloneNode(false),
                 marginTop,
                 marginBottom,
-                elements = isVirtual === true ? that.selectpicker.view.visibleElements : that.selectpicker.current.elements;
+                elements = isVirtual === true ? that.selectpicker.view.visibleElements : that.selectpicker.current.elements,
+                toSanitize = [];
 
             // replace the existing UL with an empty one - this is faster than $.empty()
             menuInner.replaceChild(emptyMenu, menuInner.firstChild);
 
             for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {
-              menuFragment.appendChild(elements[i]);
+              var element = elements[i],
+                  elText,
+                  elementData;
+
+              if (that.options.sanitize) {
+                elText = element.lastChild;
+
+                if (elText) {
+                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0].data;
+
+                  if (elementData && elementData.content && !elementData.sanitized) {
+                    toSanitize.push(elText);
+                    elementData.sanitized = true;
+                  }
+                }
+              }
+
+              menuFragment.appendChild(element);
+            }
+
+            if (that.options.sanitize && toSanitize.length) {
+              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);
             }
 
             if (isVirtual === true) {
@@ -1469,7 +1616,8 @@
           multipleSeparator = document.createTextNode(this.options.multipleSeparator),
           titleFragment = elementTemplates.fragment.cloneNode(false),
           showCount,
-          countMax;
+          countMax,
+          hasContent = false;
 
       this.togglePlaceholder();
 
@@ -1506,6 +1654,7 @@
                 titleOptions.text = option.title;
               } else if (thisData.content && that.options.showContent) {
                 titleOptions.optionContent = thisData.content.toString();
+                hasContent = true;
               } else {
                 if (that.options.showIcon) {
                   titleOptions.optionIcon = thisData.icon;
@@ -1554,6 +1703,10 @@
       // strip all HTML tags and trim the result, then unescape any escaped tags
       this.$button[0].title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();
 
+      if (this.options.sanitize && hasContent) {
+        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);
+      }
+
       buttonInner.innerHTML = '';
       buttonInner.appendChild(titleFragment);
 
@@ -2833,8 +2986,16 @@
             options = typeof _option == 'object' && _option;
 
         if (!data) {
-          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
-          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), $this.data().template, options.template);
+          var dataAttributes = $this.data();
+
+          for (var dataAttr in dataAttributes) {
+            if (dataAttributes.hasOwnProperty(dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
+              delete dataAttributes[dataAttr];
+            }
+          }
+
+          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);
+          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);
           $this.data('selectpicker', (data = new Selectpicker(this, config)));
         } else if (options) {
           for (var i in options) {",add sanitize option for data-content (#2199),"vuln-fix: Sanitize HTML content to prevent XSS attacks

Unsanitized HTML content was rendered in dropdown menus and button titles, allowing injection of malicious scripts via unsafe attributes or elements. This posed a critical security risk by enabling cross-site scripting attacks that could compromise user data and application integrity. The fix implements a whitelist-based HTML sanitizer that removes disallowed elements and attributes, validates URLs, and optionally allows custom sanitization functions to ensure only safe content is rendered.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: Critical  
CVSS: 9.8",0.11764705882352941,"[('add', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('#2199', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('unsanitized', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('unsafe', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('removes', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
37,{'CWE-79'},GHSA-x7r7-wmj8-vv5g,"@@ -8,6 +8,7 @@
 import os
 import re
 from collections import defaultdict
+from urllib.parse import urlparse
 
 from flask import (
     Response,
@@ -170,7 +171,16 @@ def _add_additional_assets(hook):
 def login():
     from flask_login import current_user
 
-    redirect_url = request.args.get(""redirect"", request.script_root + url_for(""index""))
+    default_redirect_url = request.script_root + url_for(""index"")
+    redirect_url = request.args.get(""redirect"", default_redirect_url)
+
+    parsed = urlparse(redirect_url)  # check if redirect url is valid
+    if parsed.scheme != """" or parsed.netloc != """":
+        _logger.warning(
+            f""Got an invalid redirect URL with the login attempt, misconfiguration or attack attempt: {redirect_url}""
+        )
+        redirect_url = default_redirect_url
+
     permissions = sorted(
         filter(
             lambda x: x is not None and isinstance(x, OctoPrintPermission),","🔒️ Sanitize and validate login redirect

Fixes an XSS and an open redirect issue.","vuln-fix: Prevent open redirect vulnerability in login redirect

The login endpoint accepted arbitrary redirect URLs without validation, allowing attackers to redirect users to malicious external sites.  
This posed a security risk by enabling phishing attacks and potential credential theft through crafted login redirects.  
The fix validates the redirect URL to ensure it is relative and internal, rejecting and logging any external or absolute URLs.  

Weakness: CWE-601 Open Redirect  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('sanitize', 'secword', ''), ('validate', 'secword', ''), ('login', 'secword', ''), ('fixes', 'ACTION', ''), ('xss', 'SECWORD', ''), ('open redirect', 'SECWORD', ''), ('issue', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('open redirect', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('login', 'secword', ''), ('login', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('phishing', 'secword', ''), ('attacks', 'SECWORD', ''), ('credential', 'secword', ''), ('theft', 'secword', ''), ('login', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-601', 'CWEID', ''), ('open redirect', 'secword', ''), ('high', 'SEVERITY', '')]"
38,{'CWE-79'},GHSA-2cqg-q7jm-j35c,"@@ -910,7 +910,7 @@ public function audit(Request $request) {
             }
         }
 
-        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.$request->input('asset_tag').' not found'));
+        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.e($request->input('asset_tag')).' not found'));","Merge pull request #10286 from uberbrady/fix_bulk_audit_xss

Escape asset_tag attribute at controller level for bulk checkout","vuln-fix: Escape user input in error message to prevent XSS

The vulnerability was that user-supplied input was directly embedded in the error message without proper escaping, allowing injection of malicious scripts.
This posed a security risk by enabling cross-site scripting (XSS) attacks when the error message was rendered in clients' browsers.
The fix applies proper escaping to the user input before including it in the error message, mitigating the XSS vulnerability.

Weakness: Cross-Site Scripting (CWE-79)
Severity: Medium
CVSS: 6.1",0.17647058823529413,"[('#10286', 'ISSUE', ''), ('fix_bulk_audit_xss', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('error', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('error', 'FLAW', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,{'CWE-79'},GHSA-mg5h-9rhq-4cqx,"@@ -300,6 +300,7 @@ public function isDangerFilename($filename){
 			 $isDangerStr($filename , "".php"")
 			|| $isDangerStr($filename , "".svg"")
 			|| $isDangerStr($filename , "".htm"")
+			|| $isDangerStr($filename , "".shtm"")
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
 		) {",file upload bug,"vuln-fix: Prevent dangerous file uploads with .shtm extension

The vulnerability allowed files with the .shtm extension to bypass dangerous filename checks, potentially enabling execution of malicious scripts on the server.
This poses a security risk as attackers could upload and execute harmful code, leading to unauthorized access or data compromise.
The fix adds .shtm to the list of blocked dangerous file extensions, improving filename validation and preventing unsafe file uploads.

Weakness: CWE-434: Unrestricted Upload of File with Dangerous Type
Severity: High
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('malicious', 'secword', ''), ('server', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('improving', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
40,"{'CWE-89', 'CWE-79'}",GHSA-x92h-wmg2-6hp7,"@@ -1346,22 +1346,37 @@ public function setMethod($method)
      */
     public function getMethod()
     {
-        if (null === $this->method) {
-            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
-
-            if ('POST' === $this->method) {
-                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {
-                    $this->method = strtoupper($method);
-                } elseif (self::$httpMethodParameterOverride) {
-                    $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
-                    if (\is_string($method)) {
-                        $this->method = strtoupper($method);
-                    }
-                }
-            }
+        if (null !== $this->method) {
+            return $this->method;
+        }
+
+        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
+
+        if ('POST' !== $this->method) {
+            return $this->method;
+        }
+
+        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');
+
+        if (!$method && self::$httpMethodParameterOverride) {
+            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
+        }
+
+        if (!\is_string($method)) {
+            return $this->method;
+        }
+
+        $method = strtoupper($method);
+
+        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
+            return $this->method = $method;
+        }
+
+        if (!preg_match('/^[A-Z]++$/D', $method)) {
+            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
         }
 
-        return $this->method;
+        return $this->method = $method;
     }
 
     /**",[HttpFoundation] reject invalid method override,"vuln-fix: Validate HTTP method override to prevent injection

The vulnerability allowed arbitrary HTTP methods to be set via method override headers or parameters without strict validation. This posed a security risk by enabling attackers to use unexpected or malicious HTTP methods, potentially bypassing security controls or triggering unsafe behaviors. The fix enforces strict validation against a whitelist of allowed methods and rejects invalid or suspicious method overrides with an exception.

Weakness: CWE-20: Improper Input Validation  
Severity: High  
CVSS: 7.5",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('bypassing', 'SECWORD', ''), ('security', 'secword', ''), ('unsafe', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-20', 'CWEID', ''), ('improper input validation', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
41,{'CWE-79'},GHSA-54qq-9chj-rxhv,"@@ -12,7 +12,7 @@
 
 ?>
 <li class=""nav-item dropleft"">
-    <a href=""#"" class=""nav-link dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false""><?php echo htmlspecialchars($UserData->name),' ',htmlspecialchars($UserData->surname)?></a>
+    <a href=""#"" class=""nav-link dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"" ng-non-bindable><?php echo htmlspecialchars($UserData->name),' ',htmlspecialchars($UserData->surname)?></a>
     <div class=""dropdown-menu"" style=""min-width: 25rem;"" role=""menu"">
 
         <div class=""row"">",Escape in user box,"vuln-fix: Prevent AngularJS expression injection in user dropdown

User names were rendered inside an AngularJS context without disabling expression evaluation, allowing attackers to inject malicious AngularJS expressions.
This posed a risk of client-side code execution and data exposure through crafted user names containing AngularJS syntax.
The fix adds the ng-non-bindable attribute to the dropdown toggle element to disable AngularJS expression parsing in the user name display.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: Medium
CVSS: 6.1",0.11764705882352941,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('code execution', 'SECWORD', ''), ('data exposure', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('user name', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'secword', ''), ('medium', 'SEVERITY', '')]"
42,{'CWE-79'},GHSA-mrvj-7q4f-5p42,"@@ -89,6 +89,16 @@ parameters:
         - pht
         - phtml
         - pgif
+        - hta
+        - htm
+        - html
+        - xhtm
+        - xhtml
+        - jar
+        - js
+        - jse
+        - svg
+        - swf
 
     # Content settings
     ezsettings.default.content.view_cache: true         # Whether to use content view cache or not (Etag/Last-Modified based)","Merge pull request from GHSA-mrvj-7q4f-5p42

Co-authored-by: Gunnstein Lye <gunnstein.lye@ibexa.co>","vuln-fix: Restrict risky file extensions in upload parameters

The application allowed uploading files with potentially dangerous extensions like hta, html, js, and swf, which can lead to client-side code execution or malware delivery. This poses a security risk by enabling attackers to upload and execute malicious scripts or active content on the server or client browsers. The fix adds these risky extensions to the restricted list, preventing their upload and mitigating the risk of code injection and cross-site scripting attacks.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('ghsa', 'VULNID', 'GHSA'), ('gunnstein.lye@ibexa.co', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('malware', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('code injection', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
43,{'CWE-79'},GHSA-jq4v-f5q6-mjqq,"@@ -23,6 +23,8 @@
     'usemap',
     # Not standard:
     'dynsrc', 'lowsrc',
+    # HTML5 formaction
+    'formaction'
     ])
 
 # Not in the HTML 4 spec:",Add formaction attribute to defs.link_attrs,"vuln-fix: Add 'formaction' to allowed HTML attributes whitelist

The 'formaction' attribute was missing from the allowed HTML attributes whitelist, enabling potential injection of malicious URLs in form submissions. This omission could allow attackers to redirect form actions to untrusted endpoints, leading to phishing or data exfiltration risks. The fix includes 'formaction' in the whitelist to ensure proper sanitization and prevent unsafe attribute usage.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('add', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('attackers', 'SECWORD', ''), ('untrusted', 'secword', ''), ('phishing', 'secword', ''), ('data exfiltration', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
44,{'CWE-79'},GHSA-8x44-pwr2-rgc6,"@@ -119,7 +119,7 @@ public function getTreeAction(Request $request)
                 'id' => $class->getId(),
                 'text' => $text,
                 'leaf' => true,
-                'icon' => $class->getIcon() ? $class->getIcon() : $defaultIcon,
+                'icon' => $class->getIcon() ? htmlspecialchars($class->getIcon()) : $defaultIcon,
                 'cls' => 'pimcore_class_icon',
                 'propertyVisibility' => $class->getPropertyVisibility(),
                 'enableGridLocking' => $class->isEnableGridLocking(),",added escape function to the icon field,"vuln-fix: Sanitize icon field to prevent XSS in class tree

The icon field was output without escaping, allowing injection of malicious HTML or JavaScript in the class tree UI.
This posed a cross-site scripting risk, enabling attackers to execute arbitrary scripts in users’ browsers.
The fix applies htmlspecialchars to the icon value, ensuring special characters are safely encoded before rendering.

Weakness: Cross-Site Scripting (CWE-79)
Severity: Medium
CVSS: 6.1",0.11764705882352941,"[('added', 'ACTION', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
45,{'CWE-79'},GHSA-3j9m-hcv9-rpj8,"@@ -1,6 +1,6 @@
 import React from 'react';
 import { css } from '@emotion/css';
-import { GrafanaTheme2 } from '@grafana/data';
+import { GrafanaTheme2, textUtil } from '@grafana/data';
 import { Icon, IconName, Link, useTheme2 } from '@grafana/ui';
 
 export interface Props {
@@ -29,13 +29,15 @@ const DropdownChild = ({ isDivider = false, icon, onClick, target, text, url }:
     </button>
   );
   if (url) {
+    const sanitizedUrl = textUtil.sanitizeAngularInterpolation(url);
+
     element =
       !target && url.startsWith('/') ? (
-        <Link className={styles.element} onClick={onClick} href={url}>
+        <Link className={styles.element} onClick={onClick} href={sanitizedUrl}>
           {linkContent}
         </Link>
       ) : (
-        <a className={styles.element} href={url} target={target} rel=""noopener"" onClick={onClick}>
+        <a className={styles.element} href={sanitizedUrl} target={target} rel=""noopener"" onClick={onClick}>
           {linkContent}
         </a>
       );","Merge pull request #147 from grafana/axelav/sanitized-nav-links-8-2-3

Sanitized NavBar children links to remove angular interpolation v8.2.3","vuln-fix: Sanitize URLs to prevent Angular interpolation injection

The vulnerability allowed untrusted URLs to be used directly in link elements without sanitization, enabling potential Angular expression injection attacks. This posed a security risk by allowing attackers to execute arbitrary code or manipulate the DOM through crafted URLs. The fix applies Angular interpolation sanitization to all URLs before rendering, preventing malicious expressions from being processed.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.5",0.17647058823529413,"[('#147', 'ISSUE', ''), ('sanitized', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('remove', 'ACTION', ''), ('v8.2.3', 'VERSION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('untrusted', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('preventing', 'ACTION', ''), ('malicious', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'secword', ''), ('high', 'SEVERITY', '')]"
46,{'CWE-79'},GHSA-wg4r-q74r-p7c8,"@@ -305,6 +305,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".xml"")
 			|| $isDangerStr($filename , "".xxhtml"")
 			|| $isDangerStr($filename , "".asp"")			
+			|| $isDangerStr($filename , "".xsl"")
 		) {
 			return true;
 		}","Merge pull request #1630 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Prevent dangerous .xsl files from being accepted as safe filenames

The filename validation function did not consider .xsl files as dangerous, allowing potentially harmful files to bypass security checks. This posed a risk of malicious XML stylesheet injection or server-side processing vulnerabilities. The fix adds .xsl to the list of disallowed extensions to block unsafe file uploads effectively.
Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type
Severity: High
CVSS: 7.5",0.23529411764705882,"[('#1630', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('safe', 'secword', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('malicious', 'secword', ''), ('injection', 'SECWORD', ''), ('server', 'secword', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
47,{'CWE-79'},GHSA-4p92-fv6v-fhfj,"similarity index 100%
rename from .github/workflows/templates.yml.backup
rename to .github/workflows/templates.yml",update,"vuln-fix: Restore CI workflow configuration to prevent build disruptions

The workflow configuration file was missing due to a backup rename, causing continuous integration processes to fail and skip security checks.
This disruption allowed unverified code changes to be merged without automated testing or vulnerability scanning.
The fix restores the workflow file to its correct location, ensuring CI pipelines run and enforce security validations on code changes.

Weakness: Missing or Disabled CI/CD Security Checks
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('changes', 'ACTION', ''), ('vulnerability', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('security', 'SECWORD', ''), ('changes', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('security', 'secword', ''), ('medium', 'SEVERITY', '')]"
48,{'CWE-79'},GHSA-mq35-wqvf-r23c,"@@ -78,7 +78,7 @@ def unlink?
     def params
       super
     rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
-      raise BadRequest, ""Invalid query parameters: #{e.message}""
+      raise BadRequest, ""Invalid query parameters: #{Rack::Utils.escape_html(e.message)}""
     end
 
     private","escape invalid query params, fixes #1428","vuln-fix: Escape HTML in error messages to prevent XSS

The error message included raw exception details without escaping, allowing injection of malicious HTML or scripts in the response.
This posed a cross-site scripting (XSS) risk by enabling attackers to execute arbitrary code in users' browsers.
The fix escapes HTML entities in the error message before rendering, preventing injection of executable code in the output.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('escape', 'secword', ''), ('fixes', 'ACTION', ''), ('#1428', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
49,{'CWE-79'},GHSA-p885-prv3-m4xv,"@@ -30,11 +30,11 @@ public function requestedAssets()
             // Make sure the asset and request still exist
             if ($checkoutRequest && $checkoutRequest->itemRequested()) {
                 $results['rows'][] = [
-                    'image' => $checkoutRequest->itemRequested()->present()->getImageUrl(),
-                    'name' => $checkoutRequest->itemRequested()->present()->name(),
-                    'type' => $checkoutRequest->itemType(),
-                    'qty' => $checkoutRequest->quantity,
-                    'location' => ($checkoutRequest->location()) ? $checkoutRequest->location()->name : null,
+                    'image' => e($checkoutRequest->itemRequested()->present()->getImageUrl()),
+                    'name' => e($checkoutRequest->itemRequested()->present()->name()),
+                    'type' => e($checkoutRequest->itemType()),
+                    'qty' => (int) $checkoutRequest->quantity,
+                    'location' => ($checkoutRequest->location()) ? e($checkoutRequest->location()->name) : null,
                     'expected_checkin' => Helper::getFormattedDateObject($checkoutRequest->itemRequested()->expected_checkin, 'datetime'),
                     'request_date' => Helper::getFormattedDateObject($checkoutRequest->created_at, 'datetime'),
                 ];","Merge pull request #10942 from snipe/fixes/xss_user_requested

Fixes potential XSS vuln in user requestable results","vuln-fix: Escape output to prevent XSS in requested assets data

The vulnerability was that user-controllable data was output without escaping, allowing injection of malicious scripts in the asset details displayed to users. This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or steal sensitive information. The fix applies proper HTML escaping to all output fields and casts quantities to integers to ensure safe rendering in the frontend.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('#10942', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('xss_user_requested', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('vulnerability', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('asset', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive information', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
50,{'CWE-79'},GHSA-7vvq-7r29-5vg3,"@@ -498,7 +498,7 @@ <h1><a href=""https://threejs.org"">three.js</a></h1>
 			const oldIframe = iframe;
 			iframe = oldIframe.cloneNode();
 
-			if ( hash ) {
+			if ( hash && titles[ splitHash[ 0 ] ] ) {
 
 				iframe.src = splitHash[ 0 ] + '.html' + splitHash[ 1 ];
 				subtitle = titles[ splitHash[ 0 ] ] + splitHash[ 1 ] + ' – ';",Only load trusted iframe (#23245),"vuln-fix: Prevent iframe src assignment with unverified hash keys

The vulnerability allowed setting iframe sources based on unvalidated hash keys, potentially enabling injection of malicious URLs into the iframe element. This posed a security risk by allowing attackers to load unauthorized or harmful content within the application context. The fix adds a verification step to ensure the hash key exists in the trusted titles list before assigning the iframe source. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('#23245', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('hash', 'secword', ''), ('keys', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('hash', 'secword', ''), ('keys', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('hash', 'secword', ''), ('key', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
51,{'CWE-79'},GHSA-72p5-2r6g-fm6v,"@@ -559,7 +559,7 @@ COMPONENT('grid', 'filter:true;external:false;fillcount:50;filterlabel:Filtering
 			for (var j = 0, jl = columns.length; j < jl; j++) {
 				var column = columns[j];
 				var val = items[i][column.name];
-				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : (column.format ? val.format(column.format) : val);
+				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : Thelpers.encode((column.format ? val.format(column.format) : val));
 				m.index = j;
 				m.align = column.align;
 				m.background = column.background;",Fixed XSS.,"vuln-fix: Prevent XSS by encoding grid cell output values

The vulnerability allowed untrusted data to be rendered directly in grid cells without proper encoding, enabling potential cross-site scripting attacks. This is a security risk because malicious scripts could execute in users' browsers, leading to data theft or session hijacking. The fix applies HTML encoding to all formatted cell values before rendering, ensuring that injected scripts are neutralized. 

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fixed', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('untrusted data', 'secword', ''), ('encoding', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('theft', 'secword', ''), ('hijacking', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
52,{'CWE-79'},GHSA-q67f-3jq4-mww2,"@@ -568,10 +568,11 @@ pimcore.element.properties = Class.create({
 
     addSetFromUserDefined: function (customKey, customType) {
         try {
-            if (in_array(customKey.getValue(), this.disallowedKeys)) {
+            let key = htmlspecialchars(customKey.getValue());
+            if (in_array(key, this.disallowedKeys)) {
                 Ext.MessageBox.alert(t(""error""), t(""name_is_not_allowed""));
             }
-            this.add(customKey.getValue(), customType.getValue(), false, false, false, true);
+            this.add(key, customType.getValue(), false, false, false, true);
         } catch (e) {
             console.log(e);
         }",escaping 'key' custom property field in elements,"vuln-fix: Sanitize user-defined keys to prevent XSS attacks

User input for custom keys was not properly sanitized before usage, allowing injection of malicious HTML or scripts.
This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user sessions or data.
The fix applies HTML special character encoding to user input before validation and usage, mitigating XSS vulnerabilities.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('escaping', 'secword', ''), ('key', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('keys', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('xss', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
53,{'CWE-79'},GHSA-jr37-66pj-36v7,"@@ -82,7 +82,7 @@ public function anyData()
             })
             ->addColumn('view', function ($tasks) {
                 return '<a href=""' . route(""tasks.show"", $tasks->external_id) . '"" class=""btn btn-link"">' . __('View') .'</a>'
-                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-title=""'. $tasks->title . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
+                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
                 ;
             })
             ->rawColumns(['titlelink','view', 'status_id'])",fix xss for tasks index,"vuln-fix: Prevent XSS via task deletion modal data attributes

The vulnerability involved injecting unescaped task titles into HTML attributes, enabling cross-site scripting attacks through maliciously crafted task titles. This posed a security risk by allowing attackers to execute arbitrary scripts in users’ browsers, potentially stealing session data or performing unauthorized actions. The fix removes the unsafe task title attribute from the deletion modal link, eliminating the injection vector and preventing XSS exploitation.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('maliciously', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('injection', 'secword', ''), ('preventing', 'ACTION', ''), ('xss', 'secword', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
54,{'CWE-79'},GHSA-9w7h-3wwh-6m5q,"@@ -611,10 +611,15 @@ public function module()
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
-
+                if(is_string($v)) {
+                    $v = str_replace('<', '-', $v);
+                    $v = str_replace('>', '-', $v);
+                }
                 $v = $antixss->xss_clean($v);
 
                 if(is_string($k)){
+                    $k = str_replace('<', '-', $k);
+                    $k = str_replace('>', '-', $k);
                     $k = $antixss->xss_clean($k);
                     if($k){
                         $request_data_new[$k] = $v;
@@ -622,7 +627,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
-                
+
             }
             $request_data = $request_data_new;
         }",update,"vuln-fix: Prevent XSS by sanitizing angle brackets in input keys and values

User input keys and values containing angle brackets were not fully sanitized, allowing potential cross-site scripting (XSS) attacks through malicious HTML tags. This is a security risk because attackers could inject executable scripts that compromise user data or session integrity. The fix replaces angle brackets with safe characters before applying XSS cleaning, ensuring all input is properly sanitized.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('keys', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('xss', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
55,{'CWE-79'},GHSA-hj8g-cw8x-2c6m,"@@ -276,7 +276,8 @@ public function string($skip_ajax = false)
 
         // clear request params
         $cleanParam = new HTMLClean();
-        $u1 = $cleanParam->cleanArray($u1);
+        $u1 = $cleanParam->clean($u1);
+
 
         return $u1;
     }",Update UrlManager.php,"vuln-fix: Prevent improper input sanitization in string processing

The vulnerability was caused by using an incorrect sanitization method that did not fully clean input arrays, allowing potentially malicious data to pass through. This posed a risk of cross-site scripting or injection attacks due to incomplete input cleansing. The fix replaces the array cleaning method with a more appropriate single-value cleaning function to ensure thorough sanitization of input data.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', ''), ('urlmanager.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sanitization', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('sanitization', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('sanitization', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
56,"{'CWE-74', 'CWE-79'}",GHSA-pxcf-v868-m492,"@@ -19,6 +19,23 @@ app.use((req, res, next) => {
   next();
 });
 
+
+function htmlEscape(text) {
+  return text.replace(/&/g, '&amp;').
+  replace(/</g, '&lt;').
+  replace(/""/g, '&quot;').
+  replace(/'/g, '&#039;');
+}
+
+
+function sanitize(params) {
+  result = {}
+  for (let [key, value] of Object.entries(params)) {
+      result[key] = htmlEscape(value)
+  }
+  return result;
+}
+
 app.get(""/health"", (req, res) => res.sendStatus(200));
 
 const handler = (res, params) => {
@@ -40,12 +57,14 @@ const handler = (res, params) => {
 app.get(""/"", (req, res) => handler(res, req.query));
 app.post(""/"", (req, res) => handler(res, req.body));
 
-app.get(""/dynamic"", (req, res) =>
-  handler(res, { ...req.query, renderToHtml: true })
-);
+app.get(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.query)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
-app.post(""/dynamic"", (req, res) =>
-  handler(res, { ...req.body, renderToHtml: true })
-);
+app.post(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.body)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
 module.exports = http.createServer(app);",fix: escape special characters before insertion to template,"vuln-fix: Sanitize user input to prevent HTML injection

User input parameters were directly rendered into HTML without escaping, allowing injection of malicious HTML or scripts.
This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user data and session integrity.
The fix introduces HTML escaping of all input parameters before rendering, neutralizing potentially harmful characters in user input.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
57,{'CWE-79'},GHSA-rf66-hmqf-q3fc,"@@ -260,7 +260,18 @@ $(document).ready(function () {
     }
 
     function formatDataSelection (datalist) {
-        return datalist.text;
+        // This a heinous workaround for a known bug in Select2.
+        // Without this, the rich selectlists are vulnerable to XSS.
+        // Many thanks to @uberbrady for this fix. It ain't pretty,
+        // but it resolves the issue until Select2 addresses it on their end.
+        //
+        // Bug was reported in 2016 :{
+        // https://github.com/select2/select2/issues/4587
+
+        return datalist.text.replace(/>/g, '&gt;')
+            .replace(/</g, '&lt;')
+            .replace(/""/g, '&quot;')
+            .replace(/'/g, '&#039;');
     }
 
     // This handles the radio button selectors for the checkout-to-foo options",Janky fix for Select2 bug,"vuln-fix: Prevent XSS in Select2 rich selectlists by escaping input

The vulnerability allowed unescaped HTML characters in Select2 dropdown text, enabling cross-site scripting (XSS) attacks through malicious user input.
This posed a critical security risk as attackers could execute arbitrary scripts in users’ browsers, potentially stealing data or hijacking sessions.
The fix escapes special HTML characters in the dropdown text, mitigating XSS by sanitizing input until an official Select2 patch is released.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8",0.11764705882352941,"[('fix', 'ACTION', ''), ('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('patch', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
58,{'CWE-79'},GHSA-hxmr-5gv9-6p8v,"@@ -45,9 +45,9 @@
             $snmpver = 'v2c';
             $additional = [
                 'snmp_disable' => 1,
-                'os'           => $_POST['os'] ? $_POST['os_id'] : 'ping',
-                'hardware'     => $_POST['hardware'],
-                'sysName'      => $_POST['sysName'],
+                'os'           => $_POST['os'] ? strip_tags($_POST['os_id']) : 'ping',
+                'hardware'     => strip_tags($_POST['hardware']),
+                'sysName'      => strip_tags($_POST['sysName']),
             ];
         } elseif ($_POST['snmpver'] === 'v2c' || $_POST['snmpver'] === 'v1') {
             if ($_POST['community']) {","XSS fix, cont. (#13776)

https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/","vuln-fix: Sanitize user input to prevent XSS in SNMP parameters

User input from POST parameters was directly assigned without sanitization, allowing injection of malicious HTML or JavaScript code.
This posed a cross-site scripting (XSS) risk that could compromise user sessions or execute unauthorized scripts in the application context.
The fix applies strip_tags() to sanitize the 'os_id', 'hardware', and 'sysName' inputs, removing any embedded HTML or script tags before use.

Weakness: Cross-Site Scripting (CWE-79)
Severity: Medium
CVSS: 6.1",0.23529411764705882,"[('xss', 'secword', ''), ('fix', 'ACTION', ''), ('#13776', 'ISSUE', ''), ('https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('removing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
59,{'CWE-79'},GHSA-mxh3-2699-98g9,"@@ -861,7 +861,7 @@ public function fieldcollectionTreeAction(Request $request, EventDispatcherInter
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,
@@ -1266,7 +1266,7 @@ public function objectbrickTreeAction(Request $request, EventDispatcherInterface
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,",[Admin] DataObject - Escape class definitions group properly,"vuln-fix: Sanitize group names to prevent XSS in tree views

User-supplied group names were directly rendered in the tree view without escaping, allowing injection of malicious HTML or scripts.
This posed a cross-site scripting (XSS) risk, enabling attackers to execute arbitrary scripts in users’ browsers and compromise session integrity.
The fix applies htmlspecialchars to group names before rendering, ensuring special characters are escaped and preventing script execution.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.058823529411764705,"[('admin', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
60,{'CWE-79'},GHSA-5jgj-h9wp-53fr,"@@ -285,6 +285,20 @@ public static function isImage($file_path)
             return false;
         }
 
+        /**
+         * Detects whether the file contains PHP or script tags, eg to check for embedded code in GIFs
+         * @param $file_path
+         * @return bool
+         */
+        public static function isFileFreeFromScriptTags($file_path)
+        {
+            if ($contents = file_get_contents($file_path)) {
+                if (stripos($contents, '<script') || strpos($contents, '<?')) return false;
+                return true;
+            }
+            return false;
+        }
+
         /**
          * Retrieve a file by ID
          *",Checking for script tags in GIFs etc (#3017),"vuln-fix: Prevent execution of embedded script tags in uploaded files

Uploaded files were not checked for embedded PHP or script tags, allowing attackers to upload malicious code disguised as images or other file types. This poses a critical security risk as it can lead to remote code execution if the server processes these files. The fix introduces a function that scans file contents for script or PHP tags and rejects files containing such code before further processing.

Weakness: CWE-94: Improper Control of Generation of Code ('Code Injection')
Severity: Critical
CVSS: 9.8",0.11764705882352941,"[('#3017', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('malicious code', 'secword', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('remote code execution', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-94', 'CWEID', ''), ('improper control', 'secword', ''), ('code injection', 'SECWORD', ''), ('critical', 'SEVERITY', '')]"
61,{'CWE-79'},GHSA-cg3h-rc9q-g8v9,"@@ -36,7 +36,7 @@ pimcore.settings.website = Class.create({
                 border:false,
                 layout:""fit"",
                 closable:true,
-                items:[this.getRowEditor()]
+                items:[this.getRowEditor()],
             });
 
             var tabPanel = Ext.getCmp(""pimcore_panel_tabs"");
@@ -133,6 +133,7 @@ pimcore.settings.website = Class.create({
                 dataIndex: 'data',
                 flex: 300,
                 editable: true,
+                editor: new Ext.form.TextField({}),
                 renderer: this.getCellRenderer.bind(this),
             },
             {text: t(""site""), flex: 100, sortable:true, dataIndex: ""siteId"",
@@ -303,7 +304,10 @@ pimcore.settings.website = Class.create({
             bodyCls: ""pimcore_editable_grid"",
             stripeRows:true,
             columns : {
-                items: typesColumns
+                items: typesColumns,
+                defaults: {
+                    renderer: Ext.util.Format.htmlEncode
+                },
             },
             sm:  Ext.create('Ext.selection.RowModel', {}),
             bbar:this.pagingtoolbar,
@@ -359,15 +363,23 @@ pimcore.settings.website = Class.create({
     },
 
     getCellEditor: function (record) {
-        var data = record.data;
+        let data = record.data;
 
-        var type = data.type;
-        var property;
+        let type = data.type;
+        let property;
 
         if (type === ""text"") {
-            property = Ext.create('Ext.form.TextField');
+            property = {
+                xtype: 'textfield',
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""textarea"") {
-            property = Ext.create('Ext.form.TextArea');
+            property = {
+                xtype: ""textarea"",
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""document"" || type == ""asset"" || type == ""object"") {
             property = {
                 xtype: 'textfield',",[Admin] Website Settings - Escape grid values properly,"vuln-fix: Prevent XSS by encoding grid cell content and restricting editors

The vulnerability allowed unencoded HTML content in grid cells, enabling attackers to inject malicious scripts via editable fields in the UI. This posed a security risk by potentially executing arbitrary JavaScript in users' browsers, leading to data theft or session hijacking. The fix enforces HTML encoding on grid cell renderers and restricts editors to safe text input components, mitigating script injection vectors.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('admin', 'SECWORD', ''), ('escape', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unencoded', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('theft', 'secword', ''), ('hijacking', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('safe', 'secword', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
62,{'CWE-79'},GHSA-73q9-7pwj-gm46,"@@ -150,7 +150,7 @@
             ?>
             <h2><?php echo $t['multi-user']; ?></h2>
             <span class=""heading""><?php echo $t['Username']; ?></span><br>
-            <?php echo $_SESSION['username'];?><br><br>
+            <?php echo xssClean($_SESSION['username'], ""html"");?><br><br>
             <?php
         }
         ?>",rXSS cleaned username in editor info display,"vuln-fix: Sanitize username output to prevent XSS attacks

The username stored in the session was output directly into HTML without sanitization, allowing injection of malicious scripts.
This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions and data integrity.
The fix applies an HTML context-specific sanitization function to the username before rendering it in the page output.


Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('rxss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
63,{'CWE-79'},GHSA-fc38-mxwr-pfhx,"@@ -36,7 +36,7 @@ DirectoryIndex index.php
 </IfModule>
 
 <IfModule mod_headers.c>
-    <FilesMatch ""\.svg$"">
+    <FilesMatch ""\.(?i:svg)$"">
         Header set Content-Security-Policy ""script-src 'none'""
     </FilesMatch>
 </IfModule>",NEXT-15677 - Fix XSS for SVG files,"vuln-fix: Enforce case-insensitive SVG content security policy header

The Content-Security-Policy header was applied only to lowercase "".svg"" files, missing uppercase or mixed-case SVG extensions and allowing unsafe script execution in those cases. This inconsistency could enable attackers to bypass security restrictions by using differently cased file extensions, leading to potential script injection attacks. The fix updates the file matching pattern to be case-insensitive, ensuring the policy applies to all SVG files regardless of extension casing.

Weakness: CWE-693: Protection Mechanism Failure  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('content security policy', 'SECWORD', ''), ('security', 'SECWORD', ''), ('unsafe', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-693', 'CWEID', ''), ('protection mechanism failure', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
64,{'CWE-79'},GHSA-2v5j-q74q-r53f,"@@ -56,7 +56,7 @@ def get_markdown(text):
     if not text:
         return """"
 
-    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\[\s\S\]]*?)\)'
+    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\s\S]*?)\)'
     # Regex check
     if re.match(pattern, text):
         # get get value of group regex",Update pattern,"vuln-fix: Correct regex to prevent improper markdown parsing

The vulnerability was caused by an overly permissive regex pattern that allowed malformed markdown input to bypass validation checks. This posed a security risk by enabling injection of unexpected or malicious content through improperly parsed markdown links. The fix tightens the regex pattern to correctly restrict the characters matched in the third group, preventing unintended matches and improving input validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('input validation', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
65,{'CWE-79'},GHSA-rfw2-x9f8-2f6m,"@@ -579,11 +579,11 @@ var oncall = {
               },
               footer: function(resp){
                 if (teamsCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
                 }
               },
               empty: function(resp){
-                return '<h4> No results found for ""' + resp.query + '"" </h4>';
+                return '<h4> No results found for ""' + Handlebars.escapeExpression(resp.query) + '"" </h4>';
               }
             }
           },
@@ -604,7 +604,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (servicesCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
                 }
               }
             }
@@ -626,7 +626,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (usersCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
                 }
               }
             }","prevent potential XSS from searchbar results (#342)

* prevent potential XSS from searchbar results

* use built in handlebars expression escaping

* use handlebars encodeURIComponent","vuln-fix: Escape user input in query URLs and HTML output

User input in query URLs and HTML elements was not properly escaped, allowing injection of malicious scripts or malformed URLs.
This posed a risk of cross-site scripting (XSS) attacks and URL manipulation, potentially compromising user data and application integrity.
The fix applies Handlebars escaping and URL encoding to sanitize user input before embedding it in URLs and HTML content.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.17647058823529413,"[('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('#342', 'ISSUE', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('encodeuricomponent', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('escaped', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('malformed urls', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('url manipulation', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
66,{'CWE-79'},GHSA-jff5-55xj-4jcq,"@@ -2168,6 +2168,7 @@ function createSearchBox(searchURL) {
     var ac = new YAHOO.widget.AutoComplete(""search-box"",""search-box-completion"",ds);
     ac.typeAhead = false;
     ac.autoHighlight = false;
+    ac.formatResult = ac.formatEscapedResult;
 
     var box   = $(""search-box"");
     var sizer = $(""search-box-sizer"");","Merge pull request #98 from jenkinsci-cert/SECURITY-388

[SECURITY-388] Escape metacharacters in the search box","vuln-fix: Prevent XSS by escaping autocomplete results

The autocomplete widget did not escape HTML entities in its result formatting, allowing malicious scripts to be injected via search suggestions. This posed a cross-site scripting risk by enabling attackers to execute arbitrary JavaScript in users' browsers. The fix enforces escaping of autocomplete results by assigning a safe formatting function that encodes HTML entities before rendering.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.17647058823529413,"[('#98', 'ISSUE', ''), ('security-388', 'SECWORD', ''), ('security-388', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('escape', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('safe', 'secword', ''), ('encodes html entities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
67,{'CWE-79'},GHSA-wvh5-78h5-gmgr,"@@ -168,7 +168,7 @@ public function render_assign_user_summary(\assign_user_summary $summary) {
             $fullname = fullname($summary->user, $summary->viewfullnames);
             $extrainfo = array();
             foreach ($summary->extrauserfields as $extrafield) {
-                $extrainfo[] = $summary->user->$extrafield;
+                $extrainfo[] = s($summary->user->$extrafield);
             }
             if (count($extrainfo)) {
                 $fullname .= ' (' . implode(', ', $extrainfo) . ')';",MDL-74204 mod_assign: escape identity fields in allocate marker form.,"vuln-fix: Sanitize user extra fields to prevent XSS in summaries

User extra fields were output directly without escaping, allowing injection of malicious scripts in rendered user summaries.
This posed a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in other users’ browsers.
The fix applies proper HTML escaping to all extra user fields before rendering, mitigating script injection vulnerabilities.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.058823529411764705,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
68,{'CWE-79'},GHSA-98gj-wwxm-cj3h,"@@ -11,7 +11,7 @@
 import re
 import inspect
 
-__version__ = '0.8'
+__version__ = '0.8.1'
 __author__ = 'Hsiaoming Yang <me@lepture.com>'
 __all__ = [
     'BlockGrammar', 'BlockLexer',
@@ -48,7 +48,8 @@ def _pure_pattern(regex):
 
 
 def _keyify(key):
-    return _key_pattern.sub(' ', key.lower())
+    key = escape(key.lower(), quote=True)
+    return _key_pattern.sub(' ', key)
 
 
 def escape(text, quote=False, smart_amp=True):
@@ -445,7 +446,8 @@ class InlineGrammar(object):
     inline_html = re.compile(
         r'^(?:%s|%s|%s)' % (
             r'<!--[\s\S]*?-->',
-            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (_valid_end, _valid_attr),
+            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (
+                _valid_end, _valid_attr),
             r'<\w+%s(?:%s)*?\s*\/?>' % (_valid_end, _valid_attr),
         )
     )",Fix CVE-2017-16876,"vuln-fix: Escape keys to prevent injection in key normalization

The vulnerability involved unescaped keys being processed in the key normalization function, allowing crafted input to potentially inject malicious patterns into downstream processing.
This posed a security risk by enabling attackers to manipulate keys that could lead to injection attacks or unexpected behavior in parsing or rendering.
The fix applies proper escaping to keys before substitution, ensuring that special characters are safely encoded and cannot alter the intended pattern matching logic.

Weakness: Improper Neutralization of Special Elements used in an Injection (CWE-74)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('cve-2017-16876', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('key', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('key', 'secword', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('keys', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper neutralization', 'secword', ''), ('injection', 'SECWORD', ''), ('cwe-74', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
69,{'CWE-79'},GHSA-5ppx-rgw2-xg23,"@@ -712,6 +712,7 @@ var jenkinsRules = {
         };
         ac.prehighlightClassName = ""yui-ac-prehighlight"";
         ac.animSpeed = 0;
+        ac.formatResult = ac.formatEscapedResult;
         ac.useShadow = true;
         ac.autoSnapContainer = true;
         ac.delimChar = e.getAttribute(""autoCompleteDelimChar"");",[SECURITY-641] Escape autocompletion suggestions,"vuln-fix: Prevent XSS by escaping autocomplete results

Autocomplete results were rendered without proper escaping, allowing injection of malicious HTML or scripts into the page content.
This posed a cross-site scripting (XSS) risk, enabling attackers to execute arbitrary scripts in users' browsers.
The fix applies an escaping function to autocomplete results, ensuring all output is safely encoded before rendering.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('security-641', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
70,{'CWE-79'},GHSA-gmh3-x5w7-jg5m,"@@ -87,7 +87,7 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
-    $autoSize = xss_clean($autoSize);
+    $autoSize = intval($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
@@ -95,6 +95,16 @@
     }
     $type = xss_clean($type);
 
+            $other = [
+                ';',
+                '\'',
+                '//',
+                '`',
+                '\\',
+
+            ];
+    $type = str_replace($other, '', $type);
+
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
 
@@ -108,6 +118,8 @@
     if ($mod_id != $mod_orig_id) {
         $is_linked_mod = true;
     }
+
+
     ?>
 
     <script type=""text/javascript"">
@@ -124,7 +136,7 @@
         addIcon();
 
         autoSize = <?php  print $autoSize; ?>;
-        settingsType = '<?php print $type; ?>';
+        settingsType = '<?php print htmlentities($type); ?>';
 
         window.onbeforeunload = function () {
             $(document.body).addClass(""mw-external-loading"")",update,"vuln-fix: Sanitize user input to prevent XSS and injection

User input from GET parameters was insufficiently sanitized, allowing injection of malicious scripts and special characters into the application context.
This posed a security risk by enabling cross-site scripting (XSS) attacks and potential command or query injection through unsanitized input.
The fix replaces generic XSS cleaning with strict integer casting, removes dangerous characters from strings, and encodes output with htmlentities to ensure safe rendering.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4

Weakness: Improper Neutralization of Special Elements (CWE-116)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', '')]",0.5882352941176471,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'secword', ''), ('sanitized', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('injection', 'secword', ''), ('unsanitized', 'SECWORD', ''), ('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('integer casting', 'SECWORD', ''), ('removes', 'ACTION', ''), ('encodes', 'SECWORD', ''), ('htmlentities', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', ''), ('weakness', 'SECWORD', ''), ('improper neutralization', 'secword', ''), ('cwe-116', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
71,{'CWE-79'},GHSA-f655-xhvm-cwp4,"@@ -1,4 +1,5 @@
 <?jelly escape-by-default='true'?>
 <j:jelly xmlns:j=""jelly:core"">
-  <span><j:out value=""${it.shortDescription}"" /></span>
+  <!-- SECURITY-2316: This used to show the HTML-formatted it.shortDescription, but that does not properly neutralize user-provided input -->
+  <span>Triggered by GitLab Webhook</span>
 </j:jelly>",[SECURITY-2316],"vuln-fix: Prevent XSS by removing unsafe HTML output in description

The vulnerability was caused by rendering user-controlled HTML content without proper sanitization, allowing malicious scripts to execute in the browser context. This posed a significant cross-site scripting risk, potentially compromising user sessions and data confidentiality. The fix replaces the vulnerable HTML output with a static, safe string to eliminate the injection vector entirely.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('security-2316', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('removing', 'ACTION', ''), ('unsafe', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('vulnerable', 'SECWORD', ''), ('safe', 'secword', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
72,{'CWE-79'},GHSA-fj93-7wm4-8x2g,"@@ -564,6 +564,15 @@ $.widget( ""mobile.pagecontainer"", {
 
 		return $.proxy( function( html, textStatus, xhr ) {
 
+			// Check that Content-Type is ""text/html"" (https://github.com/jquery/jquery-mobile/issues/8640)
+			if ( !/^text\/html\b/.test( xhr.getResponseHeader('Content-Type') ) ) {
+				// Display error message for unsupported content type
+				if ( settings.showLoadMsg ) {
+					this._showError();
+				}
+				return;
+			}
+
 			// Pre-parse html to check for a data-url, use it as the new fileUrl, base path, etc
 			var content,","Check Content-Type header before parsing AJAX response as HTML (#8649)

Fix for issue #8640 (possible XSS vulnerability)","vuln-fix: Validate Content-Type header for AJAX page loads

The vulnerability allowed processing of non-HTML content in AJAX page loads, which could lead to script injection or improper content handling. This poses a security risk by enabling attackers to inject malicious payloads or cause unexpected behavior in the application. The fix enforces a strict check that only responses with a Content-Type of ""text/html"" are processed, rejecting others and optionally showing an error message.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('#8649', 'ISSUE', ''), ('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('#8640', 'ISSUE', ''), ('xss', 'secword', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
73,{'CWE-79'},GHSA-xjrf-8x4f-43h4,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2008 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -21,21 +21,21 @@
  * Escapes based on the JavaScript 1.5 recommendation.
  *
  * <p>Reference:
- * <a href=""http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Guide:Literals#String_Literals"">
- * Core JavaScript 1.5 Guide
- * </a>
+ * <a href=""https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#String_literals"">
+ * JavaScript Guide</a> on Mozilla Developer Network.
  *
  * @author Juergen Hoeller
  * @author Rob Harrop
+ * @author Rossen Stoyanchev
  * @since 1.1.1
  */
 public class JavaScriptUtils {
 
 	/**
-	 * Turn special characters into escaped characters conforming to JavaScript.
-	 * Handles complete character set defined in HTML 4.01 recommendation.
+	 * Turn JavaScript special characters into escaped characters.
+	 *
 	 * @param input the input string
-	 * @return the escaped string
+	 * @return the string with escaped characters
 	 */
 	public static String javaScriptEscape(String input) {
 		if (input == null) {
@@ -73,6 +73,13 @@ else if (c == '\r') {
 			else if (c == '\f') {
 				filtered.append(""\\f"");
 			}
+			else if (c == '\b') {
+				filtered.append(""\\b"");
+			}
+			// No '\v' in Java, use octal value for VT ascii char
+			else if (c == '\013') {
+				filtered.append(""\\v"");
+			}
 			else {
 				filtered.append(c);
 			}","Add BS and VT char escape sequences to JavaScriptUtils

Issue: SPR-9983","vuln-fix: Escape additional JavaScript control characters in output

The JavaScript escaping function did not handle certain control characters like backspace and vertical tab, leaving them unescaped in output strings. This omission could allow injection of unexpected control characters, potentially leading to script parsing errors or security bypasses. The fix adds explicit escaping for backspace and vertical tab characters, ensuring all relevant control characters are safely encoded in JavaScript strings.

Weakness: Improper Neutralization of Input During Web Page Generation (CWE-79)  
Severity: Medium  
CVSS: 6.1",0.17647058823529413,"[('add', 'ACTION', ''), ('escape', 'SECWORD', ''), ('issue', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('escaping', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('injection', 'secword', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('bypasses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper neutralization', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
74,{'CWE-79'},GHSA-4mv4-gmmf-q382,"@@ -1,11 +1,11 @@
-/*! DataTables 1.10.10-dev
+/*! DataTables 1.10.10
  * ©2008-2015 SpryMedia Ltd - datatables.net/license
  */
 
 /**
  * @summary     DataTables
  * @description Paginate, search and order HTML tables
- * @version     1.10.10-dev
+ * @version     1.10.10
  * @file        jquery.dataTables.js
  * @author      SpryMedia Ltd (www.sprymedia.co.uk)
  * @contact     www.sprymedia.co.uk/contact
@@ -170,7 +170,7 @@
 	 *  @type string
 	 *  @default Version number
 	 */
-	DataTable.version = ""1.10.10-dev"";
+	DataTable.version = ""1.10.10"";
 
 	/**
 	 * Private data store, containing all of the settings objects that are",Version - 1.10.10 ready,"vuln-fix: Remove development version identifier from release build

The code contained a development version identifier which could expose internal build information to attackers. Revealing such details may aid attackers in targeting known vulnerabilities specific to development versions. The fix replaces the development version string with the official release version to prevent leaking sensitive build metadata.

Weakness: Information Exposure (CWE-200)  
Severity: Low  
CVSS: 3.1",0.11764705882352941,"[('1.10.10', 'VERSION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('known vulnerabilities', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('low', 'SEVERITY', '')]"
75,{'CWE-79'},GHSA-q3x2-jvp3-wj78,"@@ -1154,11 +1154,11 @@ function get_allowed_files_extensions_for_upload($fileTypes = 'images', $returnA
                 break;
             case 'file':
             case 'files':
-                $are_allowed .= ',doc,docx,pdf,json,rtf,txt,zip,gzip,rar,cad,xml,psd,xlsx,csv,7z';
+                $are_allowed .= ',doc,docx,pdf,json,rtf,txt,zip,gzip,rar,cad,psd,xlsx,csv,7z'; 
                 break;
             case 'documents':
             case 'doc':
-                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xml,xlr,xls,xlsx';
+                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xlr,xls,xlsx';
                 break;
             case 'archives':
             case 'arc':",Update Files.php,"vuln-fix: Remove XML file extensions from allowed upload types

Allowing XML files in uploads can lead to XML external entity (XXE) attacks, exposing sensitive data or enabling server-side request forgery.
This is a security risk because malicious XML payloads can exploit parser vulnerabilities to access internal resources or execute arbitrary code.
The fix removes XML extensions from allowed file types to prevent uploading potentially dangerous XML files and mitigate XXE attack vectors.

Weakness: XML External Entity (XXE) Injection (CWE-611)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', ''), ('files.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('sensitive data', 'secword', ''), ('server-side request forgery', 'secword', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('prevent', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('xxe', 'secword', ''), ('attack', 'secword', ''), ('weakness', 'SECWORD', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('injection', 'secword', ''), ('cwe-611', 'CWEID', ''), ('high', 'SEVERITY', '')]"
76,{'CWE-79'},GHSA-hhqj-cfjx-vj25,"@@ -368,6 +368,10 @@ <h4 class=""label"">Notes</h4>
 
 				window.addEventListener( 'message', function( event ) {
 
+					if (window.location.origin !== event.origin){
+						return;
+					}
+
 					clearTimeout( connectionTimeout );
 					connectionStatus.style.display = 'none';",Fix DOM XSS,"vuln-fix: Validate message event origin to prevent unauthorized access

The code lacked verification of the message event's origin, allowing any origin to send messages to the window event listener. This posed a security risk by enabling attackers to inject malicious messages from untrusted origins, potentially compromising application integrity. The fix adds a strict origin check that discards messages from origins different than the current window location, ensuring only trusted sources are processed.

Weakness: Improper Origin Validation (CWE-346)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('untrusted', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-346', 'CWEID', ''), ('high', 'SEVERITY', '')]"
77,{'CWE-79'},GHSA-h24f-9mm4-w336,"@@ -140,7 +140,9 @@ exports.handleRequest = function(vpath, path, req, res, readOnly, logHeadRequest
 															var name = results[f].name;
 															var normalized = url + '/' + name;
 															while(normalized[0] == '/') { normalized = normalized.slice(1, normalized.length); }
-															res.write('\r\n<p><a href=""/' + normalized + '"">' + name + '</a></p>');
+															if(normalized.indexOf('""') >= 0) throw new Error('unsupported file name')
+															name = name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
+															res.write('\r\n<p><a href=""/' + normalized + '""><span>' + name + '</span></a></p>');
 														}
 														res.end('\r\n</body></html>');
 													}",Fix not sanitizing file names rendered in html,"vuln-fix: Prevent XSS by sanitizing file names in directory listing

The vulnerability allowed unescaped special characters in file names to be injected into HTML, enabling cross-site scripting attacks via crafted directory entries. This posed a security risk by allowing attackers to execute arbitrary scripts in users’ browsers, potentially stealing sensitive data or hijacking sessions. The fix sanitizes file names by escaping HTML entities and rejects file names containing double quotes to prevent injection of malicious code.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('sanitizing', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('sensitive data', 'SECWORD', ''), ('hijacking', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitizes', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('malicious code', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
78,{'CWE-79'},GHSA-jpj5-hg26-6jgc,"@@ -7,6 +7,7 @@ import (
 	""github.com/Xhofe/alist/server/common""
 	""github.com/Xhofe/alist/utils""
 	""github.com/gin-gonic/gin""
+	""net/url""
 	""strings""
 )
 
@@ -24,11 +25,19 @@ func Plist(c *gin.Context) {
 		return
 	}
 	u := string(bytes)
+	uUrl, err := url.Parse(u)
+	if err != nil {
+		common.ErrorResp(c, err, 500)
+		return
+	}
 	name := utils.Base(u)
+	u = uUrl.String()
 	ipaIndex := strings.Index(name, "".ipa"")
 	if ipaIndex != -1 {
 		name = name[:ipaIndex]
 	}
+	name = strings.ReplaceAll(name, ""<"", ""["")
+	name = strings.ReplaceAll(name, "">"", ""]"")
 	plist := fmt.Sprintf(`<?xml version=""1.0"" encoding=""UTF-8""?><!DOCTYPE plist PUBLIC ""-//Apple//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd"">
 <plist version=""1.0"">
     <dict>",:lock: fix #645 xss vulnerability,"vuln-fix: Validate and sanitize URL input in Plist handler

The vulnerability was improper handling of user-supplied URL input without validation or sanitization, allowing malformed or malicious URLs to be processed. This posed a security risk by enabling injection attacks or server errors due to invalid URL formats. The fix parses and validates the URL using a standard library, returns errors on failure, and sanitizes output by replacing angle brackets to prevent injection.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('#645', 'ISSUE', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('sanitize', 'secword', ''), ('vulnerability', 'secword', ''), ('improper handling', 'secword', ''), ('sanitization', 'secword', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('server', 'SECWORD', ''), ('errors', 'FLAW', ''), ('invalid url', 'SECWORD', ''), ('fix', 'ACTION', ''), ('errors', 'FLAW', ''), ('sanitizes', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
79,{'CWE-79'},GHSA-66gw-5xpf-gfp5,"@@ -339,6 +339,7 @@ def wrapper(self, *args, **kwargs):
             message = e.log_message
             self.log.warn(message)
             self.set_status(e.status_code)
+            self.set_header('Content-Type', 'application/json')
             self.finish(json.dumps(dict(message=message)))
         except Exception:
             self.log.error(""Unhandled error in API request"", exc_info=True)
@@ -348,6 +349,7 @@ def wrapper(self, *args, **kwargs):
             self.set_status(status)
             tb_text = ''.join(traceback.format_exception(t, value, tb))
             reply = dict(message=message, traceback=tb_text)
+            self.set_header('Content-Type', 'application/json')
             self.finish(json.dumps(reply))
         else:
             return result",Set content type in json_error to application/json,"vuln-fix: Set Content-Type header to application/json on error responses

Error responses did not explicitly set the Content-Type header, causing clients to misinterpret the response format and potentially mishandle error data.
This can lead to security issues such as improper parsing, injection attacks, or information leakage through incorrect content handling.
The fix explicitly sets the Content-Type header to application/json for all error responses to ensure consistent and secure client processing.

Weakness: Improper Content-Type Handling (CWE-116)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('json_error', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('information leakage', 'secword', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-116', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
80,{'CWE-79'},GHSA-5fh3-25xr-g85h,"@@ -82,7 +82,7 @@ public function transformCheckedoutAccessory ($accessory, $accessory_users, $tot
                 'first_name'=> e($user->first_name),
                 'last_name'=> e($user->last_name),
                 'employee_number' =>  e($user->employee_num),
-                'checkout_notes' => $user->pivot->note,
+                'checkout_notes' => e($user->pivot->note),
                 'last_checkout' => Helper::getFormattedDateObject($user->pivot->created_at, 'datetime'),
                 'type' => 'user',
                 'available_actions' => ['checkin' => true]","Merge pull request #10361 from snipe/fixes/xss_in_accessories_checkout_notes

Escape notes in transformCheckedOutAccessory","vuln-fix: Escape user input in checkout notes to prevent XSS

The checkout notes field was output without escaping, allowing malicious scripts to be injected and executed in users’ browsers. This poses a security risk by enabling cross-site scripting attacks that can steal session data or perform unauthorized actions. The fix applies proper escaping to the checkout notes before rendering, mitigating the XSS vulnerability.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('#10361', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('xss_in_accessories_checkout_notes', 'SECWORD', ''), ('escape', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('steal', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
81,{'CWE-79'},GHSA-xg6r-5gx4-qxjm,"@@ -93,14 +93,15 @@ public function broker()
 
     public function sendResetLinkEmail(ContactPasswordResetRequest $request)
     {
-
-        if(Ninja::isHosted() && $request->session()->has('company_key'))
-            MultiDB::findAndSetDbByCompanyKey($request->session()->get('company_key'));
+        if(Ninja::isHosted() && $request->has('company_key'))
+            MultiDB::findAndSetDbByCompanyKey($request->input('company_key'));
         
         $this->validateEmail($request);
 
-        $company = Company::where('company_key', $request->session()->get('company_key'))->first();
-        $contact = ClientContact::where(['company_id' => $company->id, 'email' => $request->input('email')])->first();
+        // $company = Company::where('company_key', $request->input('company_key'))->first();
+        // $contact = ClientContact::where(['company_id' => $company->id, 'email' => $request->input('email')])->first();
+
+        $contact = ClientContact::where(['email' => $request->input('email')])->first();
 
         $response = false;
 
@@ -117,7 +118,7 @@ public function sendResetLinkEmail(ContactPasswordResetRequest $request)
             return $this->sendResetLinkFailedResponse($request, Password::INVALID_USER);
 
         // We will send the password reset link to this user. Once we have attempted
-        // to send the link, we will examine the response then see the message we
+        // to send the link, we will examine thuser@example.ce response then see the message we
         // need to show to the user. Finally, we'll send out a proper response.
         // $response = $this->broker()->sendResetLink(
         //     $this->credentials($request)",Fixes for client password reset,"vuln-fix: Prevent unauthorized password reset via company key exposure

The password reset function used company_key from user input instead of session, allowing attackers to specify arbitrary company keys and potentially reset passwords across companies. This is a security risk because it enables unauthorized access to user accounts by bypassing company isolation controls. The fix removes reliance on user-supplied company_key and restricts password reset queries to email only, preventing cross-company password reset attacks.

Weakness: Improper Access Control (CWE-284)  
Severity: Critical  
CVSS: 9.1",0.11764705882352941,"[('fixes', 'ACTION', ''), ('password', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('password', 'SECWORD', ''), ('key', 'SECWORD', ''), ('password', 'secword', ''), ('company_key', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('keys', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('security', 'secword', ''), ('bypassing', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('company_key', 'SECWORD', ''), ('password', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('password', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper access control', 'secword', ''), ('cwe-284', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
82,{'CWE-79'},GHSA-hm45-mgqm-gjm4,"@@ -930,20 +930,20 @@ <h5>{{ data['message'] }}</h5>
             img.attr(""src"", `${img.attr(""data-src-url"")}png`)
         }
     }
+
+    function safe(str) {
+        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+    }
 </script>
 
 {% if data['status'] == 1 and data['data']['status'] == 1 %}
 
-{% if 'aliascc' in data['data']['permslist'] %}
+{% if 'aliascc' in data['data']['permslist'] and false%}
 <script>
     /* ---------------------------------------------------------------------------------------------------------------------
                                                         Aliases group
        --------------------------------------------------------------------------------------------------------------------- */
 
-    function safe(str) {
-        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
-    }
-
     // Alias modal
     $(document).on('click', '.editaliasbutton', function () {
         var command = $(this).parent().parent().data(""command"")
@@ -1186,28 +1186,35 @@ <h5>{{ data['message'] }}</h5>
             } else if (json.status === 1 && json.data.status === 0) {
                 $(""#targetstatus"").html(`{{ _('Failed to fetch targets') }}: ${json.data.message}`)
             } else {
+                let big_ol_dict = {}
                 select.html("""")
 
                 var chopt = [`<optgroup label=""{{ _('Channels') }}"">`]
                 for (let [id, name] of json.data.CHANNELS) {
-                    chopt.push(`<option value=${id}>${name}</option>`)
+                    chopt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 chopt.push(""</optgroup>"")
                 select.append(chopt.join(""""))
 
                 var ropt = [`<optgroup label=""{{ _('Roles') }}"">`]
                 for (let [id, name] of json.data.ROLES) {
-                    ropt.push(`<option value=${id}>${name}</option>`)
+                    ropt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 ropt.push(""</optgroup>"")
                 select.append(ropt.join(""""))
 
                 var uopt = [`<optgroup label=""{{ _('Users') }}"">`]
                 for (let [id, name] of json.data.USERS) {
-                    uopt.push(`<option value=${id}>${name}</option>`)
+                    uopt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 uopt.push(""</optgroup>"")
                 select.append(uopt.join(""""))
+                for (let [id, name] of Object.entries(big_ol_dict)) {
+                    $(`.selectpicker-element-${id}`).text(name)
+                }
             }
             select.selectpicker({ title: ""{{ _('Choose target') }}"" })
             select.removeAttr(""disabled"")
@@ -1299,18 +1306,24 @@ <h5>{{ data['message'] }}</h5>
                 $(""#rulesdiv"").html("""")
                 var overall = ['<h3 style=""margin-bottom: 10px"">{{ _(""Cog rules"") }}</h3>']
                 var allcoglines = [""<ul>""]
+
+                let big_ol_dict_two = {}
+                let cog_counter = 0
+
                 for (let [cog, rules] of Object.entries(json.data.COG)) {
                     var coglines = []
                     for (let rule of rules) {
                         if (rule.type === ""Default"") {
                             coglines.unshift(`<li>{{ _('By default, users are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else if (rule.type === ""Role"") {
-                            coglines.push(`<li>{{ _('Users with the') }} <code>${rule.name}</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('Users with the') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else if (rule.type === ""Channel"") {
-                            coglines.push(`<li>{{ _('Users in the') }} <code>${rule.name}</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('Users in the') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else {
-                            coglines.push(`<li>{{ _('User') }} <code>${rule.name}</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('User') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         }
+                        big_ol_dict_two[`cog-rules-${cog_counter}`] = rule.name
+                        cog_counter += 1
                     }
                     if (coglines) {
                         allcoglines = allcoglines.concat(coglines)
@@ -1324,18 +1337,23 @@ <h5>{{ data['message'] }}</h5>
 
                 overall.push('<h3 style=""margin-bottom: 10px"">{{ _(""Command rules"") }}</h3>')
                 var allcmdlines = [""<ul>""]
+
+                let cmd_counter = 0
+
                 for (let [cmd, rules] of Object.entries(json.data.COMMAND)) {
                     var cmdlines = []
                     for (let rule of rules) {
                         if (rule.type === ""Default"") {
                             cmdlines.unshift(`<li>{{ _('By default, users are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else if (rule.type === ""Role"") {
-                            cmdlines.push(`<li>{{ _('Users with the') }} <code>${rule.name}</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('Users with the') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else if (rule.type === ""Channel"") {
-                            cmdlines.push(`<li>{{ _('Users in the') }} <code>${rule.name}</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('Users in the') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else {
-                            cmdlines.push(`<li>{{ _('User') }} <code>${rule.name}</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('User') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         }
+                        big_ol_dict_two[`cmd-rules-${cmd_counter}`] = rule.name
+                        cmd_counter += 1
                     }
                     if (cmdlines) {
                         allcmdlines = allcmdlines.concat(cmdlines)
@@ -1347,6 +1365,9 @@ <h5>{{ data['message'] }}</h5>
                 }
                 overall = overall.concat(allcmdlines)
                 $(""#rulesdiv"").html(overall.join(""""))
+                for (let [id, name] of Object.entries(big_ol_dict_two)) {
+                    $(`#${id}`).text(name)
+                }
                 $(""#fetchrulesstatus"").html(""{{ _('Refreshed rules') }}."")
             }
         }
@@ -1378,11 +1399,12 @@ <h5>{{ data['message'] }}</h5>
 
     $(document).on('click', '.adminroleoption', function () {
         var elm = $(this)
+        let random_number = Math.floor(Math.random() * Math.floor(100000))
         $(""#adminrolelist"").append(`
                 <li>
                     <div class=""row"">
                         <div class=""col-md-10 col-8"">
-                            <input class=""form-control adminroleinput"" value=""${elm.text()}"" disabled=True data-id=""${elm.attr(""data-id"")}"">
+                            <input class=""form-control adminroleinput"" value=""Loading..."" disabled=True data-id=""${elm.attr(""data-id"")}"" id=""admin-role-${random_number}"">
                         </div>
                         <div class=""col-md-1 col-1"">
                             <span class=""admin-role-x clickable""><i class=""tim-icons icon-simple-remove"" style=""float: right; margin-top: 10px;""></i></span>
@@ -1390,6 +1412,7 @@ <h5>{{ data['message'] }}</h5>
                     </div>
                 </li>
             `)
+        $(`#admin-role-${random_number}`).val(elm.text())
         elm.remove()
     })
 
@@ -1442,11 +1465,12 @@ <h5>{{ data['message'] }}</h5>
 
     $(document).on('click', '.modroleoption', function () {
         var elm = $(this)
+        let random_number = Math.floor(Math.random() * Math.floor(100000))
         $(""#modrolelist"").append(`
                 <li>
                     <div class=""row"">
                         <div class=""col-md-10 col-8"">
-                            <input class=""form-control modroleinput"" value=""${elm.text()}"" disabled=True data-id=""${elm.attr(""data-id"")}"">
+                            <input class=""form-control modroleinput"" value=""Loading..."" disabled=True data-id=""${elm.attr(""data-id"")}"" id=""mod-role-${random_number}"">
                         </div>
                         <div class=""col-md-1 col-1"">
                             <span class=""mod-role-x clickable""><i class=""tim-icons icon-simple-remove"" style=""float: right; margin-top: 10px;""></i></span>
@@ -1454,6 +1478,7 @@ <h5>{{ data['message'] }}</h5>
                     </div>
                 </li>
             `)
+        $(`#mod-role-${random_number}`).val(elm.text())
         elm.remove()
     })",[UI] Fix SelectPicker not rendering properly,"vuln-fix: Prevent XSS by escaping user-controlled content in UI

User-supplied strings were directly inserted into HTML without proper escaping, allowing injection of malicious scripts and potential cross-site scripting (XSS) attacks.
This vulnerability could enable attackers to execute arbitrary JavaScript in users' browsers, leading to session hijacking, data theft, or UI manipulation.
The fix introduces a safe escaping function for HTML entities and updates dynamic content insertion to use this function, ensuring all user data is properly sanitized before rendering.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('hijacking', 'secword', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('escaping', 'SECWORD', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
83,{'CWE-79'},GHSA-6hjc-m38h-7jhh,"@@ -15,12 +15,15 @@
 use nystudio107\seomatic\Seomatic;
 
 use Craft;
+use craft\elements\Asset;
 use craft\helpers\FileHelper;
+use craft\helpers\Assets as AssetsHelper;
 use craft\web\Controller;
 
 use yii\web\NotFoundHttpException;
 use yii\web\HttpException;
 use yii\web\Response;
+use yii\web\ServerErrorHttpException;
 
 /**
  * @author    nystudio107
@@ -87,6 +90,15 @@ public function actionSeoFileLink($url, $robots = '', $canonical = '', $inline =
                 $headerValue = '<'.$canonical.'>; rel=""canonical""';
                 $response->headers->add('Link', $headerValue);
             }
+            // Ensure the file type is allowed
+            // ref: https://craftcms.com/docs/3.x/config/config-settings.html#allowedfileextensions
+            $allowedExtensions = Craft::$app->getConfig()->getGeneral()->allowedFileExtensions;
+            if (($ext = pathinfo($fileName, PATHINFO_EXTENSION)) !== '') {
+                $ext = strtolower($ext);
+            }
+            if ($ext === '' || !in_array($ext, $allowedExtensions, true)) {
+                throw new ServerErrorHttpException(Craft::t('seomatic', 'File format not allowed.'));
+            }
             // Send the file as a stream, so it can exist anywhere
             $response->sendContentAsFile(
                 $contents,","Ensure that only files with the extensions listed in `allowedFileExtensions` General Config setting can be used with the SEO File Link controller

Signed-off-by: Andrew Welch <andrew@nystudio107.com>","vuln-fix: Restrict file types in SEO file link endpoint

The vulnerability allowed serving files with any extension, bypassing configured allowed file types and risking exposure of sensitive or malicious files to users. This is a security risk because attackers could exploit it to deliver harmful content or access unauthorized data through crafted URLs. The fix enforces validation against the allowed file extensions list and blocks requests with disallowed or missing file extensions by throwing an error.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('ensure', 'ACTION', ''), ('signed', 'secword', ''), ('andrew@nystudio107.com', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'SECWORD', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
84,{'CWE-79'},GHSA-hpx4-xjp7-m4vr,"@@ -98,7 +98,7 @@ public function transformAsset(Asset $asset)
             'purchase_cost' => Helper::formatCurrencyOutput($asset->purchase_cost),
             'book_value' => Helper::formatCurrencyOutput($depreciated_value),
             'monthly_depreciation' => $monthly_depreciation,
-            'checked_out_to' => $checkout_target,
+            'checked_out_to' => ($checkout_target) ? e($checkout_target) : null,
             'diff' =>  Helper::formatCurrencyOutput($diff),
             'number_of_months' =>  ($asset->model && $asset->model->depreciation) ? e($asset->model->depreciation->months) : null,
             'depreciation' => (($asset->model) && ($asset->model->depreciation)) ?  e($asset->model->depreciation->name) : null,","Escape checkout target name

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Escape output to prevent XSS in asset checkout field

The checked_out_to field was output without escaping, allowing injection of malicious scripts into the rendered HTML page.
This vulnerability could enable attackers to execute arbitrary JavaScript in users’ browsers, leading to session hijacking or data theft.
The fix applies proper HTML escaping to the checked_out_to value before output, mitigating cross-site scripting risks.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('escape', 'secword', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('asset', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('hijacking', 'secword', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('cross-site scripting', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
85,{'CWE-79'},GHSA-wg8p-w946-c482,"@@ -329,7 +329,7 @@ public function isAllowedFilename($filename){
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
 			'.pdf','.ofd','.swf','.epub','.xps',
 			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps','.wpt',
-			'.ppt','.pptx','.xls','.xlsx','.txt','.md','.psd','.csv',
+			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
 			'.cer','.ppt','.pub','.properties','.json','.css',
 			) ;",file upload bug,"vuln-fix: Prevent upload of markdown files to reduce attack surface

The vulnerability allowed uploading markdown (.md) files which can contain executable scripts or malicious content when rendered. This poses a security risk by enabling attackers to upload and execute harmful code or phishing content on the platform. The fix removes the .md extension from the allowed filename list, blocking markdown file uploads and reducing potential attack vectors.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('bug', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attack surface', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('phishing', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('attack', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('medium', 'SEVERITY', '')]"
86,{'CWE-79'},GHSA-vc5r-xfc4-4x22,"@@ -50,7 +50,7 @@ private function buildItem($configuration): array
 
         return [
             'id' => $name,
-            'text' => $name,
+            'text' => htmlspecialchars($name),
             'type' => 'config',
             'iconCls' => 'plugin_pimcore_datahub_icon_' . $type,
             'expandable' => false,",follow up to https://github.com/pimcore/data-hub/pull/462,"vuln-fix: Prevent XSS by escaping configuration item names

Unescaped configuration item names were directly output in the UI, allowing injection of malicious HTML or JavaScript code.
This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or steal sensitive data.
The fix applies htmlspecialchars to escape special characters, ensuring safe rendering of item names in the interface.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('https://github.com/pimcore/data-hub/pull/462', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
87,{'CWE-79'},GHSA-5fxf-x22x-5q38,"@@ -6,7 +6,6 @@ on:
 jobs:
   microweber-test-before-build:
     runs-on: ubuntu-latest
-    needs: stop-previous-runs
     steps:
       - uses: actions/checkout@v2",Update build-and-upload.yml,"vuln-fix: Prevent race condition by removing unnecessary job dependency

The workflow allowed concurrent runs by depending on a job that stopped previous runs, which could cause race conditions and inconsistent states during execution.
This posed a security risk by enabling potential state corruption or unauthorized access due to overlapping job executions.
The fix removes the dependency on the stop-previous-runs job to ensure jobs run independently and avoid race conditions. 

Weakness: Race Condition (CWE-362)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', ''), ('build-and-upload.yml', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('race condition', 'SECWORD', ''), ('removing', 'ACTION', ''), ('race conditions', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensure', 'ACTION', ''), ('race conditions', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('race condition', 'secword', ''), ('cwe-362', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
88,{'CWE-79'},GHSA-3pg8-c473-w6rr,"@@ -54,10 +54,10 @@ public function deleteFile($file_id){
 	}
 
 	//上传文件，返回url
-	public function upload($_files , $file_key , $uid , $item_id = 0  , $page_id = 0  ){
+	public function upload($_files , $file_key , $uid , $item_id = 0  , $page_id = 0 , $check_filename = true  ){
 		$uploadFile = $_files[$file_key] ;
 
-		if( !$this->isAllowedFilename($_files[$file_key]['name']) ){
+		if( $check_filename && !$this->isAllowedFilename($_files[$file_key]['name']) ){
 			return false;
 		}
 
@@ -324,14 +324,12 @@ public function isDangerFilename($filename){
 	public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
-			'.mp3','.wav','.mp4',
-			'.mov','.webmv','.flac','.mkv',
+			'.mp3','.wav','.mp4','.mov','.flac','.mkv',
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso',
-			'.pdf','.ofd','.swf','.epub','.xps',
-			'.doc','.docx','.wps',
+			'.pdf','.epub','.xps','.doc','.docx','.wps',
 			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
 			'.cer','.ppt','.pub','.json','.css',
-			) ;
+		) ;
 
 		$ext = strtolower(substr($filename,strripos($filename,'.')) ); //获取文件扩展名（转为小写后）
 		if(in_array( $ext , $allow_array ) ){",Upload file vulnerability,"vuln-fix: Add optional filename validation to file upload function

The file upload function lacked consistent filename validation, allowing potentially dangerous files to be uploaded without restriction. This posed a security risk by enabling attackers to upload malicious files that could compromise the system. The fix introduces an optional filename check parameter that enforces allowed extensions by default, preventing unauthorized file types from being uploaded.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious files', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
89,"{'CWE-434', 'CWE-79'}",GHSA-rphc-h572-2x9f,"@@ -324,13 +324,13 @@ public function isDangerFilename($filename){
 	public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
-			'.mp3','.wav','.m4a','.ogg','.webma','.mp4','.flv',
+			'.mp3','.wav','.mp4',
 			'.mov','.webmv','.flac','.mkv',
-			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
+			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso',
 			'.pdf','.ofd','.swf','.epub','.xps',
-			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps',
+			'.doc','.docx','.wps',
 			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
-			'.cer','.ppt','.pub','.properties','.json','.css',
+			'.cer','.ppt','.pub','.json','.css',
 			) ;
 
 		$ext = strtolower(substr($filename,strripos($filename,'.')) ); //获取文件扩展名（转为小写后）",file upload bug,"vuln-fix: Restrict allowed file extensions to reduce attack surface

The file upload function previously allowed numerous file extensions, including potentially dangerous types that could enable execution of malicious code or unauthorized access. Allowing these extensions increases the risk of remote code execution or privilege escalation attacks through crafted files. The fix narrows the allowed extensions list by removing high-risk types, thereby limiting uploadable files to safer formats and reducing potential exploitation vectors.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('attack surface', 'secword', ''), ('malicious code', 'secword', ''), ('remote code execution', 'secword', ''), ('privilege escalation', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('high', 'SEVERITY', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
90,"{'CWE-79', 'CWE-116'}",GHSA-ph5x-h23x-7q5q,"@@ -245,7 +245,7 @@
                   &lt;a href=""$backUrl"" class='button secondary'&gt;{{translation key=""platform.wiki.users.join.request.cancel.label""/}}&lt;/a&gt;
                 &lt;/span&gt;
                 &lt;input type='hidden' name='wikiId' value=""$!wikiId""/&gt;
-                &lt;input type='hidden' name='requestJoin' value=""$!request.requestJoin""/&gt;
+                &lt;input type='hidden' name='requestJoin' value=""$escapetool.xml($!request.requestJoin)""/&gt;
                 &lt;input type=""hidden"" name=""form_token"" value=""$!escapetool.xml($services.csrf.getToken())"" /&gt;
               &lt;/dl&gt;
             &lt;/form&gt;",XWIKI-19292: Fix bad escaping,"vuln-fix: Escape user input in hidden form field to prevent XSS

The hidden input field for 'requestJoin' was directly outputting user-controlled data without escaping, allowing injection of malicious scripts. This poses a security risk as attackers could execute arbitrary JavaScript in users' browsers, leading to session hijacking or data theft. The fix applies XML escaping to the 'requestJoin' value before rendering it in the form, mitigating cross-site scripting vulnerabilities.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('hijacking', 'secword', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('cross-site scripting', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
91,{'CWE-79'},GHSA-4wm8-c2vv-xrpq,"@@ -14,6 +14,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.log4j.Logger;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.core.Context;
 
@@ -25,8 +26,8 @@
  */
 public class ControlledVocabularyServlet extends DSpaceServlet
 {
-    // private static Logger log =
-    // Logger.getLogger(ControlledVocabularyServlet.class);
+    private static Logger log =
+    Logger.getLogger(ControlledVocabularyServlet.class);
 
     protected void doDSGet(Context context, HttpServletRequest request,
             HttpServletResponse response) throws ServletException, IOException,
@@ -37,6 +38,13 @@ protected void doDSGet(Context context, HttpServletRequest request,
         String filter = """";
         String callerUrl = request.getParameter(""callerUrl"");
 
+        // callerUrl must starts with URL outside DSpace request context path
+        if(!callerUrl.startsWith(request.getContextPath())) {
+            log.error(""Controlled vocabulary caller URL would result in redirect outside DSpace web app: "" + callerUrl + "". Rejecting request with 400 Bad Request."");
+            response.sendError(400, ""The caller URL must be within the DSpace base URL of "" + request.getContextPath());
+            return;
+        }
+
         if (request.getParameter(""ID"") != null)
         {
             ID = request.getParameter(""ID"");",[DS-4133] Improve URL handling in Controlled Vocab JSPUI servlet,"vuln-fix: Prevent open redirect by validating callerUrl parameter

The vulnerability allowed open redirect by accepting callerUrl parameters pointing outside the DSpace web application context path.  
This posed a security risk by enabling attackers to redirect users to malicious external sites, facilitating phishing or other attacks.  
The fix enforces that callerUrl must start with the DSpace context path and rejects requests with invalid URLs by returning a 400 Bad Request error.  

Weakness: CWE-601 Open Redirect  
Severity: Medium  
CVSS: 5.4",0.058823529411764705,"[('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('open redirect', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('open redirect', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('phishing', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('invalid urls', 'SECWORD', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cwe-601', 'CWEID', ''), ('open redirect', 'secword', ''), ('medium', 'SEVERITY', '')]"
92,{'CWE-79'},GHSA-c558-5gfm-p2r8,"@@ -209,7 +209,7 @@
         <input type=""text"" size=""50"" id=""query"" name=""query"" value=""<%= (query==null ? """" : Utils.addEntities(query)) %>""/>
         <input type=""submit"" id=""main-query-submit"" class=""btn btn-primary"" value=""<fmt:message key=""jsp.general.go""/>"" />
 <% if (StringUtils.isNotBlank(spellCheckQuery)) {%>
-	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= spellCheckQuery %></a></fmt:param></fmt:message></p>
+	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= Utils.addEntities(spellCheckQuery) %></a></fmt:param></fmt:message></p>
 <% } %>                  
         <input type=""hidden"" value=""<%= rpp %>"" name=""rpp"" />
         <input type=""hidden"" value=""<%= Utils.addEntities(sortedBy) %>"" name=""sort_by"" />",[DS-4453] Fix XSS handling in JSPUI discovery spellcheck,"vuln-fix: Prevent XSS by encoding spellCheckQuery output in JSP

The vulnerability was that spellCheckQuery was output without proper HTML entity encoding, allowing injection of malicious scripts in the rendered page. This posed a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in users’ browsers. The fix applies HTML entity encoding to spellCheckQuery before outputting it, ensuring unsafe characters are escaped and scripts cannot be injected.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'secword', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
93,{'CWE-79'},GHSA-r5jw-62xg-j433,"@@ -2,7 +2,7 @@
 
 module Kaminari
   module Helpers
-    PARAM_KEY_EXCEPT_LIST = [:authenticity_token, :commit, :utf8, :_method, :script_name].freeze
+    PARAM_KEY_EXCEPT_LIST = [:authenticity_token, :commit, :utf8, :_method, :script_name, :original_script_name].freeze
 
     # A tag stands for an HTML tag inside the paginator.
     # Basically, a tag has its own partial template file, so every tag can be","Blacklist ""original_script_name"" get param","vuln-fix: Prevent exposure of original_script_name parameter in pagination

The original_script_name parameter was not excluded from pagination parameters, allowing it to be unintentionally exposed or manipulated in generated URLs.
This could lead to information leakage or URL manipulation attacks by revealing internal routing details or enabling crafted requests.
The fix adds original_script_name to the exclusion list, preventing it from being included in pagination parameter processing and output.

Weakness: Information Exposure (CWE-200)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('blacklist', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('manipulated', 'ACTION', ''), ('information leakage', 'secword', ''), ('url manipulation', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
94,{'CWE-79'},GHSA-8w3x-r6x7-c5r5,"@@ -607,7 +607,12 @@ pimcore.object.classes.klass = Class.create({
                 for (var i = 0; i < items.length; i++) {
                     var item = items[i];
                     if (typeof item.getValue == ""function"") {
-                        this.data[item.name] = item.getValue();
+                        let value = item.getValue();
+                        if (typeof item.config.xtype !== 'undefined' && item.config.xtype === 'textfield') {
+                            value = Ext.util.Format.htmlEncode(value);
+                        }
+
+                        this.data[item.name] = value;
                     }
                 }
 
@@ -705,6 +710,7 @@ pimcore.object.classes.klass = Class.create({
             id: ""iconfield-"" + this.getId(),
             name: ""icon"",
             width: 396,
+            renderer: Ext.util.Format.htmlEncode,
             value: this.data.icon,
             listeners: {
                 ""afterrender"": function (el) {
@@ -752,6 +758,7 @@ pimcore.object.classes.klass = Class.create({
                     width: 500,
                     enableKeyEvents: true,
                     value: this.data.name,
+                    renderer: Ext.util.Format.htmlEncode,
                     listeners: {
                         keyup: function (el) {
                             this.rootPanel.getComponent(""phpClassName"").setValue(getPhpClassName(el.getValue()))
@@ -763,12 +770,14 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""description""),
                     name: ""description"",
                     width: 500,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.description
                 },
                 {
                     xtype: ""textfield"",
                     fieldLabel: t(""unique_identifier""),
                     disabled: true,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.id,
                     width: 500
                 },
@@ -779,6 +788,7 @@ pimcore.object.classes.klass = Class.create({
                     itemId: ""phpClassName"",
                     width: 500,
                     disabled: true,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: getPhpClassName(this.data.name)
                 },
                 {
@@ -786,6 +796,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""parent_php_class""),
                     name: ""parentClass"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.parentClass
                 },
                 {
@@ -793,6 +804,7 @@ pimcore.object.classes.klass = Class.create({
                     width: 600,
                     name: ""implementsInterfaces"",
                     fieldLabel: t(""implements_interfaces""),
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.implementsInterfaces
                 },
                 {
@@ -800,6 +812,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""use_traits""),
                     name: ""useTraits"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.useTraits
                 },
                 {
@@ -807,6 +820,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""listing_parent_php_class""),
                     name: ""listingParentClass"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.listingParentClass
                 },
                 {
@@ -814,6 +828,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""listing_use_traits""),
                     name: ""listingUseTraits"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.listingUseTraits
                 },
                 {
@@ -821,6 +836,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""link_generator_reference""),
                     name: ""linkGeneratorReference"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.linkGeneratorReference
                 },
                 {
@@ -828,6 +844,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""preview_generator_reference""),
                     name: ""previewGeneratorReference"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.previewGeneratorReference
                 },
                 {
@@ -835,6 +852,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""preview_url""),
                     name: ""previewUrl"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.previewUrl
                 },
                 {
@@ -885,6 +903,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""group""),
                     name: ""group"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.group
                 },
                 this.allowInheritance,","[Admin UI] DataObject Class - escape general settings input values (#10991)

* [Admin UI] DataObject Class - escape general settings input values

* Update bundles/AdminBundle/Resources/public/js/pimcore/object/classes/class.js

* [Admin UI] DataObject Class - escape general settings input values

* [Admin UI] DataObject Class - escape general settings input values","vuln-fix: Prevent XSS by encoding user input in UI fields

User input was directly assigned and rendered in multiple text fields without proper HTML encoding, allowing injection of malicious scripts.
This posed a critical cross-site scripting risk that could lead to session hijacking or unauthorized actions in the application.
The fix applies HTML encoding to all relevant input values before rendering, ensuring special characters are safely escaped in the UI.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: Critical  
CVSS: 9.8",0.11764705882352941,"[('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('#10991', 'ISSUE', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('update', 'ACTION', ''), ('adminbundle', 'SECWORD', ''), ('class.js', 'URL', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('cross-site scripting', 'secword', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
95,{'CWE-79'},GHSA-7jh9-6cpf-h4m7,"@@ -1388,8 +1388,12 @@ hello.utils.extend(hello.utils, {
 		// (URI Fragments within 302 Location URI are lost over HTTPS)
 		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
 		else if ('oauth_redirect' in p) {
+			var url = decodeURIComponent(p.oauth_redirect);
+
+			if (isValidUrl(url)) {
+				location.assign(url);
+			}
 
-			location.assign(decodeURIComponent(p.oauth_redirect));
 			return;
 		}",fix(xss): oauth_redirect should be a valid url,"vuln-fix: Validate redirect URL before OAuth redirection

The OAuth redirect URL was used without validation, allowing attackers to supply malicious URLs for redirection.  
This could lead to open redirect vulnerabilities, enabling phishing or redirecting users to harmful sites.  
The fix adds a URL validation check to ensure only safe, valid URLs are used before performing the redirection.  

Weakness: Open Redirect (CWE-601)  
Severity: Medium  
CVSS: 5.4",0.11764705882352941,"[('fix(xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('oauth', 'secword', ''), ('oauth', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('open redirect', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('phishing', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('open redirect', 'secword', ''), ('cwe-601', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
96,{'CWE-79'},GHSA-vx6v-xg64-pmr8,"@@ -330,7 +330,11 @@ <h5 class=""mb-0"">
         function get_url(row) {
             return ""{% url 'helpdesk:view' 1234 %}"".replace(/1234/, row.id.toString());
         }
-
+        
+        function htmlEntities(str) {
+            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+        }
+        
         $(document).ready(function () {
             // Ticket DataTable Initialization
             $('#ticketTable').DataTable({
@@ -366,7 +370,7 @@ <h5 class=""mb-0"">
                             if (type === 'display') {
                                 data = '<div class=""tickettitle""><a href=""' + get_url(row) + '"" >' +
                                     row.id + '. ' +
-                                    row.title + '</a></div>';
+                                    htmlEntities(row.title) + '</a></div>';
                             }
                             return data
                         }","Add function `htmlEntities`

`htmlentities()` is a function which converts special characters. This allows you to show to display the string without the browser reading it as HTML.","vuln-fix: Escape HTML entities in ticket titles to prevent XSS

The vulnerability was that ticket titles were rendered without escaping, allowing injection of malicious HTML or scripts in the user interface.
This posed a security risk by enabling cross-site scripting attacks, potentially compromising user sessions or stealing sensitive data.
The fix introduces a function to escape HTML entities in ticket titles before rendering, preventing execution of injected code in the browser.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('add', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('htmlentities', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
97,{'CWE-79'},GHSA-rcvx-rmvf-mxch,"similarity index 64%
rename from hawkbit-runtime/hawkbit-update-server/src/main/java/org/eclipse/hawkbit/app/StreamAwareErrorController.java
rename to hawkbit-runtime/hawkbit-update-server/src/main/java/org/eclipse/hawkbit/app/ErrorController.java
@@ -8,6 +8,8 @@
  */
 package org.eclipse.hawkbit.app;
 
+import java.util.Map;
+
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
@@ -23,22 +25,23 @@
 /**
  * Error page controller that ensures that ocet stream does not return text in
  * case of an error.
- *
  */
 @Controller
 // Exception squid:S3752 - errors need handling for all methods
 @SuppressWarnings(""squid:S3752"")
-public class StreamAwareErrorController extends BasicErrorController {
+public class ErrorController extends BasicErrorController {
+
+    private static final String PATH = ""path"";
 
     /**
-     * A new {@link StreamAwareErrorController}.
+     * A new {@link ErrorController}.
      * 
      * @param errorAttributes
      *            the error attributes
      * @param serverProperties
      *            configuration properties
      */
-    public StreamAwareErrorController(final ErrorAttributes errorAttributes, final ServerProperties serverProperties) {
+    public ErrorController(final ErrorAttributes errorAttributes, final ServerProperties serverProperties) {
         super(errorAttributes, serverProperties.getError());
     }
 
@@ -48,4 +51,19 @@ public ResponseEntity<Void> errorStream(final HttpServletRequest request, final
         return new ResponseEntity<>(status);
     }
 
+    @Override
+    @RequestMapping
+    public ResponseEntity<Map<String, Object>> error(final HttpServletRequest request) {
+        final HttpStatus status = getStatus(request);
+        final Map<String, Object> body = getErrorAttributesWithoutPath(request);
+        return new ResponseEntity<>(body, status);
+    }
+
+    private Map<String, Object> getErrorAttributesWithoutPath(final HttpServletRequest request) {
+        final Map<String, Object> body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));
+        if (body != null && body.containsKey(PATH)) {
+            body.remove(PATH);
+        }
+        return body;
+    }
 }","Fixes #1067

JSON body response for HTTP 404 error may contain unsafe URL path characters. Thus removing path from the response

Signed-off-by: Dominic Schabel <dominic.schabel@bosch.io>","vuln-fix: Prevent path disclosure in error responses

The error controller exposed the request path in error response bodies, revealing internal URL structures to clients. This information disclosure could aid attackers in mapping the application and crafting targeted attacks. The fix removes the path attribute from error responses to avoid leaking sensitive routing details. 

Weakness: Information Exposure Through Error Messages (CWE-209)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('fixes', 'ACTION', ''), ('#1067', 'ISSUE', ''), ('error', 'FLAW', ''), ('unsafe', 'SECWORD', ''), ('removing', 'ACTION', ''), ('signed', 'secword', ''), ('dominic.schabel@bosch.io', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('path disclosure', 'SECWORD', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('disclosure', 'secword', ''), ('attackers', 'FLAW', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('error', 'FLAW', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('error', 'FLAW', ''), ('cwe-209', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
98,{'CWE-79'},GHSA-wjh9-344g-vc49,"@@ -200,7 +200,7 @@ function( $match ) {
 
 	foreach ( $remove as $remove_string )
 	{
-		while ( strpos( $string, $remove_string ) !== false )
+		while ( stripos( $string, $remove_string ) !== false )
 		{
 			$string = str_ireplace( $remove, '', $string );
 		}",Fix stored XSS security issue: remove inline JS from URL in PreparePHP_SELF.fnc.php,"vuln-fix: Prevent case-insensitive string removal to avoid bypass

The vulnerability allowed case-sensitive checks that missed variations of dangerous substrings, enabling attackers to bypass filtering by altering letter case.
This posed a security risk by permitting malicious input to evade sanitization and potentially execute harmful actions or injections.
The fix changes the check to case-insensitive, ensuring all case variants of the target strings are detected and removed consistently.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('security', 'SECWORD', ''), ('issue', 'FLAW', ''), ('remove', 'ACTION', ''), ('preparephp_self.fnc.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('sanitization', 'secword', ''), ('injections', 'SECWORD', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('removed', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
99,{'CWE-79'},GHSA-gx5w-rrhp-f436,"@@ -145,6 +145,11 @@ window.search = window.search || {};
             url.push("""");
         }
 
+        // encodeURIComponent escapes all chars that could allow an XSS except
+        // for '. Due to that we also manually replace ' with its url-encoded
+        // representation (%27).
+        var searchterms = encodeURIComponent(searchterms.join("" "")).replace(/\'/g, ""%27"");
+
         return '<a href=""' + path_to_root + url[0] + '?' + URL_MARK_PARAM + '=' + searchterms + '#' + url[1]
             + '"" aria-details=""teaser_' + teaser_count + '"">' + result.doc.breadcrumbs + '</a>'
             + '<span class=""teaser"" id=""teaser_' + teaser_count + '"" aria-label=""Search Result Teaser"">'","fix xss in the search page

Thanks to Kamil Vavra for responsibly disclosing the vulnerability
according to Rust's Security Policy.","vuln-fix: Prevent XSS by encoding single quotes in search terms

The vulnerability was that single quotes in search terms were not URL-encoded, allowing potential injection of malicious scripts via crafted URLs. This posed a security risk by enabling cross-site scripting attacks through unescaped characters in generated links. The fix encodes single quotes as %27 after encodeURIComponent to ensure all dangerous characters are properly escaped in URLs.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('security', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('encoded', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encodes', 'SECWORD', ''), ('encodeuricomponent', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
100,{'CWE-79'},GHSA-6m26-25q2-cq46,"@@ -4,6 +4,7 @@
 
 use Conner\Tagging\Model\Tagged;
 use \Intervention\Image\ImageManagerStatic as Image;
+use MicroweberPackages\Helper\HTMLClean;
 use MicroweberPackages\Media\Models\Media;
 use MicroweberPackages\Media\Models\MediaThumbnail;
 use MicroweberPackages\Utils\Media\Thumbnailer;
@@ -1184,6 +1185,10 @@ public function thumbnail_img($params)
 
     public function create_media_dir($params)
     {
+
+        $clean = new HTMLClean();
+        $_REQUEST = $clean->cleanArray($_REQUEST);
+
         must_have_access();
         $resp = array();
         // $target_path = media_base_path() . 'uploaded' . DS;
@@ -1198,7 +1203,7 @@ public function create_media_dir($params)
 
             $target_path = $fn_path;
         }
-        if (!isset($_REQUEST['name'])) {
+        if (!isset($_REQUEST['name']) || empty($_REQUEST['name'])) {
             $resp = array('error' => 'You must send new_folder parameter');
         } else {
             $fn_new_folder_path = $_REQUEST['name'];",add xss clean to create media dir method,"vuln-fix: Sanitize user input in create_media_dir to prevent XSS

User input from the $_REQUEST array was not sanitized before use, allowing injection of malicious HTML or scripts in directory names.
This poses a security risk by enabling cross-site scripting attacks that could compromise user sessions or site integrity.
The fix applies HTML cleaning to all $_REQUEST inputs using a dedicated sanitizer before processing directory creation requests.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('sanitized', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
101,{'CWE-79'},GHSA-6jp6-9rf9-gc66,"@@ -1131,7 +1131,9 @@ $(function () {
       return """";
     },
     menuItemTemplate: function (item) {
-      return `<a>${item.string}</a>`;
+      let link = document.createElement(""a"");
+      link.innerText = item.string;
+      return link.outerHTML;
     },
     values: (text, callback) => {
       $.ajax({","js: Add missing escaping to username completion

Fixes https://hackerone.com/reports/1486674","vuln-fix: Prevent XSS by safely rendering menu item strings

The vulnerability was caused by directly injecting unescaped HTML strings into the menu item template, allowing malicious scripts to execute.
This is a security risk because attackers could exploit it to perform cross-site scripting attacks and compromise user data or session integrity.
The fix replaces raw HTML injection with safe text assignment using DOM methods to ensure proper escaping of potentially dangerous characters.


Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('escaping', 'secword', ''), ('fixes', 'ACTION', ''), ('https://hackerone.com/reports/1486674', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('injection', 'SECWORD', ''), ('safe', 'secword', ''), ('ensure', 'ACTION', ''), ('escaping', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
102,{'CWE-79'},GHSA-c558-5gfm-p2r8,"@@ -147,7 +147,7 @@
 									tmp_val = item.displayedValue;
 								}
 								return {
-									label: item.displayedValue + "" ("" + item.count + "")"",
+									label: escapeHtml(item.displayedValue) + "" ("" + item.count + "")"",
 									value: tmp_val
 								};
 							}))			
@@ -159,6 +159,11 @@
 	function validateFilters() {
 		return document.getElementById(""filterquery"").value.length > 0;
 	}
+	// Generic HTML escape utility
+	var escapeHtml = s => (s + '').replace(/[&<>""']/g, m => ({
+		'&': '&amp;', '<': '&lt;', '>': '&gt;',
+		'""': '&quot;', ""'"": '&#39;'
+	})[m]);
 </script>		
 </c:set>",[DS-4453] Fix XSS handling in JSPUI discovery autocomplete,"vuln-fix: Escape HTML in filter labels to prevent XSS

User-supplied values in filter labels were rendered without escaping, allowing injection of malicious HTML or scripts into the page.
This posed a security risk by enabling cross-site scripting attacks that could compromise user data or session integrity.
The fix introduces a generic HTML escape function and applies it to all displayed filter labels before rendering them in the UI.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
103,{'CWE-79'},GHSA-qf2g-q4mc-w7rr,"@@ -839,7 +839,7 @@ public static function processModuleXml(\SimpleXMLElement $xml): array
         $information['name'] = (string) $module->name;
         $information['version'] = (string) $module->version;
         $information['requirements'] = (array) $module->requirements;
-        $information['description'] = (string) $module->description;
+        $information['description'] = strip_tags((string) $module->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');
         $information['cronjobs'] = [];
 
         // authors
@@ -900,7 +900,7 @@ public static function processThemeXml(\SimpleXMLElement $xml): array
         $information['version'] = (string) $theme->version;
         $information['requirements'] = (array) $theme->requirements;
         $information['thumbnail'] = (string) $theme->thumbnail;
-        $information['description'] = (string) $theme->description;
+        $information['description'] = strip_tags((string) $theme->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');
 
         // authors
         foreach ($xml->xpath('/theme/authors/author') as $author) {",Fix xss though the description in the info.xml file of a theme or module,"vuln-fix: Sanitize module and theme descriptions to prevent XSS

The vulnerability involved unsanitized HTML content in module and theme descriptions, allowing injection of malicious scripts. This posed a security risk by enabling cross-site scripting attacks that could compromise user data and site integrity. The fix applies a whitelist-based strip_tags function to allow only safe HTML tags, effectively mitigating XSS risks in descriptions.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('info.xml', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('vulnerability', 'secword', ''), ('unsanitized', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
104,{'CWE-79'},GHSA-wrp6-9w7f-3wxg,"@@ -248,7 +248,7 @@ $(""#btn-upload-format"").on(""change"", function () {
     if (filename.substring(3, 11) === ""fakepath"") {
         filename = filename.substring(12);
     } // Remove c:\fake at beginning from localhost chrome
-    $(""#upload-format"").html(filename);
+    $(""#upload-format"").text(filename);
 });
 
 $(""#btn-upload-cover"").on(""change"", function () {
@@ -256,7 +256,7 @@ $(""#btn-upload-cover"").on(""change"", function () {
     if (filename.substring(3, 11) === ""fakepath"") {
         filename = filename.substring(12);
     } // Remove c:\fake at beginning from localhost chrome
-    $(""#upload-cover"").html(filename);
+    $(""#upload-cover"").text(filename);
 });
 
 $(""#xchange"").click(function () {",Fix upload of cover and book formats containing html characters,"vuln-fix: Prevent XSS by using text() instead of html() for filenames

User-supplied filenames were inserted into the DOM using html(), allowing malicious HTML or script injection via crafted filenames.
This posed a cross-site scripting risk, enabling attackers to execute arbitrary scripts in the context of the affected page.
The fix replaces html() with text() to safely encode filenames as plain text, preventing execution of injected code. 

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('malicious', 'secword', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('encode', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
105,{'CWE-79'},GHSA-49qr-xh3w-h436,"@@ -78,6 +78,13 @@ class NbconvertFileHandler(IPythonHandler):
 
     SUPPORTED_METHODS = ('GET',)
 
+    @property
+    def content_security_policy(self):
+        # In case we're serving HTML/SVG, confine any Javascript to a unique
+        # origin so it can't interact with the notebook server.
+        return super(NbconvertFileHandler, self).content_security_policy + \
+               ""; sandbox allow-scripts""
+
     @web.authenticated
     def get(self, format, path):
 
@@ -145,6 +152,13 @@ def get(self, format, path):
 class NbconvertPostHandler(IPythonHandler):
     SUPPORTED_METHODS = ('POST',)
 
+    @property
+    def content_security_policy(self):
+        # In case we're serving HTML/SVG, confine any Javascript to a unique
+        # origin so it can't interact with the notebook server.
+        return super(NbconvertPostHandler, self).content_security_policy + \
+               ""; sandbox allow-scripts""
+
     @web.authenticated
     def post(self, format):
         exporter = get_exporter(format, config=self.config)","Apply CSP sandboxing for nbconvert responses

These may contain untrusted content, so they should be treated as being
from a different domain to the notebook server.","vuln-fix: Enforce sandboxed content security policy on nbconvert handlers

The nbconvert file and post handlers lacked sandbox restrictions, allowing served HTML/SVG content to execute JavaScript with full access to the notebook server context. This posed a risk of cross-site scripting attacks that could compromise server integrity and user data. The fix adds a sandbox directive with allow-scripts to the content security policy, isolating JavaScript execution and preventing interaction with the notebook server environment.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.5",0.17647058823529413,"[('untrusted', 'secword', ''), ('server', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('content security policy', 'secword', ''), ('sandbox', 'secword', ''), ('server', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('server', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('sandbox', 'secword', ''), ('content security policy', 'secword', ''), ('preventing', 'ACTION', ''), ('server', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'secword', ''), ('high', 'SEVERITY', '')]"
106,{'CWE-79'},GHSA-38m9-3vg4-rwvp,"@@ -114,6 +114,9 @@ public function redirect($url)
         $redirectUrl = str_replace(""\r"", """", $redirectUrl);
         $redirectUrl = str_replace(""\n"", """", $redirectUrl);
 
+        $clearInput = new HTMLClean();
+        $redirectUrl = $clearInput->clean($redirectUrl);
+
         if (headers_sent()) {
             echo '<meta http-equiv=""refresh"" content=""0;url=' . $redirectUrl . '"">';
         } else {",Update UrlManager.php,"vuln-fix: Sanitize redirect URL to prevent injection attacks

The redirect URL was not fully sanitized, allowing potential injection of malicious HTML or scripts through crafted input. This posed a security risk by enabling cross-site scripting or header injection attacks during redirection. The fix applies HTML cleaning to the redirect URL, removing harmful characters and ensuring safe output in headers and meta tags.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', ''), ('urlmanager.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'secword', ''), ('high', 'SEVERITY', '')]"
107,{'CWE-79'},GHSA-vfrc-ggmc-5jwv,"@@ -145,6 +145,7 @@ def process_attachments(followup, attached_files):
                 'application/octet-stream',
                 size=attached.size,
             )
+            att.full_clean()
             att.save()
 
             if attached.size < max_email_attachment_size:","Add `att.full_clean()` before saving

Fix issue https://github.com/django-helpdesk/django-helpdesk/issues/983
Also, fix bug stored XSS disclosure: https://huntr.dev/bounties/4d7a5fdd-b2de-467a-ade0-3f2fb386638e/","vuln-fix: Validate attachment data before saving to prevent invalid input

Attachment objects were saved without validation, allowing malformed or malicious data to be persisted in the database.
This posed a risk of data corruption or injection attacks through unchecked attachment fields.
The fix adds a call to full_clean() on attachment instances to enforce model validation before saving. 

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('add', 'ACTION', ''), ('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('https://github.com/django-helpdesk/django-helpdesk/issues/983', 'URL', ''), ('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('xss', 'SECWORD', ''), ('disclosure', 'secword', ''), ('https://huntr.dev/bounties/4d7a5fdd-b2de-467a-ade0-3f2fb386638e/', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('malicious', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
108,{'CWE-79'},GHSA-3fw8-66wf-pr7m,"@@ -152,7 +152,7 @@ app.handle = function(req, res, out) {
         res.statusCode = 404;
         res.setHeader('Content-Type', 'text/plain');
         if ('HEAD' == req.method) return res.end();
-        res.end('Cannot ' + req.method + ' ' + utils.escape(req.originalUrl));
+        res.end('Cannot ' + utils.escape(req.method) + ' ' + utils.escape(req.originalUrl));
       }
       return;
     }
@@ -202,7 +202,7 @@ app.handle = function(req, res, out) {
  * Listen for connections.
  *
  * This method takes the same arguments
- * as node's `http.Server#listen()`.  
+ * as node's `http.Server#listen()`.
  *
  * HTTP and HTTPS:
  *
@@ -214,9 +214,9 @@ app.handle = function(req, res, out) {
  *      var connect = require('connect')
  *        , http = require('http')
  *        , https = require('https');
- *      
+ *
  *      var app = connect();
- *      
+ *
  *      http.createServer(app).listen(80);
  *      https.createServer(options, app).listen(443);
  *",fix: escape req.method in 404 response,"vuln-fix: Escape HTTP method in error response to prevent XSS

The vulnerability was that the HTTP method in error messages was not escaped, allowing injection of malicious scripts via crafted request methods.
This is a security risk because it enables cross-site scripting (XSS) attacks, potentially compromising user data and session integrity.
The fix escapes the HTTP method string before including it in the response, preventing script injection through the method field.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('req.method', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('error', 'FLAW', ''), ('escaped', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
109,{'CWE-79'},GHSA-455w-gv5p-wgg3,"@@ -37,6 +37,11 @@ class TargetingController extends AdminController implements KernelControllerEve
 {
     // RULES
 
+    private function correctName(string $name): string
+    {
+        return preg_replace('/[#?*:\\\\<>|""%&@=;+]/', '-', $name);
+    }
+
     /**
      * @Route(""/rule/list"", name=""pimcore_admin_targeting_rulelist"", methods={""GET""})
      *
@@ -55,7 +60,7 @@ public function ruleListAction(Request $request)
         foreach ($list->load() as $target) {
             $targets[] = [
                 'id' => $target->getId(),
-                'text' => $target->getName(),
+                'text' => htmlspecialchars($target->getName()),
                 'active' => $target->getActive(),
                 'qtip' => 'ID: ' . $target->getId(),
             ];
@@ -74,7 +79,7 @@ public function ruleListAction(Request $request)
     public function ruleAddAction(Request $request)
     {
         $target = new Targeting\Rule();
-        $target->setName($request->get('name'));
+        $target->setName($this->correctName($request->get('name')));
         $target->save();
 
         return $this->adminJson(['success' => true, 'id' => $target->getId()]);
@@ -129,6 +134,7 @@ public function ruleSaveAction(Request $request)
         /** @var Targeting\Rule|Targeting\Rule\Dao $target */
         $target = Targeting\Rule::getById($request->get('id'));
         $target->setValues($data['settings']);
+        $target->setName($this->correctName($target->getName()));
         $target->setConditions($data['conditions']);
         $target->setActions($data['actions']);
         $target->save();
@@ -208,7 +214,7 @@ public function targetGroupListAction(Request $request)
         foreach ($list->load() as $targetGroup) {
             $targetGroups[] = [
                 'id' => $targetGroup->getId(),
-                'text' => $targetGroup->getName(),
+                'text' => htmlspecialchars($targetGroup->getName()),
                 'active' => $targetGroup->getActive(),
                 'qtip' => $targetGroup->getId(),
             ];
@@ -230,7 +236,7 @@ public function targetGroupAddAction(Request $request, CoreCacheHandler $cache,
     {
         /** @var TargetGroup|TargetGroup\Dao $targetGroup */
         $targetGroup = new TargetGroup();
-        $targetGroup->setName($request->get('name'));
+        $targetGroup->setName($this->correctName($request->get('name')));
         $targetGroup->save();
 
         $event = new TargetGroupEvent($targetGroup);
@@ -300,6 +306,7 @@ public function targetGroupSaveAction(Request $request, CoreCacheHandler $cache,
         /** @var TargetGroup|TargetGroup\Dao $targetGroup */
         $targetGroup = TargetGroup::getById($request->get('id'));
         $targetGroup->setValues($data['settings']);
+        $targetGroup->setName($this->correctName($targetGroup->getName()));
         $targetGroup->save();
 
         $event = new TargetGroupEvent($targetGroup);","[Targeting] Escape/validate names of rules properly (#11205)

* [Targeting] Escape/validate names of rules properly

* Update bundles/AdminBundle/Controller/Admin/TargetingController.php

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>","vuln-fix: Sanitize and encode user input for targeting names

User-supplied names for targeting rules and groups were not properly sanitized, allowing special characters that could lead to injection or display issues. This posed a risk of cross-site scripting (XSS) and other injection attacks by enabling malicious input to be stored and rendered unsafely. The fix introduces input sanitization by replacing dangerous characters with safe ones and applies HTML escaping when outputting names to prevent script execution.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('escape', 'secword', ''), ('validate', 'secword', ''), ('#11205', 'ISSUE', ''), ('escape', 'SECWORD', ''), ('validate', 'secword', ''), ('update', 'ACTION', ''), ('adminbundle', 'SECWORD', ''), ('admin', 'SECWORD', ''), ('targetingcontroller.php', 'URL', ''), ('j.dreesen@neusta.de', 'EMAIL', ''), ('j.dreesen@neusta.de', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('issues', 'FLAW', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('unsafely', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('safe', 'secword', ''), ('escaping', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
110,{'CWE-79'},GHSA-3q55-66g3-p8xq,"@@ -834,10 +834,262 @@ function get_dangerous_files_extentions()
             'xqt',        //    SuperCalc Macro File',
             'xys',        //    XYplorer Script File',
             'zl9',        //    ZoneAlarm Quarantined EXE File
-
-
             'swf',        //    Flash File
 
+            'key',
+            'asax',
+            'btapp',
+            'xd',
+            'fwtemplate',
+            'crdownload',
+            'whtt',
+            'ssp',
+            'fmp',
+            'jspa',
+            'obml16',
+            'a5w',
+            'crt',
+            'vrt',
+            'website',
+            'p7c',
+            'dll',
+            'php',
+            'mjs',
+            'dhtml',
+            'xul',
+            'bml',
+            'download',
+            'cshtml',
+            'vsdisco',
+            'codasite',
+            'webbookmark',
+            'rjs',
+            'wsdl',
+            'dml',
+            'aro',
+            'dcr',
+            'shtml',
+            'dochtml',
+            'dwt',
+            'spc',
+            'a4p',
+            'htaccess',
+            'ascx',
+            'pac',
+            'p7b',
+            'xhtm',
+            'oam',
+            'site',
+            'kit',
+            'aspx',
+            'zul',
+            'tpl',
+            'htm',
+            'seam',
+            'svr',
+            'pem',
+            'url',
+            'dap',
+            'appcache',
+            'chm',
+            'wbs',
+            'htc',
+            'ewp',
+            'gsp',
+            'asr',
+            'der',
+            'master',
+            'stc',
+            'ap',
+            'html',
+            'p12',
+            'xpd',
+            'fwp',
+            'epibrw',
+            'strm',
+            'xss',
+            'node',
+            'disco',
+            'gsp',
+            'pro',
+            'rss',
+            'gne',
+            'sdb',
+            'compressed',
+            'asp',
+            'browser',
+            'php2',
+            'sites2',
+            'dothtml',
+            'bok',
+            'axd',
+            'nzb',
+            'vdw',
+            'obml',
+            'mhtml',
+            'ashx',
+            'con',
+            'rhtml',
+            'alx',
+            'opml',
+            'web',
+            'chat',
+            'csr',
+            'do',
+            'sht',
+            'asa',
+            'cha',
+            'h5p',
+            'qf',
+            'olp',
+            'hyperesources',
+            'sparkle',
+            'razor',
+            'php4',
+            'cms',
+            'mml',
+            'jnlp',
+            'har',
+            'br',
+            'webloc',
+            'srf',
+            'cer',
+            'uhtml',
+            'pptmhtml',
+            'phtml',
+            'xbel',
+            'cfm',
+            'fwtemplateb',
+            'jspx',
+            'jsp',
+            'xfdl',
+            'zhtml',
+            'stml',
+            'jsonl',
+            'maff',
+            'dbm',
+            'aex',
+            'crl',
+            'mht',
+            'wml',
+            'sass',
+            'xht',
+            'awm',
+            'page',
+            'hdml',
+            'webmanifest',
+            'itms',
+            'sitemap',
+            'shtm',
+            'wpp',
+            'jss',
+            'oth',
+            'ucf',
+            'prf',
+            'freeway',
+            'edge',
+            'iqy',
+            'vrml',
+            'mvc',
+            'wdgt',
+            'discomap',
+            'psp',
+            'hxs',
+            'adr',
+            'hype',
+            'csp',
+            'xhtml',
+            'webarchive',
+            'qbo',
+            'jhtml',
+            'svc',
+            'phtm',
+            'rw3',
+            'tpl',
+            'stl',
+            'wbxml',
+            'p7',
+            'ndjson',
+            'ognc',
+            'fwtb',
+            'muse',
+            'vbd',
+            'sites',
+            'rt',
+            'esproj',
+            'private',
+            'srl',
+            'zhtml',
+            'vbhtml', 
+            'hypetemplate',
+            'obml15',
+            'hypesymbol',
+            'pub',
+            'ece',
+            'mspx',
+            'docmhtml',
+            'xws',
+            'wgp',
+            'tvpi',
+            'woa',
+            'asmx',
+            'xbl',
+            'webhistory',
+            'idc',
+            'jws',
+            'lbc',
+            'att',
+            'tvvi',
+            'zvz',
+            'php3',
+            'webarchivexml',
+            'widget',
+            'swz',
+            'qrm',
+            'bwp',
+            'atom',
+            'cdf',
+            'map',
+            'hdm',
+            'php5',
+            'rwsw',
+            'wgt',
+            'nod',
+            'rflw',
+            'htx',
+            'mvr',
+            'an',
+            'rwp',
+            'lasso',
+            'vlp',
+            'stp',
+            'nxg',
+            'faces',
+            'kcmsf',
+            'ptw',
+            'less',
+            'saveddeck',
+            'ccbjs',
+            'wn',
+            'ppthtml',
+            'jcz',
+            'jvs',
+            'rwtheme',
+            'jst',
+            'mapx',
+            'cpg',
+            'wpx',
+            'qbx',
+            'suck',
+            'iwdgt',
+            'public',
+            'cphd',
+            'moz',
+            'zfo',
+            'stm',
+            'fcgi',
+            'itpc',
+            'cfml'
         );",Update Files.php,"vuln-fix: Expand list of dangerous file extensions to block

The vulnerability was insufficient filtering of potentially dangerous file extensions, allowing risky files to bypass security checks and be uploaded or processed. This posed a security risk by enabling execution or distribution of malicious scripts and executables that could compromise the system. The fix expands the list of blocked file extensions to include many additional high-risk and executable types, improving detection and prevention of unsafe files.

Weakness: CWE-434: Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', ''), ('files.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('security', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('high', 'SEVERITY', ''), ('improving', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
111,{'CWE-79'},GHSA-q73m-3q7r-fpf7,"@@ -325,7 +325,7 @@ public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
 			'.mp3','.wav','.m4a','.ogg','.webma','.mp4','.flv',
-			'.mov','.webmv','.m3u8a','.flac','.mkv',
+			'.mov','.webmv','.flac','.mkv',
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
 			'.pdf','.ofd','.swf','.epub','.xps',
 			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps','.wpt',","Merge pull request #1632 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Remove unsupported file extension from allowed list

The file extension '.m3u8a' was incorrectly included in the allowed filename extensions, permitting potentially unsafe or unsupported media playlist files to be uploaded. Allowing such files can lead to security risks including unauthorized content execution or information disclosure. The fix removes the '.m3u8a' extension from the allowed list to restrict uploads to only verified safe file types.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('#1632', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('unsafe', 'secword', ''), ('security', 'secword', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('verified', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('medium', 'SEVERITY', '')]"
112,"{'CWE-80', 'CWE-79', 'CWE-116'}",GHSA-vmhh-xh3g-j992,"@@ -287,7 +287,7 @@
       &lt;form action=""$doc.getURL()"" method=""post""&gt;
         &lt;input type=""hidden"" name=""form_token"" value=""$services.csrf.token"" /&gt;
         &lt;input type=""hidden"" name=""action"" value=""create""/&gt;
-        &lt;input type=""hidden"" name=""newThemeName"" id=""newThemeName"" value=""$request.newThemeName"" /&gt;
+        &lt;input type=""hidden"" name=""newThemeName"" id=""newThemeName"" value=""$escapetool.xml($request.newThemeName)"" /&gt;
         &lt;input type=""submit"" value=""$services.localization.render('platform.flamingo.themes.home.create.confirm')"" class=""button""/&gt;
       &lt;/form&gt;
     {{/html}}",XWIKI-19294: Fix bad escaping,"vuln-fix: Escape user input in hidden form field to prevent XSS

User input for the newThemeName field was directly embedded in a hidden form input without escaping, allowing injection of malicious scripts.
This posed a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in users’ browsers and compromise session integrity.
The fix applies XML escaping to the newThemeName value before rendering it in the form, preventing script injection via this input field.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
113,{'CWE-79'},GHSA-c558-5gfm-p2r8,"@@ -196,7 +196,7 @@
                                 <input type=""text"" size=""50"" id=""query"" name=""query"" value=""<%= (query==null ? """" : Utils.addEntities(query)) %>""/>
                                 <input type=""submit"" id=""main-query-submit"" class=""btn btn-primary"" value=""<fmt:message key=""jsp.general.go""/>"" />
 <% if (StringUtils.isNotBlank(spellCheckQuery)) {%>
-	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= spellCheckQuery %></a></fmt:param></fmt:message></p>
+	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%=Utils.addEntities(spellCheckQuery) %></a></fmt:param></fmt:message></p>
 <% } %>                  
                                 <input type=""hidden"" value=""<%= rpp %>"" name=""rpp"" />
                                 <input type=""hidden"" value=""<%= Utils.addEntities(sortedBy) %>"" name=""sort_by"" />","[DS-4453] Escape spellcheck, autocomplete HTML (JSPUI)","vuln-fix: Prevent XSS by encoding spellCheckQuery in output

The vulnerability was that spellCheckQuery was not properly HTML-encoded in the anchor text, allowing injection of malicious scripts via crafted input. This posed a security risk by enabling cross-site scripting attacks that could execute arbitrary JavaScript in users’ browsers. The fix applies proper HTML entity encoding to spellCheckQuery in the anchor text to neutralize any embedded scripts.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('escape', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('encoded', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
114,{'CWE-79'},GHSA-gq77-3r6x-383w,"@@ -301,6 +301,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".svg"")
 			|| $isDangerStr($filename , "".htm"")
 			|| $isDangerStr($filename , ""%"")
+			|| $isDangerStr($filename , "".xml"")
 		) {
 			return true;
 		}",file upload bug,"vuln-fix: Prevent dangerous XML file uploads in filename validation

The filename validation did not check for XML file extensions, allowing potentially dangerous XML files to be uploaded and processed by the system. This poses a security risk as malicious XML files can exploit XML external entity (XXE) vulnerabilities or inject harmful content. The fix adds "".xml"" to the list of disallowed filename extensions to block such dangerous file uploads effectively.

Weakness: CWE-611: Improper Restriction of XML External Entity Reference
Severity: High
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'secword', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'secword', ''), ('vulnerabilities', 'secword', ''), ('inject', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-611', 'CWEID', ''), ('improper restriction', 'secword', ''), ('xml external entity reference', 'secword', ''), ('high', 'SEVERITY', '')]"
115,{'CWE-79'},GHSA-6346-5r4h-ff5x,"@@ -158,7 +158,7 @@ class=""btn btn-link btn-sm <?php if (isset($abandoned)): ?>font-weight-bold text
             $(document).ready(function () {
                 var searchOrdersByProduct = new mw.autoComplete({
                     element: ""#js-orders-search-by-products"",
-                    placeholder: ""<?php if ($productKeyword) { echo $productKeyword; } else { _e(""Search by products...""); }?>"",
+                    placeholder: ""<?php if ($productKeyword) { echo xss_clean($productKeyword); } else { _e(""Search by products...""); }?>"",
                     autoComplete:true,
                     ajaxConfig: {
                         method: 'get',",Update order_filtering.blade.php,"vuln-fix: Sanitize product keyword to prevent XSS in search placeholder

The product keyword was directly embedded into the search input placeholder without sanitization, allowing injection of malicious scripts. This posed a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in users’ browsers. The fix applies an XSS cleaning function to the product keyword before rendering it in the placeholder attribute.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', ''), ('order_filtering.blade.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('keyword', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('keyword', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('xss', 'secword', ''), ('keyword', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
116,{'CWE-79'},GHSA-6jp6-9rf9-gc66,"@@ -37,6 +37,7 @@
 from django.template.loader import render_to_string
 from django.urls import reverse
 from django.utils import timezone
+from django.utils.html import escape
 from django.utils.http import urlencode
 from django.utils.safestring import mark_safe
 from django.utils.translation import gettext
@@ -318,7 +319,7 @@ def render(self, name, value, attrs=None, renderer=None, **kwargs):
             # Render textare
             textarea = super().render(fieldname, val, attrs, renderer, **kwargs)
             # Label for plural
-            label = str(unit.translation.language)
+            label = escape(unit.translation.language)
             if len(values) != 1:
                 label = f""{label}, {plural.get_plural_label(idx)}""
             ret.append(","translate: Add missing escaping to language name

Fixes https://hackerone.com/reports/1486674","vuln-fix: Escape user-controlled language labels to prevent XSS

The vulnerability involved rendering user-controllable language labels without escaping, allowing injection of malicious HTML or JavaScript code in the output. This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user sessions or data. The fix applies proper HTML escaping to the language labels before rendering, mitigating the XSS vulnerability.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('escaping', 'secword', ''), ('fixes', 'ACTION', ''), ('https://hackerone.com/reports/1486674', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
117,{'CWE-79'},GHSA-3x96-m42v-hvh5,"@@ -87,11 +87,13 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
+    $autoSize = xss_clean($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
         $type = $_GET['type'];
     }
+    $type = xss_clean($type);
 
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
@@ -403,7 +405,9 @@
                 if (mw.notification) {
                     mw.notification.success('<?php _ejs('Settings are saved') ?>');
                 }
+                <?php if (isset($params['id'])) : ?>
                 mw.reload_module_parent('#<?php print $params['id']  ?>')
+                <?php endif; ?>
 
             });
 
@@ -440,9 +444,11 @@
 <body class=""mw-external-loading loading"">
 <div id=""settings-main"">
     <div id=""settings-container"">
-        <div class=""mw-module-live-edit-settings <?php print $params['id'] ?>""
-             id=""module-id-<?php print $params['id'] ?>"">{content}
-        </div>
+        <?php if (isset($params['id'])) : ?>
+            <div class=""mw-module-live-edit-settings <?php print $params['id'] ?>""
+                 id=""module-id-<?php print $params['id'] ?>"">{content}
+            </div>
+        <?php endif; ?>
     </div>
 </div>",update,"vuln-fix: Sanitize inputs and conditionally render module elements

User inputs from GET parameters were not sanitized, allowing potential cross-site scripting (XSS) attacks through unsanitized input values used in the application.
This is a security risk because attackers could inject malicious scripts, compromising user data and session integrity.
The fix applies XSS cleaning functions to inputs and conditionally renders HTML elements only when safe parameters are present, preventing injection and unauthorized DOM manipulation.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('sanitized', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('unsanitized', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('xss', 'secword', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
118,{'CWE-79'},GHSA-cqhr-jqvc-qw9p,"@@ -365,7 +365,7 @@ void writeMessageIfNotNull(String message, String partToRedirectTo,
 		if (message != null) {
 			writeln(SCRIPT_BEGIN);
 			// writeDirectly pour ne pas gérer de traductions si le message contient '#'
-			writeDirectly(""alert(\"""" + javascriptEncode(message) + ""\"");"");
+			writeDirectly(""alert(\"""" + htmlEncodeButNotSpace(javascriptEncode(message)) + ""\"");"");
 			writeln("""");
 			// redirect vers une url évitant que F5 du navigateur ne refasse l'action au lieu de faire un refresh
 			if (partToRedirectTo == null) {",fix XSS,"vuln-fix: Prevent XSS by encoding alert message properly

The vulnerability was improper encoding of alert messages allowing injection of malicious scripts via crafted input strings. This posed a security risk by enabling cross-site scripting attacks that could execute arbitrary JavaScript in users’ browsers. The fix applies additional HTML encoding after JavaScript encoding to neutralize special characters and prevent script injection in alert dialogs.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('improper encoding', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
119,{'CWE-79'},GHSA-3r95-23jp-mhvg,"@@ -513,10 +513,10 @@ function factory($, Helper, Icons) {
      */
     function setStageHeadline(title) {
       if (getUtility().isUndefinedOrNull(title)) {
-        title = buildTitleByFormElement();
+        title = buildTitleByFormElement().text();
       }
 
-      $(getHelper().getDomElementDataIdentifierSelector('stageHeadline')).html(title);
+      $(getHelper().getDomElementDataIdentifierSelector('stageHeadline')).text(title);
     };
 
     /**
@@ -981,10 +981,10 @@ function factory($, Helper, Icons) {
 
       getHelper()
         .getTemplatePropertyDomElement('_type', template)
-        .append(getFormElementDefinition(formElement, 'label'));
+        .append(document.createTextNode(getFormElementDefinition(formElement, 'label')));
       getHelper()
         .getTemplatePropertyDomElement('_identifier', template)
-        .append(formElement.get('identifier'));
+        .append(document.createTextNode(formElement.get('identifier')));
     };
 
     /**
@@ -1029,7 +1029,7 @@ function factory($, Helper, Icons) {
 
             getHelper()
               .getTemplatePropertyDomElement('_label', rowTemplate)
-              .append(collectionElementConfiguration['label']);
+              .append(document.createTextNode(collectionElementConfiguration['label']));
             $(getHelper().getDomElementDataIdentifierSelector('validatorsContainer'), $(template))
               .append(rowTemplate.html());
           }
@@ -1089,7 +1089,7 @@ function factory($, Helper, Icons) {
           }
         }
 
-        getHelper().getTemplatePropertyDomElement('_label', rowTemplate).append(label);
+        getHelper().getTemplatePropertyDomElement('_label', rowTemplate).append(document.createTextNode(label));
 
         if (isPreselected) {
           getHelper().getTemplatePropertyDomElement('_label', rowTemplate).addClass(","[SECURITY] Ensure text preview of multivalue items in form editor

Multivalue items in the form editor user interface were previewed
as HTML, but should be treated as scalar text only.

Resolves: #96743
Releases: main, 11.5, 10.4
Change-Id: I5e8dab26119490ecf19ac5d48c2bc7a5a00daaad
Security-Bulletin: TYPO3-CORE-SA-2022-003
Security-References: CVE-2022-31048
Reviewed-on: https://review.typo3.org/c/Packages/TYPO3.CMS/+/73297
Tested-by: Oliver Hader <oliver.hader@typo3.org>
Reviewed-by: Oliver Hader <oliver.hader@typo3.org>","vuln-fix: Prevent XSS by escaping dynamic content in DOM updates

The vulnerability involved inserting unescaped HTML content directly into the DOM, allowing attackers to inject malicious scripts via user-controllable inputs. This posed a critical security risk as it could lead to cross-site scripting attacks compromising user data and application integrity. The fix replaces direct HTML insertion with safe text node creation and text setting methods to properly escape content before rendering.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8",0.17647058823529413,"[('security', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('#96743', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('updates', 'ACTION', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('escape', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
120,{'CWE-79'},GHSA-jp6r-xcjj-5h7r,"@@ -79,7 +79,7 @@ class TextEncodingBruteForce extends Operation {
         let table = ""<table class='table table-hover table-sm table-bordered table-nonfluid'><tr><th>Encoding</th><th>Value</th></tr>"";
 
         for (const enc in encodings) {
-            const value = Utils.printable(encodings[enc], true);
+            const value = Utils.escapeHtml(Utils.printable(encodings[enc], true));
             table += `<tr><td>${enc}</td><td>${value}</td></tr>`;
         }",Fixed XSS in 'Text Encoding Brute Force. Closes #539,"vuln-fix: Escape HTML output to prevent XSS in encoding table

The vulnerability was that unescaped encoding values were directly inserted into HTML, allowing injection of malicious scripts in the output table. This is a security risk because it enables cross-site scripting (XSS) attacks, potentially compromising user data and session integrity. The fix applies HTML escaping to all encoding values before insertion, preventing execution of injected scripts in the rendered page.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fixed', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('#539', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('encoding', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
121,{'CWE-79'},GHSA-rxch-gp62-574w,"@@ -170,7 +170,7 @@ public function transformAssignedTo($asset)
         }
         return $asset->assigned ? [
             'id' => $asset->assigned->id,
-            'name' => $asset->assigned->display_name,
+            'name' => e($asset->assigned->display_name),
             'type' => $asset->assignedType()
         ] : null;
     }","Added escape to assigned_to API response

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Escape assigned display name to prevent XSS

The vulnerability was that the assigned display name was output without escaping, allowing injection of malicious scripts in the rendered HTML.
This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or steal sensitive data.
The fix applies proper HTML escaping to the display name before output, mitigating the risk of script injection in the UI.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.17647058823529413,"[('added', 'ACTION', ''), ('escape', 'SECWORD', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
122,{'CWE-79'},GHSA-6465-r752-2h8v,"@@ -24,6 +24,7 @@
 use FacturaScripts\Core\Base\DataBase\DataBaseWhere;
 use FacturaScripts\Core\Lib\Widget\VisualItemLoadEngine;
 use FacturaScripts\Dinamic\Model\CodeModel;
+use FacturaScripts\Dinamic\Model\Page;
 use FacturaScripts\Dinamic\Model\PageOption;
 use FacturaScripts\Dinamic\Model\User;
 use Symfony\Component\HttpFoundation\Response;
@@ -121,7 +122,7 @@ public function privateCore(&$response, $user, $permissions)
         parent::privateCore($response, $user, $permissions);
         $this->model = new PageOption();
         $this->loadSelectedViewName();
-        $this->backPage = $this->request->get('url') ?: $this->selectedViewName;
+        $this->setBackPage();
         $this->selectedUser = $this->user->admin ? $this->request->get('nick') : $this->user->nick;
         $this->loadPageOptions();
 
@@ -275,6 +276,22 @@ private function loadPageOptionsForUser(): bool
         return true;
     }
 
+    private function setBackPage()
+    {
+        // check if the url is a real controller name
+        $url = $this->request->get('url', '');
+        $pageModel = new Page();
+        foreach ($pageModel->all([], [], 0, 0) as $page) {
+            if (substr($url, 0, strlen($page->name)) === $page->name) {
+                $this->backPage = $url;
+                return;
+            }
+        }
+
+        // set the default back page
+        $this->backPage = $this->selectedViewName;
+    }
+
     /**
      * @param array $column
      * @param string $name","We check the url parameter of the link to ensure that it is a valid controller.
------
Comprobamos el parámetro url del enlace para asegurar que sea un controlador válido.","vuln-fix: Validate backPage parameter against known controllers

The backPage URL parameter was directly assigned from user input without validation, allowing attackers to inject arbitrary URLs or controller names.
This could lead to unauthorized access or manipulation of application flow by referencing invalid or malicious pages.
The fix validates the backPage parameter by checking it against existing controller names and defaults to a safe page if no match is found.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('ensure', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('found', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
123,{'CWE-79'},GHSA-2gqg-2rg7-gh33,"@@ -118,8 +118,8 @@ private function formatMessage($message)
         return [
             'severity'  => $this->severityLabel($level),
             'timestamp' => $displayTime,
-            'source'    => $device ? Url::deviceLink($device) : $message['message']['source'],
-            'message'   => $message['message']['message'] ?? '',
+            'source'    => $device ? Url::deviceLink($device) : htmlspecialchars($message['message']['source']),
+            'message'   => htmlspecialchars($message['message']['message'] ?? ''),
             'facility'  => is_numeric($facility) ? ""($facility) "" . __(""syslog.facility.$facility"") : $facility,
             'level'     => (is_numeric($level) && $level >= 0) ? ""($level) "" . __(""syslog.severity.$level"") : $level,
         ];",fix graylog xss (#13931),"vuln-fix: Sanitize log message fields to prevent XSS

Log message fields were output without escaping, allowing injection of malicious HTML or JavaScript into rendered logs.
This posed a cross-site scripting risk, enabling attackers to execute scripts in users’ browsers viewing the logs.
The fix applies htmlspecialchars to sanitize the source and message fields before rendering, preventing script injection.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', ''), ('#13931', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
124,{'CWE-79'},GHSA-8c76-mxv5-w4g8,"@@ -6,18 +6,30 @@
 
 class SaveOptionApiController
 {
-    public function saveOption(Request $request) {
+    public $whitelistedGroupKeys = [
+        'website' => [
+            'website_head',
+            'website_footer'
+        ]
+    ];
+
+    public function saveOption(Request $request)
+    {
 
         $cleanFromXss = true;
         $option = $request->all();
 
-        // Allow for this keys
+        // Allow for this keys and groups
         if (isset($option['option_key'])) {
-            if ($option['option_key'] == 'website_head') {
-                $cleanFromXss = false;
-            }
-            if ($option['option_key'] == 'website_footer') {
-                $cleanFromXss = false;
+            foreach ($this->whitelistedGroupKeys as $group => $keys) {
+                if ($option['option_group'] == $group) {
+                    foreach ($keys as $key) {
+                        if ($option['option_key'] == $key) {
+                            $cleanFromXss = false;
+                            break;
+                        }
+                    }
+                }
             }
         }",Update SaveOptionApiController.php,"vuln-fix: Restrict XSS cleaning exceptions to whitelisted option keys

The vulnerability allowed disabling XSS cleaning for any option key, risking injection of malicious scripts in untrusted inputs.
This posed a security risk by enabling attackers to bypass sanitization and execute cross-site scripting attacks on the application.
The fix restricts exceptions to a predefined whitelist of option keys grouped by category, ensuring only trusted keys bypass XSS cleaning.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', ''), ('saveoptionapicontroller.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('xss', 'SECWORD', ''), ('key', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('untrusted inputs', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('sanitization', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('keys', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
125,{'CWE-79'},GHSA-rp34-85x3-3764,"@@ -34,10 +34,10 @@
 $status = 'ok';
 $message = '';
 
-$transport_id = $vars['transport_id'];
-$name = $vars['name'];
+$transport_id = strip_tags($vars['transport_id']);
+$name = strip_tags($vars['name']);
 $is_default = (int) (isset($vars['is_default']) && $vars['is_default'] == 'on');
-$transport_type = $vars['transport-type'];
+$transport_type = strip_tags($vars['transport-type']);
 
 if (empty($name)) {
     $status = 'error';","security - XSS Fix 01

fixing https://huntr.dev/bounties/114ba055-a2f0-4db9-aafb-95df944ba177/ (#13775)","vuln-fix: Prevent XSS by sanitizing user input with strip_tags

User input fields were directly assigned without sanitization, allowing injection of malicious HTML or JavaScript code into the application output.
This posed a cross-site scripting (XSS) risk, enabling attackers to execute scripts in users’ browsers and potentially steal sensitive data or hijack sessions.
The fix applies strip_tags to user inputs, removing HTML tags and preventing script injection through these fields.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('security', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixing', 'ACTION', ''), ('https://huntr.dev/bounties/114ba055-a2f0-4db9-aafb-95df944ba177/', 'URL', ''), ('#13775', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
126,"{'CWE-79', 'CWE-116'}",GHSA-xjfw-5vv5-vjq2,"@@ -58,9 +58,9 @@
       &lt;dd&gt;
         ## TODO: design a real framework to generate form by type
         #if (($descriptor.defaultValue || ""$!descriptor.defaultValue"" != '') &amp;&amp; ($descriptor.type.getName() == 'boolean' || $descriptor.type.getName() == 'int' || $descriptor.type.getName() == 'java.lang.String'))
-          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId"" value=""#if($request.get($descriptorId))$request.get($descriptorId)#else$descriptor.defaultValue#end""/&gt;
+          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId"" value=""#if($request.get($descriptorId))$escapetool.xml($request.get($descriptorId))#else$descriptor.defaultValue#end""/&gt;
         #else
-          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId""#if($request.get($descriptorId))value=""$request.get($descriptorId)""#end/&gt;
+          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId""#if($request.get($descriptorId))value=""$escapetool.xml($request.get($descriptorId))""#end/&gt;
         #end
       &lt;/dd&gt;
     #end",XWIKI-19293: Fix bad escaping,"vuln-fix: Escape user input in form fields to prevent XSS

User input was directly inserted into HTML form input values without proper escaping, allowing injection of malicious scripts.
This posed a security risk by enabling cross-site scripting attacks that could compromise user sessions or steal sensitive data.
The fix applies XML escaping to all user-supplied values before rendering them in input fields, mitigating script injection risks.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
127,{'CWE-79'},GHSA-qq74-vgcf-54c3,"@@ -311,6 +311,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".asa"")
 			|| $isDangerStr($filename , "".cshtml"")
 			|| $isDangerStr($filename , "".axd"")
+			|| $isDangerStr($filename , ""htm"")
 		) {
 			return true;
 		}",bug,"vuln-fix: Prevent dangerous file extension htm from being allowed

The code previously did not consider files with the ""htm"" extension as dangerous, allowing potentially unsafe files to be processed or uploaded. This omission could enable attackers to upload malicious HTML files that execute scripts or perform phishing attacks. The fix adds ""htm"" to the list of dangerous filename extensions, improving the detection and blocking of risky files.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type
Severity: High
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('phishing', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
128,{'CWE-79'},GHSA-gx6h-936c-vrrr,"@@ -45,7 +45,7 @@
       <div>
         <input type=""hidden"" name=""form_token"" value=""$!services.csrf.token"" />
         <input type=""hidden"" name=""register"" value=""1"" />
-        <input type=""hidden"" name=""xredirect"" value=""$!request.xredirect"" />
+        <input type=""hidden"" name=""xredirect"" value=""$escapetool.xml($!request.xredirect)"" />
         #set ($class = $xwiki.getClass('XWiki.XWikiUsers'))
         #set ($obj = $class.newObject())
         #set ($serverobj = $class.newObject())","XWIKI-19291: redirect parameter is badly handled in register page

  * Fix the typo","vuln-fix: Escape redirect URL to prevent XSS in registration form

The vulnerability was an unescaped redirect URL parameter embedded in a hidden form field, allowing injection of malicious scripts in the registration page. This posed a security risk by enabling cross-site scripting attacks that could hijack user sessions or steal sensitive data. The fix applies XML escaping to the redirect URL value before rendering it in the form, mitigating script injection risks. 

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
129,{'CWE-79'},GHSA-ff28-f46g-r9g8,"@@ -314,6 +314,7 @@ func runWeb(c *cli.Context) error {
 				}
 				defer fr.Close()
 
+				c.Header().Set(""Content-Security-Policy"", ""default-src 'none'; style-src 'unsafe-inline'; sandbox"")
 				c.Header().Set(""Cache-Control"", ""public,max-age=86400"")
 				c.Header().Set(""Content-Disposition"", fmt.Sprintf(`inline; filename=""%s""`, attach.Name))",attachment: set CSP header in the serving endpoint (#6926),"vuln-fix: Add Content-Security-Policy header to mitigate XSS risks

The application lacked a Content-Security-Policy header, allowing browsers to execute potentially malicious scripts and styles from untrusted sources. This absence increased the risk of cross-site scripting attacks that could compromise user data and session integrity. The fix introduces a restrictive Content-Security-Policy header that disables all content by default, permits only inline styles, and enforces sandboxing to isolate the execution environment.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)
Severity: High
CVSS: 7.4",0.058823529411764705,"[('csp header', 'SECWORD', ''), ('#6926', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('security', 'secword', ''), ('mitigate', 'ACTION', ''), ('xss', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('untrusted sources', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
130,{'CWE-79'},GHSA-74qp-233x-p5j8,"@@ -15,13 +15,17 @@
  * limitations under the License.
  */
 
+function escapeHtml(unescapedText) {
+  return $(""<div>"").text(unescapedText).html()
+}
+
 function loadSessionsTable(sessions) {
   $.each(sessions, function(index, session) {
     $(""#interactive-sessions .sessions-table-body"").append(
       ""<tr>"" +
         tdWrap(uiLink(""session/"" + session.id, session.id)) +
         tdWrap(appIdLink(session)) +
-        tdWrap(session.name) +
+        tdWrap(escapeHtml(session.name)) +
         tdWrap(session.owner) +
         tdWrap(session.proxyUser) +
         tdWrap(session.kind) +
@@ -38,7 +42,7 @@ function loadBatchesTable(sessions) {
       ""<tr>"" +
         tdWrap(session.id) +
         tdWrap(appIdLink(session)) +
-        tdWrap(session.name) +
+        tdWrap(escapeHtml(session.name)) +
         tdWrap(session.owner) +
         tdWrap(session.proxyUser) +
         tdWrap(session.state) +
@@ -79,4 +83,4 @@ $(document).ready(function () {
       $(""#all-sessions"").append('<h4>No Sessions or Batches have been created yet.</h4>');
     }
   });
-});
\ No newline at end of file
+});","Add html escape to session name

## What changes were proposed in this pull request?

The PR adds HTML escaping to session names.

## How was this patch tested?

Manual test.

Author: Marco Gaido <mgaido@apache.org>

Closes #302 from mgaido91/escape_html.","vuln-fix: Escape HTML in session names to prevent XSS

Session names were directly inserted into the DOM without escaping, allowing injection of malicious HTML or scripts by attackers.
This posed a critical cross-site scripting risk, potentially compromising user data and session integrity.
The fix introduces HTML escaping of session names before insertion, neutralizing any embedded malicious code.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: Critical  
CVSS: 9.8",0.17647058823529413,"[('add', 'ACTION', ''), ('escape', 'secword', ''), ('changes', 'ACTION', ''), ('adds', 'ACTION', ''), ('escaping', 'secword', ''), ('patch', 'ACTION', ''), ('manual', 'DETECTION', ''), ('mgaido@apache.org', 'EMAIL', ''), ('#302', 'ISSUE', ''), ('escape_html', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('attackers', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('cross-site scripting', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('malicious code', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
131,{'CWE-79'},GHSA-c7pp-g2v2-2766,"@@ -891,10 +891,8 @@ var Gmail_ = function(localJQuery) {
                 endIndex = (parseInt(dataLength, 10) - 2) + response.indexOf(""["");
                 data = response.substring(response.indexOf(""[""), endIndex);
 
-                var get_data = new Function(""\""use strict\""; return "" + data);
-                realData = get_data();
-
-                parsedResponse.push(realData);
+                var json = JSON.parse(data);
+                parsedResponse.push(json);
 
                 // prepare response for next loop
                 response = response.substring(response.indexOf(""[""), response.length);
@@ -1684,11 +1682,9 @@ var Gmail_ = function(localJQuery) {
             return emails;
         }
 
-        get_data = get_data.substring(get_data.indexOf(""[""), get_data.length);
-        get_data = ""\""use strict\""; return "" + get_data;
-        get_data = new Function(get_data);
-
-        api.tracker.view_data = get_data();
+        var data = get_data.substring(get_data.indexOf(""[""), get_data.length);
+        var json = JSON.parse(data);
+        api.tracker.view_data = json;
 
         for(var i in api.tracker.view_data) {
             if (typeof(api.tracker.view_data[i]) === ""function"") {
@@ -1934,13 +1930,10 @@ var Gmail_ = function(localJQuery) {
         if (!get_data) {
             return {};
         }
-        get_data = get_data.substring(get_data.indexOf(""[""), get_data.length);
-        get_data = ""\""use strict\""; return "" + get_data;
-        get_data = new Function(get_data);
-
-        var cdata = get_data();
+        var data = get_data.substring(get_data.indexOf(""[""), get_data.length);
+        var json = JSON.parse(data);
 
-        api.tracker.email_data = cdata[0];
+        api.tracker.email_data = json[0];
         return api.tools.parse_email_data(api.tracker.email_data);
     };",Replace new Function() with JSON.parse(),"vuln-fix: Replace dynamic code execution with JSON parsing

The code used dynamic function construction to parse data strings, which allowed execution of arbitrary code embedded in the input data. This posed a critical security risk as attackers could inject malicious scripts leading to code execution within the application context. The fix replaces dynamic function calls with safe JSON.parse calls to strictly parse data as JSON, eliminating code execution vulnerabilities.

Weakness: CWE-95: Improper Control of Generation of Code ('Code Injection')
Severity: Critical
CVSS: 9.8",0.11764705882352941,"[('json.parse', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('json.parse', 'URL', ''), ('code execution', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-95', 'CWEID', ''), ('improper control', 'secword', ''), ('code injection', 'SECWORD', ''), ('critical', 'SEVERITY', '')]"
132,{'CWE-79'},GHSA-c558-5gfm-p2r8,"@@ -141,7 +141,7 @@
 									tmp_val = item.displayedValue;
 								}
 								return {
-									label: item.displayedValue + "" ("" + item.count + "")"",
+									label: escapeHtml(item.displayedValue) + "" ("" + item.count + "")"",
 									value: tmp_val
 								};
 							}))			
@@ -153,7 +153,12 @@
 	function validateFilters() {
 		return document.getElementById(""filterquery"").value.length > 0;
 	}
-</script>		
+	// Generic HTML escape utility
+	var escapeHtml = s => (s + '').replace(/[&<>""']/g, m => ({
+		'&': '&amp;', '<': '&lt;', '>': '&gt;',
+		'""': '&quot;', ""'"": '&#39;'
+	})[m]);
+</script>
 </c:set>
 
 <dspace:layout titlekey=""jsp.search.title"">",[DS-4453] Discovery autocomplete HTML escaping (JSPUI),"vuln-fix: Escape HTML in displayed filter labels to prevent XSS

The vulnerability was that user-controlled filter values were rendered without escaping, allowing injection of malicious HTML or scripts in the UI.
This posed a security risk by enabling cross-site scripting attacks, potentially compromising user sessions or data.
The fix introduces an HTML escaping function applied to all displayed filter labels, sanitizing output and preventing script execution.

Weakness: Cross-Site Scripting (XSS) CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
133,{'CWE-79'},GHSA-gj85-pvp5-mvf9,"@@ -19,7 +19,7 @@ function autoload_class($class) {
 require_once dirname(__FILE__) . '/../config.php';
 require_once dirname(__FILE__) . '/../src/Storage.php';
 
-$GLOBALS['server'] = !empty($_GET['server']) ? $_GET['server'] : '';
+$GLOBALS['server'] = !empty($_GET['server']) ? htmlspecialchars($_GET['server']) : '';
 $GLOBALS['action'] = !empty($_GET['action']) ? $_GET['action'] : '';
 $GLOBALS['state'] = !empty($_GET['state']) ? $_GET['state'] : '';
 $GLOBALS['count'] = !empty($_GET['count']) ? $_GET['count'] : '';",Sanitize input,"vuln-fix: Sanitize server parameter to prevent XSS attacks

The server parameter from the GET request was used directly without sanitization, allowing injection of malicious scripts into the application output. This posed a security risk by enabling cross-site scripting (XSS) attacks that could compromise user data and session integrity. The fix applies htmlspecialchars to the server parameter, encoding special characters and preventing script execution in the browser context.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('sanitize', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('server', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('server', 'secword', ''), ('sanitization', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('server', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
134,{'CWE-79'},GHSA-3j9m-hcv9-rpj8,"@@ -40,5 +40,5 @@ export function escapeHtml(str: string): string {
 }
 
 export function sanitizeAngularInterpolation(url: string): string {
-  return url.replace('{{', '%7B%7B').replace('}}', '%7D%7D');
+  return url.replaceAll('{{', '%7B%7B').replaceAll('}}', '%7D%7D');
 }

From: Dan Cech <dcech@grafana.com>

 packages/grafana-data/src/text/sanitize.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -40,5 +40,5 @@ export function escapeHtml(str: string): string {
 }
 
 export function sanitizeAngularInterpolation(url: string): string {
-  return url.replaceAll('{{', '%7B%7B').replaceAll('}}', '%7D%7D');
+  return url.replace(/\{\{/g, '%7B%7B').replace(/\}\}/g, '%7D%7D');
 }","Merge pull request #151 from grafana/dcech/sanitize-replaceAll

use global replace when sanitizing urls in 8.2.3","vuln-fix: Prevent incomplete Angular interpolation sanitization

The sanitizeAngularInterpolation function only replaced the first occurrence of Angular interpolation markers, leaving others unescaped in URLs.
This allowed attackers to inject malicious Angular expressions, leading to potential client-side template injection vulnerabilities.
The fix replaces all occurrences of '{{' and '}}' using global regular expressions to ensure complete sanitization of interpolation markers.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.5",0.17647058823529413,"[('#151', 'ISSUE', ''), ('sanitize', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('8.2.3', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sanitization', 'secword', ''), ('sanitizeangularinterpolation', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('injection', 'secword', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-79', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('cross-site scripting', 'secword', ''), ('high', 'SEVERITY', '')]"
135,{'CWE-79'},GHSA-hm45-mgqm-gjm4,"@@ -72,6 +72,7 @@ <h1>{{ _('Loading servers...') }}</h1>
                 } else {
                     var base_guild_url = ""{{ url_for('home_blueprint.guild', guild='123456789123456789') }}""
                     $(""#serverrow"").html("""")
+                    let counter = 0
                     for (let g of json.data) {
                         var current_guild_url = base_guild_url.replace(""123456789123456789"", g.id)
                         $(""#serverrow"").append(`
@@ -80,13 +81,16 @@ <h1>{{ _('Loading servers...') }}</h1>
                                     <div class=""card h-100"" onmouseover=""playGif(this)"" onmouseout=""stopGif(this)"">
                                         <img class=""card-img-top"" src=""${g.icon}png"" alt=""Card image cap"" data-src-url=""${g.icon}"" data-is-animated=${g.animated}>
                                         <div class=""card-body"">
-                                            <h5 class=""card-title"">${g.name}</h5>
-                                            <p class=""card-text"">Owner: ${g.owner}</p>
+                                            <h5 class=""card-title"" id=""guild-counter-${counter}"">Loading...</h5>
+                                            <p class=""card-text"" id=""owner-counter-${counter}"">Owner: Loading...</p>
                                         </div>
                                     </div>
                                 </a>
                             </div>
                         `)
+                        $(`#guild-counter-${counter}`).text(g.name)
+                        $(`#owner-counter-${counter}`).text(g.owner)
+                        counter += 1
                     }
                 }
             }",Fix unformatted HTML,"vuln-fix: Prevent XSS by avoiding direct HTML injection of unescaped data

The vulnerability involves directly injecting unescaped user-controlled data into HTML, which can lead to cross-site scripting (XSS) attacks if malicious content is present. This is a security risk because attackers can execute arbitrary scripts in users’ browsers, potentially stealing sensitive information or performing unauthorized actions. The fix replaces direct HTML injection with safe text assignment methods that properly escape content, preventing script execution.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('sensitive information', 'secword', ''), ('fix', 'ACTION', ''), ('injection', 'SECWORD', ''), ('safe', 'secword', ''), ('escape', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
136,{'CWE-79'},GHSA-c53x-wwx2-pg96,"@@ -21,7 +21,7 @@ const liljs = (elem, data = {}) => {
      * @param {String} property Name of the property to render
      * @param {String} value (Optional) A value to use instead of a property (used in lil-list-text)
      */
-    const setText = (elem, property, value) => elem.innerHTML = value || state[property].value;
+    const setText = (elem, property, value) => elem.textContent = value || state[property].value;
 
     /** Set style helper function
      * @function setStyle
@@ -43,7 +43,7 @@ const liljs = (elem, data = {}) => {
      */
     const setList = (elem, property) => {
       //TODO: Find a way to update without clearing lists
-      elem.innerHTML = """";
+      elem.textContent = """";
       state[property].value.forEach(value => {
         let clone = document.importNode(state[property].template.content, true);
         clone.querySelectorAll(""[lil-list-text]"").forEach(node => {","Use textContent over innerHTML so you can bind untrusted text values
without the possibility of an XSS attack.","vuln-fix: Prevent XSS by replacing innerHTML with textContent

The code used innerHTML to set element content, which allowed injection of malicious HTML and JavaScript code through untrusted input.
This posed a critical cross-site scripting (XSS) risk, enabling attackers to execute arbitrary scripts in users' browsers.
The fix replaces innerHTML assignments with textContent to safely render text without interpreting it as HTML, mitigating XSS vulnerabilities.

Weakness: Cross-Site Scripting (CWE-79)
Severity: Critical
CVSS: 9.8",0.17647058823529413,"[('untrusted', 'secword', ''), ('xss', 'SECWORD', ''), ('attack', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('untrusted', 'secword', ''), ('critical', 'SEVERITY', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
137,{'CWE-79'},GHSA-vhm6-gw82-6f8j,"@@ -62,7 +62,7 @@
                             echo ""
                                 <tr>
                                     <td>{$rule['name']}</td>
-                                    <td><i>"" . htmlentities($rule_display) . ""</i></td>
+                                    <td><i>"" . htmlentities(strip_tags($rule_display)) . ""</i></td>
                                     <td>{$rule['severity']}</td>
                                     <td>{$rule['id']}</td>
                                 </tr>",Resolved XSS issue from alert rule list modal (#13805),"vuln-fix: Prevent XSS by stripping HTML tags before encoding output

The vulnerability allowed HTML tags in rule display content to be encoded but still rendered as HTML entities, potentially enabling cross-site scripting attacks. This is a security risk because malicious scripts could be injected and executed in users' browsers, compromising user data and session integrity. The fix strips all HTML tags from the rule display content before encoding it with htmlentities, ensuring no executable code is rendered in the output.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('xss', 'SECWORD', ''), ('issue', 'FLAW', ''), ('#13805', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('encoded', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('htmlentities', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
138,{'CWE-79'},GHSA-mw75-qvfr-hpmr,"@@ -303,6 +303,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".shtm"")
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
+			|| $isDangerStr($filename , "".xxhtml"")
 		) {
 			return true;
 		}
@@ -312,4 +313,4 @@ public function isDangerFilename($filename){
 
 
 
-}
\ No newline at end of file
+}","Merge pull request #1628 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Prevent dangerous .xxhtml file extension in filename checks

The filename validation function did not consider the .xxhtml extension as dangerous, allowing potentially harmful files to bypass security filters. This omission could enable attackers to upload malicious files disguised with this extension, risking server-side code execution or data exposure. The fix adds .xxhtml to the list of disallowed filename extensions, strengthening input validation against unsafe file uploads.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('#1628', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('server', 'secword', ''), ('code execution', 'SECWORD', ''), ('data exposure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
139,{'CWE-79'},GHSA-h3vq-wv8j-36gw,"@@ -50,8 +50,21 @@ module.exports = function (svgString) {
     // Empty script tags and javascript executing
     svgString = svgString.replace(/<script[\s\S]*>[\s\S]*<\/script>/, '<script></script>');
     
-    // Remove error handlers
-    svgString = svgString.replace(/onerror=[\s\S]*['""].*?['""]/i, '');
+    // Remove event handlers
+    const eventNames = [
+        'onbegin', 'onend', 'onrepeat', 'onabort', 'onerror', 'onresize', 'onscroll', 'onunload', 'oncopy',
+        'oncut', 'onpaste', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose',
+        'oncuechange', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragexit', 'ondragleave',
+        'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onloadeddata', 'onloadedmetadata',
+        'onloadstart', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove',
+        'onemptied', 'onended', 'onerror', 'onfocus', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress',
+        'onkeyup', 'onload', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpause', 'onplay',
+        'onplaying', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onseeked', 'onseeking',
+        'onselect', 'onshow', 'onstalled', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onvolumechange',
+        'onwaiting', 'onactivate', 'onfocusin', 'onfocusout'
+    ];
+    const eventsRegex = new RegExp(`(${eventNames.join('|')})\\s*=\\s*['""].*['""]`, 'i');
+    svgString = svgString.replace(eventsRegex, '');
 
     return svgString;
 };",Remove lots of event handlers,"vuln-fix: Prevent event handler injection in SVG sanitization

The vulnerability allowed SVG elements to retain event handler attributes, enabling execution of arbitrary JavaScript when the SVG was rendered. This posed a security risk by facilitating cross-site scripting (XSS) attacks through malicious SVG content. The fix removes a comprehensive list of event handler attributes from SVG strings using a regex, preventing script execution via embedded event handlers.

Weakness: Cross-Site Scripting (XSS) - CWE-79  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('remove', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('sanitization', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
140,{'CWE-79'},GHSA-q6mp-562x-ggvv,"@@ -1154,11 +1154,11 @@ function get_allowed_files_extensions_for_upload($fileTypes = 'images', $returnA
                 break;
             case 'file':
             case 'files':
-                $are_allowed .= ',css,json,zip,gzip,csv,7z';
+                $are_allowed .= ',css,json,zip,gzip,psd,csv,7z';
                 break;
             case 'documents':
             case 'doc':
-                $are_allowed .= ',doc,docx,pdf,odt,pages,rtf,txt,pps,ppt,pptx,xls,xlsx';
+                $are_allowed .= ',doc,docx,pdf,odt,rtf,txt,pps,ppt,pptx,xls,xlsx';
                 break;
             case 'archives':
             case 'arc':",update,"vuln-fix: Restrict allowed file upload extensions to reduce risk

The file upload function previously allowed potentially unsafe file types like PSD and Pages, increasing the attack surface for malicious uploads. Allowing these file types can lead to execution of harmful content or exploitation of vulnerabilities in file handlers. The fix removes risky extensions from allowed lists, limiting uploads to safer, well-validated file types only.

Weakness: CWE-434 Unrestricted Upload of File with Dangerous Type  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('unsafe', 'secword', ''), ('attack surface', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploitation', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-434', 'CWEID', ''), ('unrestricted upload', 'secword', ''), ('high', 'SEVERITY', '')]"
0,{'CWE-400'},GHSA-rhcw-wjcm-9h6g,"@@ -230,9 +230,15 @@ public Resource getResource(final String p) {
                 log.tracef(""Failed to get path resource %s from path resource manager with base %s, as the path did not exist"", p, base);
                 return null;
             }
-        } catch (Exception e) {
+        } catch (IOException e) {
             UndertowLogger.REQUEST_LOGGER.debugf(e, ""Invalid path %s"", p);
             return null;
+        } catch (SecurityException e) {
+            UndertowLogger.REQUEST_LOGGER.errorf(e, ""Missing JSM permissions for path %s"", p);
+            throw e;
+        } catch (Exception e) {
+            UndertowLogger.REQUEST_LOGGER.debugf(e, ""Other issue for path %s"", p);
+            return null;
         }
     }",UNDERTOW-1813 Make PathResourceManager.getResource rethrow a SecurityException,"vuln-fix: Improve exception handling to enforce security permissions

The code previously caught all exceptions broadly, potentially masking security-related permission errors during resource access. This allowed security exceptions to be logged as debug messages without proper enforcement, risking unauthorized access. The fix explicitly catches SecurityException, logs it as an error, and rethrows it to ensure permission issues are properly handled and not silently ignored.

Weakness: Improper Exception Handling (CWE-703)  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('pathresourcemanager.getresource', 'URL', ''), ('securityexception', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('security', 'SECWORD', ''), ('permissions', 'SECWORD', ''), ('security', 'SECWORD', ''), ('permission', 'SECWORD', ''), ('errors', 'FLAW', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('securityexception', 'SECWORD', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('permission issues', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,{'CWE-400'},GHSA-57f3-gghm-9mhc,"@@ -630,7 +630,7 @@ import { atob, btoa } from ""../libs/AtobBtoa.js"";
     var result = null;
 
     if (dataUrlParts.length === 2) {
-      var extractedInfo = /^data:(\w*\/\w*);*(charset=[\w=-]*)*;*$/.exec(
+      var extractedInfo = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(
         dataUrlParts[0]
       );
       if (Array.isArray(extractedInfo)) {",fix ReDoS-vulnerable regexp in addImage (#3091),"vuln-fix: Prevent double charset parameter parsing in data URLs

The vulnerability allowed multiple charset parameters in data URLs, causing incorrect parsing and potential misinterpretation of content encoding. This could lead to security issues such as injection or data corruption when processing malformed data URLs. The fix updates the regex to disallow repeated charset parameters, ensuring only a single charset is parsed and preventing ambiguous encoding interpretation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('#3091', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('injection', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
2,{'CWE-400'},GHSA-394c-5j6w-4xmx,"@@ -222,7 +222,7 @@
 
             // Presto based
             /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
-            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
+            /(opera\s[mobiletab]{3,6}).+version\/([\w\.-]+)/i,                  // Opera Mobi/Tablet
             /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
             /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
             ], [NAME, VERSION], [
@@ -252,7 +252,7 @@
             /(konqueror)\/([\w\.]+)/i                                           // Konqueror
             ], [[NAME, 'Konqueror'], VERSION], [
 
-            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
+            /(trident).+rv[:\s]([\w\.]{1,9}).+like\sgecko/i                     // IE11
             ], [[NAME, 'IE'], VERSION], [
 
             /(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i                          // Microsoft Edge
@@ -362,13 +362,13 @@
             /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
             ], [VERSION, [NAME, 'Firefox']], [
 
-            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
+            /version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i                      // Mobile Safari
             ], [VERSION, [NAME, 'Mobile Safari']], [
 
-            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
+            /version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i                   // Safari & Safari Mobile
             ], [VERSION, NAME], [
 
-            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
+            /webkit.+?(gsa)\/([\w\.]+)\s.*(mobile\s?safari|safari)(\/[\w\.]+)/i // Google Search Appliance on iOS
             ], [[NAME, 'GSA'], VERSION], [
 
             /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
@@ -387,7 +387,7 @@
 
                                                                                 // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
             /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,                       // Other Firefox-based
-            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla
+            /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,                        // Mozilla
 
             // Other
             /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
@@ -487,7 +487,7 @@
             /(sprint\s(\w+))/i                                                  // Sprint Phones
             ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [
 
-            /(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,                        // HTC
+            /(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,                    // HTC
             /(zte)-(\w*)/i,                                                     // ZTE
             /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                 // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
@@ -591,13 +591,13 @@
             ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [
 
             /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
-            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
-            /android.+(redmi[\s\-_]*(?:note|k)?(?:[\s_]?[\w\s]+))(?:\s+build|\))/i,      
+            /android.+(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,                // Xiaomi Hongmi
+            /android.+(redmi[\s\-_]?(?:note|k)?(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i,      
                                                                                 // Xiaomi Redmi
-            /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i    
+            /android.+(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i    
                                                                                 // Xiaomi Mi
             ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
-            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))(?:\s+build|\))/i     // Mi Pad tablets
+            /android.+(mi[\s\-_]?(?:pad)(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i     // Mi Pad tablets
             ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
             /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
             ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
@@ -611,7 +611,7 @@
             /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
             ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
 
-            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
+            /android.+[;\/\s](Venue[\d\s]{2,7})\s+build/i                       // Dell Venue Tablets
             ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
 
             /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
@@ -669,8 +669,8 @@
             /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
             ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
 
-            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
-            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
+            //android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
+            //], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
 
             /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
             ], [VENDOR, MODEL, [TYPE, TABLET]], [",Fix ReDoS vulnerabilities reported by Snyk,"vuln-fix: Prevent excessive regex quantifiers in user agent parsing

The vulnerability involves overly permissive regular expression quantifiers that can cause catastrophic backtracking, leading to denial of service via regex-based ReDoS attacks.
This is a security risk because attackers can craft malicious user agent strings that trigger excessive CPU usage, degrading service availability or causing crashes.
The fix restricts quantifier ranges and adjusts patterns to limit repetition, preventing excessive backtracking and improving regex matching performance and security.

Weakness: CWE-1333: Inefficient Regular Expression Complexity
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerabilities', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('permissive regular expression', 'secword', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('security', 'secword', ''), ('weakness', 'secword', ''), ('cwe-1333', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,{'CWE-400'},GHSA-f8m6-h2c7-8h9x,"@@ -266,7 +266,6 @@ def word_tokenize(self, s):
         return self._word_tokenizer_re().findall(s)
 
     _period_context_fmt = r""""""
-        \S*                          # some word material
         %(SentEndChars)s             # a potential sentence ending
         (?=(?P<after_tok>
             %(NonWord)s              # either other punctuation
@@ -1284,8 +1283,7 @@ def debug_decisions(self, text):
         See format_debug_decision() to help make this output readable.
         """"""
 
-        for match in self._lang_vars.period_context_re().finditer(text):
-            decision_text = match.group() + match.group(""after_tok"")
+        for match, decision_text in self._match_potential_end_contexts(text):
             tokens = self._tokenize_words(decision_text)
             tokens = list(self._annotate_first_pass(tokens))
             while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):
@@ -1333,10 +1331,68 @@ def sentences_from_text(self, text, realign_boundaries=True):
         """"""
         return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]
 
+    def _match_potential_end_contexts(self, text):
+        """"""
+        Given a text, find the matches of potential sentence breaks,
+        alongside the contexts surrounding these sentence breaks.
+
+        Since the fix for the ReDOS discovered in issue #2866, we no longer match
+        the word before a potential end of sentence token. Instead, we use a separate
+        regex for this. As a consequence, `finditer`'s desire to find non-overlapping
+        matches no longer aids us in finding the single longest match.
+        Where previously, we could use::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +SKIP
+            [<re.Match object; span=(9, 18), match='acting!!!'>]
+
+        Now we have to find the word before (i.e. 'acting') separately, and `finditer`
+        returns::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +NORMALIZE_WHITESPACE
+            [<re.Match object; span=(15, 16), match='!'>,
+            <re.Match object; span=(16, 17), match='!'>,
+            <re.Match object; span=(17, 18), match='!'>]
+
+        So, we need to find the word before the match from right to left, and then manually remove
+        the overlaps. That is what this method does::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> pst._match_potential_end_contexts(text)
+            [(<re.Match object; span=(17, 18), match='!'>, 'acting!!! I')]
+
+        :param text: String of one or more sentences
+        :type text: str
+        :return: List of match-context tuples.
+        :rtype: List[Tuple[re.Match, str]]
+        """"""
+        before_words = {}
+        matches = []
+        for match in reversed(list(self._lang_vars.period_context_re().finditer(text))):
+            # Ignore matches that have already been captured by matches to the right of this match
+            if matches and match.end() > before_start:
+                continue
+            # Find the word before the current match
+            split = text[: match.start()].rsplit(maxsplit=1)
+            before_start = len(split[0]) if len(split) == 2 else 0
+            before_words[match] = split[-1]
+            matches.append(match)
+
+        return [
+            (
+                match,
+                before_words[match] + match.group() + match.group(""after_tok""),
+            )
+            for match in matches[::-1]
+        ]
+
     def _slices_from_text(self, text):
         last_break = 0
-        for match in self._lang_vars.period_context_re().finditer(text):
-            context = match.group() + match.group(""after_tok"")
+        for match, context in self._match_potential_end_contexts(text):
             if self.text_contains_sentbreak(context):
                 yield slice(last_break, match.end())
                 if match.group(""next_tok""):","Resolved serious ReDoS in PunktSentenceTokenizer (#2869)

* Resolved serious ReDOS in PunktSentenceTokenizer

* Improve performance by relying on string split instead of re.search

* Solved issue if sentence contains just one token","vuln-fix: Prevent ReDOS by fixing regex sentence boundary matching

The vulnerability was a Regular Expression Denial of Service (ReDOS) caused by overly complex regex matching sentence boundaries including preceding words. This allowed attackers to craft inputs that cause excessive backtracking, leading to high CPU usage and potential service disruption. The fix separates word matching from sentence-ending punctuation and uses a custom method to find matches right-to-left, avoiding overlapping matches and reducing regex complexity.

Weakness: CWE-400: Uncontrolled Resource Consumption (ReDoS)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('redos', 'SECWORD', ''), ('#2869', 'ISSUE', ''), ('redos', 'SECWORD', ''), ('improve', 'ACTION', ''), ('re.search', 'URL', ''), ('issue', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('fixing', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('high', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
4,{'CWE-400'},GHSA-hf44-3mx6-vhhw,"@@ -188,13 +188,11 @@ private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> request
      * The url looks like: "".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..""
      */
     private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {
-
         String url = httpServletRequest.getRequestURI();
-        url = url.replaceFirst(""/navigate/directions/v5/gh/"" + profile + ""/"", """");
-        url = url.replaceAll(""\\?[*]"", """");
-
+        String urlStart = ""/navigate/directions/v5/gh/"" + profile + ""/"";
+        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(""Incorrect URL "" + url);
+        url = url.substring(urlStart.length());
         String[] pointStrings = url.split("";"");
-
         List<GHPoint> points = new ArrayList<>(pointStrings.length);
         for (int i = 0; i < pointStrings.length; i++) {
             points.add(GHPoint.fromStringLonLat(pointStrings[i]));","avoid regex in navigate module (#2304)

* replace two regexs with one indexOf

* make check stricter

* use @easbar's suggestion","vuln-fix: Validate URL prefix before parsing route points

The vulnerability was improper URL parsing without verifying the expected prefix, allowing malformed URLs to bypass checks and cause unexpected behavior or errors.
This is a security risk because attackers could exploit malformed URLs to trigger exceptions or inject malicious input into route processing.
The fix adds explicit validation of the URL prefix and safely extracts the relevant substring only if the prefix matches, preventing improper parsing.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('#2304', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'secword', ''), ('malformed urls', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('malformed urls', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
5,{'CWE-400'},GHSA-hp68-xhvj-x6j6,"@@ -1,6 +1,6 @@
 // An internal HTML tag and emoji shorthand should not escape
 const preventEscapeRegex =
-  /(<.*?>|:[-a-z0-9ÀÁÂÃÄÇÈÉÊËÍÎÏÑÓÔÕÖŒœÙÚÛÜŸßàáâãäçèéêëíîïñóôõöùúûüÿ_＿+＋'\u1100-\u11ff\u2e80-\u2fd5\u3005\u3041-\u3096\u30a0-\u30ff\u3130-\u318f\u3400-\u4db5\u4e00-\u9fcb\ua960-\ua97f\uac00-\ud7ff\uff10-\uff19\uff41-\uff5a\uff61-\uff9f]+:)/
+  /(<[^>]*>|:[-a-z0-9ÀÁÂÃÄÇÈÉÊËÍÎÏÑÓÔÕÖŒœÙÚÛÜŸßàáâãäçèéêëíîïñóôõöùúûüÿ_＿+＋'\u1100-\u11ff\u2e80-\u2fd5\u3005\u3041-\u3096\u30a0-\u30ff\u3130-\u318f\u3400-\u4db5\u4e00-\u9fcb\ua960-\ua97f\uac00-\ud7ff\uff10-\uff19\uff41-\uff5a\uff61-\uff9f]+:)/
 
 const generateReplacerForEscape = (fallback: string) => (matched: string) =>
   `<span data-escape=""${fallback.repeat(matched.length)}"">${matched}</span>`
@@ -8,13 +8,14 @@ const generateReplacerForEscape = (fallback: string) => (matched: string) =>
 export const escapeReplacers = {
   blockquote: (partial: string) =>
     partial
-      .replace(/^((?:<.*?>)*)(.{4})/gm, (matched, leading, character) =>
-        character === '&gt;' ? `${leading}\u00ad&gt;` : matched
+      .replace(
+        /^((?:<(?:[^>]|>(?=<))*>)?)(&gt;)/gm,
+        (_, leadingTags, character) => `${leadingTags}\u00ad${character}`
       )
       .replace(
-        /^((?:<.*?>)*)(＞)/gm,
-        (_, leading, character) =>
-          `${leading}${generateReplacerForEscape('\u00ad＞')(character)}`
+        /^((?:<(?:[^>]|>(?=<))*>)?)(＞)/gm,
+        (_, leadingTags, character) =>
+          `${leadingTags}${generateReplacerForEscape('\u00ad＞')(character)}`
       ),
   bold: (partial: string) =>
     partial",Prevent catastrophic backtracking in blockquote escape replacer,"vuln-fix: Prevent improper HTML tag matching in escape logic

The vulnerability was caused by overly broad regex patterns that matched across multiple HTML tags, allowing potential bypass of escape mechanisms in user content.
This posed a security risk by enabling injection of malicious HTML or scripts through improperly escaped sequences in blockquote and bold text processing.
The fix refines regex patterns to strictly match individual tags without spanning multiple tags, ensuring correct escaping and preventing injection attacks.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.058823529411764705,"[('prevent', 'ACTION', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('escape', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('bypass', 'SECWORD', ''), ('escape', 'secword', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('escaped', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('escaping', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,{'CWE-400'},GHSA-43f8-2h32-f4cj,"@@ -41,7 +41,7 @@ function fromUrl (giturl, opts) {
     isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
   )
   var parsed = parseGitUrl(url)
-  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))
+  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/)
   var matches = Object.keys(gitHosts).map(function (gitHostName) {
     try {
       var gitHostInfo = gitHosts[gitHostName]
@@ -55,7 +55,7 @@ function fromUrl (giturl, opts) {
       var defaultRepresentation = null
       if (shortcutMatch && shortcutMatch[1] === gitHostName) {
         user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])
-        project = decodeURIComponent(shortcutMatch[3])
+        project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ''))
         defaultRepresentation = 'shortcut'
       } else {
         if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return","fix: backport regex fix from #76

PR-URL: https://github.com/npm/hosted-git-info/pull/84
Credit: @nlf
Close: #84
Reviewed-by: @wraithgar","vuln-fix: Correct Git URL parsing to prevent malformed input handling

The vulnerability was caused by improper regular expression parsing of Git URLs, which could lead to incorrect extraction of user and project components. This parsing flaw risked security issues by allowing malformed or malicious URLs to bypass validation and potentially cause unexpected behavior. The fix replaces the regex with a more precise pattern and strips trailing "".git"" from project names to ensure consistent and secure URL parsing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('#76', 'ISSUE', ''), ('https://github.com/npm/hosted-git-info/pull/84', 'URL', ''), ('#84', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('security', 'SECWORD', ''), ('issues', 'FLAW', ''), ('malicious', 'secword', ''), ('bypass', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
7,{'CWE-400'},GHSA-247x-2f9f-5wp7,"@@ -25,6 +25,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/attr_value.pb.h""
 #include ""tensorflow/core/framework/function.pb.h""
 #include ""tensorflow/core/framework/node_def.pb.h""
+#include ""tensorflow/core/framework/op_def.pb.h""
 #include ""tensorflow/core/framework/tensor.pb.h""
 #include ""tensorflow/core/lib/io/path.h""
 #include ""tensorflow/core/lib/monitoring/counter.h""
@@ -99,6 +100,19 @@ static Status ValidateNode(const NodeDef& node) {
   return Status::OK();
 }
 
+static Status ValidateFunctionNotRecursive(const FunctionDef& function) {
+  const auto& function_name = function.signature().name();
+  for (const auto& node : function.node_def()) {
+    if (node.op() == function_name) {
+      return errors::FailedPrecondition(
+          ""Function "", function_name,
+          "" is self recursive and TensorFlow does not support this scenario."");
+    }
+  }
+
+  return Status::OK();
+}
+
 static Status ValidateSavedTensors(const GraphDef& graph_def) {
   for (const auto& node : graph_def.node()) {
     TF_RETURN_IF_ERROR(ValidateNode(node));
@@ -110,6 +124,10 @@ static Status ValidateSavedTensors(const GraphDef& graph_def) {
       for (const auto& node : function.node_def()) {
         TF_RETURN_IF_ERROR(ValidateNode(node));
       }
+
+      // Also check that there is no recursivity in the library
+      // TODO(mihaimaruseac): Do more than self-recursivity
+      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));
     }
   }","Prevent stack overflow when FunctionLib in GraphDef has a self-recursive function.

It is likely that no recursivity is supported, but we should handle this separately.

PiperOrigin-RevId: 414860329
Change-Id: I02a2270e86282b37362ddd485eeef16fb986a9e0","vuln-fix: Prevent self-recursive functions in TensorFlow graphs

Self-recursive functions were allowed in TensorFlow graphs, enabling infinite recursion during execution. This poses a security risk by causing denial of service or resource exhaustion when such functions are invoked. The fix adds validation to detect and reject self-recursive functions during graph loading, preventing unsupported recursive scenarios.

Weakness: CWE-674: Improper Control of a Resource Through its Lifetime  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('overflow', 'secword', ''), ('change', 'ACTION', ''), ('i02a2270e86282b37362ddd485eeef16fb986a9e0', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-674', 'CWEID', ''), ('improper control', 'secword', ''), ('high', 'SEVERITY', '')]"
8,{'CWE-400'},GHSA-566m-qj78-rww5,"@@ -48,11 +48,11 @@ class PreviousMap {
   }
 
   getAnnotationURL(sourceMapString) {
-    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\*\//)[1].trim()
+    return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim()
   }
 
   loadAnnotation(css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=.*\*\//gm)
+    let annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm)
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up","Merge pull request #1567 from yetingli/main

Fix ReDoS in previous-map","vuln-fix: Prevent sourceMappingURL regex from matching nested annotations

The vulnerability was caused by a regular expression that greedily matched sourceMappingURL annotations, allowing nested or malformed annotations to be incorrectly parsed. This posed a security risk by enabling attackers to inject or manipulate source map URLs, potentially leading to source code exposure or injection attacks. The fix updates the regex to use a tempered greedy token that prevents matching nested sourceMappingURL patterns, ensuring only valid annotations are extracted safely.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('#1567', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('manipulate', 'ACTION', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('prevents', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
9,"{'CWE-74', 'CWE-400'}",GHSA-97gv-3p2c-xw7j,"@@ -49,7 +49,10 @@ var configure = function( app, configObject ) {
 
 	// Register routes
 	app.get( ""/i18n/:locale"", i18nRoutes.i18n );
-	app.get( ""/i18n/:locale/:phrase"", i18nRoutes.translate );
+
+	if( process.env.NODE_ENV === ""development"" ) {
+		app.get( ""/i18n/:locale/:phrase"", i18nRoutes.translate );
+	}
 };
 
 /**",[FIX] Only register translate route during development,"vuln-fix: Restrict i18n translation route to development environment

The i18n translation route was exposed in all environments, allowing attackers to enumerate or manipulate localization phrases remotely.
This posed a risk of information disclosure or potential injection attacks through crafted phrase parameters in production.
The fix limits the route registration to the development environment only, preventing access in production deployments.

Weakness: CWE-200 Information Exposure
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('disclosure', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-200', 'CWEID', ''), ('information exposure', 'secword', ''), ('medium', 'SEVERITY', '')]"
10,{'CWE-400'},GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","Update index.js

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Properly close client connections to prevent resource leaks

The client connection was not properly closed, leading to potential resource exhaustion and denial of service under high load conditions.
This could allow attackers to degrade service availability by exhausting server resources through unclosed connections.
The fix replaces the improper removal of clients with an explicit close call to ensure connections are cleanly terminated and resources freed.

Weakness: Improper Resource Shutdown or Release (CWE-404)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('update', 'ACTION', ''), ('index.js', 'URL', ''), ('fixes', 'ACTION', ''), ('#1', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('resource leaks', 'SECWORD', ''), ('denial of service', 'secword', ''), ('high', 'SEVERITY', ''), ('attackers', 'FLAW', ''), ('availability', 'secword', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper resource shutdown', 'secword', ''), ('cwe-404', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,"{'CWE-400', 'CWE-918'}",GHSA-7q4h-pj78-j7vg,"@@ -21,9 +21,11 @@
 import java.security.cert.X509Certificate;
 import java.util.List;
 import java.util.Map;
+import java.util.logging.Logger;
 
 import javax.ws.rs.core.MultivaluedMap;
 
+import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.jaxrs.client.WebClient;
 import org.apache.cxf.jaxrs.impl.MetadataMap;
@@ -42,23 +44,31 @@
 import org.apache.cxf.rt.security.crypto.CryptoUtils;
 
 public class JwtRequestCodeFilter extends OAuthJoseJwtConsumer implements AuthorizationRequestFilter {
+    protected static final Logger LOG = LogUtils.getL7dLogger(JwtRequestCodeFilter.class);
     private static final String REQUEST_URI_CONTENT_TYPE = ""application/oauth-authz-req+jwt"";
     private static final String REQUEST_PARAM = ""request"";
     private static final String REQUEST_URI_PARAM = ""request_uri"";
+
     private boolean verifyWithClientCertificates;
     private String issuer;
     private JsonMapObjectReaderWriter jsonHandler = new JsonMapObjectReaderWriter();
+
     @Override
     public MultivaluedMap<String, String> process(MultivaluedMap<String, String> params,
                                                   UserSubject endUser,
                                                   Client client) {
         String requestToken = params.getFirst(REQUEST_PARAM);
+        String requestUri = params.getFirst(REQUEST_URI_PARAM);
+
         if (requestToken == null) {
-            String requestUri = params.getFirst(REQUEST_URI_PARAM);
             if (isRequestUriValid(client, requestUri)) {
                 requestToken = WebClient.create(requestUri).accept(REQUEST_URI_CONTENT_TYPE).get(String.class);
             }
+        } else if (requestUri != null) {
+            LOG.warning(""It is not valid to specify both a request and request_uri value"");
+            throw new SecurityException();
         }
+
         if (requestToken != null) {
             JweDecryptionProvider theDecryptor = super.getInitializedDecryptionProvider(client.getClientSecret());
             JwsSignatureVerifier theSigVerifier = getInitializedSigVerifier(client);",Make sure both a request + request_uri can't be specified,"vuln-fix: Prevent use of both request and request_uri parameters

The code allowed simultaneous presence of 'request' and 'request_uri' parameters, which could lead to ambiguous or conflicting authorization requests being processed. This ambiguity poses a security risk by potentially enabling attackers to bypass intended validation or inject malicious tokens. The fix adds a check that logs a warning and throws a SecurityException if both parameters are specified, enforcing strict input validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.058823529411764705,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('warning', 'FLAW', ''), ('securityexception', 'SECWORD', ''), ('input validation', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,{'CWE-400'},GHSA-6cf8-qhqj-vjqm,"@@ -6621,6 +6621,10 @@ exports.set = function(obj, path, value) {
 	var v = arr[arr.length - 1];
 	var ispush = v.lastIndexOf('[]') !== -1;
 	var a = builder.join(';') + ';var v=typeof(a)===\'function\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';
+
+	if ((/__proto__|constructor|prototype/).test(a))
+		throw new Error('Prototype pollution');
+
 	var fn = new Function('w', 'a', 'b', a);
 	F.temporary.other[cachekey] = fn;
 	fn(obj, value, path);",Fixed `U.set()` by adding check for `Prototype pollution`.,"vuln-fix: Prevent prototype pollution in object path setter

The vulnerability allowed malicious input containing __proto__, constructor, or prototype to modify object prototypes, leading to prototype pollution attacks. Prototype pollution can cause unexpected behavior, security bypasses, or denial of service by altering fundamental object properties. The fix adds a check that throws an error if the input path contains these dangerous keys, preventing prototype pollution exploits.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5",0.058823529411764705,"[('fixed', 'ACTION', ''), ('u.set', 'URL', ''), ('adding', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('malicious', 'SECWORD', ''), ('prototype pollution', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('prototype pollution', 'SECWORD', ''), ('security', 'secword', ''), ('bypasses', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('prototype pollution', 'secword', ''), ('exploits', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-1321', 'CWEID', ''), ('improper restriction', 'secword', ''), ('high', 'SEVERITY', '')]"
13,{'CWE-400'},GHSA-jxwx-85vp-gvwm,"@@ -1412,7 +1412,7 @@ $.extend( $.validator, {
 			// https://gist.github.com/dperini/729294
 			// see also https://mathiasbynens.be/demo/url-regex
 			// modified to allow protocol-relative URLs
-			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
+			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
 		},
 
 		// https://jqueryvalidation.org/date-method/","Core: fixed Regular Expression Denial of Service vulnerability (#2371)

ReDoS, or Regular Expression Denial of Service, is a vulnerability affecting
poorly constructed and potentially inefficient regular expressions which can
make them perform extremely badly given a creatively constructed input string.

GHSL-2020-294

credits to @erik-krogh for reporting the issue and providing a fix","vuln-fix: Strengthen URL validation to prevent host header attacks

The URL validation regex allowed invalid hostnames, enabling attackers to bypass restrictions and potentially inject malicious URLs or perform host header attacks. This poses a security risk by allowing crafted URLs that could lead to SSRF or phishing exploits. The fix updates the regex to enforce stricter hostname validation, disallowing invalid characters and patterns in domain names to mitigate these risks.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fixed', 'ACTION', ''), ('denial of service', 'secword', ''), ('vulnerability', 'secword', ''), ('#2371', 'ISSUE', ''), ('redos', 'SECWORD', ''), ('denial of service', 'secword', ''), ('vulnerability', 'secword', ''), ('issue', 'FLAW', ''), ('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attacks', 'FLAW', ''), ('url validation', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('ssrf', 'secword', ''), ('phishing', 'secword', ''), ('exploits', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('hostname', 'SECWORD', ''), ('mitigate', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,{'CWE-400'},GHSA-9hx2-hgq2-2g4f,"@@ -580,8 +580,9 @@ def next_object_id(self, offset=None):
     whitespace_or_hex = br""[\000\011\012\014\015\0400-9a-fA-F]""
     whitespace_optional = whitespace + b""*""
     whitespace_mandatory = whitespace + b""+""
+    whitespace_optional_no_nl = br""[\000\011\014\015\040]*""  # no ""\012"" aka ""\n""
     newline_only = br""[\r\n]+""
-    newline = whitespace_optional + newline_only + whitespace_optional
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
         + br""trailer""","Use more specific regex chars to prevent ReDoS

* CVE-2021-25292","vuln-fix: Prevent newline injection in trailer parsing regex

The vulnerability allowed newline characters within optional whitespace, enabling attackers to inject unexpected line breaks in trailer parsing. This posed a risk of malformed input processing, potentially leading to parsing errors or security bypasses. The fix restricts optional whitespace to exclude newline characters, ensuring proper and secure trailer parsing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('cve-2021-25292', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('bypasses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
15,{'CWE-400'},GHSA-rc8h-3fv6-pxv8,"@@ -82,8 +82,8 @@ internals.marshal = function (request, next) {
 
                 // Weak verifier
 
-                const ifModifiedSince = Date.parse(ifModifiedSinceHeader);
-                const lastModified = Date.parse(lastModifiedHeader);
+                const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
+                const lastModified = internals.parseDate(lastModifiedHeader);
 
                 if (ifModifiedSince &&
                     lastModified &&
@@ -147,6 +147,15 @@ internals.marshal = function (request, next) {
 };
 
 
+internals.parseDate = function (string) {
+
+    try {
+        return Date.parse(string);
+    }
+    catch (errIgnore) { }
+};
+
+
 internals.fail = function (request, boom, callback) {
 
     const error = boom.output;
@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.1"",
+    ""version"": ""11.1.3"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""
@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.2"",
+  ""version"": ""11.1.3"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""

From: Eran Hammer <eran@hammer.io>

 npm-shrinkwrap.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.3"",
+    ""version"": ""11.1.1"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""

From: Eran Hammer <eran@hammer.io>

 package.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.3"",
+  ""version"": ""11.1.2"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""","Merge pull request #2988 from hapijs/v11.1.x

Handle invalid date exceptions","vuln-fix: Prevent crash on invalid date headers in HTTP requests

Parsing date headers directly without error handling caused unhandled exceptions, leading to potential server crashes and denial of service. This is a security risk because attackers can send malformed date headers to disrupt service availability. The fix wraps date parsing in a try-catch block to safely handle invalid inputs and prevent exceptions from propagating. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('#2988', 'ISSUE', ''), ('v11.1.x', 'VERSION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('server', 'secword', ''), ('denial of service', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
16,{'CWE-400'},GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","DOS fix

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Properly close client connections to prevent resource leaks

The client connection was not properly closed, leading to potential resource exhaustion and denial of service under high load conditions. This is a security risk because attackers could exploit this to degrade service availability by exhausting server resources. The fix replaces the improper removal of clients with a proper close call to ensure connections are cleanly terminated and resources freed.

Weakness: Improper Resource Shutdown or Release (CWE-404)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('dos', 'secword', ''), ('fix', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#1', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('resource leaks', 'SECWORD', ''), ('denial of service', 'secword', ''), ('high', 'SEVERITY', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('availability', 'secword', ''), ('server', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper resource shutdown', 'secword', ''), ('cwe-404', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,{'CWE-400'},GHSA-p55x-7x9v-q8m4,"@@ -472,11 +472,14 @@ func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }","Fix for CVE-2017-15133 TCP DOS (#631)

serveTCP calls reader.ReadTCP in the accept loop rather than in
the per-connection goroutine. If an attacker opens a connection
and leaves it idle, this will block the accept loop until the
connection times out (2s by default). During this time no other
incoming connections will succeed, preventing legitimate queries
from being answered.

This commit moves the call to reader.ReadTCP into the per-connection
goroutine. It also adds a missing call to Close whose absence allowed
file-descirptors to leak in select cases.

This attack and fix have no impact on serving UDP queries.","vuln-fix: Prevent goroutine leak on TCP read errors

The vulnerability was that failed TCP reads did not close connections, causing goroutines to leak and exhaust server resources over time. This is a security risk because resource exhaustion can lead to denial of service, impacting availability and stability. The fix ensures that connections are closed immediately on read errors, preventing goroutine leaks and preserving server resources.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('cve-2017-15133', 'VULNID', 'CVE'), ('dos', 'SECWORD', ''), ('#631', 'ISSUE', ''), ('reader.readtcp', 'URL', ''), ('attacker', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('reader.readtcp', 'URL', ''), ('adds', 'ACTION', ''), ('leak', 'secword', ''), ('attack', 'FLAW', ''), ('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('leak', 'SECWORD', ''), ('errors', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('leak', 'secword', ''), ('server', 'secword', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('errors', 'FLAW', ''), ('preventing', 'ACTION', ''), ('server', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('medium', 'SEVERITY', '')]"
18,{'CWE-400'},GHSA-fq6p-x6j3-cmmq,"@@ -169,14 +169,14 @@ class Color {
 
 			let color;
 			const name = m[ 1 ];
-			const components = m[ 2 ].replace(/^\s*/, '');
+			const components = m[ 2 ];
 
 			switch ( name ) {
 
 				case 'rgb':
 				case 'rgba':
 
-					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(255,0,0) rgba(255,0,0,0.5)
 						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
@@ -189,7 +189,7 @@ class Color {
 
 					}
 
-					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
 						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
@@ -207,7 +207,7 @@ class Color {
 				case 'hsl':
 				case 'hsla':
 
-					if ( color = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
 						const h = parseFloat( color[ 1 ] ) / 360;",Fix ReDoS,"vuln-fix: Prevent regex bypass by enforcing leading whitespace in color parsing

The vulnerability allowed color component strings with leading whitespace to bypass strict pattern matching, potentially causing incorrect parsing or unexpected behavior in color processing.
This could lead to malformed color values being accepted, which might be exploited in contexts relying on precise color validation, risking data integrity or UI inconsistencies.
The fix enforces optional leading whitespace in all relevant regular expressions, ensuring consistent and secure parsing of color component strings with proper input normalization.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
19,{'CWE-400'},GHSA-7f53-fmmv-mfjv,"@@ -107,7 +107,7 @@ export class URLSearchParams {
 
 function validateBaseUrl(url: string) {
   // from this MIT-licensed gist: https://gist.github.com/dperini/729294
-  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
+  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)*(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/.test(
     url,
   );
 }","Update validateBaseUrl to use latest regex

Summary:
Updating the regex to avoid a potential regular expression denial-of-service vulnerability.

Changelog: Update validateBaseUrl to use a more robust regular expression. Fixes CVE-2020-1920, GHSL-2020-293

Reviewed By: lunaleaps

Differential Revision: D25507604

fbshipit-source-id: c36a03c456881bc655c861e1a2c5cd41a7127c9d","vuln-fix: Strengthen base URL validation to prevent host header attacks

The base URL validation regex allowed invalid or malicious hostnames, enabling attackers to bypass checks and potentially exploit host header injection vulnerabilities. This posed a security risk by permitting crafted URLs that could manipulate server behavior or redirect users to malicious sites. The fix updates the regex to enforce stricter hostname rules, disallowing invalid characters and patterns to ensure only valid, safe URLs are accepted.

Weakness: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')
Severity: High
CVSS: 7.5",0.17647058823529413,"[('update', 'ACTION', ''), ('updating', 'ACTION', ''), ('denial-of-service', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('update', 'ACTION', ''), ('fixes', 'ACTION', ''), ('cve-2020-1920', 'VULNID', 'CVE'), ('c36a03c456881bc655c861e1a2c5cd41a7127c9d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attacks', 'FLAW', ''), ('url validation', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('exploit', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('security', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('server', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('hostname', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-113', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('http response splitting', 'secword', ''), ('high', 'SEVERITY', '')]"
20,"{'CWE-400', 'CWE-20'}",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate pylist depth against ragged rank to prevent inconsistencies

The vulnerability allowed pylist inputs with a maximum depth smaller than the expected ragged rank, causing inconsistent data structures during processing. This inconsistency could lead to unexpected exceptions or corrupted data, potentially exposing the system to denial of service or logic errors. The fix adds a validation check that raises an error if the pylist depth is less than the specified ragged rank, ensuring input consistency and preventing malformed data handling.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('tf.ragged.constant', 'URL', ''), ('fixes', 'ACTION', ''), ('#55199', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('denial of service', 'secword', ''), ('logic errors', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
21,{'CWE-400'},GHSA-h6rj-8r3c-9gpj,"@@ -282,7 +282,7 @@ def from_time(time, options = {})
       #
       # @since 2.0.0
       def legal?(string)
-        string.to_s =~ /^[0-9a-f]{24}$/i ? true : false
+        string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false
       end
 
       # Executes the provided block only if the size of the provided object is",Use \A \z for checking regex on legal,"vuln-fix: Enforce strict regex anchors in ID validation

The vulnerability was due to the use of a regex without strict start and end anchors, allowing partial matches of invalid strings to pass as valid IDs. This posed a security risk by potentially permitting malformed or malicious input to be accepted and processed. The fix enforces strict start (\\A) and end (\\z) anchors in the regex to ensure only exact 24-character hexadecimal strings are considered valid.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,{'CWE-400'},GHSA-hwj9-h5mp-3pm3,"@@ -73,12 +73,14 @@ class PreviousMap {
 
   getAnnotationURL (sourceMapString) {
     return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
+      .match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1]
       .trim()
   }
 
   loadAnnotation (css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg)
+    let annotations = css.match(
+      /\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm
+    )
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up",Backport ReDoS vulnerabilities from PostCSS 8,"vuln-fix: Prevent ReDoS in sourceMappingURL regex parsing

The vulnerability is a regular expression that can cause catastrophic backtracking when parsing sourceMappingURL annotations in CSS comments. This is a security risk because an attacker can craft malicious input to trigger excessive CPU usage, leading to denial of service. The fix replaces the greedy wildcard with a tempered greedy token to safely match sourceMappingURL without backtracking issues.

Weakness: Regular Expression Denial of Service (ReDoS) CWE-1333  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('redos', 'SECWORD', ''), ('vulnerabilities', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attacker', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('issues', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('cwe-1333', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,{'CWE-400'},GHSA-v2p6-4mp7-3r9v,"@@ -2,7 +2,7 @@ var makeString = require('./helper/makeString');
 var htmlEntities = require('./helper/htmlEntities');
 
 module.exports = function unescapeHTML(str) {
-  return makeString(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
+  return makeString(str).replace(/\&([^;]{1,10});/g, function(entity, entityCode) {
     var match;
 
     if (entityCode in htmlEntities) {","Try to fix regexp redos

fixes  #510","vuln-fix: Limit HTML entity length to prevent regex abuse

The unescapeHTML function allowed matching HTML entities of any length, enabling potential ReDoS attacks through crafted long input strings.
This posed a security risk by allowing attackers to cause excessive CPU usage and degrade service availability.
The fix restricts the entity code length to a maximum of 10 characters, mitigating the risk of catastrophic backtracking in the regex engine.

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#510', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unescapehtml', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('medium', 'SEVERITY', '')]"
24,{'CWE-400'},GHSA-r33q-22hv-j29q,"@@ -610,6 +610,7 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 		var (
 			lastBHash common.Hash
 			root      common.Hash
+			header    *types.Header
 		)
 		reqCnt := len(req.Reqs)
 		if accept(req.ReqID, uint64(reqCnt), MaxProofsFetch) {
@@ -624,10 +625,6 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						return
 					}
 					// Look up the root hash belonging to the request
-					var (
-						header *types.Header
-						trie   state.Trie
-					)
 					if request.BHash != lastBHash {
 						root, lastBHash = common.Hash{}, request.BHash
 
@@ -654,6 +651,7 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 					// Open the account or storage trie for the request
 					statedb := h.blockchain.StateCache()
 
+					var trie state.Trie
 					switch len(request.AccKey) {
 					case 0:
 						// No account key specified, open an account trie",les: fix GetProofsV2 bug (#21896),"vuln-fix: Prevent variable shadowing in handleMsg to avoid logic errors

The handleMsg function contained variable shadowing that could cause incorrect state trie lookups and inconsistent blockchain state processing during peer message handling. This is a security risk because it may lead to incorrect validation or acceptance of malicious data, potentially compromising consensus or state integrity. The fix removes redundant variable declarations and ensures consistent use of shared variables to maintain correct state and prevent logic flaws.

Weakness: CWE-484: Omitted Variable Initialization
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('#21896', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('logic errors', 'secword', ''), ('security', 'secword', ''), ('incorrect validation', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensures', 'ACTION', ''), ('prevent', 'ACTION', ''), ('flaws', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cwe-484', 'CWEID', ''), ('initialization', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
25,{'CWE-400'},GHSA-4gw3-8f77-f72c,"@@ -126,7 +126,7 @@ CodeMirror.defineMode(""javascript"", function(config, parserConfig) {
           var kw = keywords[word]
           return ret(kw.type, kw.style, word)
         }
-        if (word == ""async"" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
+        if (word == ""async"" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
           return ret(""async"", ""keyword"", word)
       }
       return ret(""variable"", ""variable"", word)",[javascript mode] Fix potentially-exponential regexp,"vuln-fix: Correct regex to safely match async keyword in JS mode

The vulnerability was an incorrect regular expression that could misinterpret comment patterns following the 'async' keyword, leading to improper tokenization in the JavaScript mode parser. This flaw could allow attackers to craft malicious code that bypasses syntax checks or causes unexpected parser behavior, potentially leading to security issues in code editors or analysis tools. The fix updates the regex to correctly handle nested comment patterns, ensuring accurate parsing and preventing exploitation through malformed comments.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('keyword', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('incorrect regular expression', 'secword', ''), ('keyword', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('malicious code', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,{'CWE-400'},GHSA-43f8-2h32-f4cj,"@@ -41,7 +41,7 @@ function fromUrl (giturl, opts) {
     isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
   )
   var parsed = parseGitUrl(url)
-  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))
+  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/)
   var matches = Object.keys(gitHosts).map(function (gitHostName) {
     try {
       var gitHostInfo = gitHosts[gitHostName]
@@ -55,7 +55,7 @@ function fromUrl (giturl, opts) {
       var defaultRepresentation = null
       if (shortcutMatch && shortcutMatch[1] === gitHostName) {
         user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])
-        project = decodeURIComponent(shortcutMatch[3])
+        project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ''))
         defaultRepresentation = 'shortcut'
       } else {
         if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return","fix: simplify the regular expression for shortcut matching

PR-URL: https://github.com/npm/hosted-git-info/pull/76
Credit: @nlf
Close: #76
Reviewed-by: @isaacs","vuln-fix: Correct Git URL parsing to prevent malformed input handling

The vulnerability involved improper parsing of Git URLs, which could allow crafted inputs to bypass expected format checks and cause incorrect repository resolution. This posed a security risk by enabling attackers to manipulate repository references, potentially leading to unauthorized code access or injection. The fix updates the regular expression to more accurately parse Git URLs, ensuring proper extraction of user and project components and removing trailing "".git"" suffixes securely.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('https://github.com/npm/hosted-git-info/pull/76', 'URL', ''), ('#76', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('injection', 'secword', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('removing', 'ACTION', ''), ('securely', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
27,{'CWE-400'},GHSA-662x-fhqg-9p8v,"@@ -585,9 +585,9 @@
             /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
             /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    
                                                                                 // Xiaomi Mi
-            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i       // Redmi Phones
+            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]?[\w\s]+))\s+build/i       // Redmi Phones
             ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
-            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i            // Mi Pad tablets
+            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))\s+build/i            // Mi Pad tablets
             ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
             /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
             ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [",Fix potential ReDoS vulnerability,"vuln-fix: Prevent regex over-permissiveness in device model parsing

The vulnerability is caused by overly permissive regex patterns that allow unexpected input formats in device model detection, potentially leading to incorrect parsing or injection risks. This is a security risk because attackers could exploit the regex to bypass filters or inject malicious payloads through crafted user-agent strings. The fix tightens the regex quantifiers from '*' to '?' to limit optional whitespace and characters, reducing the attack surface for injection or parsing errors.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('injection', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('attack surface', 'secword', ''), ('injection', 'secword', ''), ('errors', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
28,{'CWE-400'},GHSA-vp56-6g26-6827,"@@ -119,7 +119,7 @@ export function isOriginPotentiallyTrustworthy(url) {
 	// 5. If origin's host component is ""localhost"" or falls within "".localhost"", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return ""Potentially Trustworthy"".
 	// We are returning FALSE here because we cannot ensure conformance to
 	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
-	if (/^(.+\.)*localhost$/.test(url.host)) {
+	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
 		return false;
 	}","fix: ReDoS referrer (#1611)

* fix ReDoS referrer

* Update src/utils/referrer.js

Eliminate regex and use string matcher

Co-authored-by: Linus Unnebäck <linus@folkdatorn.se>

Co-authored-by: Khang. Võ Vĩ <khangvv@vng.com.vn>
Co-authored-by: Linus Unnebäck <linus@folkdatorn.se>","vuln-fix: Correct localhost origin trust check to prevent bypass

The origin trust check incorrectly used a regex that could misclassify certain localhost subdomains as untrustworthy origins.
This flaw could allow attackers to exploit trusted localhost origins, potentially bypassing security policies relying on origin trustworthiness.
The fix replaces the regex with explicit string equality and suffix checks to accurately identify localhost and its subdomains as potentially trustworthy origins.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.4117647058823529,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('#1611', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('update', 'ACTION', ''), ('referrer.js', 'URL', ''), ('linus@folkdatorn.se', 'EMAIL', ''), ('khangvv@vng.com.vn', 'EMAIL', ''), ('linus@folkdatorn.se', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('trust', 'secword', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('trust', 'secword', ''), ('incorrectly used', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
29,{'CWE-400'},GHSA-xfhp-gmh8-r8v2,"@@ -41,7 +41,7 @@ var Formatter = function(/*String*/ format){
   this._tokens = tokenize(format, this._re, this._parseDelim, this);
 };
 
-Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)([\*1-9]0*)*(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
+Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
 Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
   if(mapping){
     this._mapped = true;",Fix ReDoS,"vuln-fix: Correct regex to prevent format string parsing errors

The regular expression used for parsing format strings allowed malformed width specifiers, which could lead to incorrect parsing and potential injection of unintended format tokens.
This flaw could be exploited to cause unexpected behavior or crashes, posing a security risk in applications relying on safe format string processing.
The fix adjusts the regex to properly match width specifiers, ensuring only valid numeric or asterisk characters are accepted, preventing malformed input from bypassing validation.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('injection', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('exploited', 'SECWORD', ''), ('security', 'secword', ''), ('safe', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('bypassing', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
30,{'CWE-400'},GHSA-j4f2-536g-r55m,"@@ -26,7 +26,7 @@ class Server extends EventEmitter {
         pingTimeout: 5000,
         pingInterval: 25000,
         upgradeTimeout: 10000,
-        maxHttpBufferSize: 10e7,
+        maxHttpBufferSize: 1e6,
         transports: Object.keys(transports),
         allowUpgrades: true,
         perMessageDeflate: {","feat: decrease the default value of maxHttpBufferSize

This change reduces the default value from 100 mb to a more sane 1 mb.

This helps protect the server against denial of service attacks by
malicious clients sending huge amounts of data.","vuln-fix: Limit maximum HTTP buffer size to prevent DoS attacks

The server allowed excessively large HTTP buffer sizes, enabling attackers to send huge payloads that could exhaust server memory resources. This posed a denial-of-service risk by potentially crashing or severely degrading server performance under high load. The fix reduces the maxHttpBufferSize to a safer limit, mitigating memory exhaustion and improving resilience against large payload attacks.

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: High
CVSS: 7.5",0.17647058823529413,"[('change', 'ACTION', ''), ('protect', 'ACTION', ''), ('server', 'SECWORD', ''), ('denial of service', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'secword', ''), ('attacks', 'FLAW', ''), ('server', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('server', 'secword', ''), ('denial-of-service', 'SECWORD', ''), ('server', 'secword', ''), ('high', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('improving', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('high', 'SEVERITY', '')]"
31,{'CWE-400'},GHSA-hwj9-h5mp-3pm3,"@@ -48,9 +48,7 @@ class PreviousMap {
   }
 
   getAnnotationURL(sourceMapString) {
-    return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
-      .trim()
+    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\*\//)[1].trim()
   }
 
   loadAnnotation(css) {",Fix unsafe regexp in getAnnotationURL() too,"vuln-fix: Prevent regex DoS in sourceMappingURL extraction

The vulnerability is a regular expression that can cause excessive backtracking when parsing sourceMappingURL annotations in source map strings. This poses a security risk by enabling denial-of-service attacks through crafted inputs that trigger high CPU usage. The fix simplifies the regex pattern to remove unnecessary quantifiers, reducing the risk of catastrophic backtracking and improving input parsing safety.

Weakness: Regular Expression Denial of Service (ReDoS) CWE-1333  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial-of-service', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('high', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('cwe-1333', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,{'CWE-400'},GHSA-hj5v-574p-mj7c,"@@ -396,7 +396,7 @@ def makecmdoptions(self):
     def __str__(self):
         return ""<SvnAuth username=%s ...>"" %(self.username,)
 
-rex_blame = re.compile(r'\s*(\d+)\s*(\S+) (.*)')
+rex_blame = re.compile(r'\s*(\d+)\s+(\S+) (.*)')
 
 class SvnWCCommandPath(common.PathBase):
     """""" path implementation offering access/modification to svn working copies.","svnwc: fix regular expression vulnerable to DoS in blame functionality

The subpattern `\d+\s*\S+` is ambiguous which makes the pattern subject
to catastrophic backtracing given a string like `""1"" * 5000`.

SVN blame output seems to always have at least one space between the
revision number and the user name, so the ambiguity can be fixed by
changing the `*` to `+`.

Fixes #256.","vuln-fix: Prevent improper parsing of svn blame output fields

The regular expression for parsing svn blame output allowed variable whitespace between fields, causing potential misinterpretation of revision and author data.
This could lead to incorrect attribution or processing of blame information, potentially misleading audit or security tools relying on accurate data.
The fix enforces one or more whitespace characters between fields, ensuring consistent and correct parsing of the blame output format.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerable', 'SECWORD', ''), ('dos', 'secword', ''), ('user name', 'secword', ''), ('fixed', 'ACTION', ''), ('changing', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#256', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('audit', 'secword', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,"{'CWE-400', 'CWE-918'}",GHSA-7q4h-pj78-j7vg,"@@ -42,6 +42,7 @@
 import org.apache.cxf.rt.security.crypto.CryptoUtils;
 
 public class JwtRequestCodeFilter extends OAuthJoseJwtConsumer implements AuthorizationRequestFilter {
+    private static final String REQUEST_URI_CONTENT_TYPE = ""application/oauth-authz-req+jwt"";
     private static final String REQUEST_PARAM = ""request"";
     private static final String REQUEST_URI_PARAM = ""request_uri"";
     private boolean verifyWithClientCertificates;
@@ -55,7 +56,7 @@ public MultivaluedMap<String, String> process(MultivaluedMap<String, String> par
         if (requestToken == null) {
             String requestUri = params.getFirst(REQUEST_URI_PARAM);
             if (isRequestUriValid(client, requestUri)) {
-                requestToken = WebClient.create(requestUri).get(String.class);
+                requestToken = WebClient.create(requestUri).accept(REQUEST_URI_CONTENT_TYPE).get(String.class);
             }
         }
         if (requestToken != null) {
@@ -101,9 +102,17 @@ public MultivaluedMap<String, String> process(MultivaluedMap<String, String> par
         }
         return params;
     }
-    private boolean isRequestUriValid(Client client, String requestUri) {
-        //TODO: consider restricting to specific hosts
-        return requestUri != null && requestUri.startsWith(""https://"");
+
+    /**
+     * This method must be overridden to support request_uri. Take care to validate the request_uri properly,
+     * as otherwise it could lead to a security problem
+     * (https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-30#section-10.4)
+     * @param client the Client object
+     * @param requestUri the request_uri parameter to validate
+     * @return whether the requestUri is permitted or not
+     */
+    protected boolean isRequestUriValid(Client client, String requestUri) {
+        return false;
     }
     protected JwsSignatureVerifier getInitializedSigVerifier(Client c) {
         if (verifyWithClientCertificates) {",Disallow OAuth2 request_uri by default,"vuln-fix: Prevent insecure request_uri processing in OAuth JWT filter

The code allowed fetching OAuth authorization requests from arbitrary HTTPS URIs without strict validation, enabling potential malicious request injection attacks. This is a security risk because attackers could supply crafted request_uris to manipulate authorization flows or inject harmful payloads. The fix disables request_uri usage by default and requires explicit overriding with proper validation to prevent unauthorized or unsafe URI access.

Weakness: CWE-601 Open Redirect  
Severity: High  
CVSS: 7.5",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('insecure', 'SECWORD', ''), ('oauth', 'SECWORD', ''), ('oauth', 'SECWORD', ''), ('malicious', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('inject', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-601', 'CWEID', ''), ('open redirect', 'secword', ''), ('high', 'SEVERITY', '')]"
34,{'CWE-400'},GHSA-35q2-47q7-3pc3,"@@ -127,7 +127,7 @@ module.exports = {
     reply_to_object: replyToObject,
     print: print,
     err_code: /^([A-Z]+)\s+(.+)$/,
-    monitor_regex: /^[0-9]{10,11}\.[0-9]+ \[[0-9]+ .+\]( "".+?"")+$/,
+    monitor_regex: /^[0-9]{10,11}\.[0-9]+ \[[0-9]+ .+\].*""$/,
     clone: convenienceClone,
     callback_or_emit: callbackOrEmit,
     reply_in_order: replyInOrder","fix #1569 - improve monitor_regex (#1595)

Co-authored-by: Guy Korland <gkorland@gmail.com>","vuln-fix: Fix regex to prevent excessive backtracking in monitor pattern

The original regular expression allowed multiple repeated quoted substrings, causing potential catastrophic backtracking with crafted inputs. This vulnerability could be exploited to cause denial of service by making the regex engine consume excessive CPU resources. The fix simplifies the regex by removing the repeated group, ensuring it matches a single quoted substring and preventing exponential backtracking.

Weakness: Regular Expression Denial of Service (ReDoS) - CWE-1333  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('#1569', 'ISSUE', ''), ('improve', 'ACTION', ''), ('#1595', 'ISSUE', ''), ('gkorland@gmail.com', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('cwe-1333', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
35,"{'CWE-400', 'CWE-185'}",GHSA-8462-q7x7-g2x4,"@@ -235,6 +235,13 @@ Decimal128.fromString = function(string) {
   // Trim the string
   string = string.trim();
 
+  // Naively prevent against REDOS attacks.
+  // TODO: implementing a custom parsing for this, or refactoring the regex would yield
+  //       further gains.
+  if (string.length >= 7000) {
+    throw new Error('' + string + ' not a valid Decimal128 string');
+  }
+
   // Results
   var stringMatch = string.match(PARSE_STRING_REGEXP);
   var infMatch = string.match(PARSE_INF_REGEXP);","fix(decimal128): add basic guard against REDOS attacks

This is a naive approach to reducing the efficacy of a REDOS attack
against this module. A refactor of the regular expression or a
custom parser substitute would be ideal, however this solution
suffices as a stopgap until such work is completed.

Many thanks to James Davis who graciously alterted us to the
attack","vuln-fix: Prevent ReDoS in Decimal128 string parsing

The vulnerability is a regular expression denial of service (ReDoS) risk caused by processing excessively long input strings in Decimal128 parsing. This is a security risk because attackers can exploit it to cause high CPU usage, leading to service unavailability or degraded performance. The fix adds a length check that rejects input strings longer than 7000 characters before applying regex parsing, mitigating the ReDoS attack vector.

Weakness: CWE-400: Uncontrolled Resource Consumption  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix(decimal128', 'ACTION', ''), ('add', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('redos', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attack', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('high', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attack vector', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
36,{'CWE-400'},GHSA-3pcq-34w5-p4g2,"@@ -35,7 +35,7 @@ import mapLimit from './mapLimit.mjs'
  */
 async function forEachLimit (iterable, iteratee, concurrency) {
   await mapLimit(iterable, async (v, i, t) => {
-    iteratee(v, i, t)
+    await iteratee(v, i, t)
   }, concurrency)
 }",Fix #5,"vuln-fix: Await asynchronous iteratee calls in forEachLimit function

The forEachLimit function did not await asynchronous iteratee calls, causing unhandled promise rejections and unpredictable execution order in concurrent operations.
This could lead to race conditions and inconsistent state, exposing the application to data corruption or logic errors.
The fix ensures that iteratee calls are properly awaited, enforcing correct asynchronous flow and reliable concurrency control.


Weakness: Improper Handling of Asynchronous Operations (CWE-665)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('#5', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('race conditions', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper handling', 'secword', ''), ('cwe-665', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
37,"{'CWE-400', 'CWE-1321'}",GHSA-74cr-77xc-8g6r,"@@ -4,7 +4,7 @@ export function deepMerge(target: any, source: any): any {
   if (source === undefined || source === null) return target;
 
   for (const key of Object.keys(source)) {
-    if (source[key] === undefined) continue;
+    if (source[key] === undefined || key === '__proto__') continue;
 
     if (target[key] && isObject(source[key])) {
       deepMerge(target[key], source[key]);",Ignore __proto__ fields in deepMerge,"vuln-fix: Prevent prototype pollution in deepMerge function

The deepMerge function allowed merging of properties named __proto__, enabling prototype pollution attacks.
This vulnerability could lead to arbitrary code execution or denial of service by modifying the object's prototype chain.
The fix prevents merging of __proto__ properties by explicitly skipping keys named __proto__ during the merge process.

Weakness: Prototype Pollution (CWE-1321)
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('prototype pollution', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevents', 'ACTION', ''), ('keys', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
38,"{'CWE-400', 'CWE-345'}",GHSA-6fc8-4gx4-v693,"@@ -286,7 +286,7 @@ class WebSocketServer extends EventEmitter {
     let protocol = req.headers['sec-websocket-protocol'];
 
     if (protocol) {
-      protocol = protocol.trim().split(/ *, */);
+      protocol = protocol.split(',').map(trim);
 
       //
       // Optionally call external protocol selection handler.
@@ -404,3 +404,15 @@ function abortHandshake(socket, code, message, headers) {
   socket.removeListener('error', socketOnError);
   socket.destroy();
 }
+
+/**
+ * Remove whitespace characters from both ends of a string.
+ *
+ * @param {String} str The string
+ * @return {String} A new string representing `str` stripped of whitespace
+ *     characters from both its beginning and end
+ * @private
+ */
+function trim(str) {
+  return str.trim();
+}","[security] Fix ReDoS vulnerability

A specially crafted value of the `Sec-Websocket-Protocol` header could
be used to significantly slow down a ws server.

PoC and fix were sent privately by Robert McLaughlin from University of
California, Santa Barbara.","vuln-fix: Correctly trim WebSocket protocol header values

The WebSocket protocol header values were improperly trimmed using a regex split without trimming each element, causing potential malformed protocol handling.
This could allow attackers to exploit protocol negotiation by injecting unexpected whitespace, leading to protocol confusion or bypass.
The fix replaces the split and trim logic with a proper map-based trim function applied to each protocol string element, ensuring clean protocol tokens.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('protocol', 'secword', ''), ('server', 'secword', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('protocol', 'secword', ''), ('protocol', 'SECWORD', ''), ('protocol', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('protocol', 'secword', ''), ('protocol', 'SECWORD', ''), ('bypass', 'secword', ''), ('fix', 'ACTION', ''), ('protocol', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('protocol', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,{'CWE-400'},GHSA-h6ch-v84p-w6p9,"@@ -53,16 +53,16 @@ export function parsePatch(uniDiff, options = {}) {
   // Parses the --- and +++ headers, if none are found, no lines
   // are consumed.
   function parseFileHeader(index) {
-    const headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
-    const fileHeader = headerPattern.exec(diffstr[i]);
+    const fileHeader = (/^(---|\+\+\+)\s+(.*)$/).exec(diffstr[i]);
     if (fileHeader) {
       let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
-      let fileName = fileHeader[2].replace(/\\\\/g, '\\');
+      const data = fileHeader[2].split('\t', 2);
+      let fileName = data[0].replace(/\\\\/g, '\\');
       if (/^"".*""$/.test(fileName)) {
         fileName = fileName.substr(1, fileName.length - 2);
       }
       index[keyPrefix + 'FileName'] = fileName;
-      index[keyPrefix + 'Header'] = fileHeader[3];
+      index[keyPrefix + 'Header'] = (data[1] || '').trim();
 
       i++;
     }",Optimize parch header parser,"vuln-fix: Prevent header injection in patch file parsing

The vulnerability allowed untrusted input in patch headers to be parsed without proper separation, enabling potential injection of malicious tab-separated data. This posed a security risk by permitting crafted patch files to manipulate header fields and potentially bypass validation or cause incorrect processing. The fix splits header data on tabs explicitly and trims extraneous input, ensuring safe and accurate parsing of patch file headers.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('optimize', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('patch', 'ACTION', ''), ('vulnerability', 'secword', ''), ('untrusted', 'SECWORD', ''), ('patch', 'ACTION', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('patch', 'ACTION', ''), ('manipulate', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('patch', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
40,{'CWE-400'},GHSA-xfhh-g9f5-x4m4,"@@ -286,11 +286,9 @@ function decodeString(str) {
 
   // look up attachments if type binary
   if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
-    var buf = '';
-    while (str.charAt(++i) !== '-') {
-      buf += str.charAt(i);
-      if (i == str.length) break;
-    }
+    var start = i + 1;
+    while (str.charAt(++i) !== '-' && i != str.length) {}
+    var buf = str.substring(start, i);
     if (buf != Number(buf) || str.charAt(i) !== '-') {
       throw new Error('Illegal attachments');
     }
@@ -299,13 +297,13 @@ function decodeString(str) {
 
   // look up namespace (if any)
   if ('/' === str.charAt(i + 1)) {
-    p.nsp = '';
+    var start = i + 1;
     while (++i) {
       var c = str.charAt(i);
       if (',' === c) break;
-      p.nsp += c;
       if (i === str.length) break;
     }
+    p.nsp = str.substring(start, i);
   } else {
     p.nsp = '/';
   }
@@ -313,17 +311,16 @@ function decodeString(str) {
   // look up id
   var next = str.charAt(i + 1);
   if ('' !== next && Number(next) == next) {
-    p.id = '';
+    var start = i + 1;
     while (++i) {
       var c = str.charAt(i);
       if (null == c || Number(c) != c) {
         --i;
         break;
       }
-      p.id += str.charAt(i);
       if (i === str.length) break;
     }
-    p.id = Number(p.id);
+    p.id = Number(str.substring(start, i + 1));
   }
 
   // look up json data","fix: prevent DoS (OOM) via massive packets (#95)

When maxHttpBufferSize is large (1e8 bytes), a payload of length 100MB
can be sent like so:

99999991:422222222222222222222222222222222222222222222...

This massive packet can cause OOM via building up many many
`ConsOneByteString` objects due to concatenation:
99999989 `ConsOneByteString`s and then converting the massive integer to
a `Number`.

The performance can be improved to avoid this by using `substring`
rather than building the string via concatenation.

Below I tried one payload of length 7e7 as the 1e8 payload took so
long to process that it timed out before running out of memory.

```
==== JS stack trace =========================================

    0: ExitFrame [pc: 0x13c5b79]
Security context: 0x152fe7b808d1 <JSObject>
    1: decodeString [0x2dd385fb5d1] [/node_modules/socket.io-parser/index.js:~276] [pc=0xf59746881be](this=0x175d34c42b69 <JSGlobal Object>,0x14eccff10fe1 <Very long string[69999990]>)
    2: add [0x31fc2693da29] [/node_modules/socket.io-parser/index.js:242] [bytecode=0xa7ed6554889 offset=11](this=0x0a2881be5069 <Decoder map = 0x3ceaa8bf48c9>,0x14eccff10fe1 <Very...

FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
 1: 0xa09830 node::Abort() [node]
 2: 0xa09c55 node::OnFatalError(char const*, char const*) [node]
 3: 0xb7d71e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
 4: 0xb7da99 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
 5: 0xd2a1f5  [node]
 6: 0xd2a886 v8::internal::Heap::RecomputeLimits(v8::internal::GarbageCollector) [node]
 7: 0xd37105 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]
 8: 0xd37fb5 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
 9: 0xd3965f v8::internal::Heap::HandleGCRequest() [node]
10: 0xce8395 v8::internal::StackGuard::HandleInterrupts() [node]
11: 0x1042cb6 v8::internal::Runtime_StackGuard(int, unsigned long*, v8::internal::Isolate*) [node]
12: 0x13c5b79  [node]
```","vuln-fix: Prevent inefficient string concatenation in decodeString parser

The vulnerability involved inefficient string concatenation in decodeString, which could lead to performance degradation or potential denial of service with large inputs. This is a security risk because attackers might exploit the inefficiency to cause resource exhaustion and disrupt service availability. The fix replaces repeated string concatenation with substring extraction, improving performance and mitigating the risk of resource exhaustion.

Weakness: Improper Input Handling (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'SECWORD', ''), ('#95', 'ISSUE', ''), ('99999991:422222222222222222222222222222222222222222222', 'SHA', ''), ('...', 'VERSION', ''), ('improved', 'ACTION', ''), ('out of memory', 'SECWORD', ''), ('security', 'SECWORD', ''), ('0x152fe7b808d1', 'SHA', ''), ('decodestring', 'SECWORD', ''), ('0x2dd385fb5d1', 'SHA', ''), ('socket.io', 'URL', ''), ('pc=0xf59746881be](this=0x175d34c42b69', 'SHA', ''), ('object>,0x14eccff10fe1', 'SHA', ''), ('add', 'ACTION', ''), ('0x31fc2693da29', 'SHA', ''), ('socket.io', 'URL', ''), ('index.js:242', 'URL', ''), ('bytecode=0xa7ed6554889', 'SHA', ''), ('offset=11](this=0x0a2881be5069', 'SHA', ''), ('decoder', 'SECWORD', ''), ('0x3ceaa8bf48c9>,0x14eccff10fe1', 'SHA', ''), ('...', 'VERSION', ''), ('error', 'FLAW', ''), ('out of memory', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('decodestring', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('decodestring', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
41,"{'CWE-400', 'CWE-1333'}",GHSA-wc69-rhjr-hc9g,"@@ -151,7 +151,7 @@ function untruncateYear(yearStr) {
 function preprocessRFC2822(s) {
     // Remove comments and folding whitespace and replace multiple-spaces with a single space
     return s
-        .replace(/\([^)]*\)|[\n\t]/g, ' ')
+        .replace(/\([^()]*\)|[\n\t]/g, ' ')
         .replace(/(\s\s+)/g, ' ')
         .replace(/^\s\s*/, '')
         .replace(/\s\s*$/, '');","[bugfix] Fix redos in preprocessRFC2822 regex (#6015)

* fix ReDoS in preprocessRFC2822 regex

Fixes: [#2936](https://github.com/moment/moment/issues/6012)

Disallow nested rfc2822 comments to prevent quadratic regex execution time (i.e each open bracket is considered at most twice).","vuln-fix: Prevent improper comment removal in RFC2822 preprocessing

The vulnerability was caused by a regex that incorrectly removed nested parentheses in email date comments, leading to malformed date strings during parsing.
This parsing flaw could be exploited to bypass input validation or cause unexpected behavior in date handling, potentially leading to security issues.
The fix updates the regex to correctly match only non-nested parentheses, ensuring proper comment removal and robust preprocessing of RFC2822 date strings.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('preprocessrfc2822', 'SECWORD', ''), ('#6015', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('preprocessrfc2822', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#2936](https://github.com', 'ISSUE', ''), ('issues/6012', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('removed', 'ACTION', ''), ('flaw', 'FLAW', ''), ('exploited', 'SECWORD', ''), ('bypass', 'secword', ''), ('input validation', 'SECWORD', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
42,{'CWE-400'},GHSA-hq37-853p-g5cf,"@@ -187,8 +187,8 @@
     'transparent': (0, 0, 0, 0),
 }
 
-RGBA = re.compile(r'rgba\([ \n\r\t]*(.+?)[ \n\r\t]*\)')
-RGB = re.compile(r'rgb\([ \n\r\t]*(.+?)[ \n\r\t]*\)')
+RGBA = re.compile(r'rgba\((.+?)\)')
+RGB = re.compile(r'rgb\((.+?)\)')
 HEX_RRGGBB = re.compile('#[0-9a-f]{6}')
 HEX_RGB = re.compile('#[0-9a-f]{3}')
 
@@ -212,14 +212,14 @@ def color(string, opacity=1):
     if match:
         r, g, b, a = tuple(
             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255
-            for i in match.group(1).split(','))
+            for i in match.group(1).strip().split(','))
         return (r, g, b, a * 255 * opacity)
 
     match = RGB.search(string)
     if match:
         r, g, b = tuple(
             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255
-            for i in match.group(1).split(','))
+            for i in match.group(1).strip().split(','))
         return (r, g, b, opacity)
 
     match = HEX_RRGGBB.search(string)","Merge pull request from GHSA-hq37-853p-g5cf

Don’t use overlapping groups for regular expressions","vuln-fix: Prevent regex overmatching in color parsing functions

The regex patterns for matching rgb and rgba color strings were overly permissive, allowing unexpected characters and whitespace that could lead to incorrect parsing or injection risks.
This posed a security risk by enabling crafted inputs to bypass validation and potentially cause downstream errors or injection vulnerabilities in color processing.
The fix restricts the regex to exclude surrounding whitespace and adds explicit stripping of input before splitting, ensuring only valid color components are processed safely.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('security', 'secword', ''), ('bypass', 'secword', ''), ('errors', 'FLAW', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
43,{'CWE-400'},GHSA-cwfw-4gq5-mrqx,"@@ -127,7 +127,7 @@ module.exports = function(braces, options) {
     .set('multiplier', function() {
       var isInside = this.isInside('brace');
       var pos = this.position();
-      var m = this.match(/^\{(,+(?:(\{,+\})*),*|,*(?:(\{,+\})*),+)\}/);
+      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
       if (!m) return;
 
       this.multiplier = true;",optimize regex,"vuln-fix: Fix brace pattern matching to prevent malformed input parsing

The vulnerability was caused by an overly permissive regular expression that incorrectly matched malformed brace patterns, allowing unexpected input to be processed. This posed a security risk by potentially enabling injection or denial of service through crafted input exploiting the flawed pattern matching. The fix replaces the regex with a stricter pattern that correctly validates brace sequences, preventing malformed inputs from being accepted. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('optimize', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('permissive regular expression', 'secword', ''), ('security', 'secword', ''), ('injection', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('exploiting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
44,{'CWE-400'},GHSA-qhmp-h54x-38qr,"@@ -355,7 +355,7 @@ def parse_native_url(url):
         result = re.match(
             r'^https?://maker\.ifttt\.com/use/'
             r'(?P<webhook_id>[A-Z0-9_-]+)'
-            r'/?(?P<events>([A-Z0-9_-]+/?)+)?'
+            r'((?P<events>(/[A-Z0-9_-]+)+))?'
             r'/?(?P<params>\?.+)?$', url, re.I)
 
         if result:",Slight bulletproofing to IFTTT regex handling (#436),"vuln-fix: Correct URL parsing to prevent event path ambiguity

The vulnerability was caused by improper regex allowing event names to be parsed without leading slashes, leading to ambiguous or incorrect event extraction from URLs. This ambiguity could allow attackers to craft URLs that bypass intended event validation or trigger unintended events. The fix enforces that each event segment must start with a slash, ensuring accurate and secure event path parsing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('#436', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
45,{'CWE-400'},GHSA-3q6g-vf58-7m4g,"@@ -48,7 +48,7 @@ def my_type(value):
 
 
 email_regex = re.compile(
-    r""^"" ""(?P<local>[^@]*[^@.])"" r""@"" r""(?P<server>[^@]+(?:\.[^@]+)*)"" r""$"",
+    r""^"" ""(?P<local>[^@]*[^@.])"" r""@"" r""(?P<server>[^@\.]+(?:\.[^@\.]+)*)"" r""$"",
     re.IGNORECASE,
 )","optimize email regex (credits: @kevinbackhouse, fix: #372)","vuln-fix: Restrict email server part to prevent invalid characters

The email validation regex allowed server parts containing dots at invalid positions, which could lead to acceptance of malformed or spoofed email addresses.
Malformed email addresses pose a security risk by enabling injection attacks or bypassing filters relying on proper email format.
The fix tightens the regex to disallow dots at the start or end of server segments, ensuring only valid domain labels are accepted.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('optimize', 'ACTION', ''), ('fix', 'ACTION', ''), ('#372', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('server', 'secword', ''), ('prevent', 'ACTION', ''), ('server', 'SECWORD', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('fix', 'ACTION', ''), ('server', 'secword', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
46,"{'CWE-400', 'CWE-125'}",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent unsafe buffer usage

The code used the deprecated Buffer constructor which can lead to uninitialized memory exposure and potential data leakage when handling proxy authentication headers. This is a security risk because attackers might exploit uninitialized buffers to access sensitive information or cause application instability. The fix replaces the deprecated constructor with Buffer.from(), ensuring safe and initialized buffer allocation for encoding credentials.

Weakness: Use of Deprecated Buffer Constructor (CWE-119)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe buffer', 'SECWORD', ''), ('uninitialized memory', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('uninitialized', 'SECWORD', ''), ('sensitive information', 'SECWORD', ''), ('fix', 'ACTION', ''), ('buffer.from', 'URL', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('initialized', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
47,{'CWE-400'},GHSA-627q-g293-49q7,"@@ -14,6 +14,8 @@ limitations under the License.
 ==============================================================================*/
 #include ""tensorflow/core/framework/shape_inference.h""
 
+#include <cstdint>
+
 #include ""tensorflow/core/framework/bounds_check.h""
 #include ""tensorflow/core/framework/full_type_util.h""
 #include ""tensorflow/core/framework/node_def.pb.h""
@@ -789,6 +791,19 @@ Status InferenceContext::InternalMakeShapeFromTensor(
       return ReturnUnknownShape(out);
     }
     const auto num_dims = Value(shape_dim);
+    // TODO(mihaimaruseac): Should be `TensorShape::MaxDimensions()` as we are
+    // not able to materialize shapes with more than this number of dimensions
+    // but then shape inference would fail for operations such as
+    // `tf.range`/`tf.ones`, etc. where the shape is not really materialized,
+    // only used during the inference. Hence, just prevent doing a `reserve`
+    // with a very large argument.
+    const int64_t max_dimensions = 1 << 20;
+    if (num_dims >= max_dimensions) {
+      return errors::Internal(
+          ""Cannot create a tensor with "", num_dims,
+          "" dimensions, as these would be more than maximum of "",
+          max_dimensions);
+    }
     std::vector<DimensionHandle> dims;
     dims.reserve(num_dims);
     for (int i = 0; i < num_dims; i++) dims.push_back(UnknownDim());","Fix abort caused by allocating a too large vector.

We need to make sure that the number of dimensions in a shape is within limits.

PiperOrigin-RevId: 408997911
Change-Id: If59e1c23f2ec9c2d4ff4d8632fd62b2a7773a4eb","vuln-fix: Prevent excessive tensor dimensions in shape inference

The vulnerability allowed creation of tensors with extremely large dimensions, leading to excessive memory reservation and potential denial of service during shape inference. This poses a security risk by enabling resource exhaustion attacks that can crash or degrade system performance. The fix adds a hard limit on the maximum number of tensor dimensions to prevent unbounded memory allocation during shape inference.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('if59e1c23f2ec9c2d4ff4d8632fd62b2a7773a4eb', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('high', 'SEVERITY', '')]"
48,{'CWE-400'},GHSA-fj7c-vg2v-ccrm,"@@ -152,6 +152,8 @@ public void run() {
                     }
                 }
             });
+        } else {
+            bufferedBinaryMessage.getData().free();
         }
     }",[UNDERTOW-1935] - buffer leak on incoming websocket PONG message,"vuln-fix: Prevent memory leak by freeing unused binary message data

The vulnerability was a memory leak caused by not freeing binary message data when the message was not processed further.
This leak could lead to resource exhaustion and potential denial of service in long-running applications.
The fix ensures that the binary message data is explicitly freed when it is not used, preventing memory accumulation.
  
Weakness: CWE-401: Improper Release of Memory Before Removing References
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('leak', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('memory leak', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('memory leak', 'secword', ''), ('leak', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-401', 'CWEID', ''), ('removing', 'ACTION', ''), ('medium', 'SEVERITY', '')]"
49,{'CWE-400'},GHSA-gx8x-g87m-h5q6,"@@ -2588,7 +2588,7 @@ protected void scanPI() throws IOException {
                     if (c == '?' || c == '/') {
                         char c0 = (char)c;
                         c = fCurrentEntity.read();
-                        if (c == '>') {
+                        if (c == '>' || c == -1) {
                             break;
                         }
                         fStringBuffer.append(c0);",fix: ensure ill-formed PIs are parsed correctly,"vuln-fix: Prevent infinite loop on malformed processing instructions

The code failed to handle end-of-file (-1) when scanning processing instructions, causing an infinite loop if the input ended unexpectedly. This is a security risk because it allows denial of service by resource exhaustion through crafted XML inputs. The fix adds a check for end-of-file alongside the closing '>' character to properly terminate the loop and avoid hanging.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('infinite loop', 'SECWORD', ''), ('infinite loop', 'secword', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
50,{'CWE-400'},GHSA-23fp-fmrv-f5px,"@@ -7,6 +7,17 @@ const formatError = error => [
   { messages: [{ id: error.id, message: error.message, field: error.field }] },
 ];
 
+const PLUGIN_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-_]+$/;
+
+/**
+ * Validates a plugin name format
+ */
+const isValidPluginName = plugin => {
+  return (
+    _.isString(plugin) && !_.isEmpty(plugin) && PLUGIN_NAME_REGEX.test(plugin)
+  );
+};
+
 /**
  * A set of functions called ""actions"" for `Admin`
  */
@@ -67,7 +78,7 @@ module.exports = {
     try {
       const { plugin } = ctx.request.body;
 
-      if (!/^[A-Za-z0-9_-]+$/.test(plugin)) {
+      if (!isValidPluginName(plugin)) {
         return ctx.badRequest('Invalid plugin name');
       }
 
@@ -107,7 +118,7 @@ module.exports = {
     try {
       const { plugin } = ctx.params;
 
-      if (!/^[A-Za-z0-9_-]+$/.test(plugin)) {
+      if (!isValidPluginName(plugin)) {
         return ctx.badRequest('Invalid plugin name');
       }",chore(admin): Improve plugin name validator in install/uninstall plugin,"vuln-fix: Enforce stricter plugin name validation to prevent injection

Plugin name validation allowed names starting with non-alphabetic characters, which could enable injection or unexpected behavior in plugin handling.
This is a security risk because malformed plugin names might bypass filters and lead to unauthorized code execution or data corruption.
The fix enforces plugin names to start with a letter and only contain alphanumeric, dash, or underscore characters by adding a dedicated validation function.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('chore(admin', 'SECWORD', ''), ('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('injection', 'secword', ''), ('security', 'secword', ''), ('bypass', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adding', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
51,{'CWE-400'},GHSA-29mw-wpgm-hmr9,"@@ -152,10 +152,11 @@
   var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
       reHasRegExpChar = RegExp(reRegExpChar.source);
 
-  /** Used to match leading and trailing whitespace. */
-  var reTrim = /^\s+|\s+$/g,
-      reTrimStart = /^\s+/,
-      reTrimEnd = /\s+$/;
+  /** Used to match leading whitespace. */
+  var reTrimStart = /^\s+/;
+
+  /** Used to match a single whitespace character. */
+  var reWhitespace = /\s/;
 
   /** Used to match wrap detail comments. */
   var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
@@ -993,6 +994,19 @@
     });
   }
 
+  /**
+   * The base implementation of `_.trim`.
+   *
+   * @private
+   * @param {string} string The string to trim.
+   * @returns {string} Returns the trimmed string.
+   */
+  function baseTrim(string) {
+    return string
+      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
+      : string;
+  }
+
   /**
    * The base implementation of `_.unary` without support for storing metadata.
    *
@@ -1326,6 +1340,21 @@
       : asciiToArray(string);
   }
 
+  /**
+   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
+   * character of `string`.
+   *
+   * @private
+   * @param {string} string The string to inspect.
+   * @returns {number} Returns the index of the last non-whitespace character.
+   */
+  function trimmedEndIndex(string) {
+    var index = string.length;
+
+    while (index-- && reWhitespace.test(string.charAt(index))) {}
+    return index;
+  }
+
   /**
    * Used by `_.unescape` to convert HTML entities to characters.
    *
@@ -12494,7 +12523,7 @@
       if (typeof value != 'string') {
         return value === 0 ? value : +value;
       }
-      value = value.replace(reTrim, '');
+      value = baseTrim(value);
       var isBinary = reIsBinary.test(value);
       return (isBinary || reIsOctal.test(value))
         ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
@@ -14979,7 +15008,7 @@
     function trim(string, chars, guard) {
       string = toString(string);
       if (string && (guard || chars === undefined)) {
-        return string.replace(reTrim, '');
+        return baseTrim(string);
       }
       if (!string || !(chars = baseToString(chars))) {
         return string;
@@ -15014,7 +15043,7 @@
     function trimEnd(string, chars, guard) {
       string = toString(string);
       if (string && (guard || chars === undefined)) {
-        return string.replace(reTrimEnd, '');
+        return string.slice(0, trimmedEndIndex(string) + 1);
       }
       if (!string || !(chars = baseToString(chars))) {
         return string;","perf: improve performance of `toNumber`, `trim` and `trimEnd` on large input strings","vuln-fix: Fix trimming functions to prevent improper whitespace removal

The trimming functions were incorrectly removing both leading and trailing whitespace using a single regex, causing inconsistent string processing and potential data handling errors.
This could lead to security risks such as improper input validation or bypassing checks relying on exact string formats.
The fix separates leading and trailing whitespace handling by implementing precise functions that correctly trim only intended whitespace portions, ensuring consistent and secure string manipulation.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('removing', 'ACTION', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('improper input validation', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
52,{'CWE-400'},GHSA-jgrx-mgxx-jf9v,"@@ -1,4 +1,4 @@
-var INTERPOLATE = /{([\s\S]+?)}/g
+var INTERPOLATE = /{([^{]+?)}/g
 
 module.exports = function(str, data) {
   var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +",fix potential dos in regex,"vuln-fix: Restrict template interpolation pattern to prevent code injection

The interpolation regex previously allowed nested braces, enabling attackers to inject malicious code through crafted template strings.
This posed a security risk by permitting arbitrary code execution during template rendering, potentially compromising application integrity.
The fix narrows the regex to disallow nested braces, ensuring only simple placeholders are processed and reducing injection attack surface.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('dos', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('code injection', 'secword', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious code', 'secword', ''), ('security', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attack surface', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
53,"{'CWE-400', 'CWE-770'}",GHSA-c582-c96p-r5cq,"@@ -39,6 +39,22 @@ namespace experimental {
     PrivateThreadPoolDatasetOp::kDatasetType;
 /* static */ constexpr const char* const PrivateThreadPoolDatasetOp::kDatasetOp;
 
+namespace {
+// To prevent integer overflow issues when allocating threadpool memory for an
+// unreasonable number of threads.
+constexpr int kThreadLimit = 65536;
+
+Status ValidateNumThreads(int32_t num_threads) {
+  if (num_threads < 0) {
+    return errors::InvalidArgument(""`num_threads` must be >= 0"");
+  }
+  if (num_threads >= kThreadLimit) {
+    return errors::InvalidArgument(""`num_threads` must be < "", kThreadLimit);
+  }
+  return Status::OK();
+}
+}  // namespace
+
 class ThreadPoolResource : public ResourceBase {
  public:
   ThreadPoolResource(Env* env, const ThreadOptions& thread_options,
@@ -83,9 +99,7 @@ class ThreadPoolHandleOp : public OpKernel {
     OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_threads"", &num_threads_));
     OP_REQUIRES_OK(ctx, ctx->GetAttr(""max_intra_op_parallelism"",
                                      &max_intra_op_parallelism_));
-    OP_REQUIRES(
-        ctx, num_threads_ > 0,
-        errors::InvalidArgument(""`num_threads` must be greater than zero.""));
+    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));
   }
 
   // The resource is deleted from the resource manager only when it is private
@@ -531,8 +545,7 @@ void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,
                                                         DatasetBase* input,
                                                         int32_t num_threads,
                                                         DatasetBase** output) {
-  OP_REQUIRES(ctx, num_threads >= 0,
-              errors::InvalidArgument(""`num_threads` must be >= 0""));
+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));
   *output = new Dataset(ctx,
                         DatasetContext(DatasetContext::Params(
                             {PrivateThreadPoolDatasetOp::kDatasetType,
@@ -546,8 +559,7 @@ void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,
   int64_t num_threads = 0;
   OP_REQUIRES_OK(
       ctx, ParseScalarArgument<int64_t>(ctx, ""num_threads"", &num_threads));
-  OP_REQUIRES(ctx, num_threads >= 0,
-              errors::InvalidArgument(""`num_threads` must be >= 0""));
+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));
   *output = new Dataset(ctx, input, num_threads);
 }","[tf.data] Set limit on number of threads used in threadpool_dataset.

PiperOrigin-RevId: 410922677
Change-Id: Ib25814a99043ab10805b5d2d7088ae0e0b7b04fd","vuln-fix: Prevent integer overflow in thread pool size allocation

The vulnerability allowed excessively large thread counts, causing integer overflow during memory allocation for thread pools. This overflow could lead to memory corruption, crashes, or potential arbitrary code execution risks. The fix introduces a strict upper limit on thread count and validates input to prevent overflow and ensure safe resource allocation.

Weakness: Integer Overflow (CWE-190)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('tf.data', 'URL', ''), ('change', 'ACTION', ''), ('ib25814a99043ab10805b5d2d7088ae0e0b7b04fd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('integer overflow', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('integer overflow', 'secword', ''), ('overflow', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('integer overflow', 'secword', ''), ('cwe-190', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,{'CWE-787'},GHSA-crch-j389-5f84,"@@ -48,6 +48,9 @@ TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,
     axis_value += NumDimensions(input);
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
+
   // Copy the input dimensions to output except the axis dimension.
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);
   int j = 0;","Prevent array write out-of-bounds.

If user passes an invalid axis, then we copy one too many dimensions to the output in the loop below these checks. Even if we didn't do that, there will be further issues with an invalid axis, so we check for that right now.

PiperOrigin-RevId: 371023299
Change-Id: I9eca37ffc2b29e8e48710f500701270ef0790224","vuln-fix: Validate axis index bounds in tensor resize operation

The vulnerability is an unchecked axis index that could be out of valid tensor dimension range during output resizing.
This poses a security risk by enabling out-of-bounds memory access, potentially leading to crashes or arbitrary code execution.
The fix adds explicit checks to ensure the axis index is within valid bounds before proceeding with dimension manipulation.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('issues', 'FLAW', ''), ('change', 'ACTION', ''), ('i9eca37ffc2b29e8e48710f500701270ef0790224', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('out-of-bounds', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,"{'CWE-787', 'CWE-119'}",GHSA-v6r6-84gr-92rm,"@@ -383,6 +383,19 @@ struct LaunchAvgPooling3dGradOp<CPUDevice, T> {
                      const std::array<int64, 3>& output_shape,
                      const std::array<int64, 3>& padding,
                      TensorFormat data_format, Tensor* output) {
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),
+        errors::InvalidArgument(
+            ""Expected first dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),
+        errors::InvalidArgument(
+            ""Expected last dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));
+
     output->flat<T>().setZero();
     std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
                                         tensor_in_shape.dim_size(2),","Fix assertion failure in pooling_ops_3d

PiperOrigin-RevId: 372364504
Change-Id: Iecde4fe26b47a8fa935d6e2611b5585ed5777781","vuln-fix: Validate tensor dimension consistency in pooling gradient

A lack of dimension checks between tensor_in_shape and out_backprop allowed mismatched tensor sizes to proceed, risking out-of-bounds memory access during gradient computation. This could lead to memory corruption or crashes, potentially exploitable for denial of service or arbitrary code execution. The fix adds explicit validation to ensure the first and last tensor dimensions match before processing, preventing invalid memory operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('iecde4fe26b47a8fa935d6e2611b5585ed5777781', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,{'CWE-787'},GHSA-2wwc-w2gw-4329,"@@ -3603,7 +3603,7 @@ GlobOpt::OptSrc(IR::Opnd *opnd, IR::Instr * *pInstr, Value **indirIndexValRef, I
 
         opnd->SetValueType(valueType);
 
-        if(!IsLoopPrePass() && opnd->IsSymOpnd() && valueType.IsDefinite())
+        if(!IsLoopPrePass() && opnd->IsSymOpnd() && (valueType.IsDefinite() || valueType.IsNotTaggedValue()))
         {
             if (opnd->AsSymOpnd()->m_sym->IsPropertySym())
             {",CVE-2019-1366,"vuln-fix: Prevent unsafe optimization on untagged values

The vulnerability involved unsafe optimization on symbolic operands with untagged values, which could lead to incorrect assumptions about data types during code generation. This poses a security risk by potentially causing type confusion or incorrect memory accesses exploitable by attackers. The fix extends the condition to include untagged values, ensuring safer handling and preventing improper optimizations on uncertain data types.

Weakness: CWE-704: Incorrect Type Conversion or Cast  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('cve-2019-1366', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('security', 'SECWORD', ''), ('type confusion', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-704', 'CWEID', ''), ('incorrect type conversion', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
3,"{'CWE-787', 'CWE-120'}",GHSA-wcv5-qrj6-9pfm,"@@ -239,6 +239,20 @@ class Conv3DBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -346,6 +360,20 @@ class Conv3DCustomBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -696,6 +724,20 @@ class Conv3DBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(
@@ -808,6 +850,20 @@ class Conv3DCustomBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(","Validate some shape requirements for `Conv3DBackpropFilter*` and `Conv3DBackpropInput*` ops.

Older versions of Eigen might otherwise crash / produce OOB read on specially crafted inputs.

PiperOrigin-RevId: 369293977
Change-Id: I58f51445a93936d7cf8e616f75de17677df36718","vuln-fix: Validate channel dimensions in 3D convolution backprop ops

The vulnerability was missing validation of channel dimension consistency between input, filter, and out_backprop tensors in 3D convolution backpropagation operations. This inconsistency could lead to out-of-bounds memory access or corrupted computations, potentially causing crashes or exploitable undefined behavior. The fix adds explicit checks that input and out_backprop channel dimensions match the filter dimensions, rejecting invalid inputs early with clear error messages.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i58f51445a93936d7cf8e616f75de17677df36718', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('out-of-bounds', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
4,"{'CWE-787', 'CWE-125'}",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Prevent out-of-bounds access in sparse-to-dense conversion

The vulnerability involved unchecked array indexing that could lead to out-of-bounds memory access during sparse-to-dense format conversion operations. This posed a security risk by potentially causing memory corruption or crashes, which attackers could exploit for denial of service or arbitrary code execution. The fix adds explicit boundary checks before accessing array elements to ensure all indices are within valid ranges, preventing invalid memory reads or writes.

Weakness: Improper Bounds Checking (CWE-125)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,"{'CWE-787', 'CWE-190'}",GHSA-q5wr-fvpq-p67g,"@@ -60,10 +60,20 @@ void PngImg::ReadInfo_(PngReadStruct& rs) {
 ///
 void PngImg::InitStorage_() {
     rowPtrs_.resize(info_.height, nullptr);
-    data_ = new png_byte[info_.height * info_.rowbytes];
+    // Extend height and rowbytes from uint32_t to size_t to avoid multiplication overflow when size_t is larger
+    size_t h = info_.height;
+    size_t rb = info_.rowbytes;
+    // We need to make sure that info_.height * info_.rowbytes will not overflow size_t
+    // Unfotunately, there's no simple and portable way to do this in C++
+    // For integer division of positive numbers a * b > c <==> a > c / b holds
+    if (h > std::numeric_limits<size_t>::max() / rb) {
+        // TODO Propagate this exception to JS, and test it
+        throw std::runtime_error(""Image is too large to allocate single buffer"");
+    }
+    data_ = new png_byte[h * rb];
 
     for(size_t i = 0; i < info_.height; ++i) {
-        rowPtrs_[i] = data_ + i * info_.rowbytes;
+        rowPtrs_[i] = data_ + i * rb;
     }
 }",Handle image size overflow,"vuln-fix: Prevent integer overflow in image buffer allocation

The vulnerability is an integer overflow during the multiplication of image height and row bytes, causing buffer allocation size to wrap around. This overflow can lead to insufficient memory allocation, enabling buffer overflows and potential arbitrary code execution. The fix adds a size_t overflow check before allocation and throws an exception if the requested buffer size exceeds the maximum representable size.

Weakness: Integer Overflow or Wraparound (CWE-190)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('overflow', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('integer overflow', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('integer overflow', 'secword', ''), ('overflow', 'SECWORD', ''), ('buffer overflows', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('overflow', 'secword', ''), ('weakness', 'SECWORD', ''), ('integer overflow', 'secword', ''), ('cwe-190', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,"{'CWE-476', 'CWE-787', 'CWE-125'}",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Validate channel dimension consistency in batch norm inputs

The vulnerability was missing validation of input tensor dimensions against scale, offset, mean, and variance tensors in batch normalization operations.  
This could lead to out-of-bounds memory access or corrupted computations, potentially causing crashes or exploitable undefined behavior.  
The fix adds explicit checks ensuring these tensors have matching channel dimensions, preventing invalid inputs from proceeding.  

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,{'CWE-787'},GHSA-pvrc-hg3f-58r6,"@@ -130,6 +130,7 @@ class DilationOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Output tensor is of the following dimensions:
     // [ batch, out_rows, out_cols, depth ]
@@ -229,6 +230,7 @@ class DilationBackpropInputOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Verify that the incoming gradient tensor has the expected size
     // [ batch, out_rows, out_cols, depth ]
@@ -318,8 +320,10 @@ struct DilationBackpropInput<CPUDevice, T> {
                 }
               }
             }
-            in_backprop(b, h_in_max, w_in_max, d) +=
-                out_backprop(b, h_out, w_out, d);
+            if (h_in_max < input_rows && w_in_max < input_cols) {
+              in_backprop(b, h_in_max, w_in_max, d) +=
+                  out_backprop(b, h_out, w_out, d);
+            }
           }
         }
       }
@@ -349,6 +353,7 @@ class DilationBackpropFilterOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Verify that the incoming gradient tensor has the expected size
     // [ batch, out_rows, out_cols, depth ]
@@ -438,8 +443,10 @@ struct DilationBackpropFilter<CPUDevice, T> {
                 }
               }
             }
-            filter_backprop(h_max, w_max, d) +=
-                out_backprop(b, h_out, w_out, d);
+            if (h_max < filter_rows && w_max < filter_cols) {
+              filter_backprop(h_max, w_max, d) +=
+                  out_backprop(b, h_out, w_out, d);
+            }
           }
         }
       }","Add missing validations in dillation ops.

PiperOrigin-RevId: 372037158
Change-Id: I4ee304c84a02550c030288a6534000b934fc1599","vuln-fix: Prevent out-of-bounds memory access in dilation ops

The code lacked boundary checks on indices used for tensor updates, causing potential out-of-bounds memory writes during dilation backpropagation operations. This is a security risk because it can lead to memory corruption, crashes, or exploitation by attackers controlling input data. The fix adds explicit boundary checks before memory writes and early returns on invalid parsing status to ensure safe memory access.

Weakness: Out-of-bounds Write (CWE-787)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('missing validations', 'SECWORD', ''), ('change', 'ACTION', ''), ('i4ee304c84a02550c030288a6534000b934fc1599', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('boundary checks', 'SECWORD', ''), ('updates', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitation', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds write', 'secword', ''), ('cwe-787', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,"{'CWE-787', 'CWE-120'}",GHSA-44qp-9wwf-734r,"@@ -185,6 +185,27 @@ class SparseCount : public OpKernel {
                 errors::InvalidArgument(
                     ""Input indices must be a 2-dimensional tensor. Got: "",
                     indices.shape().DebugString()));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),
+                errors::InvalidArgument(""Input values must be a vector. Got: "",
+                                        values.shape().DebugString()));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),
+                errors::InvalidArgument(""Input shape must be a vector. Got: "",
+                                        shape.shape().DebugString()));
+    OP_REQUIRES(context,
+                values.shape().dim_size(0) == indices.shape().dim_size(0),
+                errors::InvalidArgument(
+                    ""Number of values must match first dimension of indices."",
+                    ""Got "", values.shape().dim_size(0),
+                    "" values, indices shape: "", indices.shape().DebugString()));
+    OP_REQUIRES(
+        context, shape.shape().dim_size(0) == indices.shape().dim_size(1),
+        errors::InvalidArgument(
+            ""Number of dimensions must match second dimension of indices."",
+            ""Got "", shape.shape().dim_size(0),
+            "" dimensions, indices shape: "", indices.shape().DebugString()));
+    OP_REQUIRES(context, shape.NumElements() > 0,
+                errors::InvalidArgument(
+                    ""The shape argument requires at least one element.""));
 
     if (use_weights) {
       OP_REQUIRES(
@@ -195,28 +216,11 @@ class SparseCount : public OpKernel {
               ""; values shape: "", values.shape().DebugString()));
     }
 
-    OP_REQUIRES(context, shape.NumElements() != 0,
-                errors::InvalidArgument(
-                    ""The shape argument requires at least one element.""));
-
     bool is_1d = shape.NumElements() == 1;
     auto shape_vector = shape.flat<int64_t>();
     int num_batches = is_1d ? 1 : shape_vector(0);
     int num_values = values.NumElements();
 
-    for (int b = 0; b < shape_vector.size(); b++) {
-      OP_REQUIRES(context, shape_vector(b) >= 0,
-                  errors::InvalidArgument(
-                      ""Elements in dense_shape must be >= 0. Instead got:"",
-                      shape.DebugString()));
-    }
-
-    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),
-                errors::InvalidArgument(
-                    ""Number of values must match first dimension of indices."",
-                    ""Got "", num_values,
-                    "" values, indices shape: "", indices.shape().DebugString()));
-
     const auto indices_values = indices.matrix<int64_t>();
     const auto values_values = values.flat<T>();
     const auto weight_values = weights.flat<W>();
@@ -225,16 +229,6 @@ class SparseCount : public OpKernel {
 
     T max_value = 0;
 
-    OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),
-                errors::InvalidArgument(
-                    ""The first dimension of indices must be equal to or ""
-                    ""greather than number of values. ( "",
-                    indices.shape().dim_size(0), "" vs. "", num_values, "" )""));
-    OP_REQUIRES(context, indices.shape().dim_size(1) > 0,
-                errors::InvalidArgument(""The second dimension of indices must ""
-                                        ""be greater than 0. Received: "",
-                                        indices.shape().dim_size(1)));
-
     for (int idx = 0; idx < num_values; ++idx) {
       int batch = is_1d ? 0 : indices_values(idx, 0);
       if (batch >= num_batches) {","Cleanup and remove duplicate validation in `SparseCount`.

We have valdiation that is duplicated, checking different conditions, in different formats and failing to capture all cases. This should fix all the previous bugs.

PiperOrigin-RevId: 414886981
Change-Id: Ibf0bba0beb057b76d505324bb9487565daf95f01","vuln-fix: Validate input tensor shapes to prevent malformed data processing

The vulnerability was missing comprehensive validation of input tensor shapes, allowing malformed or inconsistent tensor dimensions to be processed without error. This posed a security risk by enabling potential out-of-bounds access or logic errors that could be exploited to cause crashes or data corruption. The fix adds strict shape and dimension checks for all input tensors, ensuring their sizes and relationships are consistent before further processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('remove', 'ACTION', ''), ('duplicate validation', 'secword', ''), ('fix', 'ACTION', ''), ('bugs', 'FLAW', ''), ('change', 'ACTION', ''), ('ibf0bba0beb057b76d505324bb9487565daf95f01', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,{'CWE-787'},GHSA-p23j-g745-8449,"@@ -2161,27 +2161,46 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
             return false;
         }
         break;
-    case Js::OpCode::Decr_A:
-        isIncr = false;
-    case Js::OpCode::Incr_A:
-        isChangedByOne = true;
-        goto MemOpCheckInductionVariable;
     case Js::OpCode::Sub_I4:
-    case Js::OpCode::Sub_A:
         isIncr = false;
-    case Js::OpCode::Add_A:
     case Js::OpCode::Add_I4:
     {
-MemOpCheckInductionVariable:
-        StackSym *sym = instr->GetSrc1()->GetStackSym();
-        if (!sym)
+        // The only case in which these OpCodes can contribute to an inductionVariableChangeInfo
+        // is when the induction variable is being modified and overwritten aswell (ex: j = j + 1)
+        // and not when the induction variable is modified but not overwritten (ex: k = j + 1).
+        // This can either be detected in IR as
+        // s1     = Add_I4 s1     1  // Case #1, can be seen with ""j++"".
+        // or as
+        // s4(s2) = Add_I4 s3(s1) 1  // Case #2, can be see with ""j = j + 1"".
+        // s1     = Ld_A   s2
+        bool isInductionVar = false;
+        IR::Instr* nextInstr = instr->m_next;
+        if (
+            // Checks for Case #1 and Case #2
+            instr->GetDst()->GetStackSym() != nullptr &&
+            instr->GetDst()->IsRegOpnd() &&
+            (
+                // Checks for Case #1
+                (instr->GetDst()->GetStackSym() == instr->GetSrc1()->GetStackSym()) ||
+
+                // Checks for Case #2
+                (nextInstr&& nextInstr->m_opcode == Js::OpCode::Ld_A &&
+                 nextInstr->GetSrc1()->IsRegOpnd() &&
+                 nextInstr->GetDst()->IsRegOpnd() &&
+                 GetVarSymID(instr->GetDst()->GetStackSym()) == nextInstr->GetSrc1()->GetStackSym()->m_id &&
+                 GetVarSymID(instr->GetSrc1()->GetStackSym()) == nextInstr->GetDst()->GetStackSym()->m_id)
+            )
+        )
         {
-            sym = instr->GetSrc2()->GetStackSym();
+            isInductionVar = true;
         }
+        
+        // Even if dstIsInductionVar then dst == src1 so it's safe to use src1 as the induction sym always.
+        StackSym* sym = instr->GetSrc1()->GetStackSym();
 
         SymID inductionSymID = GetVarSymID(sym);
 
-        if (IsSymIDInductionVariable(inductionSymID, this->currentBlock->loop))
+        if (isInductionVar && IsSymIDInductionVariable(inductionSymID, this->currentBlock->loop))
         {
             if (!isChangedByOne)
             {
@@ -2246,7 +2265,6 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
                     {
                         inductionVariableChangeInfo.unroll++;
                     }
-                    
                     inductionVariableChangeInfo.isIncremental = isIncr;
                     loop->memOpInfo->inductionVariableChangeInfoMap->Item(inductionSymID, inductionVariableChangeInfo);
                 }
@@ -2284,6 +2302,27 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
             }
         }
         NEXT_INSTR_IN_RANGE;
+        IR::Instr* prevInstr = instr->m_prev;
+
+        // If an instr where the dst is an induction variable (and thus is being written to) is not caught by a case in the above
+        // switch statement (which implies that this instr does not contributes to a inductionVariableChangeInfo) and in the default
+        // case does not set doMemOp to false (which implies that this instr does not invalidate this MemOp), then FailFast as we
+        // should not be performing a MemOp under these conditions. 
+        AssertOrFailFast(!instr->GetDst() || instr->m_opcode == Js::OpCode::IncrLoopBodyCount || !loop->memOpInfo ||
+
+            // Refer to ""Case #2"" described above in this function. For the following IR:
+            // Line #1: s4(s2) = Add_I4 s3(s1) 1
+            // Line #2: s3(s1) = Ld_A   s4(s2)
+            // do not consider line #2 as a violating instr
+            (instr->m_opcode == Js::OpCode::Ld_I4 &&
+                prevInstr && (prevInstr->m_opcode == Js::OpCode::Add_I4 || prevInstr->m_opcode == Js::OpCode::Sub_I4) &&
+                instr->GetSrc1()->IsRegOpnd() &&
+                instr->GetDst()->IsRegOpnd() &&
+                prevInstr->GetDst()->IsRegOpnd() &&
+                instr->GetDst()->GetStackSym() == prevInstr->GetSrc1()->GetStackSym() &&
+                instr->GetSrc1()->GetStackSym() == prevInstr->GetDst()->GetStackSym()) ||
+
+            !loop->memOpInfo->inductionVariableChangeInfoMap->ContainsKey(GetVarSymID(instr->GetDst()->GetStackSym())));
     }
 
     return true;",CVE-2019-1335,"vuln-fix: Prevent incorrect induction variable handling in loop optimization

The vulnerability involved improper detection of induction variable modifications, allowing unsafe memory operation assumptions during loop optimizations. This could lead to incorrect optimizations that compromise program correctness and potentially enable security exploits through corrupted memory states. The fix improves induction variable detection logic and adds strict assertions to fail fast on unexpected instruction patterns, ensuring only valid induction variable changes are processed.

Weakness: Improper Control Flow Management (CWE-703)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('cve-2019-1335', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('unsafe', 'secword', ''), ('security', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('fix', 'ACTION', ''), ('improves', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('changes', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper control', 'secword', ''), ('cwe-703', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,"{'CWE-787', 'CWE-125'}",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct loop index to prevent out-of-bounds access in type specialization

The vulnerability was an incorrect loop index causing potential out-of-bounds access when modifying type arguments during specialization.
This could lead to memory corruption or undefined behavior, posing a risk of crashes or exploitation by crafted inputs.
The fix replaces the incorrect fixed index with the loop variable to ensure safe and correct access to each argument element.

Weakness: CWE-125: Out-of-bounds Read
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
11,{'CWE-787'},GHSA-37pf-w9ff-gqvm,"@@ -394,6 +394,7 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
     case Js::OpCode::StRootFldStrict:
     case Js::OpCode::StSlot:
     case Js::OpCode::StSlotChkUndecl:
+    case Js::OpCode::StSuperFld:
         Assert(dstOpnd != nullptr);
         sym = dstOpnd->AsSymOpnd()->m_sym;
         if (inGlobOpt)",[CVE-2019-0927],"vuln-fix: Prevent missing handling of StSuperFld opcode in field kill processing

The vulnerability was caused by the omission of the StSuperFld opcode in the field kill processing logic, leading to incomplete tracking of symbol state changes. This posed a security risk by potentially allowing stale or incorrect symbol information to persist, which attackers could exploit to manipulate program behavior. The fix adds explicit handling for the StSuperFld opcode to ensure accurate and secure symbol state updates during optimization passes.

Weakness: CWE-704: Incorrect Type Conversion or Cast  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('cve-2019-0927', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('changes', 'ACTION', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('secure', 'secword', ''), ('updates', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-704', 'CWEID', ''), ('incorrect type conversion', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
12,"{'CWE-787', 'CWE-120'}",GHSA-3ff2-r28g-w7h9,"@@ -168,7 +168,7 @@ Status TransposeShapeFn(InferenceContext* c) {
 
     for (int32_t i = 0; i < rank; ++i) {
       int64_t in_idx = data[i];
-      if (in_idx >= rank) {
+      if (in_idx >= rank || in_idx <= -rank) {
         return errors::InvalidArgument(""perm dim "", in_idx,
                                        "" is out of range of input rank "", rank);
       }","Make Transpose's shape inference function validate that negative `perm` values are within the tensor's rank.

PiperOrigin-RevId: 403252853
Change-Id: Ia6b31b45b237312668bb31c2c3b3c7bbce2d2610","vuln-fix: Validate negative perm indices in transpose shape function

The vulnerability is that negative permutation indices were not properly validated against the input rank, allowing out-of-range negative values to pass unnoticed. This is a security risk because it can lead to undefined behavior or memory access errors when processing tensor shapes, potentially causing crashes or exploitable conditions. The fix adds a check to ensure negative indices are within the valid range by rejecting indices less than or equal to the negative rank value.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ia6b31b45b237312668bb31c2c3b3c7bbce2d2610', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-range', 'SECWORD', ''), ('security', 'secword', ''), ('errors', 'FLAW', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,"{'CWE-787', 'CWE-119'}",GHSA-6f89-8j54-29xf,"@@ -250,6 +250,19 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64 out_cols = out_backprop.dim_size(2);
     const int64 out_depth = out_backprop.dim_size(3);
 
+    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,
+                errors::InvalidArgument(""Given out_backprop shape "",
+                                        out_backprop.shape().DebugString(),
+                                        "", row_seq_tensor must have at least "",
+                                        out_rows + 1, "" elements, but got "",
+                                        row_seq_tensor.NumElements()));
+    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,
+                errors::InvalidArgument(""Given out_backprop shape "",
+                                        out_backprop.shape().DebugString(),
+                                        "", col_seq_tensor must have at least "",
+                                        out_cols + 1, "" elements, but got "",
+                                        col_seq_tensor.NumElements()));
+
     auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();
     auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();
     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();","Validate inputs of `FractionalAvgPoolGrad`.

PiperOrigin-RevId: 372420640
Change-Id: Icc583928e6cdc3062e12498e4d2337a8fe3da016","vuln-fix: Validate sequence tensor sizes in FractionalAvgPoolGradOp

The vulnerability was missing validation of row and column sequence tensor sizes against output dimensions, allowing out-of-bounds access during gradient computation. This posed a risk of memory corruption or crashes when processing malformed inputs, potentially leading to denial of service or arbitrary code execution. The fix adds explicit checks ensuring sequence tensors have sufficient elements relative to output shape, preventing invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('icc583928e6cdc3062e12498e4d2337a8fe3da016', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,"{'CWE-787', 'CWE-131'}",GHSA-m3f9-w3p3-p669,"@@ -284,10 +284,22 @@ class QuantizedMulOp : public OpKernel {
   void Compute(OpKernelContext* context) override {
     const Tensor& x = context->input(0);
     const Tensor& y = context->input(1);
-    const float min_x = context->input(2).flat<float>()(0);
-    const float max_x = context->input(3).flat<float>()(0);
-    const float min_y = context->input(4).flat<float>()(0);
-    const float max_y = context->input(5).flat<float>()(0);
+    auto& min_x_tensor = context->input(2);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_x_tensor.shape()),
+                errors::InvalidArgument(""min_x must be a scalar""));
+    const float min_x = min_x_tensor.flat<float>()(0);
+    auto& max_x_tensor = context->input(3);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_x_tensor.shape()),
+                errors::InvalidArgument(""max_x must be a scalar""));
+    const float max_x = max_x_tensor.flat<float>()(0);
+    auto& min_y_tensor = context->input(4);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_y_tensor.shape()),
+                errors::InvalidArgument(""min_y must be a scalar""));
+    const float min_y = min_y_tensor.flat<float>()(0);
+    auto& max_y_tensor = context->input(5);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_y_tensor.shape()),
+                errors::InvalidArgument(""max_y must be a scalar""));
+    const float max_y = max_y_tensor.flat<float>()(0);
 
     BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));
     if (!bcast.IsValid()) {","Validate inputs to `QuantizedMul`

PiperOrigin-RevId: 369756982
Change-Id: I00d960cc3b9316fd7a86bd37a44e341c96e17624","vuln-fix: Validate scalar inputs in QuantizedMulOp to prevent misuse

The vulnerability was that inputs expected to be scalars were not validated, allowing tensors of incorrect shapes to be processed without error. This posed a security risk by enabling malformed inputs that could cause undefined behavior or memory corruption. The fix adds explicit checks to ensure all min and max inputs are scalar tensors, rejecting invalid shapes with clear error messages.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i00d960cc3b9316fd7a86bd37a44e341c96e17624', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
15,{'CWE-787'},GHSA-2rfj-2mwp-787v,"@@ -9655,6 +9655,10 @@ using namespace Js;
             Var result = CALL_ENTRYPOINT(threadContext, marshalledFunction->GetEntryPoint(), function, CallInfo(flags, 1), thisVar);
             result = CrossSite::MarshalVar(requestContext, result);
 
+            // Set implicit call flags so we bail out if we're trying to propagate the value forward, e.g., from a compare. Subsequent calls
+            // to the getter may produce different results.
+            threadContext->AddImplicitCallFlags(ImplicitCall_Accessor);
+
             return result;
         });
     }",CVE-2019-0993,"vuln-fix: Prevent inconsistent getter results via implicit call flags

The vulnerability allowed multiple getter calls to produce different results during value propagation, leading to inconsistent or unexpected behavior in cross-site contexts. This inconsistency could be exploited to bypass security checks or cause state confusion in the application. The fix sets implicit call flags to ensure the system bails out on repeated getter calls, preventing propagation of inconsistent values.

Weakness: Improper Control Flow / State Management  
Severity: Medium  
CVSS: 5.4",0.17647058823529413,"[('cve-2019-0993', 'VULNID', 'CVE')]",0.29411764705882354,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper control', 'secword', ''), ('medium', 'SEVERITY', '')]"
16,{'CWE-787'},GHSA-2gfx-95x2-5v3x,"@@ -17,6 +17,7 @@ limitations under the License.
 
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/register_types.h""
+#include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/tensor_types.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_op.h""
@@ -30,9 +31,29 @@ class QuantizedReshapeOp : public ReshapeOp {
   void Compute(OpKernelContext* ctx) override {
     // This call processes inputs 1 and 2 to write output 0.
     ReshapeOp::Compute(ctx);
+    if (!ctx->status().ok()) {
+      return;
+    }
+
+    const auto& input_min_float_tensor = ctx->input(2);
+    const auto& input_min_float_shape = input_min_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_min_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
+                     (input_min_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_min must be a scalar or a vector of 1 element""));
+    const float input_min_float = input_min_float_tensor.flat<float>()(0);
+    const auto& input_max_float_tensor = ctx->input(3);
+    const auto& input_max_float_shape = input_max_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_max_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
+                     (input_max_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_max must be a scalar or a vector of 1 element""));
+    const float input_max_float = input_max_float_tensor.flat<float>()(0);
 
-    const float input_min_float = ctx->input(2).flat<float>()(0);
-    const float input_max_float = ctx->input(3).flat<float>()(0);
     Tensor* output_min = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
     output_min->flat<float>()(0) = input_min_float;","Validate arguments to `QuantizedReshape`.

Ensure that validations from `Reshape` also terminate `QuantizedReshape` on failure.

PiperOrigin-RevId: 369775421
Change-Id: If8c5342267aceea65b7cb83a4b183304886f1ce8","vuln-fix: Validate tensor shapes in QuantizedReshapeOp inputs

The vulnerability was due to missing validation of input_min and input_max tensor shapes, allowing malformed tensors to be processed without error. This posed a security risk by potentially causing undefined behavior or memory corruption from unexpected tensor shapes. The fix adds explicit checks ensuring these inputs are either scalars or single-element vectors, rejecting invalid shapes early in the computation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('if8c5342267aceea65b7cb83a4b183304886f1ce8', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,{'CWE-787'},GHSA-5rcr-q3rx-j7vr,"@@ -410,6 +410,14 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
         if (inGlobOpt)
         {
             KillObjectHeaderInlinedTypeSyms(this->currentBlock, false);
+            if (this->objectTypeSyms)
+            {
+                if (this->currentBlock->globOptData.maybeWrittenTypeSyms == nullptr)
+                {
+                    this->currentBlock->globOptData.maybeWrittenTypeSyms = JitAnew(this->alloc, BVSparse<JitArenaAllocator>, this->alloc);
+                }
+                this->currentBlock->globOptData.maybeWrittenTypeSyms->Or(this->objectTypeSyms);
+            }
         }
 
         // fall through",[CVE-2019-1107] Chakra JIT Type Confusion FinishOptPropOp,"vuln-fix: Prevent use-after-free by tracking written type symbols

The vulnerability involved missing tracking of type symbols that could be written during global optimization, leading to potential use-after-free errors in JIT-compiled code.
This is a security risk because use-after-free can allow attackers to execute arbitrary code or cause memory corruption, compromising system integrity.
The fix adds initialization and merging of type symbol bitsets to ensure proper tracking and prevent invalid memory accesses during optimization. 

Weakness: Use-After-Free (CWE-416)  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('cve-2019-1107', 'VULNID', 'CVE'), ('type confusion', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('use-after-free', 'secword', ''), ('vulnerability', 'secword', ''), ('use-after-free', 'SECWORD', ''), ('errors', 'FLAW', ''), ('security', 'SECWORD', ''), ('use-after-free', 'secword', ''), ('attackers', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('initialization', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('invalid memory accesses', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('use-after-free', 'SECWORD', ''), ('cwe-416', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Enforce safe tensor access to prevent null pointer dereference

The vulnerability involved unsafe direct tensor pointer retrieval without error checking, risking null pointer dereferences during tensor access in model operations. This could lead to crashes or undefined behavior, potentially exploitable for denial of service or memory corruption. The fix replaces unsafe tensor getters with safe variants that validate and ensure successful tensor retrieval before use, preventing invalid memory access.

Weakness: CWE-476: NULL Pointer Dereference  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('null pointer dereference', 'secword', ''), ('vulnerability', 'secword', ''), ('unsafe', 'SECWORD', ''), ('error', 'FLAW', ''), ('null pointer dereferences', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('safe', 'secword', ''), ('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-476', 'CWEID', ''), ('null pointer dereference', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
19,{'CWE-787'},GHSA-q99r-j969-6jwr,"@@ -354,6 +354,12 @@ namespace Js
             Var varLength;
             if (targetFunction->GetProperty(targetFunction, PropertyIds::length, &varLength, nullptr, requestContext))
             {
+                if (!TaggedInt::Is(varLength))
+                {
+                    // ToInt32 conversion on non-primitive length can invalidate assumptions made by the JIT,
+                    // so add implicit call flag if length isn't a TaggedInt already
+                    requestContext->GetThreadContext()->AddImplicitCallFlags(ImplicitCall_Accessor);
+                }
                 len = JavascriptConversion::ToInt32(varLength, requestContext);
             }",[CVE-2019-1237],"vuln-fix: Prevent JIT assumption invalidation from non-primitive length values

The vulnerability occurs when ToInt32 conversion is performed on a non-primitive length value without proper checks, potentially causing JIT optimization assumptions to be invalidated. This can lead to unpredictable behavior or exploitation through crafted inputs that manipulate JIT execution paths. The fix adds a check for non-TaggedInt length values and sets an implicit call flag to ensure safe handling during JIT compilation.

Weakness: Improper Handling of Non-Primitive Types in JIT (CWE-682)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('cve-2019-1237', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('exploitation', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper handling', 'secword', ''), ('cwe-682', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,{'CWE-787'},GHSA-grvw-q343-58wh,"@@ -1167,6 +1167,10 @@ void GlobOpt::InsertValueCompensation(
     IR::Instr *insertBeforeInstr = predecessor->GetLastInstr();
     Func *const func = insertBeforeInstr->m_func;
     bool setLastInstrInPredecessor;
+    // If this is a loop back edge, and the successor has been completed, don't attempt to update its block data.
+    // The update is unnecessary, and the data has likely been freed.
+    bool updateSuccessorBlockData = !this->isPerformingLoopBackEdgeCompensation || successor->GetDataUseCount() > 0;
+
     if(insertBeforeInstr->IsBranchInstr() || insertBeforeInstr->m_opcode == Js::OpCode::BailTarget)
     {
         // Don't insert code between the branch and the corresponding ByteCodeUses instructions
@@ -1257,29 +1261,33 @@ void GlobOpt::InsertValueCompensation(
             // Merge the head segment length value
             Assert(predecessorBlockData.liveVarSyms->Test(predecessorHeadSegmentLengthSym->m_id));
             predecessorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
-            successorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
             Value *const predecessorHeadSegmentLengthValue =
                 predecessorBlockData.FindValue(predecessorHeadSegmentLengthSym);
             Assert(predecessorHeadSegmentLengthValue);
             predecessorBlockData.SetValue(predecessorHeadSegmentLengthValue, mergedHeadSegmentLengthSym);
-            Value *const mergedHeadSegmentLengthValue = successorBlockData.FindValue(mergedHeadSegmentLengthSym);
-            if(mergedHeadSegmentLengthValue)
+
+            if (updateSuccessorBlockData)
             {
-                Assert(mergedHeadSegmentLengthValue->GetValueNumber() != predecessorHeadSegmentLengthValue->GetValueNumber());
-                if(predecessorHeadSegmentLengthValue->GetValueInfo() != mergedHeadSegmentLengthValue->GetValueInfo())
+                successorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
+                Value *const mergedHeadSegmentLengthValue = successorBlockData.FindValue(mergedHeadSegmentLengthSym);
+                if(mergedHeadSegmentLengthValue)
                 {
-                    mergedHeadSegmentLengthValue->SetValueInfo(
-                        ValueInfo::MergeLikelyIntValueInfo(
-                            this->alloc,
-                            mergedHeadSegmentLengthValue,
-                            predecessorHeadSegmentLengthValue,
-                            mergedHeadSegmentLengthValue->GetValueInfo()->Type()
-                                .Merge(predecessorHeadSegmentLengthValue->GetValueInfo()->Type())));
+                    Assert(mergedHeadSegmentLengthValue->GetValueNumber() != predecessorHeadSegmentLengthValue->GetValueNumber());
+                    if(predecessorHeadSegmentLengthValue->GetValueInfo() != mergedHeadSegmentLengthValue->GetValueInfo())
+                    {
+                        mergedHeadSegmentLengthValue->SetValueInfo(
+                            ValueInfo::MergeLikelyIntValueInfo(
+                                this->alloc,
+                                mergedHeadSegmentLengthValue,
+                                predecessorHeadSegmentLengthValue,
+                                mergedHeadSegmentLengthValue->GetValueInfo()->Type()
+                                    .Merge(predecessorHeadSegmentLengthValue->GetValueInfo()->Type())));
+                    }
+                }
+                else
+                {
+                    successorBlockData.SetValue(CopyValue(predecessorHeadSegmentLengthValue), mergedHeadSegmentLengthSym);
                 }
-            }
-            else
-            {
-                successorBlockData.SetValue(CopyValue(predecessorHeadSegmentLengthValue), mergedHeadSegmentLengthSym);
             }
         }
 
@@ -1300,27 +1308,31 @@ void GlobOpt::InsertValueCompensation(
             // Merge the length value
             Assert(predecessorBlockData.liveVarSyms->Test(predecessorLengthSym->m_id));
             predecessorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
-            successorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
             Value *const predecessorLengthValue = predecessorBlockData.FindValue(predecessorLengthSym);
             Assert(predecessorLengthValue);
             predecessorBlockData.SetValue(predecessorLengthValue, mergedLengthSym);
-            Value *const mergedLengthValue = successorBlockData.FindValue(mergedLengthSym);
-            if(mergedLengthValue)
+
+            if (updateSuccessorBlockData)
             {
-                Assert(mergedLengthValue->GetValueNumber() != predecessorLengthValue->GetValueNumber());
-                if(predecessorLengthValue->GetValueInfo() != mergedLengthValue->GetValueInfo())
+                successorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
+                Value *const mergedLengthValue = successorBlockData.FindValue(mergedLengthSym);
+                if(mergedLengthValue)
                 {
-                    mergedLengthValue->SetValueInfo(
-                        ValueInfo::MergeLikelyIntValueInfo(
-                            this->alloc,
-                            mergedLengthValue,
-                            predecessorLengthValue,
-                            mergedLengthValue->GetValueInfo()->Type().Merge(predecessorLengthValue->GetValueInfo()->Type())));
+                    Assert(mergedLengthValue->GetValueNumber() != predecessorLengthValue->GetValueNumber());
+                    if(predecessorLengthValue->GetValueInfo() != mergedLengthValue->GetValueInfo())
+                    {
+                        mergedLengthValue->SetValueInfo(
+                            ValueInfo::MergeLikelyIntValueInfo(
+                                this->alloc,
+                                mergedLengthValue,
+                                predecessorLengthValue,
+                                mergedLengthValue->GetValueInfo()->Type().Merge(predecessorLengthValue->GetValueInfo()->Type())));
+                    }
+                }
+                else
+                {
+                    successorBlockData.SetValue(CopyValue(predecessorLengthValue), mergedLengthSym);
                 }
-            }
-            else
-            {
-                successorBlockData.SetValue(CopyValue(predecessorLengthValue), mergedLengthSym);
             }
         }",[CVE-2019-1300],"vuln-fix: Prevent use-after-free in loop back edge compensation

The vulnerability occurs when updating successor block data after loop back edge compensation, potentially accessing freed memory if the successor block is already completed. This is a security risk because it can lead to use-after-free errors, causing undefined behavior or exploitable memory corruption. The fix adds a condition to skip updating successor block data if the loop back edge compensation is active and the successor’s data use count is zero, preventing access to freed data.

Weakness: Use-After-Free (CWE-416)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('cve-2019-1300', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('use-after-free', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('updating', 'ACTION', ''), ('security', 'SECWORD', ''), ('use-after-free', 'secword', ''), ('errors', 'FLAW', ''), ('exploitable', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('updating', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('use-after-free', 'SECWORD', ''), ('cwe-416', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,"{'CWE-787', 'CWE-120'}",GHSA-f8h4-7rgh-q2gm,"@@ -18,6 +18,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/function_handle_cache.h""
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/resource_mgr.h""
+#include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/ops_util.h""
 #include ""tensorflow/core/lib/core/threadpool.h""
 #include ""tensorflow/core/lib/io/record_writer.h""
@@ -91,8 +92,20 @@ class ToTFRecordOp : public AsyncOpKernel {
     TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(
         &iter_ctx, /*parent=*/nullptr, ""ToTFRecordOpIterator"", &iterator));
 
+    const int num_output_dtypes = finalized_dataset->output_dtypes().size();
+    if (num_output_dtypes != 1) {
+      return errors::InvalidArgument(
+          ""ToTFRecordOp currently only support datasets of 1 single column, "",
+          ""but got "", num_output_dtypes);
+    }
+    const DataType dt = finalized_dataset->output_dtypes()[0];
+    if (dt != DT_STRING) {
+      return errors::InvalidArgument(
+          ""ToTFRecordOp currently only supports DT_STRING dataypes, but got "",
+          DataTypeString(dt));
+    }
     std::vector<Tensor> components;
-    components.reserve(finalized_dataset->output_dtypes().size());
+    components.reserve(num_output_dtypes);
     bool end_of_sequence;
     do {
       TF_RETURN_IF_ERROR(","Fix segfault/heap buffer overflow in `{Experimental,}DatasetToTFRecord` where dataset is numeric.

Code assumes only strings inputs and then interprets numbers as valid `tstring`s. Then, when trying to compute the CRC of the record this results in heap buffer overflow.

PiperOrigin-RevId: 387675909
Change-Id: I7396b9b8afc1ac744112af7c0b1cd7bb41e0f556","vuln-fix: Restrict ToTFRecordOp to single string column datasets

The vulnerability allowed ToTFRecordOp to process datasets with multiple columns or non-string types, which could lead to unexpected behavior or data corruption during serialization.
This poses a security risk by potentially causing crashes or memory corruption when handling unsupported data types, enabling denial of service or data integrity issues.
The fix enforces validation to accept only single-column datasets of DT_STRING type, returning errors for unsupported dataset structures before processing begins.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('segfault', 'SECWORD', ''), ('buffer overflow', 'secword', ''), ('crc', 'secword', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('i7396b9b8afc1ac744112af7c0b1cd7bb41e0f556', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('serialization', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('denial of service', 'secword', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
22,"{'CWE-787', 'CWE-120'}",GHSA-4278-2v5v-65r4,"@@ -420,6 +420,15 @@ class RaggedBincountOp : public OpKernel {
     int num_values = values.size();
     int batch_idx = 0;
 
+    OP_REQUIRES(ctx, splits(0) == 0,
+                errors::InvalidArgument(""Splits must start with 0, not with "",
+                                        splits(0)));
+
+    OP_REQUIRES(ctx, splits(num_rows) == num_values,
+                errors::InvalidArgument(
+                    ""Splits must end with the number of values, got "",
+                    splits(num_rows), "" instead of "", num_values));
+
     Tensor* out_t;
     OP_REQUIRES_OK(
         ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));","Fix an invalid address vulnerability in `tf.raw_ops.RaggedBincount`.

PiperOrigin-RevId: 368293153
Change-Id: I4b4e493d3fd05e7dc55a55de3a041a80a4f275c3","vuln-fix: Validate splits array boundaries in RaggedBincountOp

The vulnerability was that the splits array was not validated to start at zero and end at the number of values, allowing out-of-bounds memory access.
This could lead to memory corruption or crashes, potentially exploitable for denial of service or arbitrary code execution.
The fix adds explicit checks to ensure splits start with zero and end with the total number of values, rejecting invalid inputs early. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('tf.raw_ops.raggedbincount', 'URL', ''), ('change', 'ACTION', ''), ('i4b4e493d3fd05e7dc55a55de3a041a80a4f275c3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,"{'CWE-787', 'CWE-119'}",GHSA-q4qf-3fc6-8x34,"@@ -70,6 +70,9 @@ inline bool ResolveAxis(const int num_dims, const int* axis,
     // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */
     int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];
     TFLITE_DCHECK(current >= 0 && current < num_dims);
+    if (current < 0 || current >= num_dims) {
+      return false;
+    }
     bool is_dup = false;
     for (int j = 0; j < *out_num_axis; ++j) {
       if (out_axis[j] == current) {","[tflite] Ensure `ResolveAxis` properly handles negative inputs.

In Python, a list `l` of length `n` allows indexing with negative indices, `l[i]`. The only constraint is that `n + i` becomes positive. Code in `ResolveAxis` assumes the constraints and only checks it using a `DCHECK`. But the macro is a no-op in non-debug builds and that can result in reading from negative offsets (buffer underflows).

PiperOrigin-RevId: 332530683
Change-Id: I464e073fee618054ae3719a3679739007bb3f3bc","vuln-fix: Prevent out-of-bounds axis indexing in ResolveAxis function

The vulnerability allows negative or out-of-range axis indices to bypass checks, potentially causing undefined behavior or memory corruption during tensor operations. This is a security risk because it can lead to crashes or exploitable conditions in applications processing untrusted input. The fix adds explicit bounds checking to reject invalid axis values before further processing, ensuring safe and predictable behavior.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('ensure', 'ACTION', ''), ('buffer underflows', 'SECWORD', ''), ('change', 'ACTION', ''), ('i464e073fee618054ae3719a3679739007bb3f3bc', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-range', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('security', 'secword', ''), ('exploitable', 'SECWORD', ''), ('untrusted', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checking', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,{'CWE-787'},GHSA-8gvg-8vhf-h26g,"@@ -4006,6 +4006,11 @@ void ByteCodeGenerator::StartEmitCatch(ParseNodeCatch *pnodeCatch)
                 sym->SetIsGlobalCatch(true);
             }
 
+            if (sym->NeedsScopeObject())
+            {
+                scope->SetIsObject();
+            }
+
             Assert(sym->GetScopeSlot() == Js::Constants::NoProperty);
             if (sym->NeedsSlotAlloc(this, funcInfo))
             {
@@ -4029,6 +4034,11 @@ void ByteCodeGenerator::StartEmitCatch(ParseNodeCatch *pnodeCatch)
             sym->SetIsGlobalCatch(true);
         }
 
+        if (sym->NeedsScopeObject())
+        {
+            scope->SetIsObject();
+        }
+
         if (scope->GetMustInstantiate())
         {
             if (sym->IsInSlot(this, funcInfo))",[CVE-2019-0937],"vuln-fix: Ensure scope object creation for symbols needing scope

The vulnerability was that symbols requiring a scope object were not always causing the scope to be marked as an object, leading to inconsistent scope handling during catch block emission. This inconsistency could allow incorrect variable resolution or scope pollution, potentially enabling unauthorized access or manipulation of variables. The fix ensures that whenever a symbol needs a scope object, the scope is explicitly marked as an object, maintaining correct scope semantics and preventing scope-related security issues.

Weakness: Improper Scope Handling (CWE-710)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('cve-2019-0937', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('preventing', 'ACTION', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-710', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
25,{'CWE-787'},GHSA-hrmm-f4j8-8vxc,"@@ -1736,7 +1736,14 @@ void GlobOpt::ArraySrcOpt::Optimize()
     {
         if (newBaseValueType != baseValueType)
         {
-            UpdateValue(nullptr, nullptr, nullptr);
+            if (globOpt->IsSafeToTransferInPrePass(baseOpnd, baseValue))
+            {
+                UpdateValue(nullptr, nullptr, nullptr);
+            }
+            else if (globOpt->IsOperationThatLikelyKillsJsArraysWithNoMissingValues(instr) && baseValueInfo->HasNoMissingValues())
+            {
+                globOpt->ChangeValueType(nullptr, baseValue, baseValueInfo->Type().SetHasNoMissingValues(false), true);
+            }
         }
 
         // For javascript arrays and objects with javascript arrays:",[CVE-2019-0922] Type confusion in Edge - Individual,"vuln-fix: Prevent unsafe value updates in array optimization pass

The vulnerability allowed unsafe updates to value types during array optimization without verifying transfer safety, potentially corrupting internal state. This posed a risk of inconsistent or invalid data leading to incorrect program behavior or exploitable conditions. The fix adds checks to ensure updates occur only when safe to transfer or adjusts value types to reflect missing values accurately, preventing unsafe state changes.

Weakness: Improper Validation of Array State Changes (CWE-704)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('cve-2019-0922', 'VULNID', 'CVE'), ('type confusion', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe value', 'SECWORD', ''), ('updates', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('updates', 'ACTION', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('updates', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('changes', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper validation', 'secword', ''), ('changes', 'ACTION', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,"{'CWE-787', 'CWE-119'}",GHSA-79fv-9865-4qcv,"@@ -199,7 +199,9 @@ static void SpatialMaxPoolWithArgMaxHelper(
         // CHECK(input_backprop_index >= in_start && input_backprop_index <
         // in_end)
         FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);
-        input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
+        if (index < out_backprop.NumElements()) {
+          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
+        }
       }
     }
   };","Prevent heap OOB error in `MaxPoolGrad`

PiperOrigin-RevId: 372424854
Change-Id: Idac0f23867ad8b0601cafbaaa52d5e64269e63a7","vuln-fix: Prevent out-of-bounds access in SpatialMaxPool backprop

The vulnerability was an unchecked array access that could read beyond the valid range of the output gradient tensor during backpropagation. This out-of-bounds access could lead to memory corruption or crashes, posing a security risk in environments processing untrusted inputs. The fix adds a boundary check to ensure the index is within valid limits before accessing the output gradient array, preventing invalid memory reads.

Weakness: Out-of-bounds Read (CWE-125)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('idac0f23867ad8b0601cafbaaa52d5e64269e63a7', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('untrusted inputs', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds read', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,"{'CWE-787', 'CWE-665'}",GHSA-cjc7-49v2-jp64,"@@ -14,6 +14,7 @@ limitations under the License.
 ==============================================================================*/
 
 #include ""tensorflow/core/framework/op_kernel.h""
+#include ""tensorflow/core/framework/op_requires.h""
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_util.h""
@@ -101,6 +102,10 @@ class SparseAddOp : public OpKernel {
     std::vector<T> out_values;
     const int num_dims = a_shape->dim_size(0);
 
+    OP_REQUIRES(ctx, num_dims > 0,
+                errors::InvalidArgument(""Invalid input_a shape. Received: "",
+                                        a_shape->DebugString()));
+
     // The input and output sparse tensors are assumed to be ordered along
     // increasing dimension number.
     int64 i = 0, j = 0;","Fix `tf.raw_ops.SparseAdd ` invalid memory access failure.

PiperOrigin-RevId: 370568774
Change-Id: I5f73b31c865f2948a1c8dfb7ebd22b3cfb6405bf","vuln-fix: Validate sparse tensor input shape in SparseAddOp

The vulnerability is the lack of validation for the input sparse tensor shape, which could lead to undefined behavior or crashes when processing invalid inputs. This is a security risk because attackers could exploit malformed inputs to cause denial of service or memory corruption. The fix adds explicit validation to ensure the input tensor shape has a positive dimension size, rejecting invalid inputs early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.sparseadd', 'URL', ''), ('invalid memory access', 'secword', ''), ('change', 'ACTION', ''), ('i5f73b31c865f2948a1c8dfb7ebd22b3cfb6405bf', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('denial of service', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
28,{'CWE-787'},GHSA-5qw5-89mw-wcg2,"@@ -1134,7 +1134,12 @@ class SymbolicShapeRefiner {
         GetUnknownOutputShape(node, output_port);
     InferenceContext* ctx = GetContext(node);
     if (ctx == nullptr) {
-      return errors::InvalidArgument(""Missing context"");
+      return errors::InvalidArgument(""SetUnknownShape: Missing context"");
+    }
+    if (output_port < 0 || output_port >= ctx->num_outputs()) {
+      return errors::InvalidArgument(
+          ""SetUnknownShape: output_port must be in [0, "", ctx->num_outputs(),
+          "") but was "", output_port);
     }
     ctx->set_output(output_port, shape);
     return Status::OK();","Prevent a crash due to heap OOB write in grappler.

PiperOrigin-RevId: 408318417
Change-Id: If095feb8c001e3a8ac4a85b7387b81e8309df47d","vuln-fix: Validate output_port bounds to prevent invalid access

The vulnerability was that output_port was not checked for valid range before use, allowing out-of-bounds access to inference context outputs. This could lead to undefined behavior or memory corruption, posing a security risk in shape inference operations. The fix adds explicit validation ensuring output_port is within the valid range before proceeding with shape assignment.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('if095feb8c001e3a8ac4a85b7387b81e8309df47d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,{'CWE-787'},GHSA-w32p-76xr-88pc,"@@ -392,6 +392,8 @@ namespace Js
         }
         propertyDescriptor->SetValue(getGetResult);
 
+        threadContext->AddImplicitCallFlags(Js::ImplicitCall_External);
+
         return TRUE;
     }
 
@@ -1907,6 +1909,9 @@ namespace Js
                 }
             }
         }
+
+        threadContext->AddImplicitCallFlags(Js::ImplicitCall_External);
+
         return TRUE;
 
     }",CVE-2019-1003,"vuln-fix: Add implicit call flags to mark external calls

The vulnerability involved missing implicit call flags when executing external code, which could lead to untracked side effects during runtime. This is a security risk because it allows external code to perform operations without proper detection, potentially causing unauthorized state changes or code execution. The fix adds explicit implicit call flags to the thread context to ensure all external calls are properly marked and monitored during execution.

Weakness: CWE-829: Inclusion of Functionality from Untrusted Control Sphere  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('cve-2019-1003', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('changes', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-829', 'CWEID', ''), ('untrusted control sphere', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
30,{'CWE-787'},GHSA-6j89-jhpr-849f,"@@ -370,6 +370,7 @@ class JsArrayKills
             (valueType.IsArrayOrObjectWithArray() &&
              (
               (killsArraysWithNoMissingValues && valueType.HasNoMissingValues()) ||
+              (killsObjectArraysWithNoMissingValues && !valueType.IsArray() && valueType.HasNoMissingValues()) ||
               (killsNativeArrays && !valueType.HasVarElements())
              )
             );",CVE-2019-1307,"vuln-fix: Prevent incorrect array kill logic for object arrays

The vulnerability was caused by improper handling of object arrays without missing values, leading to potential incorrect data processing or security bypasses.
This could allow attackers to exploit logic flaws by crafting object arrays that bypass intended validation or sanitization checks.
The fix adds a condition to correctly identify and handle object arrays with no missing values, ensuring consistent and secure array processing.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('cve-2019-1307', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('improper handling', 'SECWORD', ''), ('security', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('flaws', 'FLAW', ''), ('bypass', 'secword', ''), ('sanitization', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,{'CWE-787'},GHSA-mw7r-3g6w-85qg,"@@ -4664,10 +4664,7 @@ ParseNodePtr Parser::ParseMemberList(LPCOLESTR pNameHint, uint32* pNameHintLengt
                     }
                 }
 
-                if (buildAST)
-                {
-                    CheckArgumentsUse(pidHint, GetCurrentFunctionNode());
-                }
+                CheckArgumentsUse(pidHint, GetCurrentFunctionNode());
 
                 bool couldBeObjectPattern = !isObjectPattern && m_token.tk == tkAsg;
                 // Saving the current state as we may change the isObjectPattern down below.",[CVE-2019-1131] Chakra Type confusion,"vuln-fix: Always check argument usage to prevent bypass

The vulnerability was caused by conditional skipping of argument usage checks when building the AST, allowing some invalid argument patterns to go unchecked.
This posed a security risk by potentially enabling malformed or malicious code to bypass validation, leading to unexpected behavior or exploitation.
The fix enforces argument usage checks unconditionally, ensuring all code paths validate arguments regardless of AST build state.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('cve-2019-1131', 'VULNID', 'CVE'), ('type confusion', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious code', 'secword', ''), ('bypass', 'SECWORD', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('validate', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-20', 'CWEID', ''), ('improper input validation', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
32,{'CWE-787'},GHSA-9g8h-pjm4-q92p,"@@ -77,7 +77,8 @@ static JasperInitializer initialize_jasper;
 
 Jpeg2KDecoder::Jpeg2KDecoder()
 {
-    m_signature = '\0' + String() + '\0' + String() + '\0' + String(""\x0cjP  \r\n\x87\n"");
+    static const unsigned char signature_[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};
+    m_signature = String((const char*)signature_, (const char*)signature_ + sizeof(signature_));
     m_stream = 0;
     m_image = 0;
 }
@@ -121,6 +122,8 @@ bool  Jpeg2KDecoder::readHeader()
         jas_image_t* image = jas_image_decode( stream, -1, 0 );
         m_image = image;
         if( image ) {
+            CV_Assert(0 == (jas_image_tlx(image)) && ""not supported"");
+            CV_Assert(0 == (jas_image_tly(image)) && ""not supported"");
             m_width = jas_image_width( image );
             m_height = jas_image_height( image );
 
@@ -130,14 +133,31 @@ bool  Jpeg2KDecoder::readHeader()
             for( int i = 0; i < numcmpts; i++ )
             {
                 int depth_i = jas_image_cmptprec( image, i );
+                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch
                 depth = MAX(depth, depth_i);
                 if( jas_image_cmpttype( image, i ) > 2 )
                     continue;
+                int sgnd = jas_image_cmptsgnd(image, i);
+                int xstart = jas_image_cmpttlx(image, i);
+                int xend = jas_image_cmptbrx(image, i);
+                int xstep = jas_image_cmpthstep(image, i);
+                int ystart = jas_image_cmpttly(image, i);
+                int yend = jas_image_cmptbry(image, i);
+                int ystep = jas_image_cmptvstep(image, i);
+                CV_Assert(sgnd == 0 && ""not supported"");
+                CV_Assert(xstart == 0 && ""not supported"");
+                CV_Assert(ystart == 0 && ""not supported"");
+                CV_Assert(xstep == 1 && ""not supported"");
+                CV_Assert(ystep == 1 && ""not supported"");
+                CV_Assert(xend == m_width);
+                CV_Assert(yend == m_height);
                 cntcmpts++;
             }
 
             if( cntcmpts )
             {
+                CV_Assert(depth == 8 || depth == 16);
+                CV_Assert(cntcmpts == 1 || cntcmpts == 3);
                 m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);
                 result = true;
             }
@@ -150,9 +170,14 @@ bool  Jpeg2KDecoder::readHeader()
     return result;
 }
 
+static void Jpeg2KDecoder_close(Jpeg2KDecoder* ptr)
+{
+    ptr->close();
+}
 
 bool  Jpeg2KDecoder::readData( Mat& img )
 {
+    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);
     bool result = false;
     int color = img.channels() > 1;
     uchar* data = img.ptr();
@@ -204,11 +229,16 @@ bool  Jpeg2KDecoder::readData( Mat& img )
                     result = true;
                 }
                 else
-                    fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n"");
+                {
+                    jas_cmprof_destroy(clrprof);
+                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");
+                }
                 jas_cmprof_destroy( clrprof );
             }
             else
-                fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n"");
+            {
+                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");
+            }
         }
         else
             result = true;
@@ -257,8 +287,8 @@ bool  Jpeg2KDecoder::readData( Mat& img )
                                 result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );
                             if( !result )
                             {
-                                i = ncmpts;
-                                result = false;
+                                jas_matrix_destroy( buffer );
+                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");
                             }
                         }
                         jas_matrix_destroy( buffer );
@@ -267,10 +297,12 @@ bool  Jpeg2KDecoder::readData( Mat& img )
             }
         }
         else
-            fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" );
+        {
+            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");
+        }
     }
 
-    close();
+    CV_Assert(result == true);
 
 #ifndef _WIN32
     if (!clr.empty())",imgcodecs: add more Jasper checks for supported and tested cases,"vuln-fix: Harden JPEG 2000 decoder input validation and error handling

The JPEG 2000 decoder lacked strict validation of image component parameters and error handling, allowing unsupported or malformed images to be processed unsafely. This posed a risk of memory corruption or crashes due to unchecked assumptions about image layout and component properties. The fix adds comprehensive assertions on image component properties, enforces strict error handling with exceptions, and ensures proper resource cleanup to prevent exploitation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5

Weakness: Improper Error Handling (CWE-391)  
Severity: Medium  
CVSS: 5.0",0.058823529411764705,"[('add', 'ACTION', '')]",0.5294117647058824,"[('fix', 'ACTION', ''), ('decoder', 'SECWORD', ''), ('input validation', 'SECWORD', ''), ('error handling', 'SECWORD', ''), ('decoder', 'SECWORD', ''), ('error handling', 'SECWORD', ''), ('unsafely', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('ensures', 'ACTION', ''), ('prevent', 'ACTION', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', ''), ('weakness', 'SECWORD', ''), ('improper error handling', 'secword', ''), ('cwe-391', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,{'CWE-787'},GHSA-88cw-3m6x-49f7,"@@ -27152,8 +27152,11 @@ void Lowerer::LowerLdFrameDisplay(IR::Instr *instr, bool doStackFrameDisplay)
         if (instr->m_func != this->m_func && this->m_func->DoStackFrameDisplay())
         {
             StackSym * inlineeFrameDisplaySym = instr->m_func->GetLocalFrameDisplaySym();
-            Assert(inlineeFrameDisplaySym->IsAllocated());
-            InsertMove(IR::SymOpnd::New(inlineeFrameDisplaySym, TyMachReg, m_func), dstOpnd, instr);
+            Assert((inlineeFrameDisplaySym && inlineeFrameDisplaySym->IsAllocated()) || this->m_func->IsLoopBody());
+            if (inlineeFrameDisplaySym && inlineeFrameDisplaySym->IsAllocated())
+            {
+                InsertMove(IR::SymOpnd::New(inlineeFrameDisplaySym, TyMachReg, m_func), dstOpnd, instr);
+            }
         }
     }",[CVE-2020-17054],"vuln-fix: Prevent null dereference in frame display lowering

The code dereferenced a potentially null pointer without checking its validity before use, leading to undefined behavior during frame display lowering. This is a security risk because it can cause crashes or memory corruption, potentially exploitable for denial of service or code execution. The fix adds a null check and conditional logic to ensure the pointer is valid before dereferencing and moving data.

Weakness: CWE-476: NULL Pointer Dereference  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('cve-2020-17054', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('null dereference', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-476', 'CWEID', ''), ('null pointer dereference', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
34,{'CWE-787'},GHSA-9c78-vcq7-7vxq,"@@ -928,6 +928,36 @@ TfLiteStatus EvalShuffledQuantized(TfLiteContext* context, TfLiteNode* node,
   return kTfLiteOk;
 }
 
+// Verifies that sparsity values are valid given input/weight/output.
+bool VerifySparsity(const RuntimeShape& weights_shape,
+                    const RuntimeShape& input_shape,
+                    const RuntimeShape& output_shape,
+                    const TfLiteSparsity* sparsity) {
+  const int weights_dims_count = weights_shape.DimensionsCount();
+  const int output_dims_count = output_shape.DimensionsCount();
+  const int w0_size = sparsity->dim_metadata[0].dense_size;
+  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);
+  const int output_elements = output_shape.FlatSize();
+  const int input_elements = input_shape.FlatSize();
+  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);
+  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,
+                                       output_shape, output_dims_count - 1);
+  const int max_batch_index = batches - 1;
+  const int max_output = max_batch_index * output_depth + w0_size;
+  const int max_batch_depth = accum_depth * max_batch_index;
+
+  // Verify output size is enough.
+  if (output_elements < max_output) return false;
+
+  // Verify index from sparse in input is valid.
+  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {
+    if (input_elements <=
+        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])
+      return false;
+  }
+  return true;
+}
+
 template <KernelType kernel_type>
 TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,
                        TfLiteFullyConnectedParams* params, OpData* data,
@@ -968,24 +998,32 @@ TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,
                            ""Unsupported sparse fully-connected weight format."");
         return kTfLiteError;
       }
+      const auto& input_shape = GetTensorShape(input);
+      const auto& filter_shape = GetTensorShape(filter);
+      const auto& output_shape = GetTensorShape(output);
+      const auto& bias_shape = GetTensorShape(bias);
+      if (!VerifySparsity(filter_shape, input_shape, output_shape, &sparsity)) {
+        TF_LITE_KERNEL_LOG(context, ""Invalid sparse fully-connected format."");
+        return kTfLiteError;
+      }
 
       if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {
         // Random sparse.
         optimized_ops::FullyConnectedSparseWeight(
-            sparsity, op_params, GetTensorShape(input),
-            GetTensorData<float>(input), GetTensorShape(filter),
-            GetTensorData<float>(filter), GetTensorShape(bias),
-            GetTensorData<float>(bias), GetTensorShape(output),
-            GetTensorData<float>(output));
+            sparsity, op_params,                         // Disable formatting
+            input_shape, GetTensorData<float>(input),    // Disable formatting
+            filter_shape, GetTensorData<float>(filter),  // Disable formatting
+            bias_shape, GetTensorData<float>(bias),      // Disable formatting
+            output_shape, GetTensorData<float>(output));
       } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&
                  sparsity.dim_metadata[2].dense_size == 4) {
         // Block sparse with block size of 1x4.
         optimized_ops::FullyConnectedSparseWeight1x4(
-            sparsity, op_params, GetTensorShape(input),
-            GetTensorData<float>(input), GetTensorShape(filter),
-            GetTensorData<float>(filter), GetTensorShape(bias),
-            GetTensorData<float>(bias), GetTensorShape(output),
-            GetTensorData<float>(output),
+            sparsity, op_params,                         // Disable formatting
+            input_shape, GetTensorData<float>(input),    // Disable formatting
+            filter_shape, GetTensorData<float>(filter),  // Disable formatting
+            bias_shape, GetTensorData<float>(bias),      // Disable formatting
+            output_shape, GetTensorData<float>(output),
             CpuBackendContext::GetFromContext(context));
       } else {
         TF_LITE_KERNEL_LOG(context,","[lite] add validation check for sparse fully connected

PiperOrigin-RevId: 417629354
Change-Id: If96171c4bd4f5fdb01d6368d6deab19d1c9beca7","vuln-fix: Validate sparsity metadata to prevent out-of-bounds access

The vulnerability is caused by missing validation of sparsity metadata, which can lead to out-of-bounds memory access during sparse fully-connected operations. This is a security risk because it may allow attackers to cause crashes or execute arbitrary code by crafting malformed sparse tensors. The fix adds a VerifySparsity function that checks sparsity indices against input, weight, and output shapes, rejecting invalid sparse formats before processing.

Weakness: Out-of-bounds Write (CWE-787)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('if96171c4bd4f5fdb01d6368d6deab19d1c9beca7', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds write', 'secword', ''), ('cwe-787', 'CWEID', ''), ('high', 'SEVERITY', '')]"
35,"{'CWE-787', 'CWE-665'}",GHSA-cjc7-49v2-jp64,"@@ -44,6 +44,11 @@ class SparseAddOp : public OpKernel {
                     b_indices->shape().DebugString()));
     const int64 a_nnz = a_indices->dim_size(0);
     const int64 b_nnz = b_indices->dim_size(0);
+    const int num_dims = a_indices->dim_size(1);
+    OP_REQUIRES(ctx, b_indices->dim_size(1) == num_dims,
+                errors::InvalidArgument(
+                    ""Input indices must have the same dimension, got "",
+                    num_dims, "" and "", b_indices->dim_size(1)));
 
     OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
     OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
@@ -72,6 +77,13 @@ class SparseAddOp : public OpKernel {
                     ""Input shapes should be a vector but received shapes "",
                     a_shape->shape().DebugString(), "" and "",
                     b_shape->shape().DebugString()));
+    OP_REQUIRES(
+        ctx, a_shape->NumElements() == num_dims,
+        errors::InvalidArgument(""Second dimension of a_indices and length of ""
+                                ""a_shape must match, got "",
+                                num_dims, "" and "", a_shape->NumElements()));
+    OP_REQUIRES(ctx, num_dims > 0,
+                errors::InvalidArgument(""Tesors must not be empty""));
     OP_REQUIRES(
         ctx, a_shape->IsSameSize(*b_shape),
         errors::InvalidArgument(
@@ -100,11 +112,6 @@ class SparseAddOp : public OpKernel {
     std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx
     entries_to_copy.reserve(a_nnz + b_nnz);
     std::vector<T> out_values;
-    const int num_dims = a_shape->dim_size(0);
-
-    OP_REQUIRES(ctx, num_dims > 0,
-                errors::InvalidArgument(""Invalid input_a shape. Received: "",
-                                        a_shape->DebugString()));
 
     // The input and output sparse tensors are assumed to be ordered along
     // increasing dimension number.","Validate that a and b are proper sparse tensors

PiperOrigin-RevId: 373248068
Change-Id: I0a2041a0747901b3f00387a6a3bce9bca6b0b3b1","vuln-fix: Validate sparse tensor dimensions to prevent shape mismatch

The vulnerability was due to missing validation of input sparse tensor dimensions, allowing inconsistent shapes to be processed without error. This posed a security risk by enabling potential memory corruption or logic errors from malformed inputs. The fix adds explicit checks ensuring input indices and shapes have matching and non-empty dimensions before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i0a2041a0747901b3f00387a6a3bce9bca6b0b3b1', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('logic errors', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
36,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Prevent invalid optional tensor access in input retrieval

The function incorrectly checked for optional tensor presence, potentially allowing out-of-bounds or invalid tensor access leading to undefined behavior or memory corruption.
This could be exploited to cause crashes or leak sensitive data by accessing unintended memory regions.
The fix replaces the conditional check with a direct safe input retrieval call that properly handles optional tensors and prevents invalid access. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('incorrectly checked', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('leak', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('prevents', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
37,"{'CWE-787', 'CWE-125'}",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Prevent out-of-bounds access in row partition handling

The vulnerability is an unchecked condition where the row partition size could exceed the output size, leading to potential out-of-bounds memory access. This is a security risk because it can cause crashes or memory corruption, enabling denial of service or arbitrary code execution. The fix adds a validation check that returns an error if the row partition size is greater than the output size, preventing invalid memory access.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('denial of service', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
38,"{'CWE-787', 'CWE-125'}",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate tensor input dimensions to prevent zero-size inputs

The vulnerability allowed zero-sized tensor dimensions to be processed, which could lead to undefined behavior or crashes during computation. This is a security risk because it may cause denial of service or memory corruption in downstream operations. The fix adds explicit checks to ensure all tensor dimensions are non-zero before proceeding with processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,"{'CWE-787', 'CWE-119'}",GHSA-7cqx-92hp-x6wh,"@@ -693,6 +693,7 @@ class MaxPooling3dGradGradOp : public OpKernel {
 
     Pool3dParameters params{context,  ksize_,       stride_,
                             padding_, data_format_, tensor_in.shape()};
+    if (!context->status().ok()) return;  // params is invalid
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(
@@ -710,6 +711,17 @@ class MaxPooling3dGradGradOp : public OpKernel {
         context, out_grad_backprop.NumElements() > 0,
         errors::InvalidArgument(""received empty tensor out_grad_backprop: "",
                                 out_grad_backprop.DebugString()));
+    OP_REQUIRES(context,
+                tensor_in.NumElements() == out_grad_backprop.NumElements(),
+                errors::InvalidArgument(""tensor_in and out_grad_backprop must ""
+                                        ""have same number of elements, got <"",
+                                        tensor_in.DebugString(), ""> and <"",
+                                        out_grad_backprop.DebugString(), "">""));
+    OP_REQUIRES(
+        context, tensor_out.NumElements() == output->NumElements(),
+        errors::InvalidArgument(
+            ""tensor_out and output must have same number of elements, got <"",
+            tensor_out.DebugString(), ""> and <"", output->DebugString(), "">""));
 
     LaunchMaxPooling3dGradGradOp<Device, T>::launch(
         context, params, tensor_in, tensor_out, out_grad_backprop, output);","Add missing validation, prevent heap OOB

PiperOrigin-RevId: 372246723
Change-Id: I1a454a643810e77d7d14821b342098c56a09fbbf","vuln-fix: Validate tensor dimensions in MaxPooling3dGradGradOp kernel

The vulnerability is that tensor dimension mismatches were not checked, allowing inconsistent tensor sizes to propagate through the pooling gradient computation.
This can lead to out-of-bounds memory access or corrupted data, posing risks of crashes or potential information leakage.
The fix adds explicit validation to ensure input and output tensors have matching element counts before proceeding with the operation.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i1a454a643810e77d7d14821b342098c56a09fbbf', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('information leakage', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
40,{'CWE-787'},GHSA-w89r-qch4-8jv5,"@@ -415,11 +415,19 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
 
     case Js::OpCode::InlineArrayPush:
     case Js::OpCode::InlineArrayPop:
-        KillLiveFields(this->lengthEquivBv, bv);
-        if (inGlobOpt)
+        if(instr->m_func->GetThisOrParentInlinerHasArguments())
         {
-            // Deleting an item, or pushing a property to a non-array, may change object layout
-            KillAllObjectTypes(bv);
+            this->KillAllFields(bv);
+            this->SetAnyPropertyMayBeWrittenTo();
+        }
+        else
+        {
+            KillLiveFields(this->lengthEquivBv, bv);
+            if (inGlobOpt)
+            {
+                // Deleting an item, or pushing a property to a non-array, may change object layout
+                KillAllObjectTypes(bv);
+            }
         }
         break;
 
@@ -444,14 +452,23 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
                 // Kill length field for built-ins that can update it.
                 if (nullptr != this->lengthEquivBv)
                 {
-                    KillLiveFields(this->lengthEquivBv, bv);
+                    // If has arguments, all fields are killed in fall through
+                    if (!instr->m_func->GetThisOrParentInlinerHasArguments())
+                    {
+                        KillLiveFields(this->lengthEquivBv, bv);
+                    }
                 }
                 // fall through
 
             case IR::JnHelperMethod::HelperArray_Reverse:
-                // Deleting an item may change object layout
-                if (inGlobOpt)
+                if (instr->m_func->GetThisOrParentInlinerHasArguments())
+                {
+                    this->KillAllFields(bv);
+                    this->SetAnyPropertyMayBeWrittenTo();
+                }
+                else if (inGlobOpt)
                 {
+                    // Deleting an item may change object layout
                     KillAllObjectTypes(bv);
                 }
                 break;",[CVE-2019-0912],"vuln-fix: Correct field kill logic to prevent stale object state

The vulnerability is due to improper handling of field kills when functions have arguments, causing stale or inconsistent object state during optimization phases. This can lead to incorrect assumptions about object layouts, potentially enabling type confusion or memory corruption exploits. The fix updates the kill logic to comprehensively kill all fields and mark properties as writable when arguments are present, ensuring accurate object state tracking.

Weakness: Improper Handling of Object State During Optimization (CWE-704)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('cve-2019-0912', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('improper handling', 'SECWORD', ''), ('type confusion', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper handling', 'secword', ''), ('cwe-704', 'CWEID', ''), ('high', 'SEVERITY', '')]"
41,"{'CWE-787', 'CWE-131'}",GHSA-8c89-2vwr-chcq,"@@ -702,8 +702,14 @@ class QuantizedResizeBilinearOp : public OpKernel {
   }
 
   void Compute(OpKernelContext* context) override {
-    const float in_min = context->input(2).flat<float>()(0);
-    const float in_max = context->input(3).flat<float>()(0);
+    const auto& in_min_tensor = context->input(2);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_min_tensor.shape()),
+                errors::InvalidArgument(""min must be a scalar""));
+    const float in_min = in_min_tensor.flat<float>()(0);
+    const auto& in_max_tensor = context->input(3);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_max_tensor.shape()),
+                errors::InvalidArgument(""max must be a scalar""));
+    const float in_max = in_max_tensor.flat<float>()(0);
 
     ImageResizerState st(align_corners_, false);
     st.ValidateAndCreateOutput(context);","Validate min and max arguments to `QuantizedResizeBilinear`.

PiperOrigin-RevId: 369765091
Change-Id: I33be8b78273ab7d08b97541692fe05cb7f94963a","vuln-fix: Validate scalar inputs in QuantizedResizeBilinearOp

The vulnerability was due to missing validation of input tensor shapes, allowing non-scalar tensors to be processed as scalars. This posed a security risk by enabling malformed inputs that could cause undefined behavior or memory corruption. The fix adds explicit checks to ensure inputs are scalars before accessing their values, preventing invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i33be8b78273ab7d08b97541692fe05cb7f94963a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
42,"{'CWE-787', 'CWE-120'}",GHSA-44qp-9wwf-734r,"@@ -206,6 +206,23 @@ class SparseCount : public OpKernel {
     OP_REQUIRES(context, shape.NumElements() > 0,
                 errors::InvalidArgument(
                     ""The shape argument requires at least one element.""));
+    // Validate indices: each index must be valid for the corresponding
+    // dimension. This could be possibly done better.
+    const auto indices_values = indices.matrix<int64_t>();
+    const auto shape_vector = shape.vec<int64_t>();
+    int num_values = values.NumElements();  // same as first dim of indices
+    int rank = indices.shape().dim_size(1);
+    for (int i = 0; i < num_values; ++i) {
+      for (int j = 0; j < rank; ++j) {
+        OP_REQUIRES(
+            context,
+            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),
+            errors::InvalidArgument(
+                ""Invalid index value at "", i, "": dimension "", j, "" has value "",
+                indices_values(i, j), "" which is not in [0, "", shape_vector(j),
+                "") (as given by dense shape "", shape.DebugString()));
+      }
+    }
 
     if (use_weights) {
       OP_REQUIRES(
@@ -217,11 +234,8 @@ class SparseCount : public OpKernel {
     }
 
     bool is_1d = shape.NumElements() == 1;
-    auto shape_vector = shape.flat<int64_t>();
     int num_batches = is_1d ? 1 : shape_vector(0);
-    int num_values = values.NumElements();
 
-    const auto indices_values = indices.matrix<int64_t>();
     const auto values_values = values.flat<T>();
     const auto weight_values = weights.flat<W>();","Further validate sparse tensor for `SparseCount`: indices must be valid within dense shape.

PiperOrigin-RevId: 414888122
Change-Id: I4552bd74c135ecd4bcb5448acc0a3ce9402d8286","vuln-fix: Validate sparse indices to prevent out-of-bounds access

The vulnerability allowed sparse indices to reference out-of-bounds dimensions without validation, risking memory corruption or crashes during tensor operations. This is a security risk because attackers could exploit invalid indices to cause denial of service or potentially execute arbitrary code. The fix adds explicit checks ensuring each index is within valid bounds for its dimension, rejecting invalid inputs early with clear error messages.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i4552bd74c135ecd4bcb5448acc0a3ce9402d8286', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
43,{'CWE-787'},GHSA-mqh2-9wrp-vx84,"@@ -527,6 +527,10 @@ inline Status SparseTensor::Split(const SparseTensor& input_tensor,
   for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
     const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);
     int slice_index = GetSliceIndex(dim, split_size, residual);
+    if (slice_index >= num_values.size()) {
+      return errors::InvalidArgument(""Slice index "", slice_index,
+                                     "" is larger than num_split."");
+    }
     num_values[slice_index]++;
   }","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseSplit`.

PiperOrigin-RevId: 371242872
Change-Id: I482bb3d12602c7c3cc9446f97fb9f584bb98e9a4","vuln-fix: Prevent out-of-bounds access in SparseTensor split

The vulnerability is an unchecked slice index that can exceed the number of splits during SparseTensor splitting operations. This poses a security risk by potentially causing out-of-bounds memory access, leading to crashes or data corruption. The fix adds a boundary check that returns an error if the slice index is invalid, preventing unsafe memory access. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.sparsesplit', 'URL', ''), ('change', 'ACTION', ''), ('i482bb3d12602c7c3cc9446f97fb9f584bb98e9a4', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,"{'CWE-665', 'CWE-20'}",GHSA-9rpc-5v9q-5r7f,"@@ -26,6 +26,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_util.h""
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,6 +39,17 @@ class SparseReshapeOp : public OpKernel {
   explicit SparseReshapeOp(OpKernelConstruction* context) : OpKernel(context) {}
 
   void Compute(OpKernelContext* context) override {
+    const Tensor& input_indices_in = context->input(0);
+    const Tensor& input_shape_in = context->input(1);
+
+    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),
+                errors::InvalidArgument(""Input must be a matrix.""));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),
+                errors::InvalidArgument(""Input shape must be a vector.""));
+    OP_REQUIRES(context,
+                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),
+                errors::InvalidArgument(
+                    ""Input tensor rank must match input shape length.""));
     ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),
                                 context->input(2), 0 /* output indices index */,
                                 1 /* output shape index */);","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseReshape`.

PiperOrigin-RevId: 371218558
Change-Id: I6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45","vuln-fix: Validate input tensor shapes in SparseReshapeOp

The vulnerability was missing validation of input tensor shapes, allowing malformed inputs to proceed unchecked in the sparse reshape operation. This posed a risk of undefined behavior or crashes due to shape mismatches leading to memory corruption or denial of service. The fix adds explicit checks ensuring input indices are matrices, input shapes are vectors, and their dimensions align before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.sparsereshape', 'URL', ''), ('change', 'ACTION', ''), ('i6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,"{'CWE-908', 'CWE-200'}",GHSA-3wcq-x3mq-6r9p,"@@ -74,7 +74,8 @@ name.decode = function (buf, offset) {
 name.decode.bytes = 0
 
 name.encodingLength = function (n) {
-  return Buffer.byteLength(n) + 2
+  if (n === '.') return 1
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 var string = {}",backport encodingLength fix to v1,"vuln-fix: Prevent buffer length miscalculation for dot-only strings

The vulnerability was an incorrect calculation of buffer length when the input string was a single dot, causing potential buffer overflows or memory corruption during encoding. This is a security risk because it can lead to out-of-bounds memory access, enabling attackers to crash the application or execute arbitrary code. The fix adds a special case for single dot strings and trims leading and trailing dots before length calculation to ensure accurate buffer size estimation.

Weakness: Improper Calculation of Buffer Size (CWE-131)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('encodinglength', 'SECWORD', ''), ('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('incorrect calculation', 'secword', ''), ('buffer overflows', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('security', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-131', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,"{'CWE-200', 'CWE-287'}",GHSA-cchx-mfrc-fwqr,"@@ -120,6 +120,6 @@ protected function generateCookieValue($class, $username, $expires, $password)
      */
     protected function generateCookieHash($class, $username, $expires, $password)
     {
-        return hash_hmac('sha256', $class.$username.$expires.$password, $this->getSecret());
+        return hash_hmac('sha256', $class.self::COOKIE_DELIMITER.$username.self::COOKIE_DELIMITER.$expires.self::COOKIE_DELIMITER.$password, $this->getSecret());
     }
 }",[Security] Add a separator in the remember me cookie hash,"vuln-fix: Prevent cookie hash collision by adding delimiters

The cookie hash was generated by concatenating fields without delimiters, causing potential hash collisions for different input combinations.
This flaw could allow attackers to craft different cookie values that produce identical hashes, leading to authentication bypass or session hijacking.
The fix inserts explicit delimiters between fields before hashing, ensuring unique and unambiguous input to the HMAC function.

Weakness: CWE-347: Improper Verification of Cryptographic Signature
Severity: High
CVSS: 7.5",0.058823529411764705,"[('security', 'SECWORD', ''), ('add', 'ACTION', ''), ('cookie', 'SECWORD', ''), ('hash', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('cookie', 'SECWORD', ''), ('hash', 'secword', ''), ('collision', 'SECWORD', ''), ('adding', 'ACTION', ''), ('cookie', 'secword', ''), ('hash', 'secword', ''), ('hash', 'secword', ''), ('collisions', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('cookie', 'secword', ''), ('authentication bypass', 'secword', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('hmac', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-347', 'CWEID', ''), ('improper verification', 'secword', ''), ('cryptographic', 'SECWORD', ''), ('signature', 'secword', ''), ('high', 'SEVERITY', '')]"
3,{'CWE-200'},GHSA-xc7v-wxcw-j472,"@@ -128,7 +128,7 @@ TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
   if (connectOptions.proxyAuth) {
     connectOptions.headers = connectOptions.headers || {}
     connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
-        new Buffer(connectOptions.proxyAuth).toString('base64')
+        Buffer.from(connectOptions.proxyAuth).toString('base64')
   }
 
   debug('making CONNECT request')",Use .from,"vuln-fix: Replace deprecated Buffer constructor to prevent security risks

Using the deprecated Buffer constructor can lead to uninitialized memory exposure or unexpected behavior when encoding sensitive data like proxy authentication headers. This poses a security risk by potentially leaking credentials or causing application instability. The fix replaces the deprecated constructor with the safer Buffer.from method to ensure proper and secure encoding of authentication data.

Weakness: Use of Deprecated Buffer Constructor (CWE-676)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('uninitialized memory', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('authentication', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safer buffer.from', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('secure encoding', 'SECWORD', ''), ('authentication', 'secword', ''), ('weakness', 'secword', ''), ('cwe-676', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,{'CWE-200'},GHSA-hxf9-7h4c-f5jv,"@@ -2,6 +2,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -40,8 +41,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -77,8 +83,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.","vuln-fix: Prevent timing attacks on webhook basic authentication

The webhook basic authentication compared credentials using standard string comparison, exposing it to timing attacks that could leak sensitive authentication data. Timing attacks allow attackers to infer valid credentials by measuring response time differences, compromising webhook security. The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure uniform comparison time and prevent timing-based information leaks.

Weakness: CWE-208: Exposure of Sensitive Information Through Timing Discrepancy  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('security', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attack', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attacker', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('upgrade', 'ACTION', ''), ('docs](http://anymail.readthedocs.io', 'URL', ''), ('exploit', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('string comparison', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('leak', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('authentication', 'secword', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('string comparisons', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('information leaks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-208', 'CWEID', ''), ('sensitive information', 'SECWORD', ''), ('timing discrepancy', 'secword', ''), ('high', 'SEVERITY', '')]"
5,{'CWE-203'},GHSA-434h-p4gx-jm89,"@@ -833,6 +833,12 @@ def auth_user_db(self, username, password):
         if user is None:
             user = self.find_user(email=username)
         if user is None or (not user.is_active):
+            # Balance failure and success
+            check_password_hash(
+                ""pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118""
+                ""c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c"",
+                ""password"",
+            )
             log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))
             return None
         elif check_password_hash(user.password, password):",fix: auth balance (#1634),"vuln-fix: Prevent timing attacks on user authentication

The authentication function leaked timing information by returning early on missing or inactive users, enabling attackers to infer valid usernames through response time differences. This risk was mitigated by adding a dummy password hash check to equalize response times regardless of user existence or status. The fix balances failure and success paths to prevent attackers from distinguishing valid users based on authentication timing.

Weakness: CWE- timing side-channel vulnerability  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('auth', 'secword', ''), ('#1634', 'ISSUE', '')]",0.29411764705882354,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('mitigated', 'ACTION', ''), ('adding', 'ACTION', ''), ('password', 'secword', ''), ('hash', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'FLAW', ''), ('authentication', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('medium', 'SEVERITY', '')]"
6,{'CWE-200'},GHSA-23cm-x6j7-6hq3,"@@ -101,6 +101,13 @@ interface IPayload extends Partial<IMessage> {
 }
 /* eslint-enable camelcase */
 
+interface SharedWithData {
+    // The identity key of the device we shared with
+    deviceKey: string;
+    // The message index of the ratchet we shared with that device
+    messageIndex: number;
+}
+
 /**
  * @private
  * @constructor
@@ -115,12 +122,12 @@ interface IPayload extends Partial<IMessage> {
  *
  * @property {object} sharedWithDevices
  *    devices with which we have shared the session key
- *        userId -> {deviceId -> msgindex}
+ *        userId -> {deviceId -> SharedWithData}
  */
 class OutboundSessionInfo {
     public useCount = 0;
     public creationTime: number;
-    public sharedWithDevices: Record<string, Record<string, number>> = {};
+    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};
     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};
 
     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {
@@ -150,11 +157,11 @@ class OutboundSessionInfo {
         return false;
     }
 
-    public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {
+    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {
         if (!this.sharedWithDevices[userId]) {
             this.sharedWithDevices[userId] = {};
         }
-        this.sharedWithDevices[userId][deviceId] = chainIndex;
+        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };
     }
 
     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {
@@ -572,6 +579,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
         payload: IPayload,
     ): Promise<void> {
         const contentMap = {};
+        const deviceInfoByDeviceId = new Map<string, DeviceInfo>();
 
         const promises = [];
         for (let i = 0; i < userDeviceMap.length; i++) {
@@ -584,6 +592,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const userId = val.userId;
             const deviceInfo = val.deviceInfo;
             const deviceId = deviceInfo.deviceId;
+            deviceInfoByDeviceId.set(deviceId, deviceInfo);
 
             if (!contentMap[userId]) {
                 contentMap[userId] = {};
@@ -636,7 +645,10 @@ class MegolmEncryption extends EncryptionAlgorithm {
                 for (const userId of Object.keys(contentMap)) {
                     for (const deviceId of Object.keys(contentMap[userId])) {
                         session.markSharedWithDevice(
-                            userId, deviceId, chainIndex,
+                            userId,
+                            deviceId,
+                            deviceInfoByDeviceId.get(deviceId).getIdentityKey(),
+                            chainIndex,
                         );
                     }
                 }
@@ -719,8 +731,8 @@ class MegolmEncryption extends EncryptionAlgorithm {
             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);
             return;
         }
-        const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];
-        if (sentChainIndex === undefined) {
+        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];
+        if (sessionSharedData === undefined) {
             logger.debug(
                 ""megolm session ID "" + sessionId + "" never shared with device "" +
                 userId + "":"" + device.deviceId,
@@ -728,10 +740,18 @@ class MegolmEncryption extends EncryptionAlgorithm {
             return;
         }
 
+        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {
+            logger.warn(
+                `Session has been shared with device ${device.deviceId} but with identity ` +
+                `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,
+            );
+            return;
+        }
+
         // get the key from the inbound session: the outbound one will already
         // have been ratcheted to the next chain index.
         const key = await this.olmDevice.getInboundGroupSessionKey(
-            this.roomId, senderKey, sessionId, sentChainIndex,
+            this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,
         );
 
         if (!key) {
@@ -882,7 +902,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const deviceId = deviceInfo.deviceId;
 
             session.markSharedWithDevice(
-                userId, deviceId, key.chain_index,
+                userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,
             );
         }",Verify target device key on reshare,"vuln-fix: Verify device identity key when accessing shared session keys

The code did not verify that the device identity key matched the one used when sharing the session key, allowing potential unauthorized access if a device key changed or was spoofed. This is a security risk because an attacker could impersonate a device and decrypt messages not intended for them. The fix stores the device identity key alongside the message index and checks for a key match before allowing access to the session key, preventing unauthorized decryption.

Weakness: Improper Authentication (CWE-287)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('verify', 'ACTION', ''), ('key', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('key', 'secword', ''), ('keys', 'SECWORD', ''), ('verify', 'ACTION', ''), ('key', 'secword', ''), ('key', 'SECWORD', ''), ('key', 'SECWORD', ''), ('changed', 'ACTION', ''), ('security', 'SECWORD', ''), ('attacker', 'SECWORD', ''), ('fix', 'ACTION', ''), ('key', 'SECWORD', ''), ('key', 'SECWORD', ''), ('key', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper authentication', 'secword', ''), ('cwe-287', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,{'CWE-209'},GHSA-pwwm-pwx2-2hw7,"@@ -87,6 +87,8 @@ public function sendResetLinkEmail(Request $request)
             \Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );
         }
 
+        // Prevent timing attack to enumerate users.
+        usleep(500000 + random_int(0, 1500000));
 
         if ($response === \Password::RESET_LINK_SENT) {
             \Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');","Added usleep :(

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent timing attack in password reset endpoint

The password reset function leaked timing information that allowed attackers to enumerate valid usernames by measuring response delays. This vulnerability could enable attackers to identify registered users and target them for further attacks. The fix introduces a randomized delay to normalize response times, mitigating timing side-channel information leaks.

Weakness: CWE-203: Information Exposure Through Timing Discrepancy  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('added', 'ACTION', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attack', 'SECWORD', ''), ('password', 'secword', ''), ('password', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('information leaks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-203', 'CWEID', ''), ('information exposure', 'secword', ''), ('timing discrepancy', 'secword', ''), ('medium', 'SEVERITY', '')]"
8,{'CWE-200'},GHSA-7wv8-g97r-432h,"@@ -63,9 +63,9 @@
 
 });
 
-api_expose('users/search_authors', function ($params = false) {
+api_expose_admin('users/search_authors', function ($params = false) {
 
-    $return = array();
+    $return = array(); 
 
     $kw = false;
     if (isset($params['kw'])) {",search_authors only admins,"vuln-fix: Restrict user search authors API to admin access only

The users/search_authors API endpoint was accessible to all authenticated users without proper role restrictions.
This allowed unauthorized users to query author information, potentially exposing sensitive user data to attackers.
The fix restricts the endpoint to admin users by changing the exposure function to api_expose_admin, enforcing access control.


Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('admins', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('admin', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('admin users', 'SECWORD', ''), ('changing', 'ACTION', ''), ('api_expose_admin', 'SECWORD', ''), ('access control', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper access control', 'secword', ''), ('cwe-284', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,{'CWE-203'},GHSA-mr6r-82x4-f4jj,"@@ -136,7 +136,17 @@ public function sign($msg, $key, $enc = null, $options = null)
             if( $k->cmpn(1) <= 0 || $k->cmp($ns1) >= 0 )
                 continue;
 
-            $kp = $this->g->mul($k);
+            // Fix the bit-length of the random nonce,
+            // so that it doesn't leak via timing.
+            // This does not change that ks = k mod k
+            $ks = $k->add($this->n);
+            $kt = $ks->add($this->n);
+            if ($ks->bitLength() === $this->n->bitLength()) {
+                $kp = $this->g->mul($kt);
+            } else {
+                $kp = $this->g->mul($ks);
+            }
+
             if( $kp->isInfinity() )
                 continue;","ecdsa: Apply nonce bit-length mitigation to stop timing leakage.

Ported from elliptic-js: https://github.com/indutny/elliptic/pull/203","vuln-fix: Prevent timing leak in nonce bit-length during signature

The vulnerability involved leaking the bit-length of the random nonce through timing variations in the signature computation process. This timing leak could allow attackers to infer secret key information by analyzing operation durations, compromising cryptographic security. The fix normalizes nonce bit-length by adjusting the nonce before multiplication, ensuring constant-time execution and preventing information leakage.

Weakness: Timing Side Channel (CWE-208)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('ecdsa', 'secword', ''), ('nonce', 'secword', ''), ('timing leakage', 'SECWORD', ''), ('https://github.com/indutny/elliptic/pull/203', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('timing leak', 'SECWORD', ''), ('nonce', 'secword', ''), ('signature', 'secword', ''), ('vulnerability', 'secword', ''), ('nonce', 'secword', ''), ('signature', 'secword', ''), ('timing leak', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('key', 'secword', ''), ('cryptographic', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('nonce', 'secword', ''), ('nonce', 'secword', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('information leakage', 'secword', ''), ('weakness', 'secword', ''), ('cwe-208', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,{'CWE-209'},GHSA-hhrj-wp42-32v3,"@@ -5,10 +5,12 @@
 use EloquentFilter\Filterable;
 use Illuminate\Database\Eloquent\Model;
 use MicroweberPackages\Content\Models\ModelFilters\ContentFilter;
+use MicroweberPackages\Core\Models\HasSearchableTrait;
 
 class Comment extends Model
 {
     use Filterable;
+    use HasSearchableTrait;
 
     public $table = 'comments';
 
@@ -21,6 +23,13 @@ class Comment extends Model
         'comment_body',
     ];
 
+    protected $searchable = [
+        'comment_name',
+        'comment_email',
+        'comment_website',
+        'comment_body',
+    ];
+
     public function modelFilter()
     {
         return $this->provideFilter(ContentFilter::class);",Update Comment.php,"vuln-fix: Add searchable trait with controlled fields to Comment model

The Comment model was missing explicit control over searchable fields, potentially exposing sensitive or unintended data to search queries. This could allow attackers to infer or manipulate data through unfiltered search inputs, increasing the risk of information disclosure or injection attacks. The fix introduces a searchable trait with a defined whitelist of safe fields, restricting search operations to only intended attributes and improving data access control.

Weakness: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', ''), ('comment.php', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('disclosure', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('improving', 'ACTION', ''), ('access control', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-200', 'CWEID', ''), ('sensitive information', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
11,{'CWE-201'},GHSA-3p92-886g-qxpq,"@@ -28,7 +28,7 @@ module.exports = function(options){
 
     if(writes.length > windowSize) writes.shift();
 
-    data = data instanceof Buffer ? data : new Buffer(data);
+    data = data instanceof Buffer ? data : new Buffer(data+'');
     bufLen += data.length;
 
     buf.push(data);",adding fix for exposing uninitalized memory found by @chalker,"vuln-fix: Prevent buffer overflow by normalizing input to string before buffer conversion

The vulnerability arises from directly converting non-buffer data to a Buffer without ensuring it is a string, which can cause unexpected buffer sizes and potential overflow. This is a security risk because attackers could exploit improper buffer length calculations to trigger memory corruption or denial of service. The fix ensures all non-buffer inputs are first converted to strings before creating a Buffer, preventing malformed buffer lengths and improving input handling safety.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('adding', 'ACTION', ''), ('fix', 'ACTION', ''), ('uninitalized memory', 'secword', ''), ('found', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('buffer overflow', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('ensuring', 'ACTION', ''), ('overflow', 'secword', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,{'CWE-20'},GHSA-f7f4-hqp2-7prc,"@@ -3,6 +3,7 @@
  */
 
 var util = require('util');
+var url = require('url');
 var _ = require('@sailshq/lodash');
 var semver = require('semver');
 var parseSdkMetadata = require('./parse-sdk-metadata');
@@ -105,6 +106,8 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+
       method  : options.eventName,
 
       // Attached data becomes simulated HTTP body (`req.body`)",Define req.path for socket requests.,"vuln-fix: Parse and validate URL path from incoming messages

The vulnerability involved using the full URL string without extracting the path component, which could lead to improper routing or injection attacks. This is a security risk because attackers might exploit unvalidated URL parts to bypass access controls or inject malicious payloads. The fix extracts and uses only the pathname from the URL, ensuring safer and more precise request handling.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('req.path', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('bypass', 'secword', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,{'CWE-20'},GHSA-hrg5-737c-2p56,"@@ -92,6 +92,9 @@ class UnsortedSegmentJoinOp : public OpKernel {
     const Tensor& num_segments_tensor = context->input(2);
     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
+    OP_REQUIRES(context,
+                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
+                errors::InvalidArgument(""Number of segments must be a scalar""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(","Fix tf.raw_ops.UnsortedSegmentJoin vulnerability with invalid num_segments.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445206880","vuln-fix: Enforce scalar input for number of segments parameter

The vulnerability allowed non-scalar tensors for the number of segments input, which could cause unexpected behavior or memory corruption during kernel execution. This poses a security risk by enabling malformed inputs to trigger undefined states or crashes, potentially exploitable for denial of service or code execution. The fix adds a strict check to ensure the number of segments input is a scalar tensor, rejecting invalid shapes early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.unsortedsegmentjoin', 'URL', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,{'CWE-20'},GHSA-h5g4-ppwx-48q2,"@@ -134,6 +134,8 @@ class DeleteSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""`handle` must be scalar""));
     const string& name = handle.scalar<tstring>()();
     auto session_state = ctx->session_state();
     OP_REQUIRES(ctx, session_state != nullptr,","Fix tf.raw_ops.DeleteSessionTensor vulnerability with invalid `handle`.

Check that `handle` input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445228994","vuln-fix: Enforce scalar tensor shape for session handle input

The vulnerability was caused by missing validation on the shape of the session handle tensor input, allowing non-scalar tensors to be processed. This posed a security risk as malformed inputs could lead to unexpected behavior or memory corruption in session management. The fix adds a strict check to ensure the handle tensor is scalar, rejecting invalid inputs early in the computation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.deletesessiontensor', 'URL', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
15,{'CWE-20'},GHSA-g25h-jr74-qp5j,"@@ -113,7 +113,50 @@ class QuantizeV2Op : public OpKernel {
 
     int num_slices = 1;
     if (axis_ > -1) {
+      OP_REQUIRES(
+          ctx, input.dims() > axis_,
+          errors::InvalidArgument(
+              ""Axis is on a zero-based index, so its value must always be less ""
+              ""than number of input's dims, but given axis value was "",
+              axis_, "" and input's dims was "", input.dims()));
       num_slices = input.dim_size(axis_);
+      OP_REQUIRES(ctx, input_min_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range dims are "",
+                      input_min_range.dims()));
+      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range is a 1-D tensor of size "",
+                      input_min_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+      OP_REQUIRES(ctx, input_max_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range dims are "",
+                      input_max_range.dims()));
+      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range is a 1-D tensor of size "",
+                      input_max_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+    } else {
+      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, min_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_min_range.NumElements(), "" elements""));
+      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, max_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_max_range.NumElements(), "" elements""));
     }
 
     const TensorShape& minmax_shape = ctx->input(1).shape();","Secure tf.raw_ops.QuantizeV2

Validate size and shape of min_range and max_range
Ensure axis is within input dims limits

PiperOrigin-RevId: 387232799
Change-Id: I36975281f7b5758e9e31a8dcc73fe610ef456318","vuln-fix: Validate tensor dimensions to prevent out-of-bounds access

The vulnerability is due to missing validation of tensor dimensions and axis values, which could lead to out-of-bounds memory access or crashes during quantization operations. This poses a security risk as it may allow attackers to cause denial of service or potentially execute arbitrary code by triggering invalid memory reads. The fix adds strict checks on axis bounds and tensor dimension sizes, ensuring inputs conform to expected shapes before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('secure', 'secword', ''), ('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('i36975281f7b5758e9e31a8dcc73fe610ef456318', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,{'CWE-200'},GHSA-f5fj-7265-jxhj,"@@ -1,4 +1,5 @@
 // Copyright 2016 The Gogs Authors. All rights reserved.
+// Copyright 2018 The Gitea Authors. All rights reserved.
 // Use of this source code is governed by a MIT-style
 // license that can be found in the LICENSE file.
 
@@ -87,7 +88,9 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 		names = append(names, participants[i].Name)
 	}
 
-	SendIssueCommentMail(issue, doer, content, comment, tos)
+	for _, to := range tos {
+		SendIssueCommentMail(issue, doer, content, comment, []string{to})
+	}
 
 	// Mail mentioned people and exclude watchers.
 	names = append(names, doer.Name)
@@ -99,7 +102,12 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 
 		tos = append(tos, mentions[i])
 	}
-	SendIssueMentionMail(issue, doer, content, comment, getUserEmailsByNames(e, tos))
+
+	emails := getUserEmailsByNames(e, tos)
+
+	for _, to := range emails {
+		SendIssueMentionMail(issue, doer, content, comment, []string{to})
+	}
 
 	return nil
 }",Don't disclose emails of all users when sending out emails (#4664),"vuln-fix: Prevent email header injection via bulk recipient fields

The vulnerability allowed sending emails with multiple recipients in a single call, risking email header injection and unintended disclosure of participant email addresses. This posed a security risk by enabling attackers to manipulate email headers or expose private user information through mass email fields. The fix sends emails individually to each recipient, isolating headers and preventing injection or leakage of other recipients’ addresses.

Weakness: CWE-93: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('disclose', 'secword', ''), ('#4664', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('injection', 'secword', ''), ('disclosure', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-93', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('http response splitting', 'secword', ''), ('high', 'SEVERITY', '')]"
17,"{'CWE-915', 'CWE-20'}",GHSA-66rh-8fw6-59q6,"@@ -37,7 +37,7 @@ function extend(target, obj) {
   assignSymbols(target, obj);
 
   for (var key in obj) {
-    if (key !== '__proto__' && hasOwn(obj, key)) {
+    if (isValidKey(key) && hasOwn(obj, key)) {
       var val = obj[key];
       if (isObject(val)) {
         if (typeOf(target[key]) === 'undefined' && typeOf(val) === 'function') {
@@ -68,6 +68,14 @@ function hasOwn(obj, key) {
   return Object.prototype.hasOwnProperty.call(obj, key);
 }
 
+/**
+ * Returns true if the given `key` is a valid key that can be used for assigning properties.
+ */
+
+function isValidKey(key) {
+  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
+}
+
 /**
  * Expose `assign`
  */",ensure keys are valid,"vuln-fix: Prevent prototype pollution by restricting property keys

The vulnerability allowed assignment of dangerous keys like 'constructor' and 'prototype', enabling prototype pollution attacks that can alter object behavior globally. This is a critical security risk as it can lead to arbitrary code execution or denial of service by tampering with object prototypes. The fix introduces a key validation function that blocks assignment of '__proto__', 'constructor', and 'prototype' keys, preventing prototype pollution. 

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: Critical  
CVSS: 9.1",0.11764705882352941,"[('ensure', 'ACTION', ''), ('keys', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('security', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('tampering', 'secword', ''), ('fix', 'ACTION', ''), ('key', 'secword', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('prototype pollution', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-1321', 'CWEID', ''), ('improper restriction', 'secword', ''), ('critical', 'SEVERITY', '')]"
18,{'CWE-20'},GHSA-9m95-8hx6-7p9v,"@@ -404,6 +404,11 @@ func (te *TarExtractor) UnpackEntry(root string, hdr *tar.Header, r io.Reader) (
 	if filepath.Join(""/"", hdr.Name) == ""/"" {
 		// If we got an entry for the root, then unsafeDir is the full path.
 		unsafeDir, file = hdr.Name, "".""
+		// If we're being asked to change the root type, bail because they may
+		// change it to a symlink which we could inadvertently follow.
+		if hdr.Typeflag != tar.TypeDir {
+			return errors.New(""malicious tar entry -- refusing to change type of root directory"")
+		}
 	}
 	dir, err := securejoin.SecureJoinVFS(root, unsafeDir, te.fsEval)
 	if err != nil {","layer: don't permit / type to be changed on extraction

If users can change the type of / to a symlink, they can cause umoci to
overwrite host files. This is obviously bad, and is not caught by the
rest of our directory escape detection code because the root itself has
been changed to a different directory.

Fixes: CVE-2021-29136
Reported-by: Robin Peraglie <robin@cure53.de>
Tested-by: Daniel Dao <dqminh89@gmail.com>
Reviewed-by: Tycho Andersen <tycho@tycho.pizza>
Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>","vuln-fix: Prevent root directory type change in tar extraction

The vulnerability allows a malicious tar archive to change the root directory type to a symlink or other type during extraction. This poses a security risk by enabling symlink attacks that could lead to arbitrary file access or overwriting critical files. The fix rejects any tar entry attempting to change the root directory type unless it remains a directory, preventing unsafe type changes.

Weakness: CWE-59: Improper Link Resolution Before File Access
Severity: High
CVSS: 7.5",0.23529411764705882,"[('changed', 'ACTION', ''), ('change', 'ACTION', ''), ('symlink', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('changed', 'ACTION', ''), ('robin@cure53.de', 'EMAIL', ''), ('signed', 'secword', ''), ('cyphar@cyphar.com', 'EMAIL', ''), ('fixes', 'ACTION', ''), ('cve-2021-29136', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('change', 'ACTION', ''), ('vulnerability', 'secword', ''), ('malicious', 'SECWORD', ''), ('change', 'ACTION', ''), ('symlink', 'secword', ''), ('security', 'secword', ''), ('symlink', 'secword', ''), ('attacks', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('changes', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-59', 'CWEID', ''), ('improper link resolution', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
19,{'CWE-200'},GHSA-5r2v-6gm6-vpvh,"@@ -112,6 +112,15 @@ func reqRepoWriter() macaron.Handler {
 	}
 }
 
+func reqRepoAdmin() macaron.Handler {
+	return func(c *context.Context) {
+		if !c.Repo.IsAdmin() {
+			c.Error(http.StatusForbidden)
+			return
+		}
+	}
+}
+
 func orgAssignment(args ...bool) macaron.Handler {
 	var (
 		assignOrg  bool
@@ -236,12 +245,12 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateHookOption{}), repo.CreateHook)
 					m.Combo(""/:id"").Patch(bind(api.EditHookOption{}), repo.EditHook).
 						Delete(repo.DeleteHook)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/collaborators"", func() {
 					m.Get("""", repo.ListCollaborators)
 					m.Combo(""/:collaborator"").Get(repo.IsCollaborator).Put(bind(api.AddCollaboratorOption{}), repo.AddCollaborator).
 						Delete(repo.DeleteCollaborator)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Get(""/raw/*"", context.RepoRef(), repo.GetRawFile)
 				m.Get(""/archive/*"", repo.GetArchive)
 				m.Get(""/forks"", repo.ListForks)
@@ -260,7 +269,7 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateKeyOption{}), repo.CreateDeployKey)
 					m.Combo(""/:id"").Get(repo.GetDeployKey).
 						Delete(repo.DeleteDeploykey)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/issues"", func() {
 					m.Combo("""").Get(repo.ListIssues).Post(bind(api.CreateIssueOption{}), repo.CreateIssue)
 					m.Group(""/comments"", func() {
@@ -300,8 +309,8 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Delete(reqRepoWriter(), repo.DeleteMilestone)
 				})
 
-				m.Patch(""/issue-tracker"", bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
-				m.Post(""/mirror-sync"", repo.MirrorSync)
+				m.Patch(""/issue-tracker"", reqRepoWriter(), bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
+				m.Post(""/mirror-sync"", reqRepoWriter(), repo.MirrorSync)
 				m.Get(""/editorconfig/:filename"", context.RepoRef(), repo.GetEditorconfig)
 			}, repoAssignment())
 		}, reqToken())","routes/api: fix permission checks for routes

Reported by @ManassehZhou #5764","vuln-fix: Enforce admin-only access for sensitive repository routes

Certain repository routes previously used a generic admin check that did not verify repository-specific admin rights, allowing unauthorized users to access sensitive operations. This posed a security risk by potentially exposing critical repository management functions to non-admin users. The fix introduces a repository-specific admin check middleware and applies it to sensitive routes, ensuring only repository admins can perform these actions.

Weakness: Improper Access Control (CWE-284)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('permission', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('admin', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('admin', 'SECWORD', ''), ('verify', 'ACTION', ''), ('admin', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('security', 'secword', ''), ('critical', 'SEVERITY', ''), ('admin users', 'SECWORD', ''), ('fix', 'ACTION', ''), ('admin', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('admins', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper access control', 'secword', ''), ('cwe-284', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,{'CWE-20'},GHSA-v82p-hv3v-p6qp,"@@ -49,35 +49,45 @@ class MklRequantizePerChannelOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     try {
       const Tensor& input = ctx->input(kInputTensorIndex);
+      OP_REQUIRES(
+          ctx, input.dims() == 4,
+          errors::InvalidArgument(""Current RequantizePerChannel operator""
+                                  ""supports 4D tensors only.""));
+
       const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);
+      size_t depth = input_min_vec.NumElements();
       float* input_min_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_min_vec.flat<float>().data()));
+
       const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);
+      OP_REQUIRES(
+          ctx, input_max_vec.NumElements() == depth,
+          errors::InvalidArgument(""input_max has incorrect size, expected "",
+                                  depth, "" was "", input_max_vec.NumElements()));
       float* input_max_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_max_vec.flat<float>().data()));
 
       const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_min must be a scalar""));
       const float input_requested_min_float =
           input_requested_min.flat<float>()(0);
+
       const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_max must be a scalar""));
       const float input_requested_max_float =
           input_requested_max.flat<float>()(0);
 
-      size_t depth = input_min_vec.NumElements();
-      OP_REQUIRES(
-          ctx, input.dims() == 4,
-          errors::InvalidArgument(""Current RequantizePerChannel operator""
-                                  ""supports 4D tensors only.""));
-      OP_REQUIRES(
-          ctx, input_min_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_min has incorrect size, expected "",
-                                  depth, "" was "", input_min_vec.dim_size(0)));
-      OP_REQUIRES(
-          ctx, input_max_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_max has incorrect size, expected "",
-                                  depth, "" was "", input_max_vec.dim_size(0)));
-
-      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);
+      if (out_type_ == DT_QINT8) {
+        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,
+                    errors::InvalidArgument(
+                        ""If out_type is QINT8, requested_output_max must be ""
+                        ""non negative, got "",
+                        input_requested_min_float));
+      }
 
       const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;
       const float requested_min_max =","Reorganize and add more validation to MKL requantization

PiperOrigin-RevId: 387901341
Change-Id: I2515b9034c64e113db0bcec8337d30643ab0a0f1","vuln-fix: Validate tensor dimensions and input sizes in requantize op

The vulnerability is due to missing strict validation of tensor dimensions and input vector sizes in the requantize per-channel operator, allowing malformed inputs to proceed. This poses a security risk as it can lead to out-of-bounds memory access or undefined behavior, potentially causing crashes or exploitable conditions. The fix adds explicit checks for 4D tensor inputs, matching vector sizes, scalar constraints, and value ranges to ensure input integrity before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('i2515b9034c64e113db0bcec8337d30643ab0a0f1', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('integrity', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,{'CWE-20'},GHSA-2p9q-h29j-3f5v,"@@ -36,6 +36,10 @@ class SummaryTensorOpV2 : public OpKernel {
                 errors::InvalidArgument(""tag must be scalar""));
     const Tensor& tensor = c->input(1);
     const Tensor& serialized_summary_metadata_tensor = c->input(2);
+    OP_REQUIRES(
+        c,
+        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),
+        errors::InvalidArgument(""serialized_summary_metadata must be scalar""));
 
     Summary s;
     Summary::Value* v = s.add_value();","Fix tf.raw_ops.TensorSummaryV2 vulnerability with invalid serialized_summary_metadata.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445197183","vuln-fix: Validate serialized_summary_metadata tensor shape to prevent misuse

The vulnerability is the lack of validation for the shape of serialized_summary_metadata tensor, allowing non-scalar inputs to be processed incorrectly. This is a security risk because malformed inputs could lead to unexpected behavior or memory corruption in downstream processing. The fix enforces a scalar shape check on serialized_summary_metadata tensor and rejects invalid inputs early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('serialized_summary_metadata', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('serialized_summary_metadata', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('serialized_summary_metadata', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('serialized_summary_metadata', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,{'CWE-209'},GHSA-hm37-9xh2-q499,"@@ -221,7 +221,9 @@ def from_bytes(
 
         Raises:
             ValueError: The provided byte string is not an ``openssh-key-v1``
-                key list or the declared key count is negative.
+                key list, when the declared key count is negative, or when an
+                EOF is found while parsing the key.
+
             UserWarning: The check numbers in the decrypted private byte string
                 do not match (likely due to an incorrect passphrase), the key
                 type or parameter values of a private key do not match that of
@@ -229,110 +231,117 @@ def from_bytes(
                 at the end of the decrypted private byte string are not as
                 expected.
         """"""
-        byte_stream = PascalStyleByteStream(byte_string)
+        try:
+            byte_stream = PascalStyleByteStream(byte_string)
 
-        header = byte_stream.read_from_format_instructions_dict(
-            cls.HEADER_FORMAT_INSTRUCTIONS_DICT
-        )
+            header = byte_stream.read_from_format_instructions_dict(
+                cls.HEADER_FORMAT_INSTRUCTIONS_DICT
+            )
+
+            if header['auth_magic'] != b'openssh-key-v1\x00':
+                raise ValueError('Not an openssh-key-v1 key')
 
-        if header['auth_magic'] != b'openssh-key-v1\x00':
-            raise ValueError('Not an openssh-key-v1 key')
+            num_keys = header['num_keys']
 
-        num_keys = header['num_keys']
+            if num_keys < 0:
+                raise ValueError('Cannot parse negative number of keys')
 
-        if num_keys < 0:
-            raise ValueError('Cannot parse negative number of keys')
+            public_key_list = []
+            for i in range(num_keys):
+                public_key_bytes = byte_stream.read_from_format_instruction(
+                    PascalStyleFormatInstruction.BYTES
+                )
+                public_key_list.append(
+                    PublicKey.from_bytes(public_key_bytes)
+                )
 
-        public_key_list = []
-        for i in range(num_keys):
-            public_key_bytes = byte_stream.read_from_format_instruction(
+            cipher_bytes = byte_stream.read_from_format_instruction(
                 PascalStyleFormatInstruction.BYTES
             )
-            public_key_list.append(
-                PublicKey.from_bytes(public_key_bytes)
-            )
 
-        cipher_bytes = byte_stream.read_from_format_instruction(
-            PascalStyleFormatInstruction.BYTES
-        )
-
-        kdf_class = get_kdf_options_class(header['kdf'])
-        kdf_options = kdf_class(
-            PascalStyleByteStream(
-                header['kdf_options']
-            ).read_from_format_instructions_dict(
-                kdf_class.FORMAT_INSTRUCTIONS_DICT
+            kdf_class = get_kdf_options_class(header['kdf'])
+            kdf_options = kdf_class(
+                PascalStyleByteStream(
+                    header['kdf_options']
+                ).read_from_format_instructions_dict(
+                    kdf_class.FORMAT_INSTRUCTIONS_DICT
+                )
             )
-        )
 
-        cipher_class = get_cipher_class(header['cipher'])
+            cipher_class = get_cipher_class(header['cipher'])
 
-        if kdf_class == NoneKDFOptions:
-            passphrase = ''
-        elif passphrase is None:
-            passphrase = getpass.getpass('Key passphrase: ')
+            if kdf_class == NoneKDFOptions:
+                passphrase = ''
+            elif passphrase is None:
+                passphrase = getpass.getpass('Key passphrase: ')
 
-        if issubclass(cipher_class, ConfidentialityIntegrityCipher):
-            cipher_bytes += byte_stream.read_fixed_bytes(
-                cipher_class.TAG_LENGTH
-            )
-
-        decipher_bytes = cipher_class.decrypt(
-            kdf_class(kdf_options),
-            passphrase,
-            cipher_bytes
-        )
-
-        decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
+            if issubclass(cipher_class, ConfidentialityIntegrityCipher):
+                cipher_bytes += byte_stream.read_fixed_bytes(
+                    cipher_class.TAG_LENGTH
+                )
 
-        decipher_bytes_header = \
-            decipher_byte_stream.read_from_format_instructions_dict(
-                cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
+            decipher_bytes = cipher_class.decrypt(
+                kdf_class(kdf_options),
+                passphrase,
+                cipher_bytes
             )
 
-        if decipher_bytes_header['check_int_1'] \
-                != decipher_bytes_header['check_int_2']:
-            warnings.warn('Cipher header check numbers do not match')
+            decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
 
-        initlist = []
-        for i in range(num_keys):
-            initlist.append(
-                PublicPrivateKeyPair(
-                    public_key_list[i],
-                    PrivateKey.from_byte_stream(decipher_byte_stream)
-                )
-            )
-            if initlist[i].public.header['key_type'] \
-                    != initlist[i].private.header['key_type']:
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'key types for key {i}'
+            decipher_bytes_header = \
+                decipher_byte_stream.read_from_format_instructions_dict(
+                    cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
                 )
-            if not all(
-                (
-                    initlist[i].public.params[k] ==
-                    initlist[i].private.params[k]
-                ) for k in (
-                    initlist[i].public.params.keys() &
-                    initlist[i].private.params.keys()
+
+            if decipher_bytes_header['check_int_1'] \
+                    != decipher_bytes_header['check_int_2']:
+                warnings.warn('Cipher header check numbers do not match')
+
+            initlist = []
+            for i in range(num_keys):
+                initlist.append(
+                    PublicPrivateKeyPair(
+                        public_key_list[i],
+                        PrivateKey.from_byte_stream(decipher_byte_stream)
+                    )
                 )
+                if initlist[i].public.header['key_type'] \
+                        != initlist[i].private.header['key_type']:
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'key types for key {i}'
+                    )
+                if not all(
+                    (
+                        initlist[i].public.params[k] ==
+                        initlist[i].private.params[k]
+                    ) for k in (
+                        initlist[i].public.params.keys() &
+                        initlist[i].private.params.keys()
+                    )
+                ):
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'values for key {i}'
+                    )
+
+            decipher_padding = decipher_byte_stream.read()
+
+            if (
+                len(decipher_byte_stream.getvalue()) %
+                    cipher_class.BLOCK_SIZE != 0
+            ) or not (
+                bytes(
+                    range(1, 1 + cipher_class.BLOCK_SIZE)
+                ).startswith(decipher_padding)
             ):
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'values for key {i}'
-                )
-
-        decipher_padding = decipher_byte_stream.read()
-
-        if (
-            len(decipher_byte_stream.getvalue()) %
-                cipher_class.BLOCK_SIZE != 0
-        ) or not (
-            bytes(
-                range(1, 1 + cipher_class.BLOCK_SIZE)
-            ).startswith(decipher_padding)
-        ):
-            warnings.warn('Incorrect padding at end of ciphertext')
+                warnings.warn('Incorrect padding at end of ciphertext')
+        except ValueError as e:
+            raise e
+        except EOFError as e:
+            raise ValueError('Premature EOF detected while parsing key.')
+        except e:
+            raise ValueError('Unexpected error condition reached.')
 
         return cls(
             initlist,",Improved error handling to prevent unhandled exceptions in calling code.,"vuln-fix: Prevent premature EOF and improve key parsing validation

The vulnerability is that the key parsing function did not handle premature EOF errors, allowing incomplete or malformed keys to be processed without proper error reporting. This is a security risk because it could lead to corrupted key data being accepted, potentially causing undefined behavior or cryptographic failures. The fix adds explicit EOF detection and raises a ValueError on premature EOF, along with enhanced validation of key counts and header fields to ensure robust parsing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('improved', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('prevent', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('improve', 'ACTION', ''), ('key', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('key', 'SECWORD', ''), ('errors', 'FLAW', ''), ('keys', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('key', 'SECWORD', ''), ('cryptographic', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('valueerror', 'FLAW', ''), ('key', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,{'CWE-200'},GHSA-fcxw-hhxq-48wx,"@@ -42,6 +42,11 @@
 import java.net.URISyntaxException;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -1411,6 +1416,34 @@ public void addNote(String note, String namespace ) throws GitException, Interru
         createNote(note,namespace,""add"");
     }
 
+    private File createTempFileInSystemDir(String prefix, String suffix) throws IOException {
+        if (isWindows()) {
+            return Files.createTempFile(prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(prefix, suffix, fileAttribute).toFile();
+    }
+
+    private File createTempFile(String prefix, String suffix) throws IOException {
+        if (workspace == null) {
+            return createTempFileInSystemDir(prefix, suffix);
+        }
+        File workspaceTmp = new File(workspace.getAbsolutePath() + ""@tmp"");
+        if (!workspaceTmp.isDirectory() && !workspaceTmp.mkdirs()) {
+            if (!workspaceTmp.isDirectory()) {
+                return createTempFileInSystemDir(prefix, suffix);
+            }
+        }
+        Path tmpPath = Paths.get(workspaceTmp.getAbsolutePath());
+        if (isWindows()) {
+            return Files.createTempFile(tmpPath, prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(tmpPath, prefix, suffix, fileAttribute).toFile();
+    }
+
     private void deleteTempFile(File tempFile) {
         if (tempFile != null && !tempFile.delete() && tempFile.exists()) {
             listener.getLogger().println(""[WARNING] temp file "" + tempFile + "" not deleted"");
@@ -1420,7 +1453,7 @@ private void deleteTempFile(File tempFile) {
     private void createNote(String note, String namespace, String command ) throws GitException, InterruptedException {
         File msg = null;
         try {
-            msg = File.createTempFile(""git-note"", ""txt"", workspace);
+            msg = createTempFile(""git-note"", "".txt"");
             FileUtils.writeStringToFile(msg,note);
             launchCommand(""notes"", ""--ref="" + namespace, command, ""-F"", msg.getAbsolutePath());
         } catch (IOException | GitException e) {
@@ -1561,7 +1594,7 @@ private String launchCommandWithCredentials(ArgumentListBuilder args, File workD
     }
 
     private File createSshKeyFile(SSHUserPrivateKey sshUser) throws IOException, InterruptedException {
-        File key = File.createTempFile(""ssh"", ""key"");
+        File key = createTempFile(""ssh"", "".key"");
         try (PrintWriter w = new PrintWriter(key, Charset.defaultCharset().toString())) {
             List<String> privateKeys = sshUser.getPrivateKeys();
             for (String s : privateKeys) {
@@ -1597,7 +1630,7 @@ private String quoteUnixCredentials(String str) {
     }
 
     private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".bat"");
+        File ssh = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             // avoid echoing command as part of the password
             w.println(""@echo off"");
@@ -1610,7 +1643,7 @@ private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOExcepti
     }
 
     private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".sh"");
+        File ssh = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""echo '"" + quoteUnixCredentials(Secret.toString(sshUser.getPassphrase())) + ""'"");
@@ -1621,7 +1654,7 @@ private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException
 
     /* Package protected for testability */
     File createWindowsBatFile(String userName, String password) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".bat"");
+        File askpass = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""@set arg=%~1"");
             w.println(""@if (%arg:~0,8%)==(Username) echo "" + escapeWindowsCharsForUnquotedString(userName));
@@ -1636,7 +1669,7 @@ private File createWindowsStandardAskpass(StandardUsernamePasswordCredentials cr
     }
 
     private File createUnixStandardAskpass(StandardUsernamePasswordCredentials creds) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".sh"");
+        File askpass = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""case \""$1\"" in"");
@@ -1766,7 +1799,7 @@ private File getSSHExeFromGitExeParentDir(String userGitExe) {
     }
 
     private File createWindowsGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".bat"");
+        File ssh = createTempFile(""ssh"", "".bat"");
 
         File sshexe = getSSHExecutable();
 
@@ -1779,7 +1812,7 @@ private File createWindowsGitSSH(File key, String user) throws IOException {
     }
 
     private File createUnixGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".sh"");
+        File ssh = createTempFile(""ssh"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             // ${SSH_ASKPASS} might be ignored if ${DISPLAY} is not set
@@ -2383,7 +2416,7 @@ public void branch(String name) throws GitException, InterruptedException {
     public void commit(String message) throws GitException, InterruptedException {
         File f = null;
         try {
-            f = File.createTempFile(""gitcommit"", "".txt"");
+            f = createTempFile(""gitcommit"", "".txt"");
             try (OutputStream out = Files.newOutputStream(f.toPath())) {
                 out.write(message.getBytes(Charset.defaultCharset().toString()));
             }","[Fix SECURITY-445] better protect temporary files

Temporary files were previously written to the system temporary directory
with default permissions.  A malicious actor could have captured sensitive
information by reading files from the temporary directory.  The temporary
files typically are only on the file system for the duration of a single
command line git invocation, but cloning a large git repo could require
an extended time with those sensitive files in the temporary directory.

This change sets permissions on the temporary files to be readable only by
the file owner. If a workspace is available, a temporary directory adjacent
to the workspace is used instead of the system temporary directory.","vuln-fix: Restrict temporary file permissions to owner only

Temporary files were created without explicit permission restrictions, allowing other users on the system to potentially read or modify sensitive data stored in these files.
This poses a security risk by exposing confidential information such as SSH keys and credentials to unauthorized users on multi-user systems.
The fix enforces owner-only read/write permissions on temporary files by setting POSIX file attributes where supported, and falls back to system defaults on Windows, ensuring tighter access control.

Weakness: Improper Restriction of File Permissions (CWE-732)
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('security-445', 'SECWORD', ''), ('protect', 'secword', ''), ('permissions', 'SECWORD', ''), ('malicious', 'secword', ''), ('sensitive', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('change', 'ACTION', ''), ('permissions', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('file permissions', 'SECWORD', ''), ('permission', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('security', 'secword', ''), ('confidential', 'secword', ''), ('ssh keys', 'SECWORD', ''), ('fix', 'ACTION', ''), ('permissions', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('access control', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper restriction', 'secword', ''), ('file permissions', 'SECWORD', ''), ('cwe-732', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,"{'CWE-532', 'CWE-200'}",GHSA-25xj-89g5-fm6h,"@@ -445,9 +445,7 @@ func (c *ServerCommand) runRecoveryMode() int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// Initialize the storage backend
 	factory, exists := c.PhysicalBackends[config.Storage.Type]
@@ -684,6 +682,31 @@ func (c *ServerCommand) runRecoveryMode() int {
 	return 0
 }
 
+func logProxyEnvironmentVariables(logger hclog.Logger) {
+	proxyCfg := httpproxy.FromEnvironment()
+	cfgMap := map[string]string{
+		""http_proxy"":  proxyCfg.HTTPProxy,
+		""https_proxy"": proxyCfg.HTTPSProxy,
+		""no_proxy"":    proxyCfg.NoProxy,
+	}
+	for k, v := range cfgMap {
+		u, err := url.Parse(v)
+		if err != nil {
+			// Env vars may contain URLs or host:port values.  We only care
+			// about the former.
+			continue
+		}
+		if _, ok := u.User.Password(); ok {
+			u.User = url.UserPassword(""redacted-username"", ""redacted-password"")
+		} else if user := u.User.Username(); user != """" {
+			u.User = url.User(""redacted-username"")
+		}
+		cfgMap[k] = u.String()
+	}
+	logger.Info(""proxy environment"", ""http_proxy"", cfgMap[""http_proxy""],
+		""https_proxy"", cfgMap[""https_proxy""], ""no_proxy"", cfgMap[""no_proxy""])
+}
+
 func (c *ServerCommand) adjustLogLevel(config *server.Config, logLevelWasNotSet bool) (string, error) {
 	var logLevelString string
 	if config.LogLevel != """" && logLevelWasNotSet {
@@ -894,10 +917,7 @@ func (c *ServerCommand) Run(args []string) int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	// log proxy settings
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// If mlockall(2) isn't supported, show a warning. We disable this in dev
 	// because it is quite scary to see when first using Vault. We also disable",Don't include username or password of proxy env vars when logging them. (#9022),"vuln-fix: Redact credentials in proxy environment variable logs

Proxy environment variables containing URLs with embedded credentials were logged in plaintext, exposing sensitive authentication information in application logs.
This posed a security risk by potentially leaking usernames and passwords to unauthorized users with log access.
The fix sanitizes proxy URLs by redacting usernames and passwords before logging, preventing sensitive data exposure in logs.

Weakness: Information Exposure Through Log Files (CWE-532)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('password', 'SECWORD', ''), ('#9022', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('authentication', 'secword', ''), ('security', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitizes', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('sensitive data exposure', 'secword', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-532', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
25,{'CWE-20'},GHSA-w8rc-pgxq-x2cj,"@@ -108,7 +108,7 @@ public ShoppingCartData addItemsToShoppingCart( final ShoppingCartData shoppingC
     {
 
         ShoppingCart cartModel = null;
-        
+        if(item.getQuantity() < 1) item.setQuantity(1);
         /**
          * Sometimes a user logs in and a shopping cart is present in db (shoppingCartData
          * but ui has no cookie with shopping cart code so the cart code will have
@@ -216,7 +216,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -288,7 +288,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -554,8 +554,7 @@ public ShoppingCartData updateCartItem( final Long itemID, final String cartId,
         return null;
     }
     
-    @SuppressWarnings(""unchecked"")
-	@Override
+    @Override
     public ShoppingCartData updateCartItems( final List<ShoppingCartItem> shoppingCartItems, final MerchantStore store, final Language language )
             throws Exception
         {
@@ -720,7 +719,6 @@ public ReadableShoppingCart addToCart(PersistableShoppingCartItem item, Merchant
 	}
 	
 
-	@SuppressWarnings(""unchecked"")
 	@Override
 	public void removeShoppingCartItem(String cartCode, Long productId,
 	      MerchantStore merchant, Language language) throws Exception {

From: ""yannick.gosset"" <yannick.gosset@etu.univ-amu.fr>
 uses PersitableShoppingCartItem

 .../controller/shoppingCart/facade/ShoppingCartFacadeImpl.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -912,7 +912,7 @@ public ReadableShoppingCart addToCart(Customer customer, PersistableShoppingCart
 		
 		Validate.notNull(customer,""Customer cannot be null"");
 		Validate.notNull(customer.getId(),""Customer.id cannot be null or empty"");
-		
+		if(item.getQuantity() < 1) item.setQuantity(1);
 		//Check if customer has an existing shopping cart
 		ShoppingCart cartModel = shoppingCartService.getByCustomer(customer);","Merge pull request from GHSA-w8rc-pgxq-x2cj

Fixing negative charge vulnerability","vuln-fix: Enforce minimum quantity validation in shopping cart items

The vulnerability allowed shopping cart items to be added or updated with zero or negative quantities, bypassing proper availability checks. This could lead to inconsistent cart states and potential exploitation of inventory or pricing logic. The fix enforces a minimum quantity of one for all items before processing, ensuring valid and secure cart operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA'), ('fixing', 'ACTION', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('added', 'ACTION', ''), ('updated', 'ACTION', ''), ('bypassing', 'SECWORD', ''), ('availability', 'secword', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,{'CWE-200'},GHSA-v6wr-fch2-vm5w,"@@ -1,141 +1,142 @@
 /*
-    *
-    *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
-    *  *
-    *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
-    *  *  you may not use this file except in compliance with the License.
-    *  *  You may obtain a copy of the License at
-    *  *
-    *  *       http://www.apache.org/licenses/LICENSE-2.0
-    *  *
-    *  *  Unless required by applicable law or agreed to in writing, software
-    *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
-    *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    *  *  See the License for the specific language governing permissions and
-    *  *  limitations under the License.
-    *  *
-    *  * For more information: http://www.orientechnologies.com
-    *
-    */
+ *
+ *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
+ *  *
+ *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
+ *  *  you may not use this file except in compliance with the License.
+ *  *  You may obtain a copy of the License at
+ *  *
+ *  *       http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *  Unless required by applicable law or agreed to in writing, software
+ *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *  See the License for the specific language governing permissions and
+ *  *  limitations under the License.
+ *  *
+ *  * For more information: http://www.orientechnologies.com
+ *
+ */
 package com.orientechnologies.orient.server.network.protocol.http;
 
 import com.orientechnologies.common.concur.resource.OSharedResourceAbstract;
- import com.orientechnologies.common.log.OLogManager;
- import com.orientechnologies.orient.core.Orient;
- import com.orientechnologies.orient.core.config.OGlobalConfiguration;
-
- import java.util.HashMap;
- import java.util.Iterator;
- import java.util.Map;
- import java.util.Map.Entry;
- import java.util.Random;
- import java.util.TimerTask;
+import com.orientechnologies.common.log.OLogManager;
+import com.orientechnologies.orient.core.Orient;
+import com.orientechnologies.orient.core.config.OGlobalConfiguration;
+
+import java.security.SecureRandom;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.TimerTask;
 
 /**
-  * Handles the HTTP sessions such as a real HTTP Server.
-  *
-  * @author Luca Garulli
-  */
- public class OHttpSessionManager extends OSharedResourceAbstract {
-   private static final OHttpSessionManager instance = new OHttpSessionManager();
-   private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
-   private int                              expirationTime;
-   private Random                           random   = new Random();
-
-   protected OHttpSessionManager() {
-     expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
-
-     Orient.instance().scheduleTask(new TimerTask() {
-       @Override
-       public void run() {
-         final int expired = checkSessionsValidity();
-         if (expired > 0)
-           OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
-       }
-     }, expirationTime, expirationTime);
-   }
-
-   public int checkSessionsValidity() {
-     int expired = 0;
-
-     acquireExclusiveLock();
-     try {
-       final long now = System.currentTimeMillis();
-
-       Entry<String, OHttpSession> s;
-       for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
-         s = it.next();
-
-         if (now - s.getValue().getUpdatedOn() > expirationTime) {
-           // REMOVE THE SESSION
-           it.remove();
-           expired++;
-         }
-       }
-
-     } finally {
-       releaseExclusiveLock();
-     }
-
-     return expired;
-   }
-
-   public OHttpSession[] getSessions() {
-     acquireSharedLock();
-     try {
-
-       return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public OHttpSession getSession(final String iId) {
-     acquireSharedLock();
-     try {
-
-       final OHttpSession sess = sessions.get(iId);
-       if (sess != null)
-         sess.updateLastUpdatedOn();
-       return sess;
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
-     acquireExclusiveLock();
-     try {
-       final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
-       sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
-       return id;
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public OHttpSession removeSession(final String iSessionId) {
-     acquireExclusiveLock();
-     try {
-       return sessions.remove(iSessionId);
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public int getExpirationTime() {
-     return expirationTime;
-   }
-
-   public void setExpirationTime(int expirationTime) {
-     this.expirationTime = expirationTime;
-   }
-
-   public static OHttpSessionManager getInstance() {
-     return instance;
-   }
- }
+ * Handles the HTTP sessions such as a real HTTP Server.
+ *
+ * @author Luca Garulli
+ */
+public class OHttpSessionManager extends OSharedResourceAbstract {
+  private static final OHttpSessionManager instance = new OHttpSessionManager();
+  private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
+  private int                              expirationTime;
+  private Random                           random   = new SecureRandom();
+
+  protected OHttpSessionManager() {
+    expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
+
+    Orient.instance().scheduleTask(new TimerTask() {
+      @Override
+      public void run() {
+        final int expired = checkSessionsValidity();
+        if (expired > 0)
+          OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
+      }
+    }, expirationTime, expirationTime);
+  }
+
+  public int checkSessionsValidity() {
+    int expired = 0;
+
+    acquireExclusiveLock();
+    try {
+      final long now = System.currentTimeMillis();
+
+      Entry<String, OHttpSession> s;
+      for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
+        s = it.next();
+
+        if (now - s.getValue().getUpdatedOn() > expirationTime) {
+          // REMOVE THE SESSION
+          it.remove();
+          expired++;
+        }
+      }
+
+    } finally {
+      releaseExclusiveLock();
+    }
+
+    return expired;
+  }
+
+  public OHttpSession[] getSessions() {
+    acquireSharedLock();
+    try {
+
+      return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public OHttpSession getSession(final String iId) {
+    acquireSharedLock();
+    try {
+
+      final OHttpSession sess = sessions.get(iId);
+      if (sess != null)
+        sess.updateLastUpdatedOn();
+      return sess;
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
+    acquireExclusiveLock();
+    try {
+      final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
+      sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
+      return id;
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public OHttpSession removeSession(final String iSessionId) {
+    acquireExclusiveLock();
+    try {
+      return sessions.remove(iSessionId);
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public int getExpirationTime() {
+    return expirationTime;
+  }
+
+  public void setExpirationTime(int expirationTime) {
+    this.expirationTime = expirationTime;
+  }
+
+  public static OHttpSessionManager getInstance() {
+    return instance;
+  }
+}",Adopted SecureRandom to avoid predicable random numbers in session,"vuln-fix: Use SecureRandom for HTTP session ID generation

The HTTP session IDs were generated using java.util.Random, which is predictable and vulnerable to session fixation attacks.
Predictable session IDs allow attackers to guess or reproduce valid session tokens, leading to unauthorized access and session hijacking.
The fix replaces Random with SecureRandom to generate cryptographically strong, unpredictable session IDs, enhancing session security.

Weakness: CWE-330: Use of Insufficiently Random Values
Severity: High
CVSS: 7.5",0.058823529411764705,"[('securerandom', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('securerandom', 'SECWORD', ''), ('session ids', 'SECWORD', ''), ('java.util.random', 'URL', ''), ('vulnerable', 'SECWORD', ''), ('session fixation', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('session ids', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('hijacking', 'SECWORD', ''), ('fix', 'ACTION', ''), ('securerandom', 'SECWORD', ''), ('cryptographically', 'SECWORD', ''), ('session ids', 'SECWORD', ''), ('security', 'secword', ''), ('weakness', 'secword', ''), ('cwe-330', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,{'CWE-20'},GHSA-jjcx-999m-35hc,"@@ -60,6 +60,9 @@ public function configureJob(array $data): MessageBag
         $config['fints_password']  = (string)(Crypt::encrypt($data['fints_password']) ?? '');
         $config['apply-rules']     = 1 === (int)$data['apply_rules'];
 
+        // sanitize FinTS URL.
+        $config['fints_url'] = $this->validURI($config['fints_url']) ? $config['fints_url'] : '';
+
         $this->repository->setConfiguration($this->importJob, $config);
 
 
@@ -108,4 +111,21 @@ public function setImportJob(ImportJob $importJob): void
         $this->repository->setUser($importJob->user);
     }
 
+    /**
+     * @param string $fints_url
+     *
+     * @return bool
+     */
+    private function validURI(string $fintsUri): bool
+    {
+        $res = filter_var($fintsUri, FILTER_VALIDATE_URL);
+        if (false === $res) {
+            return false;
+        }
+        $scheme = parse_url($fintsUri, PHP_URL_SCHEME);
+
+        return 'https' === $scheme;
+    }
+
+
 }",Fix #2367,"vuln-fix: Sanitize FinTS URL to enforce HTTPS scheme

The FinTS URL configuration was not validated, allowing potentially unsafe or malformed URLs to be stored and used in the system. This posed a security risk by enabling attackers to inject malicious URLs or downgrade to insecure HTTP connections. The fix adds validation to ensure the URL is well-formed and strictly uses the HTTPS scheme, rejecting any invalid or non-HTTPS URLs.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('#2367', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('unsafe', 'SECWORD', ''), ('malformed urls', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('insecure', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,{'CWE-20'},GHSA-8687-vv9j-hgph,"@@ -27,6 +27,12 @@ module.exports = function cast(schema, obj, options, context) {
     throw new Error('Query filter must be an object, got an array ', util.inspect(obj));
   }
 
+  // bson 1.x has the unfortunate tendency to remove filters that have a top-level
+  // `_bsontype` property. Should remove this when we upgrade to bson 4.x. See gh-8222
+  if (obj.hasOwnProperty('_bsontype')) {
+    delete obj._bsontype;
+  }
+
   const paths = Object.keys(obj);
   let i = paths.length;
   let _keys;","fix(query): delete top-level `_bsontype` property in queries to prevent silent empty queries

Fix #8222","vuln-fix: Prevent query filter tampering by removing _bsontype property

The vulnerability occurs because bson 1.x removes filters containing a top-level _bsontype property, which can cause unexpected query behavior or bypasses. This is a security risk as attackers might exploit this to manipulate database queries and access unauthorized data. The fix deletes the _bsontype property from query filters to prevent bson from removing them, ensuring consistent and secure query processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix(query', 'ACTION', ''), ('prevent', 'ACTION', ''), ('fix', 'ACTION', ''), ('#8222', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('tampering', 'secword', ''), ('removing', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('removes', 'ACTION', ''), ('bypasses', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,{'CWE-20'},GHSA-xrp2-fhq4-4q3w,"@@ -50,6 +50,15 @@ struct HistogramFixedWidthFunctor<CPUDevice, T, Tout> {
                         static_cast<double>(nbins);
     const double nbins_minus_1 = static_cast<double>(nbins - 1);
 
+    // We cannot handle NANs in the algorithm below (due to the case to int32)
+    const Eigen::Tensor<int32, 1, 1> nans_tensor =
+        values.isnan().template cast<int32>();
+    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();
+    const int num_nans = reduced_tensor(0);
+    if (num_nans > 0) {
+      return errors::InvalidArgument(""Histogram values must not contain NaN"");
+    }
+
     // The calculation is done by finding the slot of each value in `values`.
     // With [a, b]:
     //   step = (b - a) / nbins
@@ -98,12 +107,12 @@ class HistogramFixedWidthOp : public OpKernel {
     const auto nbins = nbins_tensor.scalar<int32>()();
 
     OP_REQUIRES(
-        ctx, (value_range(0) < value_range(1)),
+        ctx, value_range(0) < value_range(1),
         errors::InvalidArgument(""value_range should satisfy value_range[0] < ""
                                 ""value_range[1], but got '["",
                                 value_range(0), "", "", value_range(1), ""]'""));
     OP_REQUIRES(
-        ctx, (nbins > 0),
+        ctx, nbins > 0,
         errors::InvalidArgument(""nbins should be a positive number, but got '"",
                                 nbins, ""'""));","Prevent crash when histogram is called with NaN values.

Fixes #45770

PiperOrigin-RevId: 443149951","vuln-fix: Prevent NaN values in histogram computation inputs

The vulnerability allowed NaN values to be processed in histogram calculations, which caused undefined behavior and potential incorrect results in downstream operations. This is a security risk because it can lead to data corruption or denial of service if untrusted inputs contain NaNs. The fix adds explicit detection and rejection of NaN values before processing, ensuring only valid numeric inputs are accepted.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('prevent', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#45770', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('untrusted inputs', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
30,"{'CWE-918', 'CWE-20'}",GHSA-2h63-qp69-fwvw,"@@ -847,8 +847,10 @@ private Element parseXml(String xmlString) {
         Document doc = null;
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         try {
-            javax.xml.parsers.DocumentBuilder parser = factory
-                    .newDocumentBuilder();
+            factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
+            factory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
+            factory.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+            javax.xml.parsers.DocumentBuilder parser = factory.newDocumentBuilder();
             parser.setErrorHandler(new ErrorHandler() {
                 public void error(SAXParseException exception)
                         throws SAXException {","BATIK-1284: Dont load DTDs in NodePickerPanel

git-svn-id: https://svn.apache.org/repos/asf/xmlgraphics/batik/trunk@1878396 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Prevent XML External Entity (XXE) Injection in XML Parser

The XML parser was vulnerable to XML External Entity (XXE) attacks due to enabled external entity processing by default. This vulnerability could allow attackers to read arbitrary files or cause denial of service by referencing external resources. The fix disables external general entities, external parameter entities, and external DTD loading features in the XML parser configuration.

Weakness: CWE-611: Improper Restriction of XML External Entity Reference
Severity: High
CVSS: 7.5",0.17647058823529413,"[('https://svn.apache.org/repos/asf/xmlgraphics/batik/trunk@1878396', 'URL', ''), ('ffa450edef68', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('injection', 'secword', ''), ('vulnerable', 'SECWORD', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('external entity', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-611', 'CWEID', ''), ('improper restriction', 'secword', ''), ('xml external entity reference', 'secword', ''), ('high', 'SEVERITY', '')]"
31,{'CWE-20'},GHSA-h8pj-cxx2-jfg2,"@@ -484,7 +484,11 @@ def copy_with(self, **kwargs: typing.Any) -> ""URL"":
         #  \_/   \______________/\_________/ \_________/ \__/
         #   |           |            |            |        |
         # scheme     authority       path        query   fragment
-        return URL(self._uri_reference.copy_with(**kwargs).unsplit())
+        new_url = URL(self)
+        new_url._uri_reference = self._uri_reference.copy_with(**kwargs)
+        if new_url.is_absolute_url:
+            new_url._uri_reference = new_url._uri_reference.normalize()
+        return URL(new_url)
 
     def copy_set_param(self, key: str, value: typing.Any = None) -> ""URL"":
         return self.copy_with(params=self.params.set(key, value))",Patch `copy_with`,"vuln-fix: Normalize absolute URLs to prevent ambiguous URI parsing

The vulnerability involved inconsistent normalization of absolute URLs, which could lead to ambiguous or maliciously crafted URIs being processed insecurely. This posed a security risk by allowing attackers to exploit URI parsing inconsistencies for injection or access control bypass. The fix ensures that absolute URLs are normalized after modification, enforcing consistent and secure URI representations.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('patch', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('maliciously', 'SECWORD', ''), ('insecurely', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('access control', 'secword', ''), ('bypass', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('medium', 'SEVERITY', '')]"
32,{'CWE-200'},GHSA-qpv2-jxc7-3638,"@@ -1,6 +1,6 @@
 <?php
 
 return [
-    'sent'	        => 'Your password link has been sent!',
+    'sent'	        => 'Success: If that email address exists in our system, a password recovery email has been sent.',
     'user'			=> 'No matching active user found with that email.',
 ];","Updated language string

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent user enumeration via password reset messages

The password reset response revealed whether an email address existed in the system, enabling attackers to enumerate valid users.
This information disclosure risk could facilitate targeted attacks such as phishing or brute force attempts on known accounts.
The fix standardizes the response message to avoid confirming the existence of any email address, preventing user enumeration. 

Weakness: Information Exposure Through Error Message (CWE-209)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('updated', 'ACTION', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('user enumeration', 'SECWORD', ''), ('password', 'secword', ''), ('password', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('disclosure', 'secword', ''), ('attacks', 'SECWORD', ''), ('phishing', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('user enumeration', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('error', 'FLAW', ''), ('cwe-209', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,{'CWE-20'},GHSA-xm9f-vxmx-4m58,"@@ -49,7 +49,7 @@ public function getResource($forWrite = false)
             $isError = false;
 
             $ioConfig = $this->getVars();
-            switch ($this->getVar('type', 'file')) {
+            switch (strtolower($this->getVar('type', 'file'))) {
                 case 'file':
                     //validate export/import path
                     $path = rtrim($ioConfig['path'], '\\/')","Merge pull request from GHSA-xm9f-vxmx-4m58

Co-authored-by: Mark Lewis <markwlewis@Marks-MacBook-Pro.local>","vuln-fix: Normalize input type to prevent case-sensitive bypass

The vulnerability was that the type parameter was not normalized, allowing attackers to bypass case-sensitive checks by using mixed-case input values.
This could lead to improper handling of file operations, potentially exposing sensitive files or enabling unauthorized access.
The fix converts the type parameter to lowercase before the switch statement, ensuring consistent and secure type validation.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('ghsa', 'VULNID', 'GHSA'), ('markwlewis@marks-macbook-pro.local', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('sensitive', 'SECWORD', ''), ('improper handling', 'secword', ''), ('sensitive', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-20', 'CWEID', ''), ('improper input validation', 'SECWORD', ''), ('medium', 'SEVERITY', '')]"
34,"{'CWE-325', 'CWE-200', 'CWE-502', 'CWE-20'}",GHSA-4h44-w6fm-548g,"@@ -14,10 +14,15 @@
 
 call_user_func(function() {
     $value = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('value');
-    $addition = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('addition');
     $scope = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('scope');
 
-    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, $addition);
+    if (!is_string($value) || empty($value)) {
+        \TYPO3\CMS\Core\Utility\HttpUtility::setResponseCodeAndExit(
+            \TYPO3\CMS\Core\Utility\HttpUtility::HTTP_STATUS_400
+        );
+    }
+
+    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, 'flashvars');
 
     if ($scope === 'flashvars') {
         header('Content-type: application/x-www-form-urlencoded');","[SECURITY] Restrict file validation hash generation

Security-References: CVE-2020-15086","vuln-fix: Validate input and fix HMAC key usage in flashvars handler

The code lacked validation for the 'value' GET parameter and used an untrusted 'addition' parameter as HMAC key, allowing potential misuse or errors. This posed a security risk by enabling attackers to influence the HMAC key, potentially compromising data integrity or causing unexpected behavior. The fix enforces that 'value' is a non-empty string and replaces the dynamic HMAC key with a fixed, trusted string 'flashvars' to ensure consistent and secure hashing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5

Weakness: Use of Untrusted Input in Security Function (CWE-347)  
Severity: High  
CVSS: 7.8",0.17647058823529413,"[('security', 'SECWORD', ''), ('hash', 'secword', ''), ('security', 'secword', ''), ('cve-2020-15086', 'VULNID', 'CVE')]",0.5294117647058824,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('fix', 'ACTION', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('untrusted', 'secword', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('hmac', 'secword', ''), ('key', 'secword', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', ''), ('weakness', 'SECWORD', ''), ('untrusted', 'SECWORD', ''), ('security', 'secword', ''), ('cwe-347', 'CWEID', ''), ('high', 'SEVERITY', '')]"
35,{'CWE-20'},GHSA-832h-xg76-4gv6,"@@ -106,7 +106,7 @@ function expand(str, isTop) {
   var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
   var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
   var isSequence = isNumericSequence || isAlphaSequence;
-  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
+  var isOptions = m.body.indexOf(',') >= 0;
   if (!isSequence && !isOptions) {
     // {a},b}
     if (m.post.match(/,.*\}/)) {",fix bug in https://github.com/juliangruber/brace-expansion/issues/33,"vuln-fix: Prevent ReDoS in brace expansion option detection

The original regex used to detect comma-separated options in brace expansions could cause excessive backtracking, leading to a Regular Expression Denial of Service (ReDoS) vulnerability.
This vulnerability allows attackers to craft input that triggers high CPU usage, potentially causing service degradation or outages.
The fix replaces the complex regex with a simple indexOf check for commas, eliminating the risk of catastrophic backtracking and improving performance.

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('https://github.com/juliangruber/brace-expansion/issues/33', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('high', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('medium', 'SEVERITY', '')]"
36,{'CWE-20'},GHSA-qr2j-wrhx-4829,"@@ -119,6 +119,9 @@ func (api *PrivateDebugAPI) TraceChain(ctx context.Context, start, end rpc.Block
 	if to == nil {
 		return nil, fmt.Errorf(""end block #%d not found"", end)
 	}
+	if from.Number().Cmp(to.Number()) >= 0 {
+		return nil, fmt.Errorf(""end block (#%d) needs to come after start block (#%d)"", end, start)
+	}
 	return api.traceChain(ctx, from, to, config)
 }",eth: ensure from<to when tracing chain (credits Chen Nan via bugbounty),"vuln-fix: Prevent invalid block range in TraceChain API

The TraceChain function lacked validation to ensure the end block number is greater than the start block number, allowing invalid or reversed block ranges. This could lead to unexpected behavior or potential denial of service by processing nonsensical block ranges. The fix adds a check that returns an error if the end block is not strictly after the start block, enforcing valid input ranges.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('ensure', 'ACTION', ''), ('bugbounty', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('ensure', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
37,{'CWE-200'},GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Method;
 import java.util.Set;
 import javax.el.BeanELResolver;
 import javax.el.ELContext;
@@ -111,7 +112,12 @@ private String transformPropertyName(Object property) {
   }
 
   private void checkRestrictedClass(Object o, Object method) {
-    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {
+    if (
+      o instanceof Class ||
+      o instanceof ClassLoader ||
+      o instanceof Thread ||
+      o instanceof Method
+    ) {
       throw new MethodNotFoundException(
         ""Cannot find method '"" + method + ""' in "" + o.getClass()
       );",add method to blacklist,"vuln-fix: Prevent reflective access to java.lang.reflect.Method objects

The vulnerability allowed reflective access to Method objects, enabling attackers to invoke or manipulate sensitive methods via expression language evaluation. This poses a security risk by potentially exposing internal Java reflection capabilities that can lead to unauthorized code execution. The fix blocks Method instances alongside Class, ClassLoader, and Thread objects to prevent reflective method access in the EL resolver. 

Weakness: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('blacklist', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('java.lang.reflect.method', 'URL', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('security', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-95', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('eval injection', 'secword', ''), ('high', 'SEVERITY', '')]"
38,"{'CWE-178', 'CWE-200'}",GHSA-24m3-w8g9-jwpq,"@@ -259,7 +259,7 @@ function ($val) {
             throw new Error\NotFound('The URL wasn\'t found in the module.');
         }
 
-        if (substr($path, -4) === '.php') {
+        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {
             // PHP file - attempt to run it
 
             /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that","Fix source code disclosure on case-insensitive file systems

If the file system containing the PHP code is case-insensitive, a
request containing an uppercase file extension will return the
contents of the PHP file to the browser instead of executing it.

E.g. a request for this URL will return the source code:

  https:/sp.example.org/simplesaml/module.php/core/frontpage_welcome.PHP

Fix that by converting the path to lowercase before checking the file
extension.

See the following page for details:

  https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq","vuln-fix: Normalize file extension check to prevent case bypass

The file extension check was case-sensitive, allowing attackers to bypass restrictions by using uppercase or mixed-case '.PHP' extensions.
This could lead to unauthorized execution of PHP files, increasing the risk of remote code execution vulnerabilities.
The fix converts the file extension to lowercase using a multibyte-safe function before comparison, ensuring consistent and secure validation.

Weakness: CWE-179: Improper Neutralization of Case Differences in Input
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('disclosure', 'secword', ''), ('https:/sp.example.org', 'URL', ''), ('module.php', 'URL', ''), ('frontpage_welcome.php', 'URL', ''), ('fix', 'ACTION', ''), ('https://github.com/simplesamlphp/simplesamlphp/security/advisories/ghsa-24m3-w8g9-jwpq', 'VULNID', 'GHSA')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('remote code execution', 'secword', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-179', 'CWEID', ''), ('improper neutralization', 'secword', ''), ('medium', 'SEVERITY', '')]"
39,{'CWE-200'},GHSA-f2rp-4rv7-fc95,"@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 
-attributes :url, :user, :password, :ssl_verify_peer, :ssl_certs, :renew
+attributes :url, :user, :ssl_verify_peer, :ssl_certs, :renew",Fix clean API result,"vuln-fix: Remove password attribute to prevent sensitive data exposure

The password attribute was included in the exposed attributes, potentially leaking sensitive credentials through serialization or API responses.
Exposing passwords increases the risk of unauthorized access and credential compromise in the system.
The fix removes the password attribute from the exposed attributes list, preventing accidental disclosure of sensitive information.

Weakness: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('password', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('sensitive data exposure', 'secword', ''), ('password', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('serialization', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('credential', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('password', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('disclosure', 'secword', ''), ('sensitive information', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-200', 'CWEID', ''), ('sensitive information', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
40,{'CWE-20'},GHSA-v82p-hv3v-p6qp,"@@ -57,6 +57,20 @@ class MklRequantizationRangePerChannelOp : public OpKernel {
         ctx, input_max.dim_size(0) == depth,
         errors::InvalidArgument(""input_max has incorrect size, expected "",
                                 depth, "" was "", input_max.dim_size(0)));
+    OP_REQUIRES(
+        ctx, input_min.NumElements() == depth,
+        errors::InvalidArgument(""input_min must have the same number of ""
+                                ""elements as input_max, got "",
+                                input_min.NumElements(), "" and "", depth));
+    OP_REQUIRES(ctx, input.NumElements() > 0,
+                errors::InvalidArgument(""input must not be empty""));
+    OP_REQUIRES(ctx, input.dims() == 4,
+                errors::InvalidArgument(""input must be in NHWC format""));
+    OP_REQUIRES(
+        ctx, input.dim_size(3) == depth,
+        errors::InvalidArgument(
+            ""input must have same number of channels as length of input_min: "",
+            input.dim_size(3), "" vs "", depth));
 
     const float* input_min_data = input_min.flat<float>().data();
     const float* input_max_data = input_max.flat<float>().data();","Add more validation to `RequantizationRangePerChannel`.

PiperOrigin-RevId: 387693946
Change-Id: Ife8dcbdb021bec4787eef6a4361dd08f17c14bd6","vuln-fix: Validate tensor dimensions and sizes in requantization op

The vulnerability was missing comprehensive input validation for tensor dimensions and sizes in the requantization operator, allowing malformed inputs to proceed unchecked. This posed a risk of out-of-bounds memory access or incorrect computations leading to potential crashes or data corruption. The fix adds explicit checks ensuring input tensors have expected dimensions, non-empty data, and matching channel sizes before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ife8dcbdb021bec4787eef6a4361dd08f17c14bd6', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('input validation', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
41,{'CWE-20'},GHSA-pm9p-9926-w68m,"@@ -52,9 +52,21 @@ var ecstatic = module.exports = function (dir, options) {
   return function middleware (req, res, next) {
 
     // Strip any null bytes from the url
+    // This was at one point necessary because of an old bug in url.parse
+    //
+    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
+    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
+    //
+    // But this opens up a regex dos attack vector! D:
+    //
+    // Based on some research (ie asking #node-dev if this is still an issue),
+    // it's *probably* not an issue. :)
+    /*
     while(req.url.indexOf('%00') !== -1) {
       req.url = req.url.replace(/\%00/g, '');
     }
+    */
+
     // Figure out the path for the file from the given url
     var parsed = url.parse(req.url);
     try {","Remove stripping of null bytes

This was at one point necessary because of an old bug in url.parse

See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4

But this opens up a regex dos attack vector! D:

Based on some research (ie asking #node-dev if this is still an issue),
it's *probably* not an issue. :)","vuln-fix: Prevent regex DoS by removing null byte stripping loop

The middleware previously stripped null bytes from URLs using a regex loop, which introduced a potential regular expression denial of service (ReDoS) vulnerability. This is a security risk because an attacker could craft URLs that cause excessive CPU usage, leading to service degradation or downtime. The fix removes the null byte stripping loop, relying on updated URL parsing that no longer requires this workaround, thus eliminating the ReDoS attack vector.

Weakness: CWE-400 Uncontrolled Resource Consumption (Resource Exhaustion)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('remove', 'ACTION', ''), ('bug', 'FLAW', ''), ('url.parse', 'URL', ''), ('https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914', 'URL', ''), ('https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4', 'URL', ''), ('dos', 'SECWORD', ''), ('attack vector', 'secword', ''), ('issue', 'FLAW', ''), ('issue', 'FLAW', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'SECWORD', ''), ('removing', 'ACTION', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('attacker', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('updated', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attack vector', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('high', 'SEVERITY', '')]"
42,"{'CWE-400', 'CWE-20'}",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate pylist depth against ragged_rank to prevent inconsistencies

The vulnerability allowed pylist inputs with a maximum depth smaller than the specified ragged_rank, causing inconsistent internal state and potential downstream errors. This inconsistency could lead to unexpected behavior or crashes when processing ragged tensors, posing a risk to application stability and data integrity. The fix adds a validation check that raises an error if the pylist depth is less than the ragged_rank, ensuring input consistency before further processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('tf.ragged.constant', 'URL', ''), ('fixes', 'ACTION', ''), ('#55199', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('errors', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
43,{'CWE-20'},GHSA-j259-6c58-9m58,"@@ -545,10 +545,11 @@ PostgreSQL.prototype.buildExpression = function(columnName, operator,
       return new ParameterizedSQL(columnName + regexOperator,
         [operatorValue.source]);
     case 'contains':
-      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map((v) => `'${v}'`) + ']::'
-        + propertyDefinition.postgresql.dataType);
+      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map(() => '?') + ']::'
+        + propertyDefinition.postgresql.dataType,
+        operatorValue);
     case 'match':
-      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery('${operatorValue}')`);
+      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery(?)`, [operatorValue]);
     default:
       // invoke the base implementation of `buildExpression`
       return this.invokeSuper('buildExpression', columnName, operator,","fix: improve filter sanitisation

Add sanitisation of user-input for `contains` LoopBack filter which may allow for arbitrary SQL injection.

Signed-off-by: Rifa Achrinza <25147899+achrinza@users.noreply.github.com>","vuln-fix: Prevent SQL injection in PostgreSQL query builder

The code previously interpolated user input directly into SQL strings without parameterization, enabling injection attacks through crafted inputs. This is a critical security risk as attackers could execute arbitrary SQL commands, compromising data integrity and confidentiality. The fix replaces direct string interpolation with parameterized queries, safely passing user inputs as query parameters to prevent injection.

Weakness: SQL Injection (CWE-89)  
Severity: Critical  
CVSS: 9.8",0.23529411764705882,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('sanitisation', 'SECWORD', ''), ('add', 'ACTION', ''), ('sanitisation', 'SECWORD', ''), ('sql injection', 'SECWORD', ''), ('signed', 'secword', ''), ('25147899+achrinza@users.noreply.github.com', 'EMAIL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sql injection', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('sql injection', 'secword', ''), ('cwe-89', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
44,"{'CWE-200', 'CWE-668'}",GHSA-hm3x-jwwf-jpr9,"@@ -163,7 +163,7 @@ outputs:
             ironic::api::authtoken::user_domain_name: 'Default'
             ironic::api::authtoken::project_domain_name: 'Default'
             ironic::api::authtoken::username: 'ironic'
-            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
+            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystonePublic, uri_no_suffix]}
             ironic::api::authtoken::auth_url: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
             ironic::api::authtoken::region_name: {get_param: KeystoneRegion}
             ironic::api::authtoken::interface: 'internal'","Fix remaining usage of internal url for www_authenticate_uri

This is follow-up of 160936df134a471cfd245bd60964046027a571ea and fixes
remaining usage of internal endpoint url for [keystone_authtoken]
www_authenticate_uri.

Related-Bug: #1955397
Change-Id: Ib2ee7295c7fcda276e4fcf011a9e427e041f4848","vuln-fix: Use public endpoint for www_authenticate_uri in authtoken config

The www_authenticate_uri was set to use the internal Keystone endpoint, exposing internal network details to services expecting public access. This misconfiguration could allow unauthorized internal resource access or information leakage from internal endpoints. The fix changes the www_authenticate_uri to use the Keystone public endpoint, ensuring proper external authentication routing and reducing exposure of internal services.

Weakness: Information Exposure (CWE-200)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('160936df134a471cfd245bd60964046027a571ea', 'SHA', ''), ('fixes', 'ACTION', ''), ('keystone_authtoken', 'SECWORD', ''), ('bug', 'FLAW', ''), ('#1955397', 'ISSUE', ''), ('change', 'ACTION', ''), ('ib2ee7295c7fcda276e4fcf011a9e427e041f4848', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('keystone', 'SECWORD', ''), ('misconfiguration', 'SECWORD', ''), ('information leakage', 'secword', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('keystone', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
45,{'CWE-200'},GHSA-wh98-p28r-vrc9,"@@ -58,7 +58,7 @@ def self.reload!
       prepare!
     end
 
-    def self.run! # :nodoc:
+    def self.run!(reset: false) # :nodoc:
       if check!
         super
       else","Fix reloader to work with new Executor signature

This is a follow up to [CVE-2022-23633].","vuln-fix: Prevent unintended state reset in run! method

The run! method was modified to accept a reset parameter, preventing unintended state resets during execution that could lead to inconsistent application behavior.
Uncontrolled state resets pose a security risk by potentially exposing sensitive data or causing denial of service through unexpected application states.
The fix introduces an explicit reset argument to control state changes, ensuring that resets occur only when intentionally requested by the caller. 

Weakness: Improper Control of Object State (CWE-908)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('cve-2022-23633', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('preventing', 'ACTION', ''), ('security', 'SECWORD', ''), ('sensitive data', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper control', 'secword', ''), ('cwe-908', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
46,{'CWE-200'},GHSA-cv3f-px9r-54hm,"@@ -721,7 +721,6 @@ class Spawner {
 		prepareChroot(info, options);
 		info.userSwitching = prepareUserSwitching(options);
 		prepareSwitchingWorkingDirectory(info, options);
-		inferApplicationInfo(info);
 		return info;
 	}
 
@@ -775,6 +774,7 @@ class Spawner {
 		assert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);
 	}
 
+#ifdef false
 	void inferApplicationInfo(SpawnPreparationInfo &info) const {
 		info.codeRevision = readFromRevisionFile(info);
 		if (info.codeRevision.empty()) {
@@ -817,6 +817,7 @@ class Spawner {
 			return string();
 		}
 	}
+#endif
 
 	bool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {
 		if (options.loadShellEnvvars) {",Disable unused feature.,"vuln-fix: Prevent automatic inference of application info in spawner

The automatic inference of application information from revision files was enabled, potentially exposing sensitive internal data to unauthorized users. This posed a security risk by leaking code revision details that could aid attackers in targeting specific application versions. The fix disables the inference function by removing its invocation and enclosing its implementation in a disabled preprocessor block to prevent unintended information disclosure.

Weakness: Information Exposure (CWE-200)
Severity: Medium
CVSS: 5.3",0.11764705882352941,[],0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('prevent', 'ACTION', ''), ('disclosure', 'secword', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
47,"{'CWE-1321', 'CWE-20'}",GHSA-g6ww-v8xp-vmwg,"@@ -76,6 +76,9 @@ function parsePath(path) {
   var str = path.replace(/([^\\])\[/g, '$1.[');
   var parts = str.match(/(\\\.|[^.]+?)+/g);
   return parts.map(function mapMatches(value) {
+    if (value === ""constructor"" || value === ""__proto__"" || value === ""prototype"") {
+      return {}
+    }
     var regexp = /^\[(\d+)\]$/;
     var mArr = regexp.exec(value);
     var parsed = null;",fix: 🐛 fix prototype pollution,"vuln-fix: Prevent prototype pollution in path parsing function

The vulnerability allowed special keys like ""constructor"", ""__proto__"", and ""prototype"" to be processed, enabling prototype pollution attacks. Prototype pollution can lead to unexpected behavior and security breaches by modifying object prototypes. The fix blocks these keys by returning empty objects, preventing prototype chain manipulation during path parsing.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'SECWORD', ''), ('prototype pollution', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-1321', 'CWEID', ''), ('improper restriction', 'secword', ''), ('high', 'SEVERITY', '')]"
48,"{'CWE-191', 'CWE-20'}",GHSA-hx9q-2mx4-m4pg,"@@ -94,8 +94,10 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
-    OP_REQUIRES(context, num_segments > 0,
-                errors::InvalidArgument(""Number of segments must be positive""));
+    OP_REQUIRES(
+        context, num_segments >= 0,
+        errors::InvalidArgument(
+            ""Number of segments must be non-negative but got "", num_segments));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Allow 0 for number of segments in `unsorted_segment_join_op.cc`

Related to the fix for #55305

PiperOrigin-RevId: 443157549","vuln-fix: Allow zero segments in UnsortedSegmentJoinOp validation

The validation incorrectly rejected zero as an invalid number of segments, causing potential denial of service or crashes when zero segments were legitimately used. This could lead to application instability or unexpected failures when processing empty segment inputs. The fix updates the validation to accept zero as a valid non-negative number of segments, preventing erroneous rejections and improving robustness.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('unsorted_segment_join_op.cc', 'URL', ''), ('fix', 'ACTION', ''), ('#55305', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
49,{'CWE-200'},GHSA-hxf9-7h4c-f5jv,"@@ -3,6 +3,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -41,8 +42,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -78,8 +84,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.

(cherry picked from commit db586ede1fbb41dce21310ea28ae15a1cf1286c5)","vuln-fix: Prevent timing attacks on webhook basic authentication

The webhook basic authentication compared credentials using standard string comparison, which is vulnerable to timing attacks that can leak information about valid credentials. Timing attacks allow attackers to gradually guess authentication tokens by measuring response time differences, compromising security. The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure comparisons execute in constant time, mitigating timing attack risks.

Weakness: CWE-208 Timing Attack  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('security', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attack', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attacker', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('upgrade', 'ACTION', ''), ('docs](http://anymail.readthedocs.io', 'URL', ''), ('exploit', 'SECWORD', ''), ('db586ede1fbb41dce21310ea28ae15a1cf1286c5', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('string comparison', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('leak', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('authentication', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('string comparisons', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('attack', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cwe-208', 'CWEID', ''), ('attack', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
50,{'CWE-20'},GHSA-8948-ffc6-jg52,"@@ -252,6 +252,11 @@ ReverseProxy.prototype.setupHttpsProxy = function (proxy, websocketsUpgrade, log
     key: getCertData(sslOpts.key),
     cert: getCertData(sslOpts.cert)
   };
+  
+  // Allows the option to disable older SSL/TLS versions
+  if(sslOpts.secureOptions) {
+    ssl.secureOptions = sslOpts.secureOptions;
+  }
 
   if (sslOpts.ca) {
     ssl.ca = getCertData(sslOpts.ca, true);","Adding option to disable older SSL/TLS versions

Simply pass in ""secureOptions"" as you normally would to an https config object, and redbird will pass it along into the https proxy server.","vuln-fix: Allow disabling older SSL/TLS versions in HTTPS proxy

The HTTPS proxy previously did not support disabling outdated SSL/TLS protocol versions, allowing use of insecure protocols by default. This poses a security risk as attackers can exploit known vulnerabilities in older SSL/TLS versions to intercept or manipulate traffic. The fix enables passing secureOptions to explicitly disable legacy protocols, improving the security posture of HTTPS connections.

Weakness: CWE-295 Improper Certificate Validation  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('adding', 'ACTION', ''), ('ssl', 'secword', ''), ('tls', 'secword', ''), ('secureoptions', 'SECWORD', ''), ('https proxy', 'SECWORD', ''), ('server', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('ssl', 'secword', ''), ('tls', 'SECWORD', ''), ('https proxy', 'SECWORD', ''), ('https proxy', 'SECWORD', ''), ('ssl', 'secword', ''), ('tls', 'secword', ''), ('protocol', 'SECWORD', ''), ('insecure', 'SECWORD', ''), ('protocols', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('known vulnerabilities', 'SECWORD', ''), ('ssl', 'secword', ''), ('tls', 'secword', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('secureoptions', 'SECWORD', ''), ('protocols', 'SECWORD', ''), ('improving', 'ACTION', ''), ('security', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-295', 'CWEID', ''), ('improper certificate validation', 'secword', ''), ('high', 'SEVERITY', '')]"
51,"{'CWE-475', 'CWE-20'}",GHSA-5wpj-c6f7-24x8,"@@ -304,6 +304,9 @@ Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,
     const Tensor* tensor;
     // TODO(fishx): Avoid blocking here.
     TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));
+    if (tensor->NumElements() == 0) {
+      return errors::InvalidArgument(""Empty resource handle"");
+    }
     const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);
     device_name = handle.device();","Fix empty resource handle vulnerability.

Some ops that attempt to extract a resource handle from user input
can lead to nullptr dereferences.  This returns an error in such
a case.

PiperOrigin-RevId: 445571938","vuln-fix: Prevent empty resource handle usage in device retrieval

The vulnerability occurs when an empty resource handle is processed without validation, leading to potential undefined behavior or crashes in downstream operations.
This is a security risk because it can cause denial of service or memory corruption by dereferencing invalid or uninitialized resource handles.
The fix adds a check to detect empty resource handles early and returns an error, preventing further unsafe processing of invalid inputs.


Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('nullptr', 'SECWORD', ''), ('error', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('uninitialized resource', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
52,{'CWE-20'},GHSA-qfpc-5pjr-mh26,"@@ -2990,6 +2990,10 @@ REGISTER_OP(""Dequantize"")
       if (!s.ok() && s.code() != error::NOT_FOUND) {
         return s;
       }
+      if (axis < -1) {
+        return errors::InvalidArgument(""axis should be at least -1, got "",
+                                       axis);
+      }
       const int minmax_rank = (axis == -1) ? 0 : 1;
       TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
       ShapeHandle minmax;","Fix a shape inference issue leading to nullptr deref.

PiperOrigin-RevId: 387712259
Change-Id: I7e670772b259c068a501a187cd89f18773bb95a1","vuln-fix: Validate axis parameter to prevent invalid negative values

The vulnerability allowed axis values less than -1, which could cause unexpected behavior or crashes during tensor shape inference in the Dequantize operation.
This is a security risk because it may lead to denial of service or memory corruption when processing malformed inputs.
The fix adds a validation check that rejects axis values below -1, returning an error to prevent further processing of invalid inputs.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i7e670772b259c068a501a187cd89f18773bb95a1', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
53,{'CWE-200'},GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import com.hubspot.jinjava.interpret.JinjavaInterpreter;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -136,7 +137,8 @@ protected boolean isRestrictedClass(Object o) {
       o instanceof Thread ||
       o instanceof Method ||
       o instanceof Field ||
-      o instanceof Constructor
+      o instanceof Constructor ||
+      o instanceof JinjavaInterpreter
     );
   }
 }",Add interpreter to blacklist,"vuln-fix: Restrict JinjavaInterpreter class access in security checks

The vulnerability allowed JinjavaInterpreter instances to bypass existing restrictions, potentially exposing sensitive internal interpreter state to untrusted code execution. This posed a security risk by enabling attackers to manipulate or access critical template rendering internals. The fix extends the restricted class checks to include JinjavaInterpreter, preventing unauthorized access to this sensitive class. 

Weakness: Improper Restriction of Operations within the Security Policy (CWE-276)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('blacklist', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('untrusted', 'secword', ''), ('code execution', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('critical', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper restriction', 'secword', ''), ('security', 'secword', ''), ('cwe-276', 'CWEID', ''), ('high', 'SEVERITY', '')]"
54,{'CWE-20'},GHSA-gxg6-rc6c-v673,"@@ -118,6 +118,10 @@ interface from JDK1.2 VM...
 	*/
 	class Handler implements InvocationHandler
 	{
+		private Object readResolve() throws ObjectStreamException {
+			throw new NotSerializableException();
+		}
+
 		public Object invoke( Object proxy, Method method, Object[] args )
 			throws Throwable
 		{",Prevent deserialization of Handler,"vuln-fix: Prevent serialization of dynamic proxy handler

The dynamic proxy handler class lacked protection against serialization, allowing unauthorized serialization of internal handler state.
This posed a security risk by potentially exposing sensitive internal data or enabling deserialization attacks.
The fix adds a readResolve method that throws NotSerializableException to block serialization attempts on the handler class.

Weakness: CWE-502 Deserialization of Untrusted Data  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('deserialization', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('serialization', 'SECWORD', ''), ('protection', 'SECWORD', ''), ('serialization', 'SECWORD', ''), ('serialization', 'SECWORD', ''), ('security', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('deserialization', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('notserializableexception', 'SECWORD', ''), ('serialization', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-502', 'CWEID', ''), ('deserialization', 'SECWORD', ''), ('untrusted data', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
55,{'CWE-20'},GHSA-m648-33qf-v3gp,"@@ -1468,7 +1468,9 @@ class CudnnRnnSequenceTensorDescriptor
   static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();
@@ -1486,7 +1488,9 @@ class CudnnRnnSequenceTensorDescriptor
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       const absl::Span<const int>& seq_lengths, bool time_major,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();","Prevent CHECK-fail in LSTM/GRU with zero-length input.

PiperOrigin-RevId: 346239181
Change-Id: I5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f","vuln-fix: Validate max_seq_length to prevent invalid tensor descriptor creation

The vulnerability is that max_seq_length was not properly validated, allowing zero or negative values to proceed and potentially cause undefined behavior or memory corruption. This is a security risk because it can lead to crashes or exploitable conditions in GPU tensor operations, undermining system stability and security. The fix adds explicit checks that return an error status if max_seq_length is less than or equal to zero, preventing invalid tensor descriptor creation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('change', 'ACTION', ''), ('i5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
56,{'CWE-209'},GHSA-hm37-9xh2-q499,"@@ -236,7 +236,8 @@ def read_fixed_bytes(self, num_bytes: int) -> bytes:
         """"""
         read_bytes = self.read(num_bytes)
         if len(read_bytes) < num_bytes:
-            raise EOFError(read_bytes)
+            raise EOFError(""Fewer than 'num_bytes' bytes remaining in the ""
+                    ""underlying bytestream"")
         return read_bytes
 
     def read_pascal_bytes(self, string_length_size: int) -> bytes:",Changed an exception message to prevent possible disclosures of keying material.,"vuln-fix: Improve error message to avoid leaking partial data

The previous error message exposed partial byte content when fewer bytes than expected were read from the stream. This could inadvertently leak sensitive data in error logs or exception traces, posing a confidentiality risk. The fix replaces the partial data in the error message with a generic description to prevent unintended information disclosure.

Weakness: Information Exposure Through Error Message (CWE-209)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('changed', 'ACTION', ''), ('prevent', 'ACTION', ''), ('keying', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('leak', 'SECWORD', ''), ('sensitive data', 'SECWORD', ''), ('error', 'FLAW', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('disclosure', 'secword', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('error', 'FLAW', ''), ('cwe-209', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
57,{'CWE-20'},GHSA-f522-ffg8-j8r6,"@@ -11,4 +11,4 @@ exports['alpha'] = /^[a-zA-Z]+$/
 exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
 exports['style'] = /\s*(.+?):\s*([^;]+);?/g
 exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
-exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/
+exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/",fix utc-millisec regex to avoid a ddos attack,"vuln-fix: Restrict utc-millisec regex to prevent excessive input length

The utc-millisec regular expression allowed arbitrarily long numeric input with optional decimals, enabling potential denial of service via resource exhaustion.
This posed a security risk by permitting attackers to submit extremely large strings that could degrade system performance or cause crashes.
The fix limits the integer and fractional parts to a maximum of 15 digits each, preventing overly long inputs and mitigating resource abuse. 

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('ddos', 'secword', ''), ('attack', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('medium', 'SEVERITY', '')]"
58,"{'CWE-434', 'CWE-20'}",GHSA-5gjh-5j4f-cpwv,"@@ -16,6 +16,7 @@ import (
 	""strings""
 	""time""
 
+	""github.com/pkg/errors""
 	gouuid ""github.com/satori/go.uuid""
 	""github.com/unknwon/com""
 
@@ -23,9 +24,10 @@ import (
 
 	""gogs.io/gogs/internal/conf""
 	""gogs.io/gogs/internal/cryptoutil""
-	""gogs.io/gogs/internal/db/errors""
+	dberrors ""gogs.io/gogs/internal/db/errors""
 	""gogs.io/gogs/internal/gitutil""
 	""gogs.io/gogs/internal/osutil""
+	""gogs.io/gogs/internal/pathutil""
 	""gogs.io/gogs/internal/process""
 	""gogs.io/gogs/internal/tool""
 )
@@ -134,7 +136,7 @@ func (repo *Repository) UpdateRepoFile(doer *User, opts UpdateRepoFileOptions) (
 	if opts.OldBranch != opts.NewBranch {
 		// Directly return error if new branch already exists in the server
 		if git.RepoHasBranch(repoPath, opts.NewBranch) {
-			return errors.BranchAlreadyExists{Name: opts.NewBranch}
+			return dberrors.BranchAlreadyExists{Name: opts.NewBranch}
 		}
 
 		// Otherwise, delete branch from local copy in case out of sync
@@ -449,11 +451,16 @@ func isRepositoryGitPath(path string) bool {
 	return strings.HasSuffix(path, "".git"") || strings.Contains(path, "".git""+string(os.PathSeparator))
 }
 
-func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) (err error) {
+func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {
 	if len(opts.Files) == 0 {
 		return nil
 	}
 
+	// Prevent uploading files into the "".git"" directory
+	if isRepositoryGitPath(opts.TreePath) {
+		return errors.Errorf(""bad tree path %q"", opts.TreePath)
+	}
+
 	uploads, err := GetUploadsByUUIDs(opts.Files)
 	if err != nil {
 		return fmt.Errorf(""get uploads by UUIDs[%v]: %v"", opts.Files, err)
@@ -487,7 +494,9 @@ func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions)
 			continue
 		}
 
-		// Prevent copying files into .git directory, see https://gogs.io/gogs/issues/5558.
+		upload.Name = pathutil.Clean(upload.Name)
+
+		// Prevent uploading files into the "".git"" directory
 		if isRepositoryGitPath(upload.Name) {
 			continue
 		}",repo_editor: check upload `TreePath` and file name (#6838),"vuln-fix: Prevent uploading files into .git directory in repository

The vulnerability allowed files to be uploaded or copied into the repository’s .git directory, which could corrupt repository metadata or enable malicious manipulation of git internals. This poses a security risk by potentially allowing attackers to alter git data, leading to unauthorized code execution or repository compromise. The fix adds explicit checks to reject uploads and file copies targeting paths within the .git directory, ensuring repository integrity is maintained.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5",0.058823529411764705,"[('#6838', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('integrity', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-22', 'CWEID', ''), ('improper limitation', 'secword', ''), ('path traversal', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
59,{'CWE-20'},GHSA-f7f4-hqp2-7prc,"@@ -106,7 +106,10 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
-      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname || '/',
+      // ^^ Uses || '/' because otherwise url.parse returns `null`,
+      // which is not a string and thus bad when you try to check
+      // .match() of it.
 
       method  : options.eventName,",Follow up to ff02114eaec090ee51db48435cc32d451662606e to ensure req.path is good and stringy.,"vuln-fix: Prevent null pathname causing runtime errors in URL parsing

The vulnerability was that url.parse could return a null pathname, leading to runtime errors when subsequent code attempted string operations on it. This is a security risk because such errors can cause application crashes or unexpected behavior, potentially exposing attack surfaces or denial of service. The fix ensures the pathname defaults to '/' if null, preventing invalid string operations and stabilizing URL handling logic.

Weakness: CWE-682 Improper Control of a Resource Through its Lifetime  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('ff02114eaec090ee51db48435cc32d451662606e', 'SHA', ''), ('ensure', 'ACTION', ''), ('req.path', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('url.parse', 'URL', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('errors', 'FLAW', ''), ('attack surfaces', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-682', 'CWEID', ''), ('improper control', 'secword', ''), ('medium', 'SEVERITY', '')]"
60,{'CWE-20'},GHSA-x2mc-8fgj-3wmr,"@@ -261,7 +261,7 @@ exports.extract = function (cwd, opts) {
     var onlink = function () {
       if (win32) return next() // skip links on win for now before it can be tested
       xfs.unlink(name, function () {
-        var srcpath = path.resolve(cwd, header.linkname)
+        var srcpath = path.join(cwd, path.join('/', header.linkname))
 
         xfs.link(srcpath, name, function (err) {
           if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {",force hardlink targets to be in the tar,"vuln-fix: Prevent directory traversal in hardlink extraction

The vulnerability allowed crafted link names to escape the intended directory by resolving paths outside the extraction root, enabling directory traversal attacks.
This posed a security risk by permitting attackers to overwrite or link files outside the target directory, potentially leading to privilege escalation or data corruption.
The fix replaces path resolution with a safe join that confines link targets within the extraction directory, preventing traversal beyond the intended root path.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('directory traversal', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('escape', 'secword', ''), ('directory traversal', 'secword', ''), ('attacks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('privilege escalation', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-22', 'CWEID', ''), ('improper limitation', 'secword', ''), ('path traversal', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
61,"{'CWE-191', 'CWE-20'}",GHSA-hx9q-2mx4-m4pg,"@@ -94,6 +94,8 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
+    OP_REQUIRES(context, num_segments > 0,
+                errors::InvalidArgument(""Number of segments must be positive""));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Validate `num_segments > 0` in `unsorted_segment_join`

Fixes #55305

PiperOrigin-RevId: 442047005","vuln-fix: Validate positive number of segments in UnsortedSegmentJoinOp

The vulnerability was that the number of segments could be zero or negative, which was not properly validated before processing. This could lead to undefined behavior or potential denial of service due to invalid input causing crashes or resource exhaustion. The fix adds a check to ensure the number of segments is strictly positive, rejecting invalid inputs early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('validate', 'secword', ''), ('fixes', 'ACTION', ''), ('#55305', 'ISSUE', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
62,{'CWE-209'},GHSA-m884-279h-32v2,"@@ -20,15 +20,15 @@
                 <?php if ($exception['trace']) { ?>
                 <pre class=""stacktrace"">
 <?php
-                    echo $exception['class']."":\n"";
+                    echo $this->escape($exception['class'])."":\n"";
                     if ($exception['message']) {
-                        echo $exception['message'].""\n"";
+                        echo $this->escape($exception['message']).""\n"";
                     }
 
                     foreach ($exception['trace'] as $trace) {
                         echo ""\n  "";
                         if ($trace['function']) {
-                            echo 'at '.$trace['class'].$trace['type'].$trace['function'].'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
+                            echo $this->escape('at '.$trace['class'].$trace['type'].$trace['function']).'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
                         }
                         if ($trace['file'] && $trace['line']) {
                             echo($trace['function'] ? ""\n     ("" : 'at ').strtr(strip_tags($this->formatFile($trace['file'], $trace['line'])), [' at line '.$trace['line'] => '']).':'.$trace['line'].($trace['function'] ? ')' : '');",Escape variable in Exception Template,"vuln-fix: Escape exception output to prevent XSS in error traces

Exception class names, messages, and trace function details were output without escaping, allowing injection of malicious scripts in error pages.
This vulnerability could enable attackers to execute arbitrary JavaScript in users’ browsers, leading to session hijacking or data theft.
The fix applies proper escaping to all exception output fields before rendering, mitigating cross-site scripting risks in error displays.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('error', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('hijacking', 'secword', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('mitigating', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
63,"{'CWE-915', 'CWE-20'}",GHSA-f98m-q3hr-p5wq,"@@ -74,6 +74,10 @@ module.exports = function parse_str (str, array) { // eslint-disable-line camelc
     key = _fixStr(tmp[0])
     value = (tmp.length < 2) ? '' : _fixStr(tmp[1])
 
+    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
+      break;
+    }
+
     while (key.charAt(0) === ' ') {
       key = key.slice(1)
     }",fixed prototype pollution,"vuln-fix: Prevent prototype pollution in query string parser

The vulnerability allowed keys containing __proto__, constructor, or prototype to modify object prototypes during parsing. This posed a security risk by enabling prototype pollution attacks that could lead to arbitrary code execution or denial of service. The fix blocks processing of keys with these substrings, preventing prototype chain manipulation in the parser.

Weakness: Prototype Pollution (CWE-1321)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fixed', 'ACTION', ''), ('prototype pollution', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('security', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
64,{'CWE-20'},GHSA-278g-rq84-9hmg,"@@ -527,6 +527,8 @@ class MapStageOp : public OpKernel {
     OP_REQUIRES_OK(ctx, ctx->input(""key"", &key_tensor));
     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices_tensor));
     OP_REQUIRES_OK(ctx, ctx->input_list(""values"", &values_tensor));
+    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,
+                errors::InvalidArgument(""key must not be empty""));
 
     // Create copy for insertion into Staging Area
     Tensor key(*key_tensor);","Prevent a CHECK-fail due to empty tensor input in `map_stage_op.cc`

PiperOrigin-RevId: 387737906
Change-Id: Idc52df0c71c7ed6e2dd633b651a581932f277c8a","vuln-fix: Prevent empty key usage in MapStageOp inputs

The vulnerability allowed empty keys to be used in the MapStageOp, which could cause undefined behavior or data corruption in the staging area. This is a security risk because it may lead to denial of service or inconsistent state exploitable by attackers. The fix adds a validation check that rejects empty keys by returning an invalid argument error before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('prevent', 'ACTION', ''), ('map_stage_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('idc52df0c71c7ed6e2dd633b651a581932f277c8a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('key', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('security', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('keys', 'SECWORD', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
65,{'CWE-20'},GHSA-j7c4-2xj8-wm7r,"@@ -61,6 +61,7 @@ def __str__(self):
 
 
 class Application:
+    MAX_LENGTH = 128 * 1024
     SOCKTYPES = {
         ""tcp"": socket.SOCK_STREAM,
         ""udp"": socket.SOCK_DGRAM,
@@ -180,7 +181,11 @@ def __call__(self, env, start_response):
             try:
                 length = int(env[""CONTENT_LENGTH""])
             except AttributeError:
-                length = -1
+                raise HTTPException(411, ""Length required."")
+            if length < 0:
+                raise HTTPException(411, ""Length required."")
+            if length > self.MAX_LENGTH:
+                raise HTTPException(413, ""Request entity too large."")
             try:
                 pr = codec.decode(env[""wsgi.input""].read(length))
             except codec.ParsingError as e:","Enforce a maximum packet length

Permanently fixes CVE-2015-5159 for all applications.","vuln-fix: Enforce request body length limits to prevent abuse

The application did not properly validate the Content-Length header, allowing requests with missing or excessively large bodies to be processed. This could lead to denial of service or resource exhaustion by consuming excessive memory or CPU. The fix enforces a required positive Content-Length and rejects requests exceeding a defined maximum size with appropriate HTTP errors.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('fixes', 'ACTION', ''), ('cve-2015-5159', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('validate', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('cwe-400', 'CWEID', ''), ('uncontrolled resource consumption', 'secword', ''), ('high', 'SEVERITY', '')]"
66,{'CWE-200'},GHSA-37q6-576q-vgr7,"@@ -17,7 +17,17 @@ class HMRServer {
         this.server = https.createServer(await getCertificate(options.https));
       }
 
-      this.wss = new WebSocket.Server({server: this.server});
+      let websocketOptions = {
+        server: this.server
+      };
+
+      if (options.hmrHostname) {
+        websocketOptions.origin = `${options.https ? 'https' : 'http'}://${
+          options.hmrHostname
+        }`;
+      }
+
+      this.wss = new WebSocket.Server(websocketOptions);
       this.server.listen(options.hmrPort, resolve);
     });",fix security vuln (#1794),"vuln-fix: Restrict WebSocket connections by validating origin header

The WebSocket server accepted connections from any origin, allowing unauthorized clients to connect and potentially exploit the hot module replacement service.
This unrestricted access could lead to unauthorized code injection or data leakage through malicious WebSocket clients.
The fix enforces origin validation by setting the allowed origin based on the configured hostname, preventing connections from untrusted sources.

Weakness: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-125)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('#1794', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('server', 'SECWORD', ''), ('exploit', 'secword', ''), ('code injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('hostname', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('untrusted sources', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper restriction', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
67,{'CWE-20'},GHSA-c9g6-9335-x697,"@@ -45,9 +45,6 @@ fake_response = (req, res) ->
             try
                 res.write(r.join('\r\n'))
             catch x
-            try
-                res.end()
-            catch x
         res.setHeader = (k, v) -> headers[k] = v","Merge pull request #266 from cakoose/backport-writeHead-fix

writeHead: Don't end() response","vuln-fix: Prevent server crash by removing nested error handling

The nested try-catch block around res.end() was removed to prevent masking errors and ensure proper error propagation during response handling. This was a security risk because silently swallowing errors could lead to inconsistent server states or denial of service. The fix simplifies error handling by removing redundant catch blocks, allowing errors to be handled appropriately upstream. 

Weakness: Improper Error Handling (CWE-391)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('#266', 'ISSUE', ''), ('fix', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('server', 'SECWORD', ''), ('removing', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('res.end', 'URL', ''), ('removed', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('security', 'SECWORD', ''), ('errors', 'FLAW', ''), ('server', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('removing', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper error handling', 'secword', ''), ('cwe-391', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
68,{'CWE-20'},GHSA-fv25-wrff-wf86,"@@ -98,6 +98,8 @@ class GetSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""handle must be scalar""));
     const string& name = handle.scalar<tstring>()();
     Tensor val;
     auto session_state = ctx->session_state();","Fix tf.raw_ops.GetSessionTensor vulnerability with invalid handle.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445218701","vuln-fix: Validate tensor handle shape to prevent malformed input

The vulnerability was caused by missing validation on the tensor handle shape, allowing non-scalar tensors to be processed unexpectedly. This posed a security risk by potentially enabling malformed or malicious inputs to disrupt session state handling or cause undefined behavior. The fix enforces a scalar shape check on the handle tensor and rejects invalid inputs with an explicit error. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.getsessiontensor', 'URL', ''), ('vulnerability', 'secword', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('security', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
69,{'CWE-20'},GHSA-x9rg-q5fx-fx66,"@@ -124,7 +124,7 @@ public UnixUser authenticate(String username, String password) throws PAMExcepti
             check(libpam.pam_authenticate(pht,0),""pam_authenticate failed"");
             check(libpam.pam_setcred(pht,0),""pam_setcred failed"");
             // several different error code seem to be used to represent authentication failures
-//            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
+            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
 
             PointerByReference r = new PointerByReference();
             check(libpam.pam_get_item(pht,PAM_USER,r),""pam_get_item failed"");","call pam_acct_mgmt to verify whether the user account is valid.

This fixes issue #18 and thus CVE-2017-12197","vuln-fix: Enforce account management check during PAM authentication

The vulnerability was the omission of the account management check in the PAM authentication flow, which allowed users with invalid or expired accounts to authenticate successfully. This posed a security risk by permitting unauthorized access to system resources without proper account validation. The fix reinstates the pam_acct_mgmt call to ensure account status is verified before granting authentication. 

Weakness: CWE-285 - Improper Authorization  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('verify', 'ACTION', ''), ('user account', 'secword', ''), ('fixes', 'ACTION', ''), ('#18', 'ISSUE', ''), ('cve-2017-12197', 'VULNID', 'CVE')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('verified', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-285', 'CWEID', ''), ('improper authorization', 'secword', ''), ('high', 'SEVERITY', '')]"
70,{'CWE-20'},GHSA-f7f6-xrwc-9c57,"@@ -588,7 +588,7 @@ THE SOFTWARE.
     <dependency>
       <groupId>commons-fileupload</groupId>
       <artifactId>commons-fileupload</artifactId>
-      <version>1.3.1-jenkins-1</version>
+      <version>1.3.1-jenkins-2</version> 
     </dependency>
 
     <!-- offline profiler API to put in the classpath if we need it -->",[SECURITY-490] Patch Commons File Upload 1.3.x.,"vuln-fix: Update commons-fileupload to patched Jenkins version

The project was using an outdated version of commons-fileupload with known vulnerabilities that could allow remote attackers to execute arbitrary code via crafted file uploads. This posed a critical security risk by enabling unauthorized system access and potential data compromise. The fix updates the dependency to a patched Jenkins-specific version that addresses these vulnerabilities and improves input handling security.

Weakness: CWE-502: Deserialization of Untrusted Data  
Severity: Critical  
CVSS: 9.8",0.11764705882352941,"[('security-490', 'SECWORD', ''), ('patch', 'ACTION', ''), ('1.3.x', 'VERSION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('update', 'ACTION', ''), ('patched', 'ACTION', ''), ('known vulnerabilities', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('patched', 'ACTION', ''), ('vulnerabilities', 'SECWORD', ''), ('improves', 'ACTION', ''), ('security', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-502', 'CWEID', ''), ('deserialization', 'SECWORD', ''), ('untrusted data', 'SECWORD', ''), ('critical', 'SEVERITY', '')]"
71,"{'CWE-284', 'CWE-20'}",GHSA-23c7-6444-399m,"@@ -216,6 +216,10 @@ def kick(bot, trigger):
             return
         nick = Identifier(text[1])
         reason = ' '.join(text[2:])
+        if ',' in str(nick):
+            return bot.reply('Unable to kick. Kicking multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kick. Use of # when kicking is not expected.')
         if nick != bot.config.core.nick and trigger.account in chanops:
             bot.write(['KICK', trigger.sender, nick, ':' + reason])
             if dodeop:
@@ -263,6 +267,10 @@ def parse_host_mask(text):
 @example('.ban nick')
 def ban(bot, trigger):
     """"""Ban a user from the channel. The bot must be a channel operator for this command to work.""""""
+    if ',' in str(nick):
+        return bot.reply('Unable to ban. Banning multiple users is not allowed.') 
+    if '#' in str(nick):
+        return bot.reply('Unable to ban. Use of # when banning is not expected.')
     makemodechange(bot, trigger, '+b', isbqmode=True)
 
 
@@ -312,6 +320,10 @@ def kickban(bot, trigger):
                 deopbot(trigger.sender, bot)
             return
         nick = Identifier(text[1])
+        if ',' in str(nick):
+            return bot.reply('Unable to kickban. Kickbanning multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kickban. Use of # when kickbanning is not expected.')
         mask = text[2] if any(s in text[2] for s in '!@*') else ''
         reasonidx = 3 if mask != '' else 2
         reason = ' '.join(text[reasonidx:])","Merge pull request from GHSA-23c7-6444-399m

* ban use of , & # when kicking

* Update __init__.py","vuln-fix: Prevent multiple user targeting in kick, ban, and kickban commands

The vulnerability allowed commands to target multiple users by including commas or unexpected '#' characters in nicknames, enabling mass actions unintentionally or maliciously. This posed a security risk by permitting abuse of moderation commands to disrupt multiple users or channels at once. The fix adds explicit checks to reject nicknames containing commas or '#' characters, preventing multiple user targeting and enforcing expected input formats.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('ghsa-23c7', 'VULNID', 'GHSA'), ('update', 'ACTION', ''), ('init__.py', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('maliciously', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
72,{'CWE-200'},GHSA-rp7r-79rm-2758,"@@ -209,7 +209,7 @@ public int getMinorVersion() {
 	}
 
 	public boolean jdbcCompliant() {
-		return false;
+		return true;
 	}
 
 	/*","DERBY-561 - Embedded driver jdbcCompliant() method should return true
Test will be checked in as part of tess for DERBY-530



git-svn-id: https://svn.apache.org/repos/asf/db/derby/code/trunk@279860 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Enable JDBC compliance to prevent security bypass

The jdbcCompliant method was incorrectly returning false, indicating non-compliance with JDBC standards in the driver implementation.
This misrepresentation could allow applications to bypass security checks relying on JDBC compliance, potentially exposing sensitive data or operations.
The fix corrects the method to return true, ensuring accurate compliance reporting and preventing security bypass through driver misbehavior.


Weakness: Improper Implementation of Security Features (CWE-710)  
Severity: Medium  
CVSS: 5.4",0.11764705882352941,"[('https://svn.apache.org/repos/asf/db/derby/code/trunk@279860', 'URL', ''), ('ffa450edef68', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('misrepresentation', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('security', 'SECWORD', ''), ('bypass', 'secword', ''), ('weakness', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cwe-710', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
73,{'CWE-200'},GHSA-wwgf-3xp7-cxj4,"new file mode 100644
@@ -0,0 +1,13 @@
+title:     Potentially sensitive data exposure
+link:      https://github.com/GeniusesOfSymfony/WebSocketBundle/security/advisories/GHSA-wwgf-3xp7-cxj4
+branches:
+    1.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['<1.10.4']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=2.0.0', '<2.6.1']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=3.0.0', '<3.3.0']
+reference: composer://gos/web-socket-bundle",Add gos/web-socket-bundle advisory,"vuln-fix: Prevent sensitive data exposure in WebSocketBundle

Sensitive information was exposed due to improper handling of data within certain versions of the WebSocketBundle, risking unauthorized access to confidential details.  
This exposure could allow attackers to retrieve sensitive data, leading to privacy violations and potential system compromise.  
The fix updates the bundle to versions that properly restrict data access and sanitize outputs, eliminating the exposure risk.  

Weakness: Sensitive Data Exposure (CWE-200)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive data exposure', 'secword', ''), ('sensitive information', 'secword', ''), ('improper handling', 'SECWORD', ''), ('confidential', 'secword', ''), ('attackers', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('privacy violations', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('sensitive data exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('high', 'SEVERITY', '')]"
74,{'CWE-200'},GHSA-m2q3-53fq-7h66,"@@ -176,6 +176,7 @@ def wiki_new
         fullname = params[:file][:filename]
         tempfile = params[:file][:tempfile]
       end
+      halt 500 unless tempfile.is_a? Tempfile
 
       # Remove page file dir prefix from upload path if necessary -- committer handles this itself
       dir      = wiki.per_page_uploads ? params[:upload_dest].match(/^(#{wiki.page_file_dir}\/+)?(.*)/)[2] : 'uploads'",Added security check.,"vuln-fix: Prevent file upload processing with invalid tempfile objects

The code did not verify that the uploaded file's tempfile was a valid Tempfile object before processing, allowing potential injection of malicious objects. This could lead to unexpected behavior or security risks if attackers supply crafted non-Tempfile objects. The fix adds a type check that halts processing with an error unless the tempfile is a valid Tempfile instance.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('added', 'ACTION', ''), ('security', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('verify', 'ACTION', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
75,"{'CWE-908', 'CWE-200'}",GHSA-3wcq-x3mq-6r9p,"@@ -78,7 +78,7 @@ name.decode.bytes = 0
 
 name.encodingLength = function (n) {
   if (n === '.') return 1
-  return Buffer.byteLength(n) + 2
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 const string = {}",do trim on encodingLength as well,"vuln-fix: Prevent buffer length miscalculation on dot-padded strings

The vulnerability involved incorrect byte length calculation for strings with leading or trailing dots, causing potential buffer overflow or memory corruption risks.
This is a security risk because attackers could exploit the miscalculation to overflow buffers, leading to arbitrary code execution or denial of service.
The fix trims leading and trailing dots before calculating byte length, ensuring accurate buffer size allocation and preventing overflow conditions.

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5",0.11764705882352941,"[('encodinglength', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('buffer overflow', 'secword', ''), ('memory corruption', 'secword', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('overflow', 'secword', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('overflow', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-119', 'CWEID', ''), ('improper restriction', 'secword', ''), ('high', 'SEVERITY', '')]"
76,{'CWE-209'},GHSA-4r65-35qq-ch8j,"@@ -38,10 +38,13 @@
 import uuid
 
 from functools import partial
+from ansible import constants as C
 from ansible.module_utils._text import to_bytes, to_text
 from ansible.module_utils.common.json import AnsibleJSONEncoder
+from ansible.module_utils.common.parameters import remove_values
 from ansible.module_utils.six import iteritems
 from ansible.module_utils.six.moves import cPickle
+from ansible.utils.helpers import deduplicate_list
 
 
 def write_to_file_descriptor(fd, obj):
@@ -163,12 +166,26 @@ def _exec_jsonrpc(self, name, *args, **kwargs):
         try:
             response = json.loads(out)
         except ValueError:
-            params = [repr(arg) for arg in args] + ['{0}={1!r}'.format(k, v) for k, v in iteritems(kwargs)]
+            sensitive_keys = list(
+                    C.MAGIC_VARIABLE_MAPPING[""password""]
+                    + C.MAGIC_VARIABLE_MAPPING[""private_key_file""]
+                    + C.MAGIC_VARIABLE_MAPPING[""become_pass""]
+            )
+            sensitive_values = [
+                v2 
+                for k, v in iteritems(kwargs) 
+                for k2, v2 in iteritems(v) 
+                if k2 in sensitive_keys
+            ]
+            params = [repr(remove_values(arg, sensitive_values)) for arg in args] + [
+                ""{0}={1!r}"".format(k, remove_values(v, sensitive_values)) 
+                for k, v in iteritems(kwargs)]
             params = ', '.join(params)
             raise ConnectionError(
                 ""Unable to decode JSON from response to {0}({1}). Received '{2}'."".format(name, params, out)
             )
 
+
         if response['id'] != reqid:
             raise ConnectionError('invalid json-rpc id received')
         if ""result_type"" in response:","Fixed exposed credentials in exception

Under certain conditions, sensitive connection parameters are shown in tracebacks when Ansible receives an unexpected response (in my case `None`) from `set_options` in ansible-connection. This patch creates a list of sensitive connection parameter names from `ansible.constants`, pulls a list of those values in the `params` that are about to be dumped to the screen and log file, and sends the `params` and list of `sensitive_values` to the `module_utils.common.parameters.remove_values` function for processing to hide them before being exposed.","vuln-fix: Mask sensitive data in JSON-RPC error logs

The code previously logged sensitive information such as passwords and private keys in JSON-RPC error messages, exposing secrets in logs. This posed a security risk by potentially leaking confidential credentials to unauthorized users or attackers with log access. The fix sanitizes error parameters by removing sensitive values before logging, preventing exposure of secrets in error outputs.

Weakness: Information Exposure (CWE-200)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fixed', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('patch', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('ansible.constants', 'URL', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('sensitive data', 'SECWORD', ''), ('error', 'FLAW', ''), ('sensitive information', 'secword', ''), ('passwords', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('confidential', 'secword', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitizes', 'SECWORD', ''), ('error', 'FLAW', ''), ('removing', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('information exposure', 'secword', ''), ('cwe-200', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,{'CWE-125'},GHSA-j47f-4232-hvv8,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/fingerprint.h""
 #include ""tensorflow/core/util/util.h""
 #include ""tensorflow/core/util/work_sharder.h""
@@ -466,16 +467,45 @@ class RaggedCrossOp : public OpKernel {
     int next_dense = 0;
     for (char c : input_order_) {
       if (c == 'R') {
+        if (next_ragged >= ragged_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor value at index "",
+              next_ragged, "" from a list of "", ragged_values_list.size(),
+              "" values."");
+        if (next_ragged >= ragged_splits_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor split at index "",
+              next_ragged, "" from a list of "", ragged_splits_list.size(),
+              "" splits."");
         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
             features));
         next_ragged++;
       } else if (c == 'S') {
+        if (next_sparse >= sparse_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor value at index "",
+              next_sparse, "" from a list of "", sparse_values_list.size(),
+              "" values."");
+        if (next_sparse >= sparse_indices_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor index at index "",
+              next_sparse, "" from a list of "", sparse_indices_list.size(),
+              "" indices."");
         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
             batch_size, features));
         next_sparse++;
       } else if (c == 'D') {
+        if (next_dense >= dense_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a dense tensor at index "", next_dense,
+              "" from a list of "", dense_list.size(), "" tensors."");
         TF_RETURN_IF_ERROR(
             BuildDenseFeatureReader(dense_list[next_dense++], features));
       } else {","Fix out of bounds read in `ragged_cross_op.cc`.

PiperOrigin-RevId: 369757702
Change-Id: Ie6e5d2c21513a8d56bf41fcf35960caf76e890f9","vuln-fix: Prevent out-of-bounds access in RaggedCrossOp input processing

The vulnerability was due to missing bounds checks when accessing ragged, sparse, and dense tensor lists, allowing out-of-bounds reads. This is a security risk because it can lead to memory corruption, crashes, or potential exploitation via crafted inputs. The fix adds explicit index bounds validation with error returns before accessing these lists to ensure safe and validated input handling.

Weakness: Improper Bounds Checking (CWE-125)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('out of bounds read', 'secword', ''), ('ragged_cross_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie6e5d2c21513a8d56bf41fcf35960caf76e890f9', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('bounds checks', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,{'CWE-125'},GHSA-h9px-9vqg-222h,"@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include ""tensorflow/core/framework/op_requires.h""
 #define EIGEN_USE_THREADS
 
 #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \
@@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, axis_ < input.dims(),
+                errors::InvalidArgument(
+                    ""Axis requested is larger than input dimensions. Axis: "",
+                    axis_, "" Input Dimensions: "", input.dims()));
     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix `tf.raw_ops.QuantizeAndDequantizeV3` array index failure.

PiperOrigin-RevId: 370577691
Change-Id: Ifeae64212f6bcd139435824fa2748d1329213c4c","vuln-fix: Validate axis parameter against input dimensions

The vulnerability is that the axis parameter was not checked against the input tensor's dimensions, allowing out-of-bounds access during computation. This is a security risk because it can lead to undefined behavior, crashes, or potential memory corruption exploitable by attackers. The fix adds a validation check that ensures the axis is within the valid range before proceeding with the operation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('ifeae64212f6bcd139435824fa2748d1329213c4c', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
2,{'CWE-125'},GHSA-374m-jm66-3vj8,"@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel {
       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {
         const int64_t batch = indices_mat(i, 0);
         const Tidx bin = values(i);
+        OP_REQUIRES(
+            ctx, batch < out.dimension(0),
+            errors::InvalidArgument(""Index out of bound. `batch` ("", batch,
+                                    "") must be less than the dimension size ("",
+                                    out.dimension(0), "").""));
+        OP_REQUIRES(
+            ctx, bin < out.dimension(1),
+            errors::InvalidArgument(""Index out ouf bound. `bin` ("", bin,
+                                    "") must be less then the dimension size ("",
+                                    out.dimension(1), "").""));
         if (bin < size) {
           if (binary_output_) {
             out(batch, bin) = T(1);","Prevent out-of-bound accesses in SparseBincount.

PiperOrigin-RevId: 399918616
Change-Id: I11d154f4444d3fde1f09c5c40628b8671791a30d","vuln-fix: Prevent out-of-bounds access in SparseBincountOp kernel

The vulnerability allowed out-of-bounds indexing on batch and bin dimensions without validation, leading to potential memory corruption or crashes. This is a security risk because attackers could exploit it to cause denial of service or arbitrary code execution. The fix adds explicit boundary checks that reject invalid indices before accessing output tensor dimensions.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out-of-bound', 'SECWORD', ''), ('change', 'ACTION', ''), ('i11d154f4444d3fde1f09c5c40628b8671791a30d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('denial of service', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,{'CWE-125'},GHSA-9697-98pf-4rw7,"@@ -86,6 +86,10 @@ class UpperBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,
@@ -127,6 +131,10 @@ class LowerBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,","Prevent CHECK-fail/heap OOB in UpperBound and LowerBound

PiperOrigin-RevId: 387738073
Change-Id: Iee74de95ddad18440d052a75a5a1cb67544f490a","vuln-fix: Enforce minimum input dimensionality in bound operations

The vulnerability allowed inputs with fewer than two dimensions to be processed, which could cause unexpected behavior or memory access errors during tensor operations. This is a security risk because it may lead to crashes or exploitable conditions in downstream code relying on valid input shapes. The fix adds explicit checks to ensure input tensors have at least two dimensions, rejecting invalid inputs early with clear error messages.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('iee74de95ddad18440d052a75a5a1cb67544f490a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('errors', 'FLAW', ''), ('security', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,"{'CWE-787', 'CWE-125'}",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Prevent out-of-bounds access in sparse-to-dense conversion

The code lacked sufficient boundary checks on array indices during sparse-to-dense format conversion, risking out-of-bounds memory access. This vulnerability could lead to memory corruption or crashes, potentially exploitable for arbitrary code execution or denial of service. The fix adds explicit bounds checks before accessing arrays and indices to ensure all accesses remain within valid ranges.

Weakness: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('boundary checks', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper restriction', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,"{'CWE-476', 'CWE-787', 'CWE-125'}",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Validate channel dimension consistency in batch norm inputs

The vulnerability was missing validation of input tensor dimensions against scale, offset, mean, and variance tensors in batch normalization operations.  
This could lead to out-of-bounds memory access or corrupted computations, potentially causing crashes or exploitable undefined behavior.  
The fix adds explicit checks ensuring these tensors have matching channel dimensions, preventing invalid inputs from proceeding.  

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,{'CWE-125'},GHSA-cgfm-62j4-v4rf,"@@ -219,7 +219,20 @@ class SparseReduceOp : public OpKernel {
     sp.Reorder<T>(reduction.reorder_dims);
     for (const auto &g : sp.group(reduction.group_by_dims)) {
       Op::template Run<T>(ctx, reduced_val, g.template values<T>());
+      OP_REQUIRES(ctx,
+                  output_strides.empty() ||
+                  (g.group().size() == output_strides.size()),
+                  errors::Internal(
+                      ""Expected group size and output_strides size to match"",
+                      "", but got "", g.group().size(), "" and "",
+                      output_strides.size()));
       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);
+      OP_REQUIRES(ctx,
+                  idx >= 0 && idx < out_flat.size(),
+                  errors::Internal(
+                      ""Obtained a write index of "", idx,
+                      "" which is outside of bounds of [0, "",
+                      out_flat.size(), "")""));
       out_flat(idx) = reduced_val();
       VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")
               << ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""","Prevent heap OOB in sparse reduction ops.

PiperOrigin-RevId: 387934524
Change-Id: I894aa30f1e454f09b471d565b4a325da49322c1a","vuln-fix: Prevent out-of-bounds writes in sparse reduction operation

The vulnerability was an unchecked index calculation that could lead to out-of-bounds memory writes during sparse tensor reduction operations. This posed a security risk by potentially corrupting memory and enabling arbitrary code execution or crashes. The fix adds explicit bounds checks and validates group size against output strides to ensure all computed indices are within valid output tensor ranges.

Weakness: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i894aa30f1e454f09b471d565b4a325da49322c1a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds writes', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper restriction', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,{'CWE-125'},GHSA-q3g3-h9r4-prrc,"@@ -265,6 +265,11 @@ class SimpleBinaryOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     const Tensor& in0 = ctx->input(0);
     const Tensor& in1 = ctx->input(1);
+    OP_REQUIRES(
+        ctx, in0.NumElements() == in1.NumElements(),
+        errors::InvalidArgument(""The two arguments to a cwise op must have ""
+                                ""same number of elements, got "",
+                                in0.NumElements(), "" and "", in1.NumElements()));
     auto in0_flat = in0.flat<Tin>();
     auto in1_flat = in1.flat<Tin>();
     const Device& eigen_device = ctx->eigen_device<Device>();","Fix nullptr deref and heap OOB access in binary cwise ops.

PiperOrigin-RevId: 387936777
Change-Id: I608b8074cec36a982cca622b7144cb2c43e6e19f","vuln-fix: Validate input tensor sizes in element-wise operations

The vulnerability allowed element-wise operations on tensors with differing sizes without validation, leading to potential out-of-bounds memory access. This posed a security risk by enabling memory corruption or crashes when processing malformed inputs. The fix enforces a size equality check and returns an error if the input tensors have mismatched element counts before proceeding. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('nullptr', 'SECWORD', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i608b8074cec36a982cca622b7144cb2c43e6e19f', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,{'CWE-125'},GHSA-5hj3-vjjf-f5m7,"@@ -380,6 +380,11 @@ Status Examples::Initialize(OpKernelContext* const context,
   const Tensor* example_labels_t;
   TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
   auto example_labels = example_labels_t->flat<float>();
+  if (example_labels.size() != num_examples) {
+    return errors::InvalidArgument(""Expected "", num_examples,
+                                   "" example labels but got "",
+                                   example_labels.size());
+  }
 
   OpInputList dense_features_inputs;
   TF_RETURN_IF_ERROR(","Add remaining validation to `sdca_internal.cc`

PiperOrigin-RevId: 387738010
Change-Id: I28eedcfd87a53aaf34deb075acea1f8c95470808","vuln-fix: Validate example labels size to prevent input mismatch

The vulnerability is a lack of validation for the size of example labels compared to the expected number of examples, allowing inconsistent input data to proceed. This mismatch can lead to undefined behavior or memory corruption, posing a security risk through potential crashes or data leaks. The fix adds a size check that returns an error if the example labels count does not match the expected number, preventing further processing of invalid inputs.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('sdca_internal.cc', 'URL', ''), ('change', 'ACTION', ''), ('i28eedcfd87a53aaf34deb075acea1f8c95470808', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('size check', 'SECWORD', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,"{'CWE-787', 'CWE-125'}",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct index usage to prevent out-of-bounds access in type specialization

The vulnerability was an incorrect loop index causing out-of-bounds access when modifying type arguments, potentially leading to memory corruption or undefined behavior.
This is a security risk because it can be exploited to cause crashes or arbitrary code execution by manipulating type argument data structures.
The fix replaces the incorrect fixed index with the loop variable to ensure proper bounds checking and safe access to type arguments during specialization.

Weakness: Improper Indexing Leading to Out-of-Bounds Access (CWE-125)
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('manipulating', 'ACTION', ''), ('fix', 'ACTION', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('bounds checking', 'SECWORD', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,{'CWE-125'},GHSA-83rh-hx5x-q9p5,"@@ -101,10 +101,14 @@ bool HdrDecoder::readData(Mat& _img)
 
 bool HdrDecoder::checkSignature( const String& signature ) const
 {
-    if(signature.size() >= m_signature.size() &&
-       (!memcmp(signature.c_str(), m_signature.c_str(), m_signature.size()) ||
-       !memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())))
-       return true;
+    if (signature.size() >= m_signature.size() &&
+        0 == memcmp(signature.c_str(), m_signature.c_str(), m_signature.size())
+    )
+        return true;
+    if (signature.size() >= m_signature_alt.size() &&
+        0 == memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())
+    )
+        return true;
     return false;
 }",imgproc(hdr): fix bounds check in HdrDecoder::checkSignature(),"vuln-fix: Correct signature check to prevent partial match bypass

The vulnerability was caused by combining two memcmp calls with a logical OR in a single condition, which could lead to incorrect evaluation and partial signature matches.
This flaw allowed attackers to bypass signature verification by exploiting short-circuit evaluation, potentially leading to processing of malicious or malformed data.
The fix separates the two memcmp checks into distinct if statements, ensuring each signature is fully and independently verified before acceptance.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('hdrdecoder::checksignature', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('signature', 'secword', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('signature', 'secword', ''), ('exploiting', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('signature', 'secword', ''), ('verified', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,{'CWE-125'},GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stat_dim bounds in feature split calculation

The vulnerability was an unchecked stat_dim value that could exceed the allocated stats_dims array bounds during feature split computation. This posed a risk of out-of-bounds memory access, potentially leading to crashes or arbitrary code execution. The fix adds explicit validation to ensure stat_dim is less than stats_dims, preventing invalid memory access and improving robustness.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('tf.raw_ops.boostedtreessparsecalculatebestfeaturesplit', 'URL', ''), ('change', 'ACTION', ''), ('i83ca8a75b22aa78c037e8b98779da6cced16bfaa', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('improving', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,{'CWE-125'},GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter to prevent out-of-bounds access

The vulnerability occurs due to missing validation of the axis parameter, which can lead to out-of-bounds tensor dimension access during dequantization operations. This poses a security risk by potentially causing memory corruption or crashes that attackers could exploit for denial of service or arbitrary code execution. The fix adds a check to ensure the axis is less than the input tensor’s dimension count, rejecting invalid arguments early in the execution flow.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound access', 'secword', ''), ('adding', 'ACTION', ''), ('change', 'ACTION', ''), ('i3249d2a69ddc82f182c589a3a5bbfb71543f4b29', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('missing validation', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
13,{'CWE-125'},GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate tensor element counts in dequantization axis

The vulnerability is that input_min_tensor and input_max_tensor element counts were not verified against the dequantization axis size, allowing mismatched tensor inputs. This can lead to out-of-bounds memory access or corrupted computations, posing risks of crashes or data leakage. The fix adds explicit checks to ensure these tensors have element counts matching the input dimension along the specified axis, preventing invalid inputs from proceeding.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.23529411764705882,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('change', 'ACTION', ''), ('i135e94d360c2a1ce374c10f7e0fed1af603dbc02', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('verified', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Enforce safe tensor access to prevent null pointer dereference

The vulnerability was due to unchecked tensor retrieval calls that could return null pointers, leading to potential crashes or undefined behavior during tensor operations.
This is a security risk because it can cause denial of service or memory corruption if invalid tensor pointers are dereferenced.
The fix replaces direct tensor access with safe accessor functions that validate and ensure successful retrieval before use, preventing null pointer dereferences.

Weakness: CWE-476: NULL Pointer Dereference  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('null pointer dereference', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('null pointer dereferences', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-476', 'CWEID', ''), ('null pointer dereference', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
15,{'CWE-125'},GHSA-545v-42p7-98fq,"@@ -1014,6 +1014,9 @@ struct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {
         const int input_start = start * input_size_per_batch;
         const int input_end = limit * input_size_per_batch;
         for (int64 index = input_start; index < input_end; index++) {
+          if (index >= argmax.NumElements()) {
+            break;
+          }
           int64 grad_out_index = argmax_flat(index);
           if (!include_batch_in_index) {
             const int64 cur_batch = index / input_size_per_batch;","Fix heap buffer overflow

PiperOrigin-RevId: 372132844
Change-Id: Idef9895efaf145f2b1c23d31983601ec980cd5e4","vuln-fix: Prevent out-of-bounds access in max pooling gradient kernel

The vulnerability was an out-of-bounds read from the argmax tensor when index exceeded its element count during gradient computation. This could lead to undefined behavior or memory corruption, posing a security risk in processing untrusted inputs. The fix adds a boundary check to break the loop if the index surpasses the number of elements in argmax, preventing invalid memory access.

Weakness: Out-of-bounds Read (CWE-125)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('idef9895efaf145f2b1c23d31983601ec980cd5e4', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'secword', ''), ('out-of-bounds read', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('untrusted inputs', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds read', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,{'CWE-125'},GHSA-4fg4-p75j-w5xj,"@@ -173,20 +173,50 @@ class QuantizedBatchNormOp : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
-    const float input_min = context->input(1).flat<float>()(0);
-    const float input_max = context->input(2).flat<float>()(0);
+    const auto& input_min_tensor = context->input(1);
+    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_min must have 1 element""));
+    const float input_min = input_min_tensor.flat<float>()(0);
+    const auto& input_max_tensor = context->input(2);
+    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_max must have 1 element""));
+    const float input_max = input_max_tensor.flat<float>()(0);
     const Tensor& mean = context->input(3);
-    const float mean_min = context->input(4).flat<float>()(0);
-    const float mean_max = context->input(5).flat<float>()(0);
+    const auto& mean_min_tensor = context->input(4);
+    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_min must have 1 element""));
+    const float mean_min = mean_min_tensor.flat<float>()(0);
+    const auto& mean_max_tensor = context->input(5);
+    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_max must have 1 element""));
+    const float mean_max = mean_max_tensor.flat<float>()(0);
     const Tensor& var = context->input(6);
-    const float var_min = context->input(7).flat<float>()(0);
-    const float var_max = context->input(8).flat<float>()(0);
+    const auto& var_min_tensor = context->input(7);
+    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_min must have 1 element""));
+    const float var_min = var_min_tensor.flat<float>()(0);
+    const auto& var_max_tensor = context->input(8);
+    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_max must have 1 element""));
+    const float var_max = var_max_tensor.flat<float>()(0);
     const Tensor& beta = context->input(9);
-    const float beta_min = context->input(10).flat<float>()(0);
-    const float beta_max = context->input(11).flat<float>()(0);
+    const auto& beta_min_tensor = context->input(10);
+    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_min must have 1 element""));
+    const float beta_min = beta_min_tensor.flat<float>()(0);
+    const auto& beta_max_tensor = context->input(11);
+    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_max must have 1 element""));
+    const float beta_max = beta_max_tensor.flat<float>()(0);
     const Tensor& gamma = context->input(12);
-    const float gamma_min = context->input(13).flat<float>()(0);
-    const float gamma_max = context->input(14).flat<float>()(0);
+    const auto& gamma_min_tensor = context->input(13);
+    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_min must have 1 element""));
+    const float gamma_min = gamma_min_tensor.flat<float>()(0);
+    const auto& gamma_max_tensor = context->input(14);
+    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_max must have 1 element""));
+    const float gamma_max = gamma_max_tensor.flat<float>()(0);
 
     OP_REQUIRES(context, input.dims() == 4,
                 errors::InvalidArgument(""input must be 4-dimensional"",
@@ -203,6 +233,33 @@ class QuantizedBatchNormOp : public OpKernel {
     OP_REQUIRES(context, gamma.dims() == 1,
                 errors::InvalidArgument(""gamma must be 1-dimensional"",
                                         gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value"",
+                                        gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value""));
+    const auto last_dim = input.shape().dims() - 1;
+    OP_REQUIRES(context,
+                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),
+                errors::InvalidArgument(""Must provide as many means as the ""
+                                        ""last dimension of the input tensor: "",
+                                        mean.shape().DebugString(), "" vs. "",
+                                        input.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == var.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and variance tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", var.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and beta tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", beta.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and gamma tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", gamma.shape().DebugString()));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Add missing validation in `QuantizedBatchNormWithGlobalNormalization`

PiperOrigin-RevId: 370123451
Change-Id: Id234d6dab1ec21230bb8e503dba30f899af87f33","vuln-fix: Validate tensor element counts and shapes in QuantizedBatchNormOp

The vulnerability was due to missing validation of tensor element counts and shape consistency for input parameters, allowing malformed tensors to be processed unsafely. This posed a security risk by enabling potential out-of-bounds memory access or logic errors during computation, which could be exploited for denial of service or data corruption. The fix adds explicit checks ensuring each tensor has exactly one element where expected and enforces shape consistency across related tensors before proceeding.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('change', 'ACTION', ''), ('id234d6dab1ec21230bb8e503dba30f899af87f33', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'secword', ''), ('missing validation', 'SECWORD', ''), ('unsafely', 'SECWORD', ''), ('security', 'secword', ''), ('out-of-bounds', 'secword', ''), ('logic errors', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
17,"{'CWE-908', 'CWE-125'}",GHSA-q263-fvxm-m5mw,"@@ -44,6 +44,7 @@ limitations under the License.
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
 #include ""tensorflow/core/lib/strings/scanner.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/logging.h""
 #include ""tensorflow/core/platform/macros.h""
 #include ""tensorflow/core/public/version.h""
@@ -1425,6 +1426,17 @@ void GraphConstructor::Undo() {
 
 Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,
                                   int input_index) {
+  if (output_index >= src->num_outputs()) {
+    return errors::InvalidArgument(
+        ""Output "", output_index, "" of node "", src->name(),
+        "" does not exist. Node only has "", src->num_outputs(), "" outputs."");
+  }
+  if (input_index >= dst->num_inputs()) {
+    return errors::InvalidArgument(
+        ""Input "", input_index, "" of node "", dst->name(),
+        "" does not exist. Node only has "", dst->num_inputs(), "" inputs."");
+  }
+
   DataType src_out = src->output_type(output_index);
   DataType dst_in = dst->input_type(input_index);
   if (!TypesCompatible(dst_in, src_out)) {","Prevent unitialized memory access in `GraphConstructor::MakeEdge`

The `MakeEdge` implementation assumes that there exists an output at `output_index` of `src` node and an input at `input_index` of `dst` node. However, if this is not the case this results in accessing data out of bounds. Because we are accessing an array that is a private member of a class and only in read only mode, this usually results only in unitialized memory access. However, it is reasonable to think that malicious users could manipulate these indexes to actually read data outside the class, thus resulting in information leakage and further exploits.

PiperOrigin-RevId: 346343288
Change-Id: I2127da27c2023d27f26efd39afa6c853385cab6f","vuln-fix: Validate node edge indices to prevent out-of-bounds access

The vulnerability was missing validation for output and input indices when creating edges between nodes, allowing invalid indices to be used. This posed a security risk by potentially causing out-of-bounds memory access or undefined behavior in graph construction. The fix adds explicit checks that return errors if the specified output or input index exceeds the node’s available outputs or inputs.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out of bounds', 'SECWORD', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('information leakage', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('change', 'ACTION', ''), ('i2127da27c2023d27f26efd39afa6c853385cab6f', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('security', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,{'CWE-125'},GHSA-9c8h-vvrj-w2p8,"@@ -58,15 +58,21 @@ class RaggedGatherOpBase : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     // Get the input Tensors.
+
     OpInputList params_nested_splits_in;
     OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",
                                                 &params_nested_splits_in));
+    OP_REQUIRES(
+        context, params_nested_splits_in.size() > 0,
+        errors::InvalidArgument(""params_nested_splits must be non empty""));
+
     const Tensor& params_dense_values_in =
         context->input(params_nested_splits_in.size());
     const Tensor& indices_in =
         context->input(params_nested_splits_in.size() + 1);
 
-    DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, params_nested_splits_in[0].dims() > 0,
+                errors::InvalidArgument(""Split tensors must not be scalars""));
     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;
     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));","Fix heap OOB in `tf.raw_ops.RaggedGather`

PiperOrigin-RevId: 388355464
Change-Id: If14d96231d1cd7aad7c4d1c22c1bab1576b75717","vuln-fix: Validate input tensor list and dimensions in RaggedGatherOpBase

The vulnerability was missing validation for empty input tensor lists and scalar split tensors, which could cause undefined behavior or crashes during tensor operations. This is a security risk because it may lead to denial of service or memory corruption when processing malformed inputs. The fix adds explicit checks to ensure the input tensor list is non-empty and that split tensors have valid dimensions before proceeding.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('tf.raw_ops.raggedgather', 'URL', ''), ('change', 'ACTION', ''), ('if14d96231d1cd7aad7c4d1c22c1bab1576b75717', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('security', 'SECWORD', ''), ('denial of service', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
19,{'CWE-125'},GHSA-c545-c4f9-rf6v,"@@ -37,6 +37,7 @@ TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,
     axis = input_dims.size + 1 + axis;
   }
   TF_LITE_ENSURE(context, axis <= input_dims.size);
+  TF_LITE_ENSURE(context, axis >= 0);
 
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);
   for (int i = 0; i < output_dims->size; ++i) {","Prevent an OOB read in `expand_dims.cc`

The for loop that follows this check assumes that `axis` is between `0` and `input_dims.size`. If user supplied `axis` is negative, the if code before this check is supposed to bring it back to positive (similar to how in Python one can do `l[-3]` to mean `l[-3 + len(l)]`).

PiperOrigin-RevId: 387200206
Change-Id: I162f4feba12d547c3a4340833ae682016a2ebfab","vuln-fix: Prevent negative axis index in tensor dimension expansion

The vulnerability allowed negative axis values to bypass validation, potentially causing out-of-bounds memory access during tensor dimension expansion. This poses a security risk by enabling memory corruption or crashes that attackers could exploit for denial of service or code execution. The fix adds a lower bound check ensuring the axis index is non-negative before proceeding with dimension expansion.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('expand_dims.cc', 'URL', ''), ('input_dims.size', 'URL', ''), ('change', 'ACTION', ''), ('i162f4feba12d547c3a4340833ae682016a2ebfab', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bound check', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,{'CWE-125'},GHSA-3h8m-483j-7xxm,"@@ -46,6 +46,10 @@ class RequantizationRangeOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,
+                errors::InvalidArgument(""Input min must not be empty.""));
+    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,
+                errors::InvalidArgument(""Input max must not be empty.""));
     const float input_min_float = ctx->input(1).flat<float>()(0);
     const float input_max_float = ctx->input(2).flat<float>()(0);
     Tensor* output_min = nullptr;","Fix out of bound read in requantization_range_op.cc

PiperOrigin-RevId: 372129031
Change-Id: Ie684ab98a3840c5186ead3eafffc0e0ed0e8030d","vuln-fix: Validate non-empty inputs for min and max tensors

The vulnerability is that the code did not verify whether the input min and max tensors were empty before accessing their elements. This is a security risk because accessing empty tensors can lead to undefined behavior or crashes, potentially exploitable for denial of service. The fix adds explicit checks to ensure these tensors contain elements before use, preventing invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound read', 'secword', ''), ('requantization_range_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie684ab98a3840c5186ead3eafffc0e0ed0e8030d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('verify', 'ACTION', ''), ('security', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
21,{'CWE-125'},GHSA-cvgx-3v3q-m36c,"@@ -2559,6 +2559,9 @@ Status QuantizeV2Shape(InferenceContext* c) {
   if (!s.ok() && s.code() != error::NOT_FOUND) {
     return s;
   }
+  if (axis < -1) {
+    return errors::InvalidArgument(""axis should be at least -1, got "", axis);
+  }
   const int minmax_rank = (axis == -1) ? 0 : 1;
   TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
   ShapeHandle minmax;","Prevent OOB access in QuantizeV2 shape inference

PiperOrigin-RevId: 400309614
Change-Id: I31412c71b05b4f21b677f7fa715a61499cbee39d","vuln-fix: Validate axis parameter to prevent invalid negative values

The vulnerability allowed axis values less than -1, which could cause unexpected behavior or crashes during shape inference in tensor operations. This is a security risk because it may lead to denial of service or memory corruption when processing malformed inputs. The fix adds a validation check that returns an error if the axis parameter is less than -1, preventing invalid values from propagating.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i31412c71b05b4f21b677f7fa715a61499cbee39d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,{'CWE-125'},GHSA-7fvx-3jfc-2cpc,"@@ -955,11 +955,12 @@ class ResourceScatterUpdateOp : public OpKernel {
                         params->dim_size(0), "")""));
       } else {
         int64_t num_updates = updates.NumElements();
-        OP_REQUIRES(c, num_updates % N == 0,
-                    errors::InvalidArgument(
-                        ""shape of indices ("", indices.shape().DebugString(),
-                        "") is not compatible with the shape of updates ("",
-                        updates.shape().DebugString(), "")""));
+        OP_REQUIRES(
+            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),
+            errors::InvalidArgument(
+                ""The shape of indices ("", indices.shape().DebugString(),
+                "") must be a prefix of the shape of updates ("",
+                updates.shape().DebugString(), "")""));
         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});
 
         functor::ScatterFunctor<Device, T, Index, op> functor;","Fix heap OOB due to dimension mismatch in `ResourceScatterUpdate`

PiperOrigin-RevId: 388292801
Change-Id: Id9bd7244d98d41b1517d4771850b32782c0cc949","vuln-fix: Validate updates shape prefix to prevent out-of-bounds access

The vulnerability was caused by insufficient validation of the updates tensor shape against indices, allowing incompatible shapes to pass unchecked. This posed a security risk by enabling potential out-of-bounds memory access or data corruption during scatter update operations. The fix enforces that the updates shape must start with the indices shape, ensuring shape compatibility and preventing invalid memory operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('id9bd7244d98d41b1517d4771850b32782c0cc949', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('updates', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('updates', 'ACTION', ''), ('security', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('update', 'ACTION', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,{'CWE-125'},GHSA-59q2-x2qc-4c97,"@@ -533,6 +533,17 @@ class UnicodeEncodeOp : public OpKernel {
     const Tensor& input_splits = context->input(1);
     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();
 
+    // Operation will treat first argument in input_splits as if it were zero
+    // regardless of its actual value since splits should begin with zero and
+    // end with the length of the input values vector.
+    OP_REQUIRES(
+        context, input_splits_flat(0) == 0,
+        errors::InvalidArgument(""First value in input_splits must be zero.""));
+    OP_REQUIRES(context,
+                input_splits_flat(input_splits_flat.size() - 1) ==
+                    input_tensor_flat.size(),
+                errors::InvalidArgument(""Last value in input_splits must be ""
+                                        ""equal to length of input_tensor.""));
     // Since we limit to a 2-D input (flat_values of rank 1 and a single splits
     // tensor), our output dimension will be 1 with it's size equal to the
     // number of splits (outer dimension or ragged tensor).
@@ -548,6 +559,14 @@ class UnicodeEncodeOp : public OpKernel {
     for (int i = 1; i < input_splits_flat.size(); ++i) {
       icu::UnicodeString unicode_string;
       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);
+      OP_REQUIRES(
+          context, input_splits_flat(i - 1) <= input_splits_flat(i),
+          errors::InvalidArgument(
+              ""Values in input_splits must be equal or in ascending order.""));
+      OP_REQUIRES(
+          context, input_splits_flat(i) <= input_tensor_flat.size(),
+          errors::InvalidArgument(""Values in input_splits must be less than or ""
+                                  ""equal to input_tensor length.""));
       for (; idx < input_splits_flat(i); ++idx) {
         int32 code_point = input_tensor_flat(idx);
         // Check for invalid code point","Fix heap buffer overflow in tf.raw_ops.UnicodeEncode.

PiperOrigin-RevId: 371717714
Change-Id: If33443b28f158e58078f1268f6b92f2728d219e0","vuln-fix: Validate input_splits boundaries and ordering in UnicodeEncodeOp

The vulnerability is improper validation of input_splits array boundaries and ordering, which could lead to out-of-bounds memory access or corrupted data processing. This poses a security risk by enabling potential memory corruption or denial of service through crafted inputs. The fix enforces that input_splits start at zero, end at the input length, and are non-decreasing and within valid range, preventing invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('tf.raw_ops.unicodeencode', 'URL', ''), ('change', 'ACTION', ''), ('if33443b28f158e58078f1268f6b92f2728d219e0', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('unicodeencodeop', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('improper validation', 'secword', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,{'CWE-125'},GHSA-jwf9-w5xm-f437,"@@ -123,6 +123,17 @@ TfLiteStatus GatherNdString(const TfLiteTensor* params,
 template <typename IndicesT>
 TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,
                           const TfLiteTensor* indices, TfLiteTensor* output) {
+  bool indices_has_only_positive_elements = true;
+  const auto* indices_values = GetTensorData<IndicesT>(indices);
+  const size_t num_indices = indices->bytes / sizeof(IndicesT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indices_values[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   switch (params->type) {
     case kTfLiteFloat32:
       return GatherNd<float, IndicesT>(params, indices, output);","Prevent heap OOB read in TFLite's `gather_nd.cc`.

Passing negative indices is illegal but there was a missing check so that resulted in OOB accesses.

PiperOrigin-RevId: 387208551
Change-Id: I6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd","vuln-fix: Prevent negative indices in GatherNd tensor operation

The vulnerability allowed negative index values in tensor gathering operations, which could lead to out-of-bounds memory access or undefined behavior during execution. This poses a security risk by potentially enabling memory corruption or data leakage through invalid indexing. The fix adds a validation step that ensures all indices are non-negative before proceeding with the gather operation, aborting if any negative index is detected.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('gather_nd.cc', 'URL', ''), ('missing check', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Prevent use of optional tensor without validation

The function returned optional tensors without verifying their presence, allowing potential use of uninitialized or invalid memory references. This could lead to undefined behavior or memory corruption, posing a security risk in model execution. The fix enforces proper input retrieval by always calling GetInput, ensuring consistent validation and preventing access to optional tensors that may not exist.

Weakness: Use of Uninitialized Memory (CWE-457)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('uninitialized', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('uninitialized memory', 'SECWORD', ''), ('cwe-457', 'CWEID', ''), ('high', 'SEVERITY', '')]"
26,"{'CWE-787', 'CWE-125'}",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Prevent out-of-bounds access in row partition handling

The code lacked a boundary check for row partition size exceeding output size, risking out-of-bounds memory access during tensor processing. This could lead to memory corruption or crashes, potentially exploitable for denial of service or arbitrary code execution. The fix adds a validation step that returns an error if the row partition size is greater than the output size, preventing invalid memory access.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('boundary check', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
27,{'CWE-125'},GHSA-2r8p-fg3c-wcj4,"@@ -660,6 +660,11 @@ class ResourceGatherOp : public OpKernel {
     OP_REQUIRES(
         c, TensorShapeUtils::IsVectorOrHigher(params.shape()),
         errors::InvalidArgument(""params must be at least 1 dimensional""));
+    OP_REQUIRES(
+        c, params.shape().dims() >= batch_dims_,
+        errors::InvalidArgument(""params must have at least "", batch_dims_,
+                                "" (batch_dims) dimensions but it has shape "",
+                                params.shape().DebugString()));
 
     // Check that we have enough index space
     const int64_t N = indices.NumElements();","Prevent heap oob access in `resource_variable_ops.cc`

PiperOrigin-RevId: 387936433
Change-Id: I9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6","vuln-fix: Enforce minimum batch_dims dimension in params tensor

The vulnerability allowed params tensors with fewer dimensions than batch_dims, potentially causing out-of-bounds memory access or logic errors during tensor operations. This is a security risk because it can lead to crashes or data corruption exploitable by crafted inputs. The fix adds a validation check ensuring params has at least batch_dims dimensions, rejecting invalid inputs early to prevent unsafe operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('resource_variable_ops.cc', 'URL', ''), ('change', 'ACTION', ''), ('i9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('security', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,{'CWE-125'},GHSA-h4pc-gx2w-f2xv,"@@ -96,6 +96,8 @@ TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
     }
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
   const int input_size = SizeOfDimension(input, axis_value);
 
   if (minus_one_index != -1) {","Prevent array OOB read/write

PiperOrigin-RevId: 371026165
Change-Id: I26ac6372c87246e03c7eb8c94e84c84d86054b36","vuln-fix: Validate axis parameter bounds in tensor resizing

The vulnerability is that the axis parameter was not validated to be within valid dimension bounds, allowing out-of-range access during tensor resizing operations. This poses a security risk by enabling potential memory corruption or crashes due to invalid tensor dimension indexing. The fix adds explicit checks to ensure the axis value is non-negative and less than the number of input dimensions before proceeding.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i26ac6372c87246e03c7eb8c94e84c84d86054b36', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-range', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,{'CWE-125'},GHSA-vqw6-72r7-fgw7,"@@ -162,6 +162,9 @@ class BaseMatrixTriangularSolveOp : public OpKernel {
     const Tensor& in1 = ctx->input(1);
 
     ValidateInputTensors(ctx, in0, in1);
+    if (!ctx->status().ok()) {
+      return;
+    }
 
     MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());
     OP_REQUIRES(
@@ -230,13 +233,22 @@ class MatrixTriangularSolveOp
  private:
   void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,
                             const Tensor& in1) override {
+    const auto in0_num_dims = in0.dims();
     OP_REQUIRES(
-        ctx, in0.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0.dims()));
+        ctx, in0_num_dims >= 2,
+        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0_num_dims));
 
+    const auto in1_num_dims = in1.dims();
     OP_REQUIRES(
-        ctx, in1.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in1.dims()));
+        ctx, in1_num_dims >= 2,
+        errors::InvalidArgument(""In[1] ndims must be >= 2: "", in1_num_dims));
+
+    const auto in0_last_dim = in0.dim_size(in0_num_dims - 1);
+    const auto in0_prev_dim = in0.dim_size(in0_num_dims - 2);
+    OP_REQUIRES(ctx, in0_last_dim == in0_prev_dim,
+                errors::InvalidArgument(
+                    ""In[0] matrices in the last dimensions must be square ("",
+                    in0_last_dim, "" =/= "", in0_prev_dim, "")""));
   }
 };","Validate (and ensure validation sticks) inputs for `MatrixTriangularSolve`.

PiperOrigin-RevId: 370282444
Change-Id: Iaed61a0b0727cc42c830658b72eb69f785f48dc5","vuln-fix: Prevent invalid tensor shapes in triangular solve op

The vulnerability allowed processing of input tensors with invalid dimensions or non-square matrices, leading to potential undefined behavior or crashes. This is a security risk because malformed inputs could cause denial of service or memory corruption in downstream operations. The fix adds strict validation of input tensor dimensions and shape, and aborts processing early if validation fails.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('iaed61a0b0727cc42c830658b72eb69f785f48dc5', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,"{'CWE-400', 'CWE-125'}",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent security risks

Using the deprecated Buffer constructor can lead to security vulnerabilities due to uninitialized memory exposure or unexpected behavior in encoding operations.
This poses a risk of leaking sensitive data or enabling injection attacks when handling proxy authentication headers.
The fix replaces the deprecated Buffer constructor with the safer Buffer.from method to ensure proper and secure buffer creation.

Weakness: CWE-676: Use of Potentially Dangerous Function
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('security', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('uninitialized memory', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('authentication', 'secword', ''), ('fix', 'ACTION', ''), ('safer buffer.from', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('cwe-676', 'CWEID', ''), ('dangerous function', 'secword', ''), ('medium', 'SEVERITY', '')]"
31,"{'CWE-787', 'CWE-125'}",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate tensor input dimensions to prevent zero-size inputs

The vulnerability allowed zero-sized tensor dimensions to be processed, which could lead to undefined behavior or crashes during computation. This is a security risk because it may cause denial of service or memory corruption when invalid tensor shapes are used. The fix adds explicit checks to ensure all tensor dimensions are non-zero before proceeding with further operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,{'CWE-125'},GHSA-qpw2-xchm-655q,"@@ -28,7 +28,7 @@ StringStream.prototype.write = function(data) {
     return false
   }
   if (this.fromEncoding) {
-    if (Buffer.isBuffer(data)) data = data.toString()
+    if (Buffer.isBuffer(data) || typeof data === 'number') data = data.toString()
     data = new Buffer(data, this.fromEncoding)
   }
   var string = this.decoder.write(data)","Merge pull request #9 from mhart/fix-buffer-constructor-vuln

Ensure data is not a number in Buffer constructor","vuln-fix: Prevent improper number handling in StringStream write method

The write method did not properly handle numeric inputs, converting them unsafely to strings without validation. This could lead to unexpected behavior or memory corruption when processing numeric data as buffers. The fix adds a type check for numbers and converts them safely to strings before further processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('#9', 'ISSUE', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafely', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,{'CWE-125'},GHSA-6gmv-pjp9-p8w8,"@@ -1653,11 +1653,21 @@ REGISTER_OP(""ReverseSequence"")
         return errors::InvalidArgument(
             ""batch_dim must be < input rank: "", batch_dim, "" vs. "", input_rank);
       }
+
       if (seq_dim >= input_rank) {
         return errors::InvalidArgument(
             ""seq_dim must be < input rank: "", seq_dim, "" vs. "", input_rank);
       }
 
+      // To prevent out of bound access when calling c->Dim(input, batch_dim),
+      // batch_dim range [-1 * input rank, input rank) is allowed. However,
+      // the op implementation has a stricter bound for batch_dim requiring >= 0
+      // value. Thus, perform strict check here.
+      if (batch_dim < 0) {
+        return errors::InvalidArgument(""batch_dim must be >=0, got "",
+                                       batch_dim);
+      }
+
       DimensionHandle batch_dim_dim = c->Dim(input, batch_dim);
       TF_RETURN_IF_ERROR(
           c->Merge(batch_dim_dim, c->Dim(seq_lens_shape, 0), &batch_dim_dim));","Fix out of bound error in ReverseSequence Op shape function

PiperOrigin-RevId: 411896080
Change-Id: I7e59a38e2f960886edf2b6c54ed5a84e86a9b193","vuln-fix: Enforce non-negative batch_dim in ReverseSequence op

The vulnerability allowed negative batch_dim values, which could cause out-of-bounds memory access during dimension handling in the ReverseSequence operation. This is a security risk because it may lead to memory corruption or crashes exploitable by attackers to execute arbitrary code. The fix adds a strict check to reject negative batch_dim values, ensuring safe and valid input dimensions before proceeding.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('i7e59a38e2f960886edf2b6c54ed5a84e86a9b193', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
