id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message,original_message_score,original_message_entities,generated_secom_message_score,generated_secom_message_entities
0,{'CWE-125'},GHSA-j47f-4232-hvv8,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/fingerprint.h""
 #include ""tensorflow/core/util/util.h""
 #include ""tensorflow/core/util/work_sharder.h""
@@ -466,16 +467,45 @@ class RaggedCrossOp : public OpKernel {
     int next_dense = 0;
     for (char c : input_order_) {
       if (c == 'R') {
+        if (next_ragged >= ragged_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor value at index "",
+              next_ragged, "" from a list of "", ragged_values_list.size(),
+              "" values."");
+        if (next_ragged >= ragged_splits_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor split at index "",
+              next_ragged, "" from a list of "", ragged_splits_list.size(),
+              "" splits."");
         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
             features));
         next_ragged++;
       } else if (c == 'S') {
+        if (next_sparse >= sparse_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor value at index "",
+              next_sparse, "" from a list of "", sparse_values_list.size(),
+              "" values."");
+        if (next_sparse >= sparse_indices_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor index at index "",
+              next_sparse, "" from a list of "", sparse_indices_list.size(),
+              "" indices."");
         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
             batch_size, features));
         next_sparse++;
       } else if (c == 'D') {
+        if (next_dense >= dense_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a dense tensor at index "", next_dense,
+              "" from a list of "", dense_list.size(), "" tensors."");
         TF_RETURN_IF_ERROR(
             BuildDenseFeatureReader(dense_list[next_dense++], features));
       } else {","Fix out of bounds read in `ragged_cross_op.cc`.

PiperOrigin-RevId: 369757702
Change-Id: Ie6e5d2c21513a8d56bf41fcf35960caf76e890f9","vuln-fix: Prevent out-of-bounds access in RaggedCrossOp input processing

The vulnerability was due to missing bounds checks when accessing ragged, sparse, and dense tensor lists based on input_order indices. This could lead to out-of-bounds memory access, causing crashes or potential data corruption exploitable by attackers. The fix adds explicit index validation with error returns before accessing these lists, ensuring safe and validated input handling.

Weakness: Improper Bounds Checking (CWE-125)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('out of bounds read', 'secword', ''), ('ragged_cross_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie6e5d2c21513a8d56bf41fcf35960caf76e890f9', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('bounds checks', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,{'CWE-125'},GHSA-h9px-9vqg-222h,"@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include ""tensorflow/core/framework/op_requires.h""
 #define EIGEN_USE_THREADS
 
 #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \
@@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, axis_ < input.dims(),
+                errors::InvalidArgument(
+                    ""Axis requested is larger than input dimensions. Axis: "",
+                    axis_, "" Input Dimensions: "", input.dims()));
     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix `tf.raw_ops.QuantizeAndDequantizeV3` array index failure.

PiperOrigin-RevId: 370577691
Change-Id: Ifeae64212f6bcd139435824fa2748d1329213c4c","vuln-fix: Validate axis parameter against input dimensions in quantization op

The vulnerability is an unchecked axis parameter that could exceed input tensor dimensions, leading to out-of-bounds memory access during computation. This is a security risk because it can cause crashes or undefined behavior exploitable by crafted inputs to disrupt service or execute arbitrary code. The fix adds explicit validation to ensure the axis is within valid bounds before proceeding with tensor operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('ifeae64212f6bcd139435824fa2748d1329213c4c', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,{'CWE-125'},GHSA-374m-jm66-3vj8,"@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel {
       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {
         const int64_t batch = indices_mat(i, 0);
         const Tidx bin = values(i);
+        OP_REQUIRES(
+            ctx, batch < out.dimension(0),
+            errors::InvalidArgument(""Index out of bound. `batch` ("", batch,
+                                    "") must be less than the dimension size ("",
+                                    out.dimension(0), "").""));
+        OP_REQUIRES(
+            ctx, bin < out.dimension(1),
+            errors::InvalidArgument(""Index out ouf bound. `bin` ("", bin,
+                                    "") must be less then the dimension size ("",
+                                    out.dimension(1), "").""));
         if (bin < size) {
           if (binary_output_) {
             out(batch, bin) = T(1);","Prevent out-of-bound accesses in SparseBincount.

PiperOrigin-RevId: 399918616
Change-Id: I11d154f4444d3fde1f09c5c40628b8671791a30d","vuln-fix: Prevent out-of-bounds access in SparseBincountOp kernel

The vulnerability allowed out-of-bounds indices for batch and bin dimensions, potentially causing memory corruption or crashes during sparse bincount operations. This is a security risk because it can lead to undefined behavior, data leakage, or denial of service by triggering invalid memory accesses. The fix adds explicit bounds checks on batch and bin indices, rejecting invalid inputs with clear error messages to prevent unsafe memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out-of-bound', 'SECWORD', ''), ('change', 'ACTION', ''), ('i11d154f4444d3fde1f09c5c40628b8671791a30d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('invalid memory accesses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,{'CWE-125'},GHSA-9697-98pf-4rw7,"@@ -86,6 +86,10 @@ class UpperBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,
@@ -127,6 +131,10 @@ class LowerBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,","Prevent CHECK-fail/heap OOB in UpperBound and LowerBound

PiperOrigin-RevId: 387738073
Change-Id: Iee74de95ddad18440d052a75a5a1cb67544f490a","vuln-fix: Enforce minimum input dimensionality in bound operations

The vulnerability was missing validation for input tensor dimensionality, allowing inputs with fewer than two dimensions to be processed. This could lead to unexpected behavior or crashes, potentially causing denial of service or data corruption. The fix adds explicit checks requiring input tensors to have at least two dimensions, rejecting invalid inputs early with clear error messages.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('iee74de95ddad18440d052a75a5a1cb67544f490a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,"{'CWE-787', 'CWE-125'}",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Prevent out-of-bounds access in sparse-to-dense conversion

The code lacked sufficient boundary checks on vector indices, causing potential out-of-bounds memory access during sparse-to-dense format conversion operations. This vulnerability could lead to memory corruption, crashes, or exploitable conditions allowing attackers to manipulate program behavior. The fix adds explicit bounds checks before accessing vectors to ensure all indices are within valid ranges, preventing invalid memory reads or writes.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.5294117647058824,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('boundary checks', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', ''), ('weakness', 'SECWORD', ''), ('cwe-119', 'CWEID', ''), ('improper restriction', 'secword', ''), ('high', 'SEVERITY', '')]"
5,"{'CWE-476', 'CWE-787', 'CWE-125'}",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Validate channel dimension consistency in batch norm inputs

The vulnerability was missing validation of input tensor channel dimensions against scale, offset, mean, and variance tensors in batch normalization operations. This could lead to out-of-bounds memory access or corrupted computations, potentially causing crashes or exploitable undefined behavior. The fix adds explicit checks ensuring these tensors have matching channel counts, preventing invalid inputs from proceeding.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,{'CWE-125'},GHSA-cgfm-62j4-v4rf,"@@ -219,7 +219,20 @@ class SparseReduceOp : public OpKernel {
     sp.Reorder<T>(reduction.reorder_dims);
     for (const auto &g : sp.group(reduction.group_by_dims)) {
       Op::template Run<T>(ctx, reduced_val, g.template values<T>());
+      OP_REQUIRES(ctx,
+                  output_strides.empty() ||
+                  (g.group().size() == output_strides.size()),
+                  errors::Internal(
+                      ""Expected group size and output_strides size to match"",
+                      "", but got "", g.group().size(), "" and "",
+                      output_strides.size()));
       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);
+      OP_REQUIRES(ctx,
+                  idx >= 0 && idx < out_flat.size(),
+                  errors::Internal(
+                      ""Obtained a write index of "", idx,
+                      "" which is outside of bounds of [0, "",
+                      out_flat.size(), "")""));
       out_flat(idx) = reduced_val();
       VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")
               << ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""","Prevent heap OOB in sparse reduction ops.

PiperOrigin-RevId: 387934524
Change-Id: I894aa30f1e454f09b471d565b4a325da49322c1a","vuln-fix: Prevent out-of-bounds writes in sparse reduction operation

The vulnerability was an unchecked write index in sparse reduction that could cause out-of-bounds memory access during tensor updates. This is a security risk because it may lead to memory corruption, crashes, or arbitrary code execution by malicious inputs. The fix adds explicit bounds checks and size validations to ensure all write indices are within valid output tensor ranges.

Weakness: CWE-125: Out-of-bounds Read/Write  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i894aa30f1e454f09b471d565b4a325da49322c1a', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds writes', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('updates', 'ACTION', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
7,{'CWE-125'},GHSA-q3g3-h9r4-prrc,"@@ -265,6 +265,11 @@ class SimpleBinaryOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     const Tensor& in0 = ctx->input(0);
     const Tensor& in1 = ctx->input(1);
+    OP_REQUIRES(
+        ctx, in0.NumElements() == in1.NumElements(),
+        errors::InvalidArgument(""The two arguments to a cwise op must have ""
+                                ""same number of elements, got "",
+                                in0.NumElements(), "" and "", in1.NumElements()));
     auto in0_flat = in0.flat<Tin>();
     auto in1_flat = in1.flat<Tin>();
     const Device& eigen_device = ctx->eigen_device<Device>();","Fix nullptr deref and heap OOB access in binary cwise ops.

PiperOrigin-RevId: 387936777
Change-Id: I608b8074cec36a982cca622b7144cb2c43e6e19f","vuln-fix: Enforce element count equality in binary operations

The vulnerability allowed element-wise operations on tensors with differing element counts, leading to out-of-bounds memory access during computation. This posed a security risk by enabling potential memory corruption and arbitrary code execution through crafted inputs. The fix adds a validation check that enforces both input tensors have the same number of elements before proceeding with the operation.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('nullptr', 'SECWORD', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i608b8074cec36a982cca622b7144cb2c43e6e19f', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
8,{'CWE-125'},GHSA-5hj3-vjjf-f5m7,"@@ -380,6 +380,11 @@ Status Examples::Initialize(OpKernelContext* const context,
   const Tensor* example_labels_t;
   TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
   auto example_labels = example_labels_t->flat<float>();
+  if (example_labels.size() != num_examples) {
+    return errors::InvalidArgument(""Expected "", num_examples,
+                                   "" example labels but got "",
+                                   example_labels.size());
+  }
 
   OpInputList dense_features_inputs;
   TF_RETURN_IF_ERROR(","Add remaining validation to `sdca_internal.cc`

PiperOrigin-RevId: 387738010
Change-Id: I28eedcfd87a53aaf34deb075acea1f8c95470808","vuln-fix: Validate example labels size to prevent input mismatch

The vulnerability occurs due to missing validation of example labels size against the expected number of examples, allowing inconsistent input data to proceed unchecked.  
This can lead to out-of-bounds memory access or logic errors, potentially causing crashes or data corruption in downstream processing.  
The fix adds a size check that returns an error if the example labels count does not match the expected number of examples, preventing invalid inputs from being processed.  

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('sdca_internal.cc', 'URL', ''), ('change', 'ACTION', ''), ('i28eedcfd87a53aaf34deb075acea1f8c95470808', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('size check', 'secword', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,"{'CWE-787', 'CWE-125'}",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct loop index to prevent out-of-bounds access in type specialization

The vulnerability was an incorrect loop index causing potential out-of-bounds access when modifying type arguments during specialization.
This could lead to memory corruption or undefined behavior, posing a risk of crashes or exploitation by crafted inputs.
The fix replaces the incorrect fixed index with the loop variable to ensure proper iteration and safe access to all type arguments.

Weakness: CWE-125: Out-of-bounds Read
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('out-of-bounds read', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
10,{'CWE-125'},GHSA-83rh-hx5x-q9p5,"@@ -101,10 +101,14 @@ bool HdrDecoder::readData(Mat& _img)
 
 bool HdrDecoder::checkSignature( const String& signature ) const
 {
-    if(signature.size() >= m_signature.size() &&
-       (!memcmp(signature.c_str(), m_signature.c_str(), m_signature.size()) ||
-       !memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())))
-       return true;
+    if (signature.size() >= m_signature.size() &&
+        0 == memcmp(signature.c_str(), m_signature.c_str(), m_signature.size())
+    )
+        return true;
+    if (signature.size() >= m_signature_alt.size() &&
+        0 == memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())
+    )
+        return true;
     return false;
 }",imgproc(hdr): fix bounds check in HdrDecoder::checkSignature(),"vuln-fix: Correct signature check to prevent partial match bypass

The vulnerability was due to a combined condition allowing partial signature matches to pass validation incorrectly. This posed a security risk by enabling attackers to bypass signature verification with crafted inputs. The fix separates the checks for each signature variant to ensure exact and complete matches are required for validation success.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('hdrdecoder::checksignature', 'SECWORD', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('signature', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('signature', 'secword', ''), ('fix', 'ACTION', ''), ('signature', 'secword', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,{'CWE-125'},GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stat_dim bounds in feature split calculation

The vulnerability was an unchecked stat_dim value that could exceed the expected stats_dims boundary in stats_summary_indices, leading to out-of-bounds memory access. This posed a security risk by potentially causing crashes or enabling memory corruption exploits. The fix adds a validation check that enforces stat_dim to be less than stats_dims, aborting with an error if the condition is violated.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('tf.raw_ops.boostedtreessparsecalculatebestfeaturesplit', 'URL', ''), ('change', 'ACTION', ''), ('i83ca8a75b22aa78c037e8b98779da6cced16bfaa', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,{'CWE-125'},GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter to prevent out-of-bounds access

The vulnerability is an unchecked axis parameter that could exceed input tensor dimensions, leading to invalid memory access or crashes during dequantization operations. This poses a security risk by potentially causing denial of service or memory corruption exploitable by attackers. The fix adds a validation check that ensures the axis is less than the input tensor’s dimension count, rejecting invalid arguments early. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound access', 'secword', ''), ('adding', 'ACTION', ''), ('change', 'ACTION', ''), ('i3249d2a69ddc82f182c589a3a5bbfb71543f4b29', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('invalid memory access', 'SECWORD', ''), ('security', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
13,{'CWE-125'},GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate tensor element counts in dequantization axis

The vulnerability is that input_min_tensor and input_max_tensor element counts were not validated against the dequantization axis size, allowing mismatched tensor inputs. This can lead to out-of-bounds memory access or incorrect computations, potentially causing crashes or data corruption. The fix adds explicit checks to ensure these tensors have element counts matching the input dimension along the dequantization axis, rejecting invalid inputs early.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.23529411764705882,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('change', 'ACTION', ''), ('i135e94d360c2a1ce374c10f7e0fed1af603dbc02', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Add safe input and output retrieval to prevent null pointer use

The vulnerability is caused by unsafe direct tensor pointer retrieval without error checking, which can lead to null pointer dereferences and undefined behavior during tensor access. This is a security risk because it may cause crashes or memory corruption, potentially exploitable by crafted inputs to disrupt or control program flow. The fix replaces direct tensor retrieval calls with safe variants that perform error checking and ensure valid pointers before use, preventing invalid memory access.

Weakness: CWE-476: NULL Pointer Dereference  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('unsafe', 'secword', ''), ('error', 'FLAW', ''), ('null pointer dereferences', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('cwe-476', 'CWEID', ''), ('null pointer dereference', 'SECWORD', ''), ('high', 'SEVERITY', '')]"
15,{'CWE-125'},GHSA-545v-42p7-98fq,"@@ -1014,6 +1014,9 @@ struct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {
         const int input_start = start * input_size_per_batch;
         const int input_end = limit * input_size_per_batch;
         for (int64 index = input_start; index < input_end; index++) {
+          if (index >= argmax.NumElements()) {
+            break;
+          }
           int64 grad_out_index = argmax_flat(index);
           if (!include_batch_in_index) {
             const int64 cur_batch = index / input_size_per_batch;","Fix heap buffer overflow

PiperOrigin-RevId: 372132844
Change-Id: Idef9895efaf145f2b1c23d31983601ec980cd5e4","vuln-fix: Prevent out-of-bounds access in max pooling gradient kernel

The vulnerability is an out-of-bounds read from the argmax tensor during gradient computation in max pooling operations. This is a security risk because it can lead to undefined behavior, memory corruption, or potential information disclosure. The fix adds a boundary check to ensure the index does not exceed the number of elements in the argmax tensor, preventing invalid memory access.

Weakness: Out-of-bounds Read (CWE-125)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('idef9895efaf145f2b1c23d31983601ec980cd5e4', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds read', 'SECWORD', ''), ('security', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('out-of-bounds read', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,{'CWE-125'},GHSA-4fg4-p75j-w5xj,"@@ -173,20 +173,50 @@ class QuantizedBatchNormOp : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
-    const float input_min = context->input(1).flat<float>()(0);
-    const float input_max = context->input(2).flat<float>()(0);
+    const auto& input_min_tensor = context->input(1);
+    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_min must have 1 element""));
+    const float input_min = input_min_tensor.flat<float>()(0);
+    const auto& input_max_tensor = context->input(2);
+    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_max must have 1 element""));
+    const float input_max = input_max_tensor.flat<float>()(0);
     const Tensor& mean = context->input(3);
-    const float mean_min = context->input(4).flat<float>()(0);
-    const float mean_max = context->input(5).flat<float>()(0);
+    const auto& mean_min_tensor = context->input(4);
+    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_min must have 1 element""));
+    const float mean_min = mean_min_tensor.flat<float>()(0);
+    const auto& mean_max_tensor = context->input(5);
+    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_max must have 1 element""));
+    const float mean_max = mean_max_tensor.flat<float>()(0);
     const Tensor& var = context->input(6);
-    const float var_min = context->input(7).flat<float>()(0);
-    const float var_max = context->input(8).flat<float>()(0);
+    const auto& var_min_tensor = context->input(7);
+    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_min must have 1 element""));
+    const float var_min = var_min_tensor.flat<float>()(0);
+    const auto& var_max_tensor = context->input(8);
+    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_max must have 1 element""));
+    const float var_max = var_max_tensor.flat<float>()(0);
     const Tensor& beta = context->input(9);
-    const float beta_min = context->input(10).flat<float>()(0);
-    const float beta_max = context->input(11).flat<float>()(0);
+    const auto& beta_min_tensor = context->input(10);
+    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_min must have 1 element""));
+    const float beta_min = beta_min_tensor.flat<float>()(0);
+    const auto& beta_max_tensor = context->input(11);
+    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_max must have 1 element""));
+    const float beta_max = beta_max_tensor.flat<float>()(0);
     const Tensor& gamma = context->input(12);
-    const float gamma_min = context->input(13).flat<float>()(0);
-    const float gamma_max = context->input(14).flat<float>()(0);
+    const auto& gamma_min_tensor = context->input(13);
+    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_min must have 1 element""));
+    const float gamma_min = gamma_min_tensor.flat<float>()(0);
+    const auto& gamma_max_tensor = context->input(14);
+    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_max must have 1 element""));
+    const float gamma_max = gamma_max_tensor.flat<float>()(0);
 
     OP_REQUIRES(context, input.dims() == 4,
                 errors::InvalidArgument(""input must be 4-dimensional"",
@@ -203,6 +233,33 @@ class QuantizedBatchNormOp : public OpKernel {
     OP_REQUIRES(context, gamma.dims() == 1,
                 errors::InvalidArgument(""gamma must be 1-dimensional"",
                                         gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value"",
+                                        gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value""));
+    const auto last_dim = input.shape().dims() - 1;
+    OP_REQUIRES(context,
+                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),
+                errors::InvalidArgument(""Must provide as many means as the ""
+                                        ""last dimension of the input tensor: "",
+                                        mean.shape().DebugString(), "" vs. "",
+                                        input.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == var.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and variance tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", var.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and beta tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", beta.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and gamma tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", gamma.shape().DebugString()));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Add missing validation in `QuantizedBatchNormWithGlobalNormalization`

PiperOrigin-RevId: 370123451
Change-Id: Id234d6dab1ec21230bb8e503dba30f899af87f33","vuln-fix: Validate tensor element counts and shapes in QuantizedBatchNormOp

The vulnerability was that input tensors for min/max values and parameters lacked validation for element counts and shape consistency, allowing malformed inputs to proceed unchecked. This posed a security risk by enabling potential out-of-bounds access or logic errors that could be exploited to cause crashes or data corruption. The fix adds explicit checks ensuring each min/max tensor has exactly one element and that parameter tensors have matching shapes consistent with the input tensor’s last dimension.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('change', 'ACTION', ''), ('id234d6dab1ec21230bb8e503dba30f899af87f33', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('security', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
17,"{'CWE-908', 'CWE-125'}",GHSA-q263-fvxm-m5mw,"@@ -44,6 +44,7 @@ limitations under the License.
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
 #include ""tensorflow/core/lib/strings/scanner.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/logging.h""
 #include ""tensorflow/core/platform/macros.h""
 #include ""tensorflow/core/public/version.h""
@@ -1425,6 +1426,17 @@ void GraphConstructor::Undo() {
 
 Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,
                                   int input_index) {
+  if (output_index >= src->num_outputs()) {
+    return errors::InvalidArgument(
+        ""Output "", output_index, "" of node "", src->name(),
+        "" does not exist. Node only has "", src->num_outputs(), "" outputs."");
+  }
+  if (input_index >= dst->num_inputs()) {
+    return errors::InvalidArgument(
+        ""Input "", input_index, "" of node "", dst->name(),
+        "" does not exist. Node only has "", dst->num_inputs(), "" inputs."");
+  }
+
   DataType src_out = src->output_type(output_index);
   DataType dst_in = dst->input_type(input_index);
   if (!TypesCompatible(dst_in, src_out)) {","Prevent unitialized memory access in `GraphConstructor::MakeEdge`

The `MakeEdge` implementation assumes that there exists an output at `output_index` of `src` node and an input at `input_index` of `dst` node. However, if this is not the case this results in accessing data out of bounds. Because we are accessing an array that is a private member of a class and only in read only mode, this usually results only in unitialized memory access. However, it is reasonable to think that malicious users could manipulate these indexes to actually read data outside the class, thus resulting in information leakage and further exploits.

PiperOrigin-RevId: 346343288
Change-Id: I2127da27c2023d27f26efd39afa6c853385cab6f","vuln-fix: Validate node edge indices to prevent out-of-bounds access

The vulnerability was missing bounds checks on node output and input indices when creating graph edges, allowing invalid indices to be used. This posed a security risk by potentially causing undefined behavior or memory corruption through out-of-bounds access. The fix adds explicit validation of output and input indices, returning errors if indices exceed node limits to ensure safe edge creation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out of bounds', 'SECWORD', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('information leakage', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('change', 'ACTION', ''), ('i2127da27c2023d27f26efd39afa6c853385cab6f', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('bounds checks', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('errors', 'FLAW', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,{'CWE-125'},GHSA-9c8h-vvrj-w2p8,"@@ -58,15 +58,21 @@ class RaggedGatherOpBase : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     // Get the input Tensors.
+
     OpInputList params_nested_splits_in;
     OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",
                                                 &params_nested_splits_in));
+    OP_REQUIRES(
+        context, params_nested_splits_in.size() > 0,
+        errors::InvalidArgument(""params_nested_splits must be non empty""));
+
     const Tensor& params_dense_values_in =
         context->input(params_nested_splits_in.size());
     const Tensor& indices_in =
         context->input(params_nested_splits_in.size() + 1);
 
-    DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, params_nested_splits_in[0].dims() > 0,
+                errors::InvalidArgument(""Split tensors must not be scalars""));
     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;
     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));","Fix heap OOB in `tf.raw_ops.RaggedGather`

PiperOrigin-RevId: 388355464
Change-Id: If14d96231d1cd7aad7c4d1c22c1bab1576b75717","vuln-fix: Validate input tensor list size and dimensions

The vulnerability was caused by missing runtime checks for empty input tensor lists and scalar split tensors, which could lead to invalid memory access or crashes. This is a security risk because it may allow attackers to trigger denial of service or exploit undefined behavior in the kernel. The fix adds explicit validation to ensure the input tensor list is non-empty and that split tensors have valid dimensions before proceeding.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('tf.raw_ops.raggedgather', 'URL', ''), ('change', 'ACTION', ''), ('if14d96231d1cd7aad7c4d1c22c1bab1576b75717', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('invalid memory access', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('denial of service', 'secword', ''), ('exploit', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,{'CWE-125'},GHSA-c545-c4f9-rf6v,"@@ -37,6 +37,7 @@ TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,
     axis = input_dims.size + 1 + axis;
   }
   TF_LITE_ENSURE(context, axis <= input_dims.size);
+  TF_LITE_ENSURE(context, axis >= 0);
 
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);
   for (int i = 0; i < output_dims->size; ++i) {","Prevent an OOB read in `expand_dims.cc`

The for loop that follows this check assumes that `axis` is between `0` and `input_dims.size`. If user supplied `axis` is negative, the if code before this check is supposed to bring it back to positive (similar to how in Python one can do `l[-3]` to mean `l[-3 + len(l)]`).

PiperOrigin-RevId: 387200206
Change-Id: I162f4feba12d547c3a4340833ae682016a2ebfab","vuln-fix: Prevent negative axis values in tensor dimension expansion

The vulnerability allowed negative axis values to bypass validation, potentially causing out-of-bounds memory access during tensor dimension expansion. This is a security risk because it can lead to undefined behavior, crashes, or memory corruption exploitable by attackers. The fix adds a lower bound check ensuring the axis value is non-negative before proceeding with dimension expansion.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('expand_dims.cc', 'URL', ''), ('input_dims.size', 'URL', ''), ('change', 'ACTION', ''), ('i162f4feba12d547c3a4340833ae682016a2ebfab', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('bypass', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bound check', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,{'CWE-125'},GHSA-3h8m-483j-7xxm,"@@ -46,6 +46,10 @@ class RequantizationRangeOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,
+                errors::InvalidArgument(""Input min must not be empty.""));
+    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,
+                errors::InvalidArgument(""Input max must not be empty.""));
     const float input_min_float = ctx->input(1).flat<float>()(0);
     const float input_max_float = ctx->input(2).flat<float>()(0);
     Tensor* output_min = nullptr;","Fix out of bound read in requantization_range_op.cc

PiperOrigin-RevId: 372129031
Change-Id: Ie684ab98a3840c5186ead3eafffc0e0ed0e8030d","vuln-fix: Validate non-empty inputs for min and max tensors

The vulnerability was caused by missing checks for empty input tensors representing minimum and maximum values, which could lead to out-of-bounds memory access during computation. This poses a security risk as it may cause crashes or undefined behavior exploitable by attackers to cause denial of service or memory corruption. The fix adds explicit validation to ensure these input tensors are not empty before accessing their elements, preventing invalid memory reads.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound read', 'secword', ''), ('requantization_range_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie684ab98a3840c5186ead3eafffc0e0ed0e8030d', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'secword', ''), ('missing checks', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,{'CWE-125'},GHSA-cvgx-3v3q-m36c,"@@ -2559,6 +2559,9 @@ Status QuantizeV2Shape(InferenceContext* c) {
   if (!s.ok() && s.code() != error::NOT_FOUND) {
     return s;
   }
+  if (axis < -1) {
+    return errors::InvalidArgument(""axis should be at least -1, got "", axis);
+  }
   const int minmax_rank = (axis == -1) ? 0 : 1;
   TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
   ShapeHandle minmax;","Prevent OOB access in QuantizeV2 shape inference

PiperOrigin-RevId: 400309614
Change-Id: I31412c71b05b4f21b677f7fa715a61499cbee39d","vuln-fix: Validate axis parameter to prevent invalid negative values

The vulnerability allowed axis values less than -1, which could cause unexpected behavior or crashes during shape inference in tensor operations.
This is a security risk because it may lead to denial of service or memory corruption when processing malformed inputs.
The fix adds a validation check that rejects axis values below -1, returning an invalid argument error to prevent further processing.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i31412c71b05b4f21b677f7fa715a61499cbee39d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,{'CWE-125'},GHSA-7fvx-3jfc-2cpc,"@@ -955,11 +955,12 @@ class ResourceScatterUpdateOp : public OpKernel {
                         params->dim_size(0), "")""));
       } else {
         int64_t num_updates = updates.NumElements();
-        OP_REQUIRES(c, num_updates % N == 0,
-                    errors::InvalidArgument(
-                        ""shape of indices ("", indices.shape().DebugString(),
-                        "") is not compatible with the shape of updates ("",
-                        updates.shape().DebugString(), "")""));
+        OP_REQUIRES(
+            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),
+            errors::InvalidArgument(
+                ""The shape of indices ("", indices.shape().DebugString(),
+                "") must be a prefix of the shape of updates ("",
+                updates.shape().DebugString(), "")""));
         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});
 
         functor::ScatterFunctor<Device, T, Index, op> functor;","Fix heap OOB due to dimension mismatch in `ResourceScatterUpdate`

PiperOrigin-RevId: 388292801
Change-Id: Id9bd7244d98d41b1517d4771850b32782c0cc949","vuln-fix: Enforce shape prefix validation for scatter update indices

The vulnerability was due to insufficient validation of the relationship between indices and updates tensor shapes in scatter update operations. This flaw could lead to out-of-bounds memory access or data corruption by allowing incompatible tensor shapes to proceed unchecked. The fix enforces that the shape of indices must be a prefix of the updates shape, ensuring consistent and safe tensor operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('id9bd7244d98d41b1517d4771850b32782c0cc949', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('update', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('updates', 'ACTION', ''), ('update', 'ACTION', ''), ('flaw', 'FLAW', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,{'CWE-125'},GHSA-59q2-x2qc-4c97,"@@ -533,6 +533,17 @@ class UnicodeEncodeOp : public OpKernel {
     const Tensor& input_splits = context->input(1);
     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();
 
+    // Operation will treat first argument in input_splits as if it were zero
+    // regardless of its actual value since splits should begin with zero and
+    // end with the length of the input values vector.
+    OP_REQUIRES(
+        context, input_splits_flat(0) == 0,
+        errors::InvalidArgument(""First value in input_splits must be zero.""));
+    OP_REQUIRES(context,
+                input_splits_flat(input_splits_flat.size() - 1) ==
+                    input_tensor_flat.size(),
+                errors::InvalidArgument(""Last value in input_splits must be ""
+                                        ""equal to length of input_tensor.""));
     // Since we limit to a 2-D input (flat_values of rank 1 and a single splits
     // tensor), our output dimension will be 1 with it's size equal to the
     // number of splits (outer dimension or ragged tensor).
@@ -548,6 +559,14 @@ class UnicodeEncodeOp : public OpKernel {
     for (int i = 1; i < input_splits_flat.size(); ++i) {
       icu::UnicodeString unicode_string;
       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);
+      OP_REQUIRES(
+          context, input_splits_flat(i - 1) <= input_splits_flat(i),
+          errors::InvalidArgument(
+              ""Values in input_splits must be equal or in ascending order.""));
+      OP_REQUIRES(
+          context, input_splits_flat(i) <= input_tensor_flat.size(),
+          errors::InvalidArgument(""Values in input_splits must be less than or ""
+                                  ""equal to input_tensor length.""));
       for (; idx < input_splits_flat(i); ++idx) {
         int32 code_point = input_tensor_flat(idx);
         // Check for invalid code point","Fix heap buffer overflow in tf.raw_ops.UnicodeEncode.

PiperOrigin-RevId: 371717714
Change-Id: If33443b28f158e58078f1268f6b92f2728d219e0","vuln-fix: Validate input_splits boundaries and ordering in UnicodeEncodeOp

The vulnerability is improper validation of input_splits array boundaries and ordering, which could lead to out-of-bounds memory access or corrupted data processing. This poses a security risk by enabling potential crashes or arbitrary code execution through malformed input data. The fix enforces that input_splits starts with zero, ends with the input length, and contains non-decreasing values within valid bounds.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('tf.raw_ops.unicodeencode', 'URL', ''), ('change', 'ACTION', ''), ('if33443b28f158e58078f1268f6b92f2728d219e0', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('unicodeencodeop', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('improper validation', 'secword', ''), ('out-of-bounds', 'secword', ''), ('security', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,{'CWE-125'},GHSA-jwf9-w5xm-f437,"@@ -123,6 +123,17 @@ TfLiteStatus GatherNdString(const TfLiteTensor* params,
 template <typename IndicesT>
 TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,
                           const TfLiteTensor* indices, TfLiteTensor* output) {
+  bool indices_has_only_positive_elements = true;
+  const auto* indices_values = GetTensorData<IndicesT>(indices);
+  const size_t num_indices = indices->bytes / sizeof(IndicesT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indices_values[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   switch (params->type) {
     case kTfLiteFloat32:
       return GatherNd<float, IndicesT>(params, indices, output);","Prevent heap OOB read in TFLite's `gather_nd.cc`.

Passing negative indices is illegal but there was a missing check so that resulted in OOB accesses.

PiperOrigin-RevId: 387208551
Change-Id: I6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd","vuln-fix: Prevent negative indices in GatherNd tensor operation

The vulnerability allowed negative index values in the GatherNd operation, which could cause out-of-bounds memory access or undefined behavior during tensor evaluation. This poses a security risk by potentially enabling memory corruption or data leakage through invalid memory reads. The fix adds a validation step that ensures all indices are non-negative before proceeding with the tensor gathering operation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('gather_nd.cc', 'URL', ''), ('missing check', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,"{'CWE-787', 'CWE-125'}",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Prevent use of optional tensor leading to invalid memory access

The code incorrectly accessed optional input tensors without proper validation, causing potential out-of-bounds or null pointer dereferences. This is a security risk because it can lead to crashes or arbitrary code execution through memory corruption. The fix replaces conditional checks with a safer direct input retrieval that properly handles optional tensor cases to prevent invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('incorrectly accessed', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('null pointer dereferences', 'SECWORD', ''), ('security', 'secword', ''), ('code execution', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
26,"{'CWE-787', 'CWE-125'}",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Prevent out-of-bounds access in row partition handling

The code lacked a boundary check for row partition size compared to output size, risking out-of-bounds memory access during tensor operations. This could lead to memory corruption or crashes, potentially exploitable for denial of service or arbitrary code execution. The fix adds a validation step that returns an error if the row partition size exceeds the output size, preventing invalid memory access.

Weakness: Improper Bounds Checking (CWE-125)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('boundary check', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,{'CWE-125'},GHSA-2r8p-fg3c-wcj4,"@@ -660,6 +660,11 @@ class ResourceGatherOp : public OpKernel {
     OP_REQUIRES(
         c, TensorShapeUtils::IsVectorOrHigher(params.shape()),
         errors::InvalidArgument(""params must be at least 1 dimensional""));
+    OP_REQUIRES(
+        c, params.shape().dims() >= batch_dims_,
+        errors::InvalidArgument(""params must have at least "", batch_dims_,
+                                "" (batch_dims) dimensions but it has shape "",
+                                params.shape().DebugString()));
 
     // Check that we have enough index space
     const int64_t N = indices.NumElements();","Prevent heap oob access in `resource_variable_ops.cc`

PiperOrigin-RevId: 387936433
Change-Id: I9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6","vuln-fix: Enforce minimum batch dimensions in ResourceGatherOp parameters

The vulnerability was a missing check ensuring that the params tensor has at least batch_dims_ dimensions, allowing malformed inputs to proceed unchecked. This could lead to out-of-bounds memory access or undefined behavior during tensor operations, posing a security risk. The fix adds a validation step that rejects params tensors with fewer dimensions than batch_dims_, preventing invalid memory access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('resource_variable_ops.cc', 'URL', ''), ('change', 'ACTION', ''), ('i9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('missing check', 'secword', ''), ('ensuring', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,{'CWE-125'},GHSA-h4pc-gx2w-f2xv,"@@ -96,6 +96,8 @@ TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
     }
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
   const int input_size = SizeOfDimension(input, axis_value);
 
   if (minus_one_index != -1) {","Prevent array OOB read/write

PiperOrigin-RevId: 371026165
Change-Id: I26ac6372c87246e03c7eb8c94e84c84d86054b36","vuln-fix: Validate axis parameter bounds in tensor resizing

The vulnerability was an unchecked axis parameter that could be negative or exceed tensor dimensions during output tensor resizing.
This posed a risk of out-of-bounds memory access or undefined behavior leading to potential crashes or data corruption.
The fix adds explicit validation to ensure the axis value is non-negative and less than the number of input tensor dimensions before proceeding.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i26ac6372c87246e03c7eb8c94e84c84d86054b36', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,{'CWE-125'},GHSA-vqw6-72r7-fgw7,"@@ -162,6 +162,9 @@ class BaseMatrixTriangularSolveOp : public OpKernel {
     const Tensor& in1 = ctx->input(1);
 
     ValidateInputTensors(ctx, in0, in1);
+    if (!ctx->status().ok()) {
+      return;
+    }
 
     MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());
     OP_REQUIRES(
@@ -230,13 +233,22 @@ class MatrixTriangularSolveOp
  private:
   void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,
                             const Tensor& in1) override {
+    const auto in0_num_dims = in0.dims();
     OP_REQUIRES(
-        ctx, in0.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0.dims()));
+        ctx, in0_num_dims >= 2,
+        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0_num_dims));
 
+    const auto in1_num_dims = in1.dims();
     OP_REQUIRES(
-        ctx, in1.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in1.dims()));
+        ctx, in1_num_dims >= 2,
+        errors::InvalidArgument(""In[1] ndims must be >= 2: "", in1_num_dims));
+
+    const auto in0_last_dim = in0.dim_size(in0_num_dims - 1);
+    const auto in0_prev_dim = in0.dim_size(in0_num_dims - 2);
+    OP_REQUIRES(ctx, in0_last_dim == in0_prev_dim,
+                errors::InvalidArgument(
+                    ""In[0] matrices in the last dimensions must be square ("",
+                    in0_last_dim, "" =/= "", in0_prev_dim, "")""));
   }
 };","Validate (and ensure validation sticks) inputs for `MatrixTriangularSolve`.

PiperOrigin-RevId: 370282444
Change-Id: Iaed61a0b0727cc42c830658b72eb69f785f48dc5","vuln-fix: Validate input tensor dimensions and halt on error

The vulnerability was missing validation for input tensor dimensions and continuing execution despite errors, which could cause undefined behavior or memory corruption. This is a security risk because malformed inputs might lead to crashes or exploitable states in the matrix solve operation. The fix adds dimension checks for inputs, ensures matrices are square where required, and stops execution immediately if validation fails.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('iaed61a0b0727cc42c830658b72eb69f785f48dc5', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('error', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('missing validation', 'secword', ''), ('errors', 'FLAW', ''), ('memory corruption', 'SECWORD', ''), ('security', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,"{'CWE-400', 'CWE-125'}",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent potential memory issues

Using the deprecated Buffer constructor can lead to uninitialized memory exposure, causing potential information leaks or security vulnerabilities in the proxy authorization header handling.
This is a security risk because attackers might exploit uninitialized memory to gain sensitive data or cause application instability.
The fix replaces the deprecated Buffer constructor with the safer Buffer.from method to ensure proper memory initialization and prevent accidental data exposure.

Weakness: Use of Deprecated Buffer Constructor (CWE-676)
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('issues', 'FLAW', ''), ('uninitialized memory', 'SECWORD', ''), ('information leaks', 'SECWORD', ''), ('security', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('uninitialized memory', 'SECWORD', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('safer buffer.from', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('initialization', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('data exposure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-676', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,"{'CWE-787', 'CWE-125'}",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate tensor dimensions to prevent zero-size inputs

The vulnerability allowed zero-sized tensor dimensions to be processed, which could lead to undefined behavior or crashes during computation.
This is a security risk because it may cause denial of service or memory corruption when invalid tensor shapes are used.
The fix adds explicit checks to ensure batch, rows, columns, and depth dimensions are non-zero before proceeding with operations.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,{'CWE-125'},GHSA-qpw2-xchm-655q,"@@ -28,7 +28,7 @@ StringStream.prototype.write = function(data) {
     return false
   }
   if (this.fromEncoding) {
-    if (Buffer.isBuffer(data)) data = data.toString()
+    if (Buffer.isBuffer(data) || typeof data === 'number') data = data.toString()
     data = new Buffer(data, this.fromEncoding)
   }
   var string = this.decoder.write(data)","Merge pull request #9 from mhart/fix-buffer-constructor-vuln

Ensure data is not a number in Buffer constructor","vuln-fix: Prevent improper number handling in StringStream write method

The vulnerability allowed numeric inputs to be converted to strings without proper encoding, potentially causing unexpected behavior or data corruption during stream processing. This is a security risk because it can lead to malformed data handling, which attackers might exploit to disrupt application logic or cause denial of service. The fix adds a type check for numbers and converts them to strings before encoding, ensuring consistent and safe data processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('#9', 'ISSUE', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,{'CWE-125'},GHSA-6gmv-pjp9-p8w8,"@@ -1653,11 +1653,21 @@ REGISTER_OP(""ReverseSequence"")
         return errors::InvalidArgument(
             ""batch_dim must be < input rank: "", batch_dim, "" vs. "", input_rank);
       }
+
       if (seq_dim >= input_rank) {
         return errors::InvalidArgument(
             ""seq_dim must be < input rank: "", seq_dim, "" vs. "", input_rank);
       }
 
+      // To prevent out of bound access when calling c->Dim(input, batch_dim),
+      // batch_dim range [-1 * input rank, input rank) is allowed. However,
+      // the op implementation has a stricter bound for batch_dim requiring >= 0
+      // value. Thus, perform strict check here.
+      if (batch_dim < 0) {
+        return errors::InvalidArgument(""batch_dim must be >=0, got "",
+                                       batch_dim);
+      }
+
       DimensionHandle batch_dim_dim = c->Dim(input, batch_dim);
       TF_RETURN_IF_ERROR(
           c->Merge(batch_dim_dim, c->Dim(seq_lens_shape, 0), &batch_dim_dim));","Fix out of bound error in ReverseSequence Op shape function

PiperOrigin-RevId: 411896080
Change-Id: I7e59a38e2f960886edf2b6c54ed5a84e86a9b193","vuln-fix: Enforce non-negative batch_dim in ReverseSequence op

The vulnerability allowed negative batch_dim values, which could cause out-of-bounds memory access during dimension handling in the ReverseSequence operation. This is a security risk because it may lead to memory corruption or crashes exploitable by attackers. The fix adds a strict check to reject negative batch_dim values, ensuring safe and valid input dimensions.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('i7e59a38e2f960886edf2b6c54ed5a84e86a9b193', 'SHA', '')]",0.35294117647058826,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('security', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'SECWORD', ''), ('improper input validation', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
