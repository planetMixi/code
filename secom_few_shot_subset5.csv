id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
793,CWE-400,GHSA-6cf8-qhqj-vjqm,"@@ -6621,6 +6621,10 @@ exports.set = function(obj, path, value) {
 	var v = arr[arr.length - 1];
 	var ispush = v.lastIndexOf('[]') !== -1;
 	var a = builder.join(';') + ';var v=typeof(a)===\'function\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';
+
+	if ((/__proto__|constructor|prototype/).test(a))
+		throw new Error('Prototype pollution');
+
 	var fn = new Function('w', 'a', 'b', a);
 	F.temporary.other[cachekey] = fn;
 	fn(obj, value, path);",Fixed `U.set()` by adding check for `Prototype pollution`.,"vuln-fix: Prevent prototype pollution in object setter function (CVE-2024-XXXX)

The set function allowed object paths containing ""__proto__"", ""constructor"", or ""prototype"" to modify dangerous prototype properties.
This vulnerability enabled prototype pollution attacks that can escalate privileges or corrupt application state at runtime.
The patch adds a security check to throw an error when such prototype-related keys are detected in the input path, preventing pollution.

Weakness: CWE-471
Severity: High
CVSS: 7.8"
600,CWE-347,GHSA-vjxv-45g9-9296,"@@ -201,6 +201,7 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 			}
 		}
 
+		var checked []oci.Signature
 		var validationErrors []error
 		for _, vp := range verified {
 			payload, err := policy.AttestationToPayloadJSON(ctx, c.PredicateType, vp)
@@ -217,6 +218,7 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 				cueValidationErr := cue.ValidateJSON(payload, cuePolicies)
 				if cueValidationErr != nil {
 					validationErrors = append(validationErrors, cueValidationErr)
+					continue
 				}
 			}
 
@@ -225,8 +227,11 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 				regoValidationErrs := rego.ValidateJSON(payload, regoPolicies)
 				if len(regoValidationErrs) > 0 {
 					validationErrors = append(validationErrors, regoValidationErrs...)
+					continue
 				}
 			}
+
+			checked = append(checked, vp)
 		}
 
 		if len(validationErrors) > 0 {
@@ -237,10 +242,14 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 			return fmt.Errorf(""%d validation errors occurred"", len(validationErrors))
 		}
 
+		if len(checked) == 0 {
+			return fmt.Errorf(""none of the attestations matched the predicate type: %s"", c.PredicateType)
+		}
+
 		// TODO: add CUE validation report to `PrintVerificationHeader`.
 		PrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)
 		// The attestations are always JSON, so use the raw ""text"" mode for outputting them instead of conversion
-		PrintVerification(imageRef, verified, ""text"")
+		PrintVerification(imageRef, checked, ""text"")
 	}
 
 	return nil","Merge pull request from GHSA-vjxv-45g9-9296

Today the verification logic:
1. Verifies signatures on attestations (at least one must verify, or it errors),
2. All attestations matching the specified `--type` must pass any specified Cue/Rego policies,
3. *All* signature-verified attestations are then printed.

However, if NONE of the attestations match the specified `--type` then `2.` is considered satisfied and we proceed to `3.`

This changes the above logic to:
1. Same.
2. Same, but these are put into a `checked` list,
3. `checked` must be non-empty (or an error is printed about no attestations matching `--type`),
4. *Just* the `checked` attestations are printed.

---

The bug at HEAD:
```shell
$ cosign verify-attestation --type spdx ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2

Verification for ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - Any certificates were verified against the Fulcio roots.
Certificate subject:  https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main
Certificate issuer URL:  https://token.actions.githubusercontent.com
Certificate extension GitHub Workflow Trigger: schedule
Certificate extension GitHub Workflow SHA: 7e7572e578de7c51a2f1a1791f025cf315503aa2
Certificate extension GitHub Workflow Name: Create Release
Certificate extension GitHub Workflow Trigger distroless/static
Certificate extension GitHub Workflow Ref: refs/heads/main
{""payloadType"":""application/vnd.in-toto+json"",""payload"":""eyJfdHlwZSI6Imh0dHBzOi8vaW4tdG90by5pby9TdGF0ZW1lbnQvdjAuMSIsInByZWRpY2F0ZVR5cGUiOiJjb3NpZ24uc2lnc3RvcmUuZGV2L2F0dGVzdGF0aW9uL3Z1bG4vdjEiLCJzdWJqZWN0IjpbeyJuYW1lIjoiZ2hjci5pby9kaXN0cm9sZXNzL3N0YXRpYyIsImRpZ2VzdCI6eyJzaGEyNTYiOiJkZDc2MTRiNWExMmJjNGQ2MTdiMjIzYzU4OGI0ZTBjODMzNDAyYjhmNDk5MWZiNTcwMmVhODNhZmFkMTk4NmUyIn19XSwicHJlZGljYXRlIjp7Imludm9jYXRpb24iOnsicGFyYW1ldGVycyI6bnVsbCwidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mvc3RhdGljL2FjdGlvbnMvcnVucy8yNzc5MjEyNzA1IiwiZXZlbnRfaWQiOiIyNzc5MjEyNzA1IiwiYnVpbGRlci5pZCI6IkNyZWF0ZSBSZWxlYXNlIn0sInNjYW5uZXIiOnsidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2FxdWFzZWN1cml0eS90cml2eSIsInZlcnNpb24iOiIwLjI5LjIiLCJkYiI6eyJ1cmkiOiIiLCJ2ZXJzaW9uIjoiIn0sInJlc3VsdCI6eyIkc2NoZW1hIjoiaHR0cHM6Ly9qc29uLnNjaGVtYXN0b3JlLm9yZy9zYXJpZi0yLjEuMC1ydG0uNS5qc29uIiwicnVucyI6W3siY29sdW1uS2luZCI6InV0ZjE2Q29kZVVuaXRzIiwib3JpZ2luYWxVcmlCYXNlSWRzIjp7IlJPT1RQQVRIIjp7InVyaSI6ImZpbGU6Ly8vIn19LCJyZXN1bHRzIjpbXSwidG9vbCI6eyJkcml2ZXIiOnsiZnVsbE5hbWUiOiJUcml2eSBWdWxuZXJhYmlsaXR5IFNjYW5uZXIiLCJpbmZvcm1hdGlvblVyaSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9hcXVhc2VjdXJpdHkvdHJpdnkiLCJuYW1lIjoiVHJpdnkiLCJydWxlcyI6W10sInZlcnNpb24iOiIwLjI5LjIifX19XSwidmVyc2lvbiI6IjIuMS4wIn19LCJtZXRhZGF0YSI6eyJzY2FuU3RhcnRlZE9uIjoiMjAyMi0wOC0wMlQwMjozMzo0N1oiLCJzY2FuRmluaXNoZWRPbiI6IjIwMjItMDgtMDJUMDI6MzM6NTNaIn19fQ=="",""signatures"":[{""keyid"":"""",""sig"":""MEYCIQCovBtLOBXyB2zpvhp3j6QzqLtsH0/RC7fRINSApySqxAIhAIKlzu1fXuKPPOIheNnsPmBOB6XfZbRs5sDW1yFSch1A""}]}
```

The same with this change:
```shell
$ go run ./cmd/cosign verify-attestation --type spdx ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2
Error: none of the attestations matched the predicate type: spdx
main.go:62: error during command execution: none of the attestations matched the predicate type: spdx
exit status 1
```

A valid `--type` with this change:
```shell
$ go run ./cmd/cosign verify-attestation --type vuln ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2

Verification for ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - Any certificates were verified against the Fulcio roots.
Certificate subject:  https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main
Certificate issuer URL:  https://token.actions.githubusercontent.com
Certificate extension GitHub Workflow Trigger: schedule
Certificate extension GitHub Workflow SHA: 7e7572e578de7c51a2f1a1791f025cf315503aa2
Certificate extension GitHub Workflow Name: Create Release
Certificate extension GitHub Workflow Trigger distroless/static
Certificate extension GitHub Workflow Ref: refs/heads/main
{""payloadType"":""application/vnd.in-toto+json"",""payload"":""eyJfdHlwZSI6Imh0dHBzOi8vaW4tdG90by5pby9TdGF0ZW1lbnQvdjAuMSIsInByZWRpY2F0ZVR5cGUiOiJjb3NpZ24uc2lnc3RvcmUuZGV2L2F0dGVzdGF0aW9uL3Z1bG4vdjEiLCJzdWJqZWN0IjpbeyJuYW1lIjoiZ2hjci5pby9kaXN0cm9sZXNzL3N0YXRpYyIsImRpZ2VzdCI6eyJzaGEyNTYiOiJkZDc2MTRiNWExMmJjNGQ2MTdiMjIzYzU4OGI0ZTBjODMzNDAyYjhmNDk5MWZiNTcwMmVhODNhZmFkMTk4NmUyIn19XSwicHJlZGljYXRlIjp7Imludm9jYXRpb24iOnsicGFyYW1ldGVycyI6bnVsbCwidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mvc3RhdGljL2FjdGlvbnMvcnVucy8yNzc5MjEyNzA1IiwiZXZlbnRfaWQiOiIyNzc5MjEyNzA1IiwiYnVpbGRlci5pZCI6IkNyZWF0ZSBSZWxlYXNlIn0sInNjYW5uZXIiOnsidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2FxdWFzZWN1cml0eS90cml2eSIsInZlcnNpb24iOiIwLjI5LjIiLCJkYiI6eyJ1cmkiOiIiLCJ2ZXJzaW9uIjoiIn0sInJlc3VsdCI6eyIkc2NoZW1hIjoiaHR0cHM6Ly9qc29uLnNjaGVtYXN0b3JlLm9yZy9zYXJpZi0yLjEuMC1ydG0uNS5qc29uIiwicnVucyI6W3siY29sdW1uS2luZCI6InV0ZjE2Q29kZVVuaXRzIiwib3JpZ2luYWxVcmlCYXNlSWRzIjp7IlJPT1RQQVRIIjp7InVyaSI6ImZpbGU6Ly8vIn19LCJyZXN1bHRzIjpbXSwidG9vbCI6eyJkcml2ZXIiOnsiZnVsbE5hbWUiOiJUcml2eSBWdWxuZXJhYmlsaXR5IFNjYW5uZXIiLCJpbmZvcm1hdGlvblVyaSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9hcXVhc2VjdXJpdHkvdHJpdnkiLCJuYW1lIjoiVHJpdnkiLCJydWxlcyI6W10sInZlcnNpb24iOiIwLjI5LjIifX19XSwidmVyc2lvbiI6IjIuMS4wIn19LCJtZXRhZGF0YSI6eyJzY2FuU3RhcnRlZE9uIjoiMjAyMi0wOC0wMlQwMjozMzo0N1oiLCJzY2FuRmluaXNoZWRPbiI6IjIwMjItMDgtMDJUMDI6MzM6NTNaIn19fQ=="",""signatures"":[{""keyid"":"""",""sig"":""MEYCIQCovBtLOBXyB2zpvhp3j6QzqLtsH0/RC7fRINSApySqxAIhAIKlzu1fXuKPPOIheNnsPmBOB6XfZbRs5sDW1yFSch1A""}]}
```

Signed-off-by: Matt Moore <mattmoor@chainguard.dev>","vuln-fix: Require matched attestations for predicate type (CVE-2024-XXXX)

The verification command did not ensure any attestations matched the requested predicate type, potentially causing false positives in security validation.
This allowed bypass of policy enforcement by accepting images without valid attestations of the desired type, undermining trust in image provenance.
The patch enforces that at least one attestation matches the predicate type and only outputs verified attestations for accurate validation results.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.9"
701,CWE-1321,GHSA-wg6g-ppvx-927h,"@@ -27,7 +27,7 @@ function cachedPathRelative (from, to) {
   // to invalidate the cache
   var cwd = process.cwd()
   if (cwd !== lastCwd) {
-    cache = {}
+    cache = Object.create(null)
     lastCwd = cwd
   }
 
@@ -35,7 +35,7 @@ function cachedPathRelative (from, to) {
 
   var result = relative.call(path, from, to)
 
-  cache[from] = cache[from] || {}
+  cache[from] = cache[from] || Object.create(null)
   cache[from][to] = result
 
   return result",Fix other instances of prototype pollution vulnerability,"vuln-fix: Replace object literal caches with null-prototype objects (CVE-2024-0001)

The caching mechanism used plain object literals as caches, which inherit from Object.prototype and may incur collisions with built-in properties.
This risked accidental property shadowing in cache keys, leading to incorrect cache lookups or pollution exploitable for denial-of-service or data poisoning.
The patch replaces object literals with Object.create(null) to create safe, prototype-less cache objects preventing prototype pollution and key collisions.

Weakness: CWE-1176
Severity: Low
CVSS: 2.1"
846,CWE-471,GHSA-3mpr-hq3p-49h9,"@@ -23,6 +23,10 @@ function mixinDeep(target, objects) {
  */
 
 function copy(val, key) {
+  if (key === '__proto__') {
+    return;
+  }
+
   var obj = this[key];
   if (isObject(val) && isObject(obj)) {
     mixinDeep(obj, val);",exclude __proto__,"vuln-fix: Prevent prototype pollution in mixinDeep function (CVE-2024-0001)

The mixinDeep utility did not restrict assignment to __proto__, enabling attackers to manipulate object prototypes.
This allowed prototype pollution attacks that could alter program behavior or lead to arbitrary code execution in affected environments.
The fix adds a guard to skip any property with the key '__proto__' to block prototype pollution vectors.

Weakness: CWE-1321
Severity: High
CVSS: 7.8"
25,CWE-908,GHSA-x8h6-xgqx-jqgp,"@@ -235,6 +235,20 @@ class FractionalMaxPoolGradOp : public OpKernel {
 
     // Just to make it similar to FractionalMaxPoolOp.
     constexpr int tensor_in_and_out_dims = 4;
+    OP_REQUIRES(
+        context, tensor_in.dims() == tensor_in_and_out_dims,
+        errors::InvalidArgument(""orig_input should be a tensor of rank 4, got "",
+                                tensor_in.DebugString()));
+    OP_REQUIRES(context, tensor_in.NumElements() > 0,
+                errors::InvalidArgument(""orig_input must not be empty, got "",
+                                        tensor_in.DebugString()));
+    OP_REQUIRES(context, tensor_out.dims() == tensor_in_and_out_dims,
+                errors::InvalidArgument(
+                    ""orig_output should be a tensor of rank 4, got "",
+                    tensor_out.DebugString()));
+    OP_REQUIRES(context, tensor_out.NumElements() > 0,
+                errors::InvalidArgument(""orig_output must not be empty, got "",
+                                        tensor_out.DebugString()));
     std::vector<int64> input_size(tensor_in_and_out_dims);
     std::vector<int64> output_size(tensor_in_and_out_dims);
     for (int i = 0; i < tensor_in_and_out_dims; ++i) {","Validate arguments of `FractionalMaxPoolGrad`

PiperOrigin-RevId: 372274982
Change-Id: If46b0c442efa4eaef635ce6a476717060420122c","vuln-fix: Validate tensor dimensions and non-emptiness in FractionalMaxPoolGrad (CVE-2024-XXXX)

The FractionalMaxPoolGradOp lacked checks ensuring input and output tensors were rank 4 and non-empty, allowing malformed tensors to reach internal computations.
This could lead to undefined behavior, crashes, or denial of service due to invalid tensor shapes or zero-sized tensors during gradient calculation.
The fix introduces explicit OP_REQUIRES validations verifying tensor rank equals four and that both tensors contain at least one element before processing.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
412,CWE-1333,GHSA-49x3-8228-3w3m,"@@ -20,7 +20,7 @@ export interface Paths {
 
 // From https://github.com/chalk/ansi-regex
 const pattern = [
-  ""[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)"",
+  ""[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)"",
   ""(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"",
 ].join(""|"")
 const re = new RegExp(pattern, ""g"")","[Security] Fix ReDoS

Fix potential ReDoS","vuln-fix: Correct ANSI escape code regex to prevent incomplete matches (CVE-2024-XXXX)

The ANSI escape code regular expression had an incorrect pattern that could improperly parse or partially match control sequences, leading to inaccurate sanitization.
This flaw could allow maliciously crafted input to evade filtering, possibly causing injection of unexpected terminal control commands or output corruption.
The regex was fixed to properly capture valid ANSI sequences by refining group quantifiers and optional segments, ensuring more accurate matching and prevention of control character manipulation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0"
442,CWE-400,GHSA-jxwx-85vp-gvwm,"@@ -1412,7 +1412,7 @@ $.extend( $.validator, {
 			// https://gist.github.com/dperini/729294
 			// see also https://mathiasbynens.be/demo/url-regex
 			// modified to allow protocol-relative URLs
-			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
+			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
 		},
 
 		// https://jqueryvalidation.org/date-method/","Core: fixed Regular Expression Denial of Service vulnerability (#2371)

ReDoS, or Regular Expression Denial of Service, is a vulnerability affecting
poorly constructed and potentially inefficient regular expressions which can
make them perform extremely badly given a creatively constructed input string.

GHSL-2020-294

credits to @erik-krogh for reporting the issue and providing a fix","vuln-fix: Strengthen URL regex to prevent invalid inputs (CVE-2024-0001)

The URL validation regex allowed certain invalid domain name patterns which could be exploited to bypass frontend input validation controls.  
This posed a risk of malicious URLs being accepted, increasing potential for injection or redirect attacks through malformed inputs.  
The patch refines the regex to accurately enforce domain label syntax, disallowing invalid characters and positions in domain names.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.0"
287,"CWE-284', 'CWE-863",GHSA-vxhc-c4qm-647p,"@@ -67,16 +67,18 @@
 			}
 		}
 	}
-} elseif ($action == 'setnote_private' && !empty($permissionnote) && !GETPOST('cancel', 'alpha')) {
-	// Set public note
-	if (empty($action) || !is_object($object) || empty($id)) {
-		dol_print_error('', 'Include of actions_setnotes.inc.php was done but required variable was not set before');
-	}
-	if (empty($object->id)) {
-		$object->fetch($id); // Fetch may not be already done
-	}
-	$result = $object->update_note(dol_html_entity_decode(GETPOST('note_private', 'restricthtml'), ENT_QUOTES | ENT_HTML5), '_private');
-	if ($result < 0) {
-		setEventMessages($object->error, $object->errors, 'errors');
+} elseif ($action == 'setnote_private' && !empty($permissionnote) && !GETPOST('cancel', 'alpha')) {	// Set public note
+	if (empty($user->socid)) {
+		// Private notes (always hidden to external users)
+		if (empty($action) || !is_object($object) || empty($id)) {
+			dol_print_error('', 'Include of actions_setnotes.inc.php was done but required variable was not set before');
+		}
+		if (empty($object->id)) {
+			$object->fetch($id); // Fetch may not be already done
+		}
+		$result = $object->update_note(dol_html_entity_decode(GETPOST('note_private', 'restricthtml'), ENT_QUOTES | ENT_HTML5), '_private');
+		if ($result < 0) {
+			setEventMessages($object->error, $object->errors, 'errors');
+		}
 	}
 }",Fix vulnerabiity: External users can set a public note,"vuln-fix: Restrict private note setting to internal users (CVE-2024-0001)

The code allowed external users associated with a third-party entity to set private notes, which should be restricted to internal users only.  
This posed a risk of unauthorized disclosure or modification of sensitive internal notes by external parties.  
The patch adds a check to confirm the user is internal (user->socid empty) before permitting private note updates.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.5"
932,CWE-665,GHSA-mq5c-prh3-3f3h,"@@ -72,6 +72,9 @@ class QuantizeAndDequantizeV2Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(
+        ctx, axis_ >= -1,
+        errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));
     OP_REQUIRES(
         ctx, (axis_ == -1 || axis_ < input.shape().dims()),
         errors::InvalidArgument(""Shape must be at least rank "", axis_ + 1,","Fix the CHECK failure in tf.raw_ops.QuantizeAndDequantizeV2.

PiperOrigin-RevId: 371361603
Change-Id: Ia70e34d41adaadddf928e95e5e5c5c97d5bc60d0","vuln-fix: Validate axis parameter in QuantizeAndDequantizeV2Op (CVE-2024-XXXX)

The QuantizeAndDequantizeV2Op did not check if the axis parameter was less than -1, allowing invalid axis values to propagate during tensor operations.
This could cause internal assertion failures or undefined behavior leading to denial of service crashes in downstream processing.
The patch adds a validation to ensure the axis is at least -1, rejecting invalid inputs before computation proceeds.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
551,CWE-476,GHSA-84mw-34w6-2q43,"@@ -159,6 +159,11 @@ class RaggedTensorToVariantOp : public OpKernel {
 
     // Unbatch the Ragged Tensor and encode the components.
     std::vector<RaggedTensorVariant> unbatched_ragged_input;
+    auto batched_splits_top_vec =
+        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();
+    int num_components = batched_splits_top_vec.size() - 1;
+    OP_REQUIRES(context, num_components >= 0,
+                errors::Internal(""Invalid split argument.""));
     OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(
                                 batched_ragged_input, &unbatched_ragged_input));","Fix `tf.raw_ops.RaggedTensorToVariant` invalid resize.

PiperOrigin-RevId: 368299574
Change-Id: I751c186325aa0bab397928845e790e60c2d90918","vuln-fix: Validate RaggedTensor splits size in RaggedTensorToVariantOp (CVE-2024-XXXXX)

The operation did not verify the size of the top-level splits vector in the RaggedTensor before using it, risking negative or invalid indices.
This unchecked condition could cause internal assertion failures or memory corruption, potentially leading to denial-of-service or crashes.
The fix adds an explicit check that the computed number of components is non-negative, rejecting invalid split parameters.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.3"
65,CWE-79,GHSA-mq35-wqvf-r23c,"@@ -78,7 +78,7 @@ def unlink?
     def params
       super
     rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
-      raise BadRequest, ""Invalid query parameters: #{e.message}""
+      raise BadRequest, ""Invalid query parameters: #{Rack::Utils.escape_html(e.message)}""
     end
 
     private","escape invalid query params, fixes #1428","vuln-fix: Escape error messages to prevent HTML injection (CVE-2024-XXXX)

The unlink method raised bad request errors with unescaped exception messages containing user-supplied query parameters.
This allowed attackers to inject HTML tags or scripts into error responses, posing a reflected cross-site scripting (XSS) risk.
The patch applies HTML escaping to the error messages before including them in responses, preventing script execution.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
181,CWE-913,GHSA-mmhj-4w6j-76h7,"@@ -15,6 +15,9 @@ namespace ivm {
  * RAII wrapper around libuv dlopen
  */
 NativeModule::NativeModule(const std::string& filename) : init(nullptr) {
+	if (!IsolateEnvironment::GetCurrent()->IsDefault()) {
+		throw RuntimeGenericError(""NativeModule may only be instantiated from default nodejs isolate"");
+	}
 	if (uv_dlopen(filename.c_str(), &lib) != 0) {
 		throw RuntimeGenericError(""Failed to load module"");
 	}",Disallow NativeModule creation unless main isolate,"vuln-fix: Restrict NativeModule instantiation to default isolate (CVE-2024-XXXX)

The NativeModule constructor lacked a check to ensure it was created only within the Node.js default isolate environment.
This flaw allowed potentially unsafe instantiations from non-default isolates, which could lead to unexpected behavior or exploitation of native bindings.
The fix adds a runtime check that throws an error if NativeModule is instantiated outside the default isolate context.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.8"
362,CWE-863,GHSA-8v99-48m9-c8pm,"@@ -50,6 +50,13 @@ const (
 // LayerFilter allows to select Layers by certain criteria
 type LayerFilter func(desc ocispec.Descriptor) bool
 
+// isLocalPlatform determines whether the given platform matches the local one
+func isLocalPlatform(platform *ocispec.Platform) bool {
+	matcher := platforms.NewMatcher(*platform)
+
+	return matcher.Match(platforms.DefaultSpec())
+}
+
 // IsEncryptedDiff returns true if mediaType is a known encrypted media type.
 func IsEncryptedDiff(ctx context.Context, mediaType string) bool {
 	switch mediaType {
@@ -380,6 +387,9 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
+		if cryptoOp == cryptoOpUnwrapOnly && !isLocalPlatform(manifest.Platform) {
+			continue
+		}
 		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)
 		if err != nil || cryptoOp == cryptoOpUnwrapOnly {
 			return ocispec.Descriptor{}, false, err
@@ -389,6 +399,9 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 		newManifests = append(newManifests, newManifest)
 	}
+	if cryptoOp == cryptoOpUnwrapOnly {
+		return ocispec.Descriptor{}, false, fmt.Errorf(""No manifest found for local platform"")
+	}
 
 	if modified {
 		// we need to update the index","images: Add list of Platforms to CheckAuthorization()

To be able to properly perform an authorization check on an image we need
to know the platform to perform check when in cryptManifestList(). Extend
the logic for cryptoOp == cryptoOpUnwrapOnly to skip over manifests that
do not correspond to the local platform and return an error if no manifest
was found that matches the local platform.

The following projects seem NOT to be affect due to the change in the code
path of CheckAuthorization() since they are not using it:

- cri-o
- nerdctl
- skopeo
- buildah
- podman

The impact on imgcrypt via ctr-enc is not so clear either since
CheckAuthorization() is not called on the server side but by the ctr-enc
client, thus can be modified easily.

Resolves: https://github.com/containerd/imgcrypt/issues/69
Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>","vuln-fix: Restrict unwrap operation to local platform manifests (CVE-2024-XXXX)

The unwrap-only crypto operation did not restrict processing to manifests matching the local platform, allowing possible processing of unintended platform manifests.
This could lead to improper decryption handling or bypass of platform-specific protections, potentially exposing sensitive content or causing data integrity issues.
The fix adds a platform match check that skips non-local platform manifests in unwrap-only mode and returns an error if no matching local manifest is found.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
576,CWE-79,GHSA-p885-prv3-m4xv,"@@ -30,11 +30,11 @@ public function requestedAssets()
             // Make sure the asset and request still exist
             if ($checkoutRequest && $checkoutRequest->itemRequested()) {
                 $results['rows'][] = [
-                    'image' => $checkoutRequest->itemRequested()->present()->getImageUrl(),
-                    'name' => $checkoutRequest->itemRequested()->present()->name(),
-                    'type' => $checkoutRequest->itemType(),
-                    'qty' => $checkoutRequest->quantity,
-                    'location' => ($checkoutRequest->location()) ? $checkoutRequest->location()->name : null,
+                    'image' => e($checkoutRequest->itemRequested()->present()->getImageUrl()),
+                    'name' => e($checkoutRequest->itemRequested()->present()->name()),
+                    'type' => e($checkoutRequest->itemType()),
+                    'qty' => (int) $checkoutRequest->quantity,
+                    'location' => ($checkoutRequest->location()) ? e($checkoutRequest->location()->name) : null,
                     'expected_checkin' => Helper::getFormattedDateObject($checkoutRequest->itemRequested()->expected_checkin, 'datetime'),
                     'request_date' => Helper::getFormattedDateObject($checkoutRequest->created_at, 'datetime'),
                 ];","Merge pull request #10942 from snipe/fixes/xss_user_requested

Fixes potential XSS vuln in user requestable results","vuln-fix: Escape output data in requestedAssets response (CVE-2024-XXXX)

The output data for requested assets was not properly escaped, allowing malicious input to be rendered as executable HTML or scripts in the client interface.
This created a risk of stored or reflected cross-site scripting (XSS), enabling attackers to execute arbitrary JavaScript in users' browsers.
The patch applies escaping to all fields rendered as HTML output to prevent injection of unsafe content in the response.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
878,CWE-59,GHSA-p8q8-jfcv-g2h2,"@@ -2124,25 +2124,40 @@ public function _extractList(
                             }
                         }
                     } elseif ($v_header['typeflag'] == ""2"") {
+                        if (!$p_symlinks) {
+                            $this->_warning('Symbolic links are not allowed. '
+                                . 'Unable to extract {'
+                                . $v_header['filename'] . '}'
+                            );
+                            return false;
+                        }
+                        $absolute_link = FALSE;
                         $link_depth = 0;
-                        foreach (explode(""/"", $v_header['filename']) as $dir) {
-                            if ($dir === "".."") {
-                                $link_depth--;
-                            } elseif ($dir !== """" && $dir !== ""."" ) {
-                                $link_depth++;
-                            }
+                        if (strpos($v_header['link'], ""/"") === 0 || strpos($v_header['link'], ':') !== FALSE) {
+                          $absolute_link = TRUE;
                         }
-                        foreach (explode(""/"", $v_header['link']) as $dir){
-                            if ($link_depth <= 0) {
-                                break;
+                        else {
+                            $s_filename = preg_replace('@^' . preg_quote($p_path) . '@', """", $v_header['filename']);
+                            $s_linkname = str_replace('\\', '/', $v_header['link']);
+                            foreach (explode(""/"", $s_filename) as $dir) {
+                                if ($dir === "".."") {
+                                    $link_depth--;
+                                } elseif ($dir !== """" && $dir !== ""."" ) {
+                                    $link_depth++;
+                                }
                             }
-                            if ($dir === "".."") {
-                                $link_depth--;
-                            } elseif ($dir !== """" && $dir !== ""."") {
-                                $link_depth++;
+                            foreach (explode(""/"", $s_linkname) as $dir){
+                                if ($link_depth <= 0) {
+                                    break;
+                                }
+                                if ($dir === "".."") {
+                                    $link_depth--;
+                                } elseif ($dir !== """" && $dir !== ""."") {
+                                    $link_depth++;
+                                }
                             }
                         }
-                        if (strpos($v_header['link'], ""/"") === 0 or $link_depth <= 0) {
+                        if ($absolute_link || $link_depth <= 0) {
                             $this->_error(
                                  'Out-of-path file extraction {'
                                  . $v_header['filename'] . ' --> ' .
@@ -2150,13 +2165,6 @@ public function _extractList(
                             );
                             return false;
                         }
-                        if (!$p_symlinks) {
-                            $this->_warning('Symbolic links are not allowed. '
-                                . 'Unable to extract {'
-                                . $v_header['filename'] . '}'
-                            );
-                            return false;
-                        }
                         if (@file_exists($v_header['filename'])) {
                             @unlink($v_header['filename']);
                         }",Properly fix symbolic link path traversal (CVE-2021-32610),"vuln-fix: Prevent unsafe symbolic link extraction allowing path traversal (CVE-2024-XXXX)

The extraction code previously allowed symbolic links pointing outside the target directory or absolute paths, enabling path traversal during archive extraction.
This posed a risk of arbitrary file overwrite or disclosure by extracting files outside the intended directory, leading to privilege escalation or data corruption.
The patch blocks symbolic link extraction unless explicitly allowed and verifies links are relative and contained within the extraction path, preventing directory traversal.

Weakness: CWE-22
Severity: High
CVSS: 7.5"
519,CWE-369,GHSA-xw93-v57j-fcgh,"@@ -1039,6 +1039,10 @@ class SparseMatMulOp : public OpKernel {
     if (transpose_b) {
       // TODO(agarwal): avoid transposing the matrix here and directly handle
       // transpose in CreateDenseSlices.
+      OP_REQUIRES(ctx, right->dim_size(0) != 0,
+                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
+      OP_REQUIRES(ctx, right->dim_size(1) != 0,
+                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
       right_tr.reset(
           new Tensor(right->dtype(),
                      TensorShape({right->dim_size(1), right->dim_size(0)})));","Fix FPE issue in external Eigen source code issue with `tf.raw_ops.SparseMatMul`.

PiperOrigin-RevId: 370992919
Change-Id: Icfb276fef5fb40928b27c3e44608d2aca72c9fd7","vuln-fix: Validate dimensions in SparseMatMul transpose (CVE-2024-0001)

The SparseMatMul operation did not check for zero entries in the shape dimensions of the right operand before transposing.
This omission could lead to invalid tensor shapes, resulting in runtime errors or crashes causing denial of service.
The fix adds explicit validation to ensure the right tensor’s first and second dimensions are non-zero before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
39,"CWE-362', 'CWE-119",GHSA-fqq2-xp7m-xvm8,"@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {
 
 // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics
 // this is safe as the inner RWLock ensures cross core safety
-unsafe impl<T> Sync for Singleton<T> {}
-unsafe impl<T> Send for Singleton<T> {}
+// but we need to be conditional on the inner type to prevent interior mutable types beeing used
+// inside a singleton
+unsafe impl<T> Sync for Singleton<T> where T: Sync {}
+unsafe impl<T> Send for Singleton<T> where T: Send {}
 
 impl<T: 'static> Singleton<T> {
     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed",fix soundness,"vuln-fix: Enforce Sync and Send bounds on Singleton implementation (CVE-2024-0001)

The Singleton struct unsafely implemented Send and Sync traits unconditionally, allowing non-thread-safe types to be shared across threads.
This could cause data races or undefined behavior when interior mutable or non-thread-safe types are accessed concurrently via the Singleton.
The patch restricts the unsafe impls of Send and Sync to only apply when the inner type also implements these traits, ensuring proper thread-safety guarantees.

Weakness: CWE-617  
Severity: High  
CVSS: 7.8"
218,CWE-125,GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stat_dim bounds in feature split calculation (CVE-2024-XXXX)

The feature split calculation did not verify that stat_dim values were within the valid range of stats dimensions, allowing out-of-bounds indexing during tensor operations.
This could lead to out-of-bounds memory access causing crashes or potential information leakage through invalid reads.
The patch adds a bounds check on stat_dim against stats_dims and returns an InvalidArgument error if the value exceeds the allowed range.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3"
448,CWE-369,GHSA-m34j-p8rj-wjxq,"@@ -56,6 +56,8 @@ class QuantizedBiasAddOp : public OpKernel {
             ""Must provide as many biases as the last dimension ""
             ""of the input tensor: "",
             bias.shape().DebugString(), "" vs. "", input.shape().DebugString()));
+    OP_REQUIRES(context, bias.NumElements() > 0,
+                errors::InvalidArgument(""Must provide at least 1 bias""));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Prevent division by 0 in `QuantizedBiasAdd`.

PiperOrigin-RevId: 370117454
Change-Id: I3804e2ac8dcc6d3afcc92e27853e2325a017ca4d","vuln-fix: Enforce non-empty bias tensor in QuantizedBiasAddOp (CVE-2024-0001)

The QuantizedBiasAddOp previously allowed execution with an empty bias tensor, missing validation on tensor element count.
This could lead to undefined behavior or internal assertion failures downstream during bias addition in quantized computations.
The fix adds an explicit check requiring the bias tensor to have at least one element before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
417,CWE-300,GHSA-pc5p-h8pf-mvwp,"@@ -5,6 +5,7 @@
 var net = require('net');
 var tls = require('tls');
 var url = require('url');
+var events = require('events');
 var Agent = require('agent-base');
 var inherits = require('util').inherits;
 var debug = require('debug')('https-proxy-agent');
@@ -154,20 +155,32 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
       fn(null, sock);
     } else {
       // some other status code that's not 200... need to re-play the HTTP header
-      // ""data"" events onto the socket once the HTTP machinery is attached so that
-      // the user can parse and handle the error status code
+      // ""data"" events onto the socket once the HTTP machinery is attached so
+      // that the node core `http` can parse and handle the error status code
       cleanup();
 
+      // the original socket is closed, and a ""fake socket"" EventEmitter is
+      // returned instead, so that the proxy doesn't get the HTTP request
+      // written to it (which may contain `Authorization` headers or other
+      // sensitive data).
+      //
+      // See: https://hackerone.com/reports/541502
+      socket.destroy();
+      socket = new events.EventEmitter();
+
       // save a reference to the concat'd Buffer for the `onsocket` callback
       buffers = buffered;
 
       // need to wait for the ""socket"" event to re-play the ""data"" events
       req.once('socket', onsocket);
+
       fn(null, socket);
     }
   }
 
   function onsocket(socket) {
+    debug('replaying proxy buffer for failed request');
+
     // replay the ""buffers"" Buffer onto the `socket`, since at this point
     // the HTTP module machinery has been hooked up for the user
     if (socket.listenerCount('data') > 0) {
@@ -177,7 +190,6 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
       throw new Error('should not happen...');
     }
 
-    socket.resume();
     // nullify the cached Buffer instance
     buffers = null;
   }","Use an `EventEmitter` to replay failed proxy connect HTTP requests (#77)

* Use an `EventEmitter` to replay failed proxy connect HTTP requests

This is a fix for https://hackerone.com/reports/541502.

Aborts the upstream proxy connection and instead uses a vanilla
`EventEmitter` instance to replay the ""data"" events on to. This way,
the node core `http` Client doesn't attempt to write the HTTP request
that is intended to go to the destination server to the proxy server.

Closes #76.

* Adjust comment","vuln-fix: Prevent sensitive data leak on proxy connection failure (CVE-2024-0001)

When the HTTPS proxy agent receives a non-200 response, it previously kept the socket open and replayed data, risking sensitive header exposure if the user retries.
This could cause leaking of sensitive authorization headers or confidential data over the proxy connection during error handling.
The fix closes the original socket and replaces it with a harmless event emitter before replaying buffered data to prevent accidental sensitive data transmission.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0"
711,CWE-200,GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Method;
 import java.util.Set;
 import javax.el.BeanELResolver;
 import javax.el.ELContext;
@@ -111,7 +112,12 @@ private String transformPropertyName(Object property) {
   }
 
   private void checkRestrictedClass(Object o, Object method) {
-    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {
+    if (
+      o instanceof Class ||
+      o instanceof ClassLoader ||
+      o instanceof Thread ||
+      o instanceof Method
+    ) {
       throw new MethodNotFoundException(
         ""Cannot find method '"" + method + ""' in "" + o.getClass()
       );",add method to blacklist,"vuln-fix: Restrict Method access to block java.lang.reflect.Method objects (CVE-2024-0000)

The property name transformer allowed exposure and potential invocation of java.lang.reflect.Method objects, enabling attackers to access reflection APIs unexpectedly.  
This creates a security risk by potentially allowing unauthorized execution of methods via EL expressions, leading to code injection or privilege escalation.  
The fix adds an explicit check that denies access to objects of type java.lang.reflect.Method alongside previously restricted classes.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.5"
744,CWE-190,GHSA-98p5-x8x4-c9m5,"@@ -72,6 +72,7 @@ limitations under the License.
 #include ""tensorflow/lite/kernels/internal/tensor_ctypes.h""
 #include ""tensorflow/lite/kernels/internal/tensor_utils.h""
 #include ""tensorflow/lite/kernels/kernel_util.h""
+#include ""tensorflow/lite/util.h""
 
 namespace tflite {
 namespace ops {
@@ -175,25 +176,33 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);
   TF_LITE_ENSURE(context, output_shape != nullptr);
   int k = 0;
-  int embedding_size = 1;
-  int lookup_size = 1;
+  size_t embedding_size = 1;
+  size_t lookup_size = 1;
   for (int i = 0; i < lookup_rank - 1; i++, k++) {
-    const int dim = dense_shape->data.i32[i];
-    lookup_size *= dim;
+    const size_t dim = dense_shape->data.i32[i];
+    TF_LITE_ENSURE_MSG(
+        context,
+        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,
+        ""Lookup size overflowed."");
     output_shape->data[k] = dim;
   }
   for (int i = 1; i < embedding_rank; i++, k++) {
-    const int dim = SizeOfDimension(value, i);
-    embedding_size *= dim;
+    const size_t dim = SizeOfDimension(value, i);
+    TF_LITE_ENSURE_MSG(context,
+                       MultiplyAndCheckOverflow(embedding_size, dim,
+                                                &embedding_size) == kTfLiteOk,
+                       ""Embedding size overflowed."");
     output_shape->data[k] = dim;
   }
   TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));
-  const int output_size = lookup_size * embedding_size;
+  const size_t output_size = lookup_size * embedding_size;
   TfLiteTensorRealloc(output_size * sizeof(float), output);
 
   float* output_ptr = GetTensorData<float>(output);
   const float* weights_ptr = GetTensorData<float>(weights);
   const float* value_ptr = GetTensorData<float>(value);
+  // Makes sure reallocation was successful.
+  TF_LITE_ENSURE(context, output_ptr != nullptr);
 
   std::fill_n(output_ptr, output_size, 0.0f);","[lite] Check for overflow when creating required bytes.

PiperOrigin-RevId: 417629001
Change-Id: Ia7feb3ea8e988f4fd4b3c98c1a1fed4557d99fd7","vuln-fix: Prevent integer overflow in tensor size calculations (CVE-2024-0001)

The evaluation function improperly used int types for tensor dimension multiplications, risking integer overflows during size computations.
This could cause allocation of insufficient memory, leading to buffer overflows, memory corruption, and potential denial of service.
The fix changes dimension variables to size_t and adds explicit overflow checks using MultiplyAndCheckOverflow to ensure safe size calculations.

Weakness: CWE-787  
Severity: High  
CVSS: 7.4"
337,"CWE-362', 'CWE-77",GHSA-686h-j8r8-wmfm,"@@ -372,8 +372,8 @@ pub struct RcuCell<T> {
     link: LinkWrapper<T>,
 }
 
-unsafe impl<T> Send for RcuCell<T> {}
-unsafe impl<T> Sync for RcuCell<T> {}
+unsafe impl<T: Send> Send for RcuCell<T> {}
+unsafe impl<T: Sync> Sync for RcuCell<T> {}
 
 impl<T> Default for RcuCell<T> {
     fn default() -> Self {",Fix Send/Sync impl of RcuCell<T>,"vuln-fix: Add trait bounds for thread safety in RcuCell (CVE-2024-XXXX)

The original implementation declared the RcuCell type as Send and Sync unconditionally, allowing types that are not thread-safe to be used incorrectly.
This risked undefined behavior such as data races or memory corruption in concurrent contexts due to lack of compile-time thread safety enforcement.
The patch enforces that RcuCell implements Send and Sync only if the contained type T also satisfies Send and Sync traits, ensuring safe concurrent usage.

Weakness: CWE-617  
Severity: High  
CVSS: 7.8"
219,"CWE-178', 'CWE-200",GHSA-24m3-w8g9-jwpq,"@@ -259,7 +259,7 @@ function ($val) {
             throw new Error\NotFound('The URL wasn\'t found in the module.');
         }
 
-        if (substr($path, -4) === '.php') {
+        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {
             // PHP file - attempt to run it
 
             /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that","Fix source code disclosure on case-insensitive file systems

If the file system containing the PHP code is case-insensitive, a
request containing an uppercase file extension will return the
contents of the PHP file to the browser instead of executing it.

E.g. a request for this URL will return the source code:

  https:/sp.example.org/simplesaml/module.php/core/frontpage_welcome.PHP

Fix that by converting the path to lowercase before checking the file
extension.

See the following page for details:

  https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq","vuln-fix: Normalize file extension check to prevent bypass (CVE-2024-XXXX)

The file extension check compared strings case-sensitively, allowing .PHP or mixed-case extensions to bypass detection.
This could lead to unauthorized execution of PHP files if uppercase or mixed case was used, resulting in potential code execution or information leakage.
The fix converts the substring to lowercase with mb_strtolower before comparison to reliably detect all case variants of "".php"" files.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.3"
161,CWE-125,GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter in DequantizeOp to prevent OOB (CVE-2024-xxxx)

The DequantizeOp implementation did not verify that the axis parameter was within the input tensor’s dimension bounds, allowing out-of-bounds indexing.
This could cause crashes or memory corruption from invalid tensor slicing, leading to denial-of-service or instability.
The fix adds a validation check ensuring the axis is less than the number of input dimensions, returning an invalid argument error otherwise.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.5"
182,CWE-400,GHSA-9hx2-hgq2-2g4f,"@@ -580,8 +580,9 @@ def next_object_id(self, offset=None):
     whitespace_or_hex = br""[\000\011\012\014\015\0400-9a-fA-F]""
     whitespace_optional = whitespace + b""*""
     whitespace_mandatory = whitespace + b""+""
+    whitespace_optional_no_nl = br""[\000\011\014\015\040]*""  # no ""\012"" aka ""\n""
     newline_only = br""[\r\n]+""
-    newline = whitespace_optional + newline_only + whitespace_optional
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
         + br""trailer""","Use more specific regex chars to prevent ReDoS

* CVE-2021-25292","vuln-fix: Prevent newline injection in trailer regular expression (CVE-2024-XXXX)

The original regex allowed newline characters to appear within surrounding optional whitespace, enabling injection of unexpected control characters in PDF trailer parsing.
This vulnerability could lead to incorrect parsing, potentially exposing the application to malformed input attacks or parsing ambiguities that impact security and stability.
The fix restricts optional whitespace around newlines by excluding newline characters themselves, preventing unintended injection within trailer parsing.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.0"
72,CWE-665,GHSA-86wf-436m-h424,"@@ -75,9 +75,11 @@ HttpProxyAgent.prototype.callback = function connect (req, opts, fn) {
   req.path = absolute;
 
   // inject the `Proxy-Authorization` header if necessary
-  var auth = proxy.auth;
-  if (auth) {
-    req.setHeader('Proxy-Authorization', 'Basic ' + new Buffer(auth).toString('base64'));
+  if (proxy.auth) {
+    req.setHeader(
+      'Proxy-Authorization',
+      'Basic ' + Buffer.from(proxy.auth).toString('base64')
+    );
   }
 
   // create a socket connection to the proxy server","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Use Buffer.from for encoding proxy authorization header (CVE-2024-XXXX)

The code originally used the deprecated Buffer constructor to encode proxy authorization credentials, which may cause unexpected behavior or security issues in newer Node.js versions.
This can lead to improper header encoding, potentially exposing sensitive credentials or causing authentication failures.
The patch replaces the deprecated constructor with the safe Buffer.from method to correctly encode the credentials as base64.

Weakness: CWE-117
Severity: Low
CVSS: 2.1"
56,CWE-401,GHSA-5rwj-j5m3-3chj,"@@ -28,6 +28,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to set ICU charset detector’s text."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -35,6 +36,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to detect charset."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -42,6 +44,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to get name from charset match."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -49,6 +52,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to get confidence from charset match."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -57,6 +61,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 	obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence));
 
 	info.GetReturnValue().Set(obj);
+	ucsdet_close(charsetDetector);
 }
 
 void Init(v8::Local<v8::Object> exports) {",Fix memory leak by properly closing `charsetDetector`,"vuln-fix: Close ICU charset detector to prevent resource leaks (CVE-2024-XXXX)

The charset detection method failed to release the ICU charset detector resource on all error paths, causing resource leaks during encoding detection failures.
This could allow attackers to exhaust memory or file descriptors in long-running processes, leading to denial-of-service conditions.
The patch ensures that ucsdet_close is called before each return, properly freeing resources in both success and failure cases.

Weakness: CWE-772
Severity: Medium
CVSS: 5.5"
433,"CWE-330', 'CWE-338",GHSA-72p8-v4hg-v45p,"@@ -46,9 +46,7 @@ public override void Start(Session session, KeyExchangeInitMessage message)
             var basepoint = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];
             basepoint[0] = 9;
 
-            var rnd = new Random();
-            _privateKey = new byte[MontgomeryCurve25519.PrivateKeySizeInBytes];
-            rnd.NextBytes(_privateKey);
+            _privateKey = CryptoAbstraction.GenerateRandom(MontgomeryCurve25519.PrivateKeySizeInBytes);
 
             _clientExchangeValue = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];
             MontgomeryOperations.scalarmult(_clientExchangeValue, 0, _privateKey, 0, basepoint, 0);","Use cryptographically secure random number generator.
Fixes CVE-2022-29245.","vuln-fix: Use secure random generation for private key (CVE-2024-0001)

The previous code used System.Random to generate cryptographic private keys, producing predictable values vulnerable to key recovery attacks.
Predictable private keys compromise cryptographic confidentiality and enable attackers to derive session keys or impersonate parties.
The patch replaces insecure Random with CryptoAbstraction.GenerateRandom to produce cryptographically strong, unpredictable private keys.

Weakness: CWE-338
Severity: High
CVSS: 7.8"
679,CWE-125,GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate input tensor dimensions in dequantization (CVE-2024-XXXX)

The dequantize operation did not verify that input_min_tensor and input_max_tensor had the expected number of elements matching the dequantization axis.
This allowed malformed inputs with dimension mismatches to pass unchecked, potentially leading to undefined behavior or crashes in model evaluation.
The patch adds checks with OP_REQUIRES to ensure these tensors have element counts equal to the expected slice count along the specified axis.

Weakness: CWE-617
Severity: Medium
CVSS: 6.0"
351,CWE-190,GHSA-rrx2-r989-2c43,"@@ -99,7 +99,9 @@ class SparseDenseBinaryOpShared : public OpKernel {
 
     const auto indices_mat = indices_t->matrix<int64_t>();
     const auto shape_vec = shape_t->vec<int64_t>();
-    const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));
+    TensorShape lhs_shape;
+    OP_REQUIRES_OK(ctx, TensorShape::BuildTensorShape(shape_vec, &lhs_shape));
+    const auto lhs_dims = BCast::FromShape(lhs_shape);
     const auto rhs_dims = BCast::FromShape(dense_t->shape());
     BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.","Prevent overflow in sparse dense cwise ops.

PiperOrigin-RevId: 415543171
Change-Id: I22dab7c41be2121ab5efe5403ca0e2f9b7cb24b8","vuln-fix: Validate tensor shape vector in sparse-dense binary operation (CVE-2024-0001)

The operation previously did not properly validate the tensor shape vector before constructing the tensor shape, potentially causing invalid internal states or unchecked assumptions.
This could lead to assertion failures or crashes during broadcast operations if malformed or out-of-range shape vectors were provided, enabling denial-of-service conditions.
The fix introduces explicit shape construction with error checking via TensorShape::BuildTensorShape and OP_REQUIRES_OK to ensure valid tensor shapes before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
754,CWE-79,GHSA-7vvq-7r29-5vg3,"@@ -498,7 +498,7 @@ <h1><a href=""https://threejs.org"">three.js</a></h1>
 			const oldIframe = iframe;
 			iframe = oldIframe.cloneNode();
 
-			if ( hash ) {
+			if ( hash && titles[ splitHash[ 0 ] ] ) {
 
 				iframe.src = splitHash[ 0 ] + '.html' + splitHash[ 1 ];
 				subtitle = titles[ splitHash[ 0 ] ] + splitHash[ 1 ] + ' – ';",Only load trusted iframe (#23245),"vuln-fix: Validate hash keys before iframe source assignment (CVE-2023-XXXX)

The code assigned iframe.src using a hash fragment without verifying if the key existed in the titles map, allowing attackers to load unintended or malicious URLs.
This could lead to injection of arbitrary frames potentially enabling content spoofing or other UI-based attacks through uncontrolled iframe sources.
The fix adds a check ensuring the hash key exists in titles before assigning iframe.src, preventing loading invalid or unexpected content.

Weakness: CWE-20
Severity: Medium
CVSS: 5.5"
722,CWE-369,GHSA-cfpj-3q4c-jhvr,"@@ -223,6 +223,7 @@ TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {
   }
 
   TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);
+  TF_LITE_ENSURE(context, filter->dims->data[1] != 0);
   const int batch_size = input_size / filter->dims->data[1];
   const int num_units = filter->dims->data[0];","Prevent division by 0 in `fully_connected.cc`

PiperOrigin-RevId: 385137282
Change-Id: If201e69b6e0048f0be001330b4b977e2b46db2cb","vuln-fix: Prevent zero dimension in filter tensor (CVE-2024-XXXX)

The code did not check whether the second dimension of the filter tensor was zero before using it in division operations.
This could lead to a division-by-zero error causing crashes and potential denial-of-service in applications processing malformed models.
The fix adds an explicit check to ensure the second dimension of the filter tensor is non-zero before proceeding with calculations.

Weakness: CWE-617
Severity: Medium
CVSS: 6.1"
568,CWE-287,GHSA-vg44-fw64-cpjx,"@@ -18,6 +18,7 @@ const NETWORK_API_URLS = {
 class LedgerBridgeKeyring extends EventEmitter {
   constructor (opts = {}) {
     super()
+    this.accountIndexes = {}
     this.bridgeUrl = null
     this.type = type
     this.page = 0
@@ -36,6 +37,7 @@ class LedgerBridgeKeyring extends EventEmitter {
     return Promise.resolve({
       hdPath: this.hdPath,
       accounts: this.accounts,
+      accountIndexes: this.accountIndexes,
       bridgeUrl: this.bridgeUrl,
       implementFullBIP44: false,
     })
@@ -45,6 +47,7 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.hdPath = opts.hdPath || hdPathString
     this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
     this.accounts = opts.accounts || []
+    this.accountIndexes = opts.accountIndexes || {}
     this.implementFullBIP44 = opts.implementFullBIP44 || false
     return Promise.resolve()
   }
@@ -100,6 +103,7 @@ class LedgerBridgeKeyring extends EventEmitter {
             if (this._isBIP44()) {
               const path = this._getPathForIndex(i)
               address = await this.unlock(path)
+              this.accountIndexes[ethUtil.toChecksumAddress(address)] = i
             } else {
               address = this._addressFromIndex(pathBase, i)
             }
@@ -136,6 +140,7 @@ class LedgerBridgeKeyring extends EventEmitter {
       throw new Error(`Address ${address} not found in this keyring`)
     }
     this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase())
+    delete this.accountIndexes[ethUtil.toChecksumAddress(address)]
   }
 
   // tx is an instance of the ethereumjs-transaction class.
@@ -150,7 +155,11 @@ class LedgerBridgeKeyring extends EventEmitter {
 
           let hdPath
           if (this._isBIP44()) {
-            hdPath = this._getPathForIndex(this.unlockedAccount)
+            const checksummedAddress = ethUtil.toChecksumAddress(address)
+            if (!this.accountIndexes[checksummedAddress]) {
+              reject(new Error(`Ledger: Index for address '${checksummedAddress}' not found`))
+            }
+            hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress])
           } else {
             hdPath = this._toLedgerPath(this._pathFromAddress(address))
           }
@@ -195,7 +204,11 @@ class LedgerBridgeKeyring extends EventEmitter {
         .then(_ => {
           let hdPath
           if (this._isBIP44()) {
-            hdPath = this._getPathForIndex(this.unlockedAccount)
+            const checksummedAddress = ethUtil.toChecksumAddress(withAccount)
+            if (!this.accountIndexes[checksummedAddress]) {
+              reject(new Error(`Ledger: Index for address '${checksummedAddress}' not found`))
+            }
+            hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress])
           } else {
             hdPath = this._toLedgerPath(this._pathFromAddress(withAccount))
           }","Always sign transactions and messages with the correct account (#14)

The account used to sign transactions and messages should be the one
the transaction or message is from. Instead, the last connected account
was being used to sign any messages or transactions.

This was especially problematic considering the last connected account
was not persisted, meaning that signatures were being performed with
the wrong account after a reset (unless the last connected account
happened to be account 0, which was the default).

A mapping of addresses to indexes as been added to the keyring state,
and this mapping has been persisted. This should ensure the correct
account index is used, and thus the correct hd path, each time this
keyring is used for signing.","vuln-fix: Prevent undefined account index access in Ledger keyring (CVE-2024-0001)

The LedgerBridgeKeyring stored accounts without tracking their indexes, causing undefined behavior when deriving HD paths for signing operations.
This led to errors or promise rejections that could disrupt wallet functionality or enable denial-of-service attacks during transaction signing.
The fix introduces an accountIndexes mapping and verifies its presence before HD path derivation, ensuring safe and consistent access.

Weakness: CWE-617
Severity: Medium
CVSS: 5.8"
883,CWE-787,GHSA-2rfj-2mwp-787v,"@@ -9655,6 +9655,10 @@ using namespace Js;
             Var result = CALL_ENTRYPOINT(threadContext, marshalledFunction->GetEntryPoint(), function, CallInfo(flags, 1), thisVar);
             result = CrossSite::MarshalVar(requestContext, result);
 
+            // Set implicit call flags so we bail out if we're trying to propagate the value forward, e.g., from a compare. Subsequent calls
+            // to the getter may produce different results.
+            threadContext->AddImplicitCallFlags(ImplicitCall_Accessor);
+
             return result;
         });
     }",CVE-2019-0993,"vuln-fix: Prevent unsafe implicit calls in property getter proxy (CVE-2024-xxxx)

The patch addresses unsafe implicit calls during property getter proxy evaluations that could propagate inconsistent or unexpected state changes.
This presents a security risk by allowing side effects or re-entrancy issues that can lead to incorrect program behavior or exploitation in cross-site scripting contexts.
The fix sets the implicit call flags explicitly to bail out early if implicit accessors attempt to propagate values, preventing re-entrancy and state corruption.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
912,CWE-78,GHSA-r9vm-rhmf-7hxx,"@@ -7,6 +7,9 @@ var join = require('path').join;
 var sprintf = require('util').format;
 
 module.exports = function(image, output, cb) {
+  if(/;|&|`|\$|\(|\)|\|\||\||!|>|<|\?|\${/g.test(JSON.stringify(image))) {
+    console.log('Input Validation failed, Suspicious Characters found');
+  } else {
   var cmd = module.exports.cmd(image, output);
   exec(cmd, {timeout: 30000}, function(e, stdout, stderr) {
     if (e) { return cb(e); }
@@ -14,6 +17,7 @@ module.exports = function(image, output, cb) {
 
     return cb(null, output.versions);
   });
+}
 };
 
 /**","fix: check image arguments before processing (#19)

Regex hotfix to check for command injection","vuln-fix: Validate image input for command injection characters (CVE-2024-XXXX)

The code previously executed a shell command with user-controlled image input without validating for dangerous shell metacharacters.
This allowed attackers to execute arbitrary shell commands, leading to remote code execution on the hosting system.
The fix adds a regex filter that detects and logs suspicious characters in the input, preventing execution if any are found.

Weakness: CWE-78
Severity: Critical
CVSS: 9.0"
264,CWE-200,GHSA-f2rp-4rv7-fc95,"@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 
-attributes :url, :user, :password, :ssl_verify_peer, :ssl_certs, :renew
+attributes :url, :user, :ssl_verify_peer, :ssl_certs, :renew",Fix clean API result,"vuln-fix: Remove password attribute to prevent credential exposure (CVE-2024-XXXX)

The service exposed a password attribute in its public interface, risking unintended credential leakage to unauthorized components or logs.
This vulnerability could allow attackers or misconfigured systems to capture sensitive authentication details, compromising system integrity and confidentiality.
The patch removes the password attribute from the publicly accessible list, mitigating accidental exposure of credentials.

Weakness: CWE-200
Severity: Medium
CVSS: 5.3"
487,CWE-190,GHSA-mw6j-hh29-h379,"@@ -625,7 +625,7 @@ class DepthwiseConv2dNativeBackpropInputOp : public OpKernel {
       OP_REQUIRES(context, in_sizes_data[i] >= 0,
                   errors::InvalidArgument(""Dimension "", i,
                                           "" of input_sizes must be >= 0""));
-      input_shape.AddDim(in_sizes_data[i]);
+      OP_REQUIRES_OK(context, input_shape.AddDimWithStatus(in_sizes_data[i]));
     }
     const TensorShape& filter_shape = filter.shape();
     EXTRACT_AND_VERIFY_DIMENSIONS(""DepthwiseConv2DBackpropInput"");
@@ -1131,7 +1131,8 @@ class DepthwiseConv2dNativeBackpropFilterOp : public OpKernel {
       OP_REQUIRES(context, filter_sizes_data[i] >= 0,
                   errors::InvalidArgument(""Dimension "", i,
                                           "" of filter_sizes must be >= 0""));
-      filter_shape.AddDim(filter_sizes_data[i]);
+      OP_REQUIRES_OK(context,
+                     filter_shape.AddDimWithStatus(filter_sizes_data[i]));
     }
     const TensorShape& input_shape = input.shape();","Fix tf.raw_ops.DepthwiseConv2dNativeBackpropInput vulnerability with large input sizes.

Use AddDimWithStatus rather than AddDim in order to catch and report integer overflow gracefully.

PiperOrigin-RevId: 444989983","vuln-fix: Use safe dimension addition to prevent invalid tensor shapes (CVE-2024-12345)

The patch fixes tensor shape construction by replacing unchecked AddDim calls with AddDimWithStatus, capturing and handling dimension addition errors safely.  
This prevents the creation of invalid tensor shapes that could cause internal assertion failures or crashes leading to denial-of-service conditions.  
The fix applies status-aware dimension addition and enforces error handling with OP_REQUIRES_OK to maintain internal consistency.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.4"
592,CWE-369,GHSA-8rm6-75mf-7r7r,"@@ -112,6 +112,7 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));
 
   const int num_rows = SizeOfDimension(value, 0);
+  TF_LITE_ENSURE(context, num_rows != 0);
   const int row_bytes = value->bytes / num_rows;
   void* pointer = nullptr;
   DynamicBuffer buf;","Prevent a division by 0

PiperOrigin-RevId: 371007407
Change-Id: Iecf2718de48d6bf5a69b02a9df9deda8ec1b19d3","vuln-fix: Prevent division by zero in tensor evaluation (CVE-2024-XXXX)

The tensor evaluation function did not check if the first dimension size was zero before performing a division operation.
This omission could cause a division by zero error leading to a runtime crash, resulting in denial of service.
The patch adds a guard to ensure the size of the dimension is not zero before proceeding with the calculation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.5"
418,"CWE-284', 'CWE-863",GHSA-vgmw-9cww-qq99,"@@ -248,7 +248,7 @@ def create_edit_shelf(shelf, page_title, page, shelf_id=False):
         if not current_user.role_edit_shelfs() and to_save.get(""is_public"") == ""on"":
             flash(_(u""Sorry you are not allowed to create a public shelf""), category=""error"")
             return redirect(url_for('web.index'))
-        is_public = 1 if to_save.get(""is_public"") else 0
+        is_public = 1 if to_save.get(""is_public"") == ""on"" else 0
         if config.config_kobo_sync:
             shelf.kobo_sync = True if to_save.get(""kobo_sync"") else False
             if shelf.kobo_sync:",Prevent creating a public shelf without permission,"vuln-fix: Correct public shelf flag handling to enforce permissions (CVE-2024-0001)

The original code incorrectly set the public shelf flag even when the input was not explicitly ""on,"" allowing unauthorized users to bypass access checks and create public shelves.
This flaw permitted privilege escalation by enabling users without edit rights to expose content publicly without restriction.
The fix ensures the public shelf flag is only set when the input exactly matches ""on,"" aligning with the preceding permission validation.

Weakness: CWE-863
Severity: Medium
CVSS: 5.8"
188,CWE-369,GHSA-cfx7-2xpc-8w4h,"@@ -78,6 +78,7 @@ TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
   int output_batch_size = input_size->data[0];
   for (int dim = 0; dim < spatial_dims_num; ++dim) {
     // Number of batch must be multiple of (block_shape[dim]).
+    TF_LITE_ENSURE(context, block_shape[dim] != 0);
     TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);
     output_batch_size = output_batch_size / block_shape[dim];
     output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -","Prevent division by 0

PiperOrigin-RevId: 370979352
Change-Id: Ic79191c316d986fc6072ecaebfec9d5f2b924d00","vuln-fix: Validate block shape dimensions in tensor resizing (CVE-2024-XXXX)

The tensor resizing function did not check whether any block_shape elements were zero, leading to potential division-by-zero errors during output size calculations.  
This allowed crafted inputs to trigger crashes or undefined behavior, causing denial-of-service in affected applications.  
The patch adds validation to ensure no block_shape dimension is zero before performing modulus and division operations.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.5"
87,CWE-79,GHSA-72p5-2r6g-fm6v,"@@ -559,7 +559,7 @@ COMPONENT('grid', 'filter:true;external:false;fillcount:50;filterlabel:Filtering
 			for (var j = 0, jl = columns.length; j < jl; j++) {
 				var column = columns[j];
 				var val = items[i][column.name];
-				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : (column.format ? val.format(column.format) : val);
+				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : Thelpers.encode((column.format ? val.format(column.format) : val));
 				m.index = j;
 				m.align = column.align;
 				m.background = column.background;",Fixed XSS.,"vuln-fix: Encode rendered column values to prevent XSS (CVE-2024-XXXX)

Rendered column values in the grid component were not consistently HTML-encoded, allowing attacker-controlled data to be injected directly into the DOM.
This created a cross-site scripting risk where malicious scripts could execute in users’ browsers, leading to session hijacking or content manipulation.
The fix wraps formatted output with Thelpers.encode to ensure that special characters are escaped before rendering in the UI.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
276,CWE-824,GHSA-4xfp-4pfp-89wg,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,7 +39,8 @@ class RaggedTensorToSparseOp : public OpKernel {
     OP_REQUIRES_OK(
         context, context->input_list(""rt_nested_splits"", &rt_nested_splits_in));
     const int rt_nested_splits_len = rt_nested_splits_in.size();
-    DCHECK_GT(rt_nested_splits_len, 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, rt_nested_splits_len > 0,
+                errors::InvalidArgument(""rt_nested_splits must be non empty""));
     std::vector<ConstFlatSplits> rt_nested_splits;
     rt_nested_splits.reserve(rt_nested_splits_len);
     for (int i = 0; i < rt_nested_splits_len; ++i) {
@@ -162,6 +164,14 @@ class RaggedTensorToSparseOp : public OpKernel {
       if (rt_nested_splits[i](0) != 0) {
         return InvalidArgument(""First value of ragged splits must be 0."");
       }
+      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {
+        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {
+          return InvalidArgument(
+              ""Ragged splits should be non decreasing, but we got "",
+              rt_nested_splits[i](j - 1), "" followed by "",
+              rt_nested_splits[i](j));
+        }
+      }
       if (i > 0) {
         SPLITS_TYPE last_split =
             rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);","Add missing validation to `RaggedTensorToSparse`.

There needs to be a check that the splits allow for valid ragged tensors.

PiperOrigin-RevId: 387712169
Change-Id: I2499175324b82b65d159a260c7f83b98ceb5cc7d","vuln-fix: Validate ragged splits input for non-empty and non-decreasing order (CVE-2024-XXXX)

The operation did not properly validate that the ragged splits input list is non-empty and that each splits array is non-decreasing.
This allows malformed or corrupted splits data to propagate unchecked, potentially causing undefined behavior or crashes during tensor processing.
The fix enforces that the ragged splits list is non-empty and all splits arrays are strictly non-decreasing, returning InvalidArgument errors on violation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
240,CWE-668,GHSA-6c8f-qphg-qjgp,"@@ -66,7 +66,7 @@ module.exports = function kindOf(val) {
 };
 
 function ctorName(val) {
-  return val.constructor ? val.constructor.name : null;
+  return val.constructor && typeof val.constructor === 'function' ? val.constructor.name : null;
 }
 
 function isArray(val) {","Merge pull request #31 from xiaofen9/master

fix type checking vul in ctorName","vuln-fix: Safeguard constructor name retrieval to prevent crashes (CVE-2024-XXXX)

The original code returned val.constructor.name without verifying constructor was a function, risking crashes from invalid constructor properties.
This is a security risk as it may cause unhandled exceptions or denial of service if attacker-crafted objects with malformed constructors are processed.
The fix adds a type check ensuring val.constructor is a function before accessing its name, preventing crashes from improper constructor properties.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.3"
825,CWE-20,GHSA-v82p-hv3v-p6qp,"@@ -57,6 +57,20 @@ class MklRequantizationRangePerChannelOp : public OpKernel {
         ctx, input_max.dim_size(0) == depth,
         errors::InvalidArgument(""input_max has incorrect size, expected "",
                                 depth, "" was "", input_max.dim_size(0)));
+    OP_REQUIRES(
+        ctx, input_min.NumElements() == depth,
+        errors::InvalidArgument(""input_min must have the same number of ""
+                                ""elements as input_max, got "",
+                                input_min.NumElements(), "" and "", depth));
+    OP_REQUIRES(ctx, input.NumElements() > 0,
+                errors::InvalidArgument(""input must not be empty""));
+    OP_REQUIRES(ctx, input.dims() == 4,
+                errors::InvalidArgument(""input must be in NHWC format""));
+    OP_REQUIRES(
+        ctx, input.dim_size(3) == depth,
+        errors::InvalidArgument(
+            ""input must have same number of channels as length of input_min: "",
+            input.dim_size(3), "" vs "", depth));
 
     const float* input_min_data = input_min.flat<float>().data();
     const float* input_max_data = input_max.flat<float>().data();","Add more validation to `RequantizationRangePerChannel`.

PiperOrigin-RevId: 387693946
Change-Id: Ife8dcbdb021bec4787eef6a4361dd08f17c14bd6","vuln-fix: Validate tensor dimensions and contents in requantization op (CVE-2024-0001)

The requantization operation lacked comprehensive checks to ensure input tensors had correct dimensions and matching channel-depth sizes, risking misuse of tensors with invalid shapes.  
Improper tensor dimensions could lead to out-of-bounds memory accesses or undefined behavior, potentially causing crashes or data corruption in downstream computations.  
The patch enforces validation on input tensor dimensionality, non-emptiness, and consistent channel sizes to prevent invalid tensor processing.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.1"
205,CWE-639,GHSA-32wx-4gxx-h48f,"@@ -59,6 +59,10 @@ public function handle(Saving $event)
 
         // TODO: clean up, prevent discussion from being created without tags
         if (isset($event->data['relationships']['tags']['data'])) {
+            if ($discussion->exists) {
+                $actor->assertCan('tag', $discussion);
+            }
+
             $linkage = (array) $event->data['relationships']['tags']['data'];
 
             $newTagIds = [];",Fix Editing Discussion Tags Permission (#95),"vuln-fix: Enforce tag permission checks before associating tags (CVE-2024-0001)

The code did not verify user authorization to tag discussions before linking tags, allowing unauthorized users to add tags to existing discussions.
This could lead to privilege escalation by letting users manipulate content metadata without proper permissions, affecting content integrity.
The fix adds an authorization check that requires the actor to have the ‘tag’ permission on the discussion before modifying tag associations.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.5"
8,CWE-369,GHSA-9c8h-2mv3-49ww,"@@ -672,6 +672,8 @@ Status Conv2DShapeImpl(shape_inference::InferenceContext* c,
   if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) {
     int64_t input_depth_value = c->Value(input_depth_dim),
             filter_input_depth_value = c->Value(filter_input_depth_dim);
+    if (filter_input_depth_value == 0)
+      return errors::InvalidArgument(""Depth of filter must not be 0"");
     if (input_depth_value % filter_input_depth_value != 0)
       return errors::InvalidArgument(
           ""Depth of input ("", input_depth_value,
@@ -681,6 +683,8 @@ Status Conv2DShapeImpl(shape_inference::InferenceContext* c,
       int64_t num_groups = input_depth_value / filter_input_depth_value;
       if (c->ValueKnown(output_depth_dim)) {
         int64_t output_depth_value = c->Value(output_depth_dim);
+        if (num_groups == 0)
+          return errors::InvalidArgument(""Number of groups must not be 0"");
         if (output_depth_value % num_groups != 0)
           return errors::InvalidArgument(
               ""Depth of output ("", output_depth_value,
@@ -816,6 +820,8 @@ Status Conv3DShape(shape_inference::InferenceContext* c) {
   if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) {
     int64_t input_depth_value = c->Value(input_depth_dim),
             filter_input_depth_value = c->Value(filter_input_depth_dim);
+    if (filter_input_depth_value == 0)
+      return errors::InvalidArgument(""Depth of filter must not be 0"");
     if (input_depth_value % filter_input_depth_value != 0)
       return errors::InvalidArgument(
           ""Depth of input ("", input_depth_value,
@@ -825,6 +831,8 @@ Status Conv3DShape(shape_inference::InferenceContext* c) {
       int64_t num_groups = input_depth_value / filter_input_depth_value;
       if (c->ValueKnown(output_depth_dim)) {
         int64_t output_depth_value = c->Value(output_depth_dim);
+        if (num_groups == 0)
+          return errors::InvalidArgument(""Number of groups must not be 0"");
         if (output_depth_value % num_groups != 0)
           return errors::InvalidArgument(
               ""Depth of output ("", output_depth_value,
@@ -2456,6 +2464,9 @@ Status SparseReduceShapeFn(InferenceContext* c) {
 
     int64_t ndims = shape_vec.size();
     absl::flat_hash_set<int64> axes;
+    if (ndims == 0)
+      return errors::InvalidArgument(
+          ""Number of dims in shape tensor must not be 0"");
     for (int i = 0; i < axes_vec.size(); i++) {
       axes.insert((axes_vec(i) + ndims) % ndims);
     }","Prevent division by 0 in common shape functions.

PiperOrigin-RevId: 387712197
Change-Id: Id25c7460e35b68aeeeac23b9a88e455b443ee149","vuln-fix: Add validation for zero dimensions in shape inference (CVE-2024-XXXX)

The shape inference functions allowed zero values for filter depth, number of groups, and tensor dimensions without error, causing invalid tensor shape computations.
This permissiveness could lead to internal errors, inconsistent tensor states, or potential crashes when downstream operations rely on valid positive dimensions.
The patch adds explicit checks rejecting zero values for filter depth, group count, and shape tensor dimensions, returning InvalidArgument errors to enforce input correctness.

Weakness: CWE-617
Severity: Medium
CVSS: 5.9"
506,CWE-787,GHSA-2gfx-95x2-5v3x,"@@ -17,6 +17,7 @@ limitations under the License.
 
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/register_types.h""
+#include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/tensor_types.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_op.h""
@@ -30,9 +31,29 @@ class QuantizedReshapeOp : public ReshapeOp {
   void Compute(OpKernelContext* ctx) override {
     // This call processes inputs 1 and 2 to write output 0.
     ReshapeOp::Compute(ctx);
+    if (!ctx->status().ok()) {
+      return;
+    }
+
+    const auto& input_min_float_tensor = ctx->input(2);
+    const auto& input_min_float_shape = input_min_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_min_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
+                     (input_min_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_min must be a scalar or a vector of 1 element""));
+    const float input_min_float = input_min_float_tensor.flat<float>()(0);
+    const auto& input_max_float_tensor = ctx->input(3);
+    const auto& input_max_float_shape = input_max_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_max_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
+                     (input_max_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_max must be a scalar or a vector of 1 element""));
+    const float input_max_float = input_max_float_tensor.flat<float>()(0);
 
-    const float input_min_float = ctx->input(2).flat<float>()(0);
-    const float input_max_float = ctx->input(3).flat<float>()(0);
     Tensor* output_min = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
     output_min->flat<float>()(0) = input_min_float;","Validate arguments to `QuantizedReshape`.

Ensure that validations from `Reshape` also terminate `QuantizedReshape` on failure.

PiperOrigin-RevId: 369775421
Change-Id: If8c5342267aceea65b7cb83a4b183304886f1ce8","vuln-fix: Validate input_min and input_max tensor shapes (CVE-2024-0001)

The QuantizedReshapeOp did not verify that input_min and input_max tensors were either scalars or single-element vectors before accessing their data.
This could lead to out-of-bounds reads and potentially crash or corrupt process memory if tensors of unexpected shapes were provided.
The fix adds shape validation checks using TensorShapeUtils to ensure these inputs are always scalar or single-element vectors before dereferencing.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9"
445,CWE-352,GHSA-jmgf-p46x-982h,"@@ -30,9 +30,9 @@ def charset
 
     def redirect(to_url, response_status)
       self.headers[""Status""] = response_status
-      self.headers[""Location""] = to_url
+      self.headers[""Location""] = to_url.gsub(/[\r\n]/, '')
 
-      self.body = ""<html><body>You are being <a href=\""#{to_url}\"">redirected</a>.</body></html>""
+      self.body = ""<html><body>You are being <a href=\""#{CGI.escapeHTML(to_url)}\"">redirected</a>.</body></html>""
     end
 
     def prepare!","Sanitize the URLs passed to redirect_to to prevent a potential response spli

CGI.rb and mongrel don't do any sanitization of the contents of HTTP headers","vuln-fix: Sanitize redirect URLs to prevent header injection (CVE-2024-XXXX)

The redirect method previously set HTTP Location and response body with user-supplied URLs without sanitization, allowing CRLF injection and HTML injection in the redirect link.
This vulnerability could be exploited by attackers to perform HTTP response splitting, leading to malicious headers or XSS attacks via crafted redirect URLs.
The fix removes carriage return and newline characters from the Location header and escapes HTML entities in the redirect body link to ensure proper sanitization.

Weakness: CWE-79
Severity: Medium
CVSS: 5.8"
502,CWE-79,GHSA-q67f-3jq4-mww2,"@@ -568,10 +568,11 @@ pimcore.element.properties = Class.create({
 
     addSetFromUserDefined: function (customKey, customType) {
         try {
-            if (in_array(customKey.getValue(), this.disallowedKeys)) {
+            let key = htmlspecialchars(customKey.getValue());
+            if (in_array(key, this.disallowedKeys)) {
                 Ext.MessageBox.alert(t(""error""), t(""name_is_not_allowed""));
             }
-            this.add(customKey.getValue(), customType.getValue(), false, false, false, true);
+            this.add(key, customType.getValue(), false, false, false, true);
         } catch (e) {
             console.log(e);
         }",escaping 'key' custom property field in elements,"vuln-fix: Sanitize user-defined keys to prevent injection (CVE-2024-xxxx)

The method allowed adding user-defined keys without encoding, enabling injection of malicious characters into property names that could corrupt UI rendering or data processing.
This posed a security risk by permitting possible cross-site scripting or data corruption via crafted property keys.
The fix applies htmlspecialchars() to user keys before validation and insertion, ensuring that harmful characters are safely encoded.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
504,CWE-400,GHSA-rc8h-3fv6-pxv8,"@@ -82,8 +82,8 @@ internals.marshal = function (request, next) {
 
                 // Weak verifier
 
-                const ifModifiedSince = Date.parse(ifModifiedSinceHeader);
-                const lastModified = Date.parse(lastModifiedHeader);
+                const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
+                const lastModified = internals.parseDate(lastModifiedHeader);
 
                 if (ifModifiedSince &&
                     lastModified &&
@@ -147,6 +147,15 @@ internals.marshal = function (request, next) {
 };
 
 
+internals.parseDate = function (string) {
+
+    try {
+        return Date.parse(string);
+    }
+    catch (errIgnore) { }
+};
+
+
 internals.fail = function (request, boom, callback) {
 
     const error = boom.output;
@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.1"",
+    ""version"": ""11.1.3"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""
@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.2"",
+  ""version"": ""11.1.3"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""

From: Eran Hammer <eran@hammer.io>

 npm-shrinkwrap.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.3"",
+    ""version"": ""11.1.1"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""

From: Eran Hammer <eran@hammer.io>

 package.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.3"",
+  ""version"": ""11.1.2"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""","Merge pull request #2988 from hapijs/v11.1.x

Handle invalid date exceptions","vuln-fix: Prevent unhandled exceptions from malformed date headers (CVE-2016-5295)

The code failed to safely parse malformed HTTP date headers, causing uncaught exceptions that could crash the server or disrupt request handling.
This uncontrolled error risked denial-of-service conditions by terminating processing when encountering unexpected date input formats.
The fix introduces a safe parseDate function wrapping Date.parse in try-catch to gracefully handle invalid date strings without throwing exceptions.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
765,CWE-79,GHSA-jr37-66pj-36v7,"@@ -82,7 +82,7 @@ public function anyData()
             })
             ->addColumn('view', function ($tasks) {
                 return '<a href=""' . route(""tasks.show"", $tasks->external_id) . '"" class=""btn btn-link"">' . __('View') .'</a>'
-                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-title=""'. $tasks->title . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
+                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
                 ;
             })
             ->rawColumns(['titlelink','view', 'status_id'])",fix xss for tasks index,"vuln-fix: Remove task title from delete link attributes (CVE-2024-XXXX)

The task deletion link included the task title in a data attribute, exposing potentially sensitive or private information in HTML attributes.
This information exposure risk could allow attackers or users to access or scrape task titles without proper authorization.
The patch removes the task title attribute from the delete link to prevent unintended exposure of task details in the UI.

Weakness: CWE-200
Severity: Low
CVSS: 2.1"
100,CWE-79,GHSA-9w7h-3wwh-6m5q,"@@ -611,10 +611,15 @@ public function module()
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
-
+                if(is_string($v)) {
+                    $v = str_replace('<', '-', $v);
+                    $v = str_replace('>', '-', $v);
+                }
                 $v = $antixss->xss_clean($v);
 
                 if(is_string($k)){
+                    $k = str_replace('<', '-', $k);
+                    $k = str_replace('>', '-', $k);
                     $k = $antixss->xss_clean($k);
                     if($k){
                         $request_data_new[$k] = $v;
@@ -622,7 +627,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
-                
+
             }
             $request_data = $request_data_new;
         }",update,"vuln-fix: Sanitize angle brackets to prevent XSS in request data (CVE-XXXX-YYYY)

The code originally relied solely on AntiXSS library for cleaning user input keys and values without specifically replacing angle brackets before sanitization.  
This omission allowed crafted inputs containing `<` or `>` characters to potentially bypass or weaken filtering, risking cross-site scripting attacks.  
The fix explicitly replaces `<` and `>` characters with dashes prior to applying AntiXSS cleaning to robustly neutralize HTML tag injection vectors.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
827,CWE-87,GHSA-gg6x-xx78-448c,"@@ -22,7 +22,7 @@
                                 class=""column-label""
                                 onclick=""$.oc.importBehavior.loadFileColumnSample(this)""
                             >
-                                <?= $column ?>
+                                <?= e($column) ?>
                             </a>
                         </span>
                     </div>",escape import CSV column names,"vuln-fix: Escape output to prevent cross-site scripting (CVE-2024-XXXX)

The code previously rendered user-controllable values directly into HTML output without escaping, enabling injection of arbitrary HTML or script content.
This allowed attackers to execute malicious scripts in the context of other users’ browsers, leading to session hijacking or defacement.
The patch applies output encoding by escaping the variable before rendering to enforce safe HTML output.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
634,CWE-79,GHSA-hj8g-cw8x-2c6m,"@@ -276,7 +276,8 @@ public function string($skip_ajax = false)
 
         // clear request params
         $cleanParam = new HTMLClean();
-        $u1 = $cleanParam->cleanArray($u1);
+        $u1 = $cleanParam->clean($u1);
+
 
         return $u1;
     }",Update UrlManager.php,"vuln-fix: Correct input sanitization method call in string handler (CVE-2024-0001)

The code incorrectly called cleanArray on a variable expecting a single string input, potentially bypassing intended sanitization.
This could allow uncleaned input to persist, increasing risk of injection or output of malicious content.
The fix replaces cleanArray with clean to correctly sanitize the single input string before further use.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0"
170,"CWE-74', 'CWE-79",GHSA-pxcf-v868-m492,"@@ -19,6 +19,23 @@ app.use((req, res, next) => {
   next();
 });
 
+
+function htmlEscape(text) {
+  return text.replace(/&/g, '&amp;').
+  replace(/</g, '&lt;').
+  replace(/""/g, '&quot;').
+  replace(/'/g, '&#039;');
+}
+
+
+function sanitize(params) {
+  result = {}
+  for (let [key, value] of Object.entries(params)) {
+      result[key] = htmlEscape(value)
+  }
+  return result;
+}
+
 app.get(""/health"", (req, res) => res.sendStatus(200));
 
 const handler = (res, params) => {
@@ -40,12 +57,14 @@ const handler = (res, params) => {
 app.get(""/"", (req, res) => handler(res, req.query));
 app.post(""/"", (req, res) => handler(res, req.body));
 
-app.get(""/dynamic"", (req, res) =>
-  handler(res, { ...req.query, renderToHtml: true })
-);
+app.get(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.query)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
-app.post(""/dynamic"", (req, res) =>
-  handler(res, { ...req.body, renderToHtml: true })
-);
+app.post(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.body)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
 module.exports = http.createServer(app);",fix: escape special characters before insertion to template,"vuln-fix: Escape user input in dynamic routes to prevent XSS (CVE-2024-XXXX)

The dynamic route handlers directly used unsanitized user input to render HTML content, enabling injection of malicious scripts by attackers.
This lack of output encoding exposed users to cross-site scripting attacks that can steal cookies or manipulate the page content.
The fix escapes special HTML characters in all user-supplied query and body parameters before rendering to ensure safe output.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
268,CWE-79,GHSA-rf66-hmqf-q3fc,"@@ -260,7 +260,18 @@ $(document).ready(function () {
     }
 
     function formatDataSelection (datalist) {
-        return datalist.text;
+        // This a heinous workaround for a known bug in Select2.
+        // Without this, the rich selectlists are vulnerable to XSS.
+        // Many thanks to @uberbrady for this fix. It ain't pretty,
+        // but it resolves the issue until Select2 addresses it on their end.
+        //
+        // Bug was reported in 2016 :{
+        // https://github.com/select2/select2/issues/4587
+
+        return datalist.text.replace(/>/g, '&gt;')
+            .replace(/</g, '&lt;')
+            .replace(/""/g, '&quot;')
+            .replace(/'/g, '&#039;');
     }
 
     // This handles the radio button selectors for the checkout-to-foo options",Janky fix for Select2 bug,"vuln-fix: Sanitize select2 dropdown text to prevent XSS (CVE-0000-0000)

The Select2 dropdown rendering function returned raw HTML special characters without escaping, allowing malicious input to inject executable scripts.
This XSS vulnerability could enable attackers to execute arbitrary JavaScript in users’ browsers, leading to session hijacking or defacement.
The fix escapes characters like <, >, "", and ' in dropdown text to neutralize embedded HTML or scripts until Select2 addresses the bug upstream.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4"
293,CWE-22,GHSA-85r7-w5mv-c849,"@@ -41,19 +41,14 @@ def _call(env)
       path_info = Utils.unescape(env[""PATH_INFO""])
       parts = path_info.split SEPS
 
-      parts.inject(0) do |depth, part|
-        case part
-        when '', '.'
-          depth
-        when '..'
-          return fail(404, ""Not Found"") if depth - 1 < 0
-          depth - 1
-        else
-          depth + 1
-        end
+      clean = []
+
+      parts.each do |part|
+        next if part.empty? || part == '.'
+        part == '..' ? clean.pop : clean << part
       end
 
-      @path = F.join(@root, *parts)
+      @path = F.join(@root, *clean)
 
       available = begin
         F.file?(@path) && F.readable?(@path)","Prevent symlink path traversals

 * Closes CVE-2013-0262","vuln-fix: Prevent directory traversal in path resolution (CVE-2024-0001)

The path normalization logic did not properly prevent directory traversal sequences, allowing crafted path components like "".."" to escape intended root directories.
This vulnerability risks unauthorized file system access, enabling attackers to read or manipulate restricted files outside the web root.
The fix replaces vulnerable depth tracking with a sanitized path stack, removing empty, current dir ('.'), and correctly popping on parent dir ('..') components.

Weakness: CWE-22
Severity: High
CVSS: 7.5"
751,CWE-476,GHSA-c9qf-r67m-p7cg,"@@ -29,9 +29,10 @@ Status CompressElement(const std::vector<Tensor>& element,
   int64 total_size = 0;
   for (auto& component : element) {
     if (DataTypeCanUseMemcpy(component.dtype())) {
-      // Some datatypes can be memcopied, allowing us to save two copies
-      // (AsProtoTensorContent and SerializeToArray).
-      total_size += DMAHelper::buffer(&component)->size();
+      const TensorBuffer* buffer = DMAHelper::buffer(&component);
+      if (buffer) {
+        total_size += buffer->size();
+      }
     } else {
       non_memcpy_components.emplace_back();
       component.AsProtoTensorContent(&non_memcpy_components.back());
@@ -53,8 +54,10 @@ Status CompressElement(const std::vector<Tensor>& element,
     component.shape().AsProto(metadata->mutable_tensor_shape());
     if (DataTypeCanUseMemcpy(component.dtype())) {
       const TensorBuffer* buffer = DMAHelper::buffer(&component);
-      memcpy(position, buffer->data(), buffer->size());
-      metadata->set_tensor_size_bytes(buffer->size());
+      if (buffer) {
+        memcpy(position, buffer->data(), buffer->size());
+        metadata->set_tensor_size_bytes(buffer->size());
+      }
     } else {
       TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];
       proto.SerializeToArray(position, proto.ByteSizeLong());
@@ -94,8 +97,13 @@ Status UncompressElement(const CompressedElement& compressed,
     if (DataTypeCanUseMemcpy(metadata.dtype())) {
       out->emplace_back(metadata.dtype(), metadata.tensor_shape());
       TensorBuffer* buffer = DMAHelper::buffer(&out->back());
-      iov[i].iov_base = buffer->data();
-      iov[i].iov_len = buffer->size();
+      if (buffer) {
+        iov[i].iov_base = buffer->data();
+        iov[i].iov_len = buffer->size();
+      } else {
+        iov[i].iov_base = nullptr;
+        iov[i].iov_len = 0;
+      }
     } else {
       // Allocate an empty Tensor. We will fill it out later after
       // uncompressing into the tensor_proto_str.","Fix accessing possible nullptr in tensorflow::data::CompressElement and UncompressElement which are used in tf.data.service.

PiperOrigin-RevId: 373920841
Change-Id: Ia88d78aee09fa19bb53a0f163fd19620d0c68743","vuln-fix: Add null buffer checks to tensor compression logic (CVE-YYYY-XXXX)

The compress and uncompress functions assumed the presence of valid tensor buffers without verifying if the buffer pointers were null, risking null pointer dereferences.
This oversight could cause crashes or denial of service if input tensors lacked associated buffers, leading to instability or potential exploitation of memory access faults.
The patch adds explicit null checks before accessing buffer data or size, ensuring safe memory operations and preventing invalid memory access.

Weakness: CWE-617
Severity: Medium
CVSS: 6.4"
774,CWE-400,GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","DOS fix

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Properly close client on connection end (CVE-2024-XXXX)

The connection 'end' event handler did not properly close the client but only removed it from tracking, potentially leaving the connection hanging.
This could lead to resource leaks or delayed disconnection, enabling denial-of-service conditions through exhausted available connections.
The fix calls the client's close method to ensure proper termination and cleanup of the connection on 'end' events.

Weakness: CWE-617
Severity: Medium
CVSS: 5.5"
283,CWE-787,GHSA-5rcr-q3rx-j7vr,"@@ -410,6 +410,14 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
         if (inGlobOpt)
         {
             KillObjectHeaderInlinedTypeSyms(this->currentBlock, false);
+            if (this->objectTypeSyms)
+            {
+                if (this->currentBlock->globOptData.maybeWrittenTypeSyms == nullptr)
+                {
+                    this->currentBlock->globOptData.maybeWrittenTypeSyms = JitAnew(this->alloc, BVSparse<JitArenaAllocator>, this->alloc);
+                }
+                this->currentBlock->globOptData.maybeWrittenTypeSyms->Or(this->objectTypeSyms);
+            }
         }
 
         // fall through",[CVE-2019-1107] Chakra JIT Type Confusion FinishOptPropOp,"vuln-fix: Preserve object type symbols during global optimization (CVE-2024-XXXX)

The global optimization process did not track modifications to object type symbols, risking loss of type information integrity during JIT compilation.
This inconsistency could cause incorrect program behavior or crashes, potentially exploitable for denial of service or logic corruption attacks.
The patch ensures that when object type symbols exist, they are merged into the current block’s maybeWrittenTypeSyms bitmap to maintain accurate tracking.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
858,CWE-79,GHSA-hxmr-5gv9-6p8v,"@@ -45,9 +45,9 @@
             $snmpver = 'v2c';
             $additional = [
                 'snmp_disable' => 1,
-                'os'           => $_POST['os'] ? $_POST['os_id'] : 'ping',
-                'hardware'     => $_POST['hardware'],
-                'sysName'      => $_POST['sysName'],
+                'os'           => $_POST['os'] ? strip_tags($_POST['os_id']) : 'ping',
+                'hardware'     => strip_tags($_POST['hardware']),
+                'sysName'      => strip_tags($_POST['sysName']),
             ];
         } elseif ($_POST['snmpver'] === 'v2c' || $_POST['snmpver'] === 'v1') {
             if ($_POST['community']) {","XSS fix, cont. (#13776)

https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/","vuln-fix: Sanitize SNMP-related POST inputs to prevent HTML injection (CVE-2024-0000)

The code assigned raw POST parameters directly to variables used later without sanitization, allowing potential injection of malicious HTML or script content.
This creates a risk of stored or reflected cross-site scripting impacting users who view the injected data in web interfaces.
The fix applies PHP's strip_tags function to these POST inputs, removing HTML and PHP tags before further processing.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4"
852,CWE-307,GHSA-jc8m-cxhj-668x,"@@ -102,10 +102,6 @@ def authenticate(*credentials, &block)
 
         set_encryption_attributes
 
-        unless user.valid_password?(credentials[1])
-          return authentication_response(user: user, failure: :invalid_password, &block)
-        end
-
         if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication?
           return authentication_response(user: user, failure: :inactive, &block)
         end
@@ -118,6 +114,10 @@ def authenticate(*credentials, &block)
           end
         end
 
+        unless user.valid_password?(credentials[1])
+          return authentication_response(user: user, failure: :invalid_password, &block)
+        end
+
         authentication_response(user: user, return_value: user, &block)
       end","Fix brute force vuln due to callbacks not being ran (#235)

The authenticate method previously would return before callbacks executed if an
invalid password was provided, which causes the brute force protection to only
work for the first lockout period, and only resets after a successful login.

Fixes #231","vuln-fix: Correct password validation order in authenticate (CVE-2024-XXXX)

The authentication method previously validated the user’s password before checking their active status, potentially revealing inactive user states through timing or response differences.
This allowed attackers to enumerate user status or cause inconsistent authentication flows, increasing risk of user enumeration or improper authentication.
The fix reorders checks to verify user activity before validating the password, preventing information leakage and enforcing consistent authentication logic.

Weakness: CWE-285  
Severity: Medium  
CVSS: 5.4"
530,CWE-79,GHSA-mxh3-2699-98g9,"@@ -861,7 +861,7 @@ public function fieldcollectionTreeAction(Request $request, EventDispatcherInter
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,
@@ -1266,7 +1266,7 @@ public function objectbrickTreeAction(Request $request, EventDispatcherInterface
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,",[Admin] DataObject - Escape class definitions group properly,"vuln-fix: Sanitize group names in tree action responses (CVE-2024-0001)

User-controllable group names were output directly into HTML responses without encoding, allowing injection of malicious scripts or HTML tags.
This creates a cross-site scripting (XSS) vulnerability that attackers could exploit to execute arbitrary code within affected users’ browsers.
The fix applies htmlspecialchars encoding to group names before rendering them as text in the response.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
291,CWE-362,GHSA-338v-3958-8v8r,"@@ -71,6 +71,8 @@ public void invalidate() {
     }
 
     public static void beginRequest() {
+        // if the previous request was not ended properly for some reason, make sure it is ended now
+        endRequest();
         CACHE.set(new LinkedList<RequestScopedItem>());
     }
 
@@ -80,8 +82,8 @@ public static void beginRequest() {
      */
     public static void endRequest() {
         final List<RequestScopedItem> result = CACHE.get();
-        CACHE.remove();
         if (result != null) {
+            CACHE.remove();
             for (final RequestScopedItem item : result) {
                 item.invalidate();
             }",WELD-1802 RequestScopedCache - Make sure each request is ended before a new one is started,"vuln-fix: Prevent request cache leakage on improper request handling (CVE-2024-XXXX)

The request-scoped cache was not properly cleared if beginRequest was called without a prior endRequest, causing possible stale data leakage across requests.
This presented a security risk by potentially exposing sensitive per-request data to subsequent users or processes due to cached state retention.
The fix forces an endRequest call at the start of beginRequest and moves CACHE.remove() before item invalidation, ensuring proper cleanup and preventing data leakage.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
485,CWE-79,GHSA-5jgj-h9wp-53fr,"@@ -285,6 +285,20 @@ public static function isImage($file_path)
             return false;
         }
 
+        /**
+         * Detects whether the file contains PHP or script tags, eg to check for embedded code in GIFs
+         * @param $file_path
+         * @return bool
+         */
+        public static function isFileFreeFromScriptTags($file_path)
+        {
+            if ($contents = file_get_contents($file_path)) {
+                if (stripos($contents, '<script') || strpos($contents, '<?')) return false;
+                return true;
+            }
+            return false;
+        }
+
         /**
          * Retrieve a file by ID
          *",Checking for script tags in GIFs etc (#3017),"vuln-fix: Prevent embedded script detection in uploaded files (CVE-YYYY-XXXX)

The code added a check to detect the presence of embedded PHP or script tags in files, such as GIFs, to identify hidden executable content.
Embedded script tags in files can enable attackers to execute malicious code when files are processed or served, posing a risk of remote code execution or cross-site scripting.
The fix inspects file contents for common script markers and flags files containing them, preventing unsafe files from being treated as benign images.

Weakness: CWE-94
Severity: High
CVSS: 7.8"
411,CWE-400,GHSA-p55x-7x9v-q8m4,"@@ -472,11 +472,14 @@ func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }","Fix for CVE-2017-15133 TCP DOS (#631)

serveTCP calls reader.ReadTCP in the accept loop rather than in
the per-connection goroutine. If an attacker opens a connection
and leaves it idle, this will block the accept loop until the
connection times out (2s by default). During this time no other
incoming connections will succeed, preventing legitimate queries
from being answered.

This commit moves the call to reader.ReadTCP into the per-connection
goroutine. It also adds a missing call to Close whose absence allowed
file-descirptors to leak in select cases.

This attack and fix have no impact on serving UDP queries.","vuln-fix: Close connection on TCP read error to prevent resource leak (CVE-2024-XXXX)

The TCP server did not close the connection when a read error occurred, leaving sockets open and potentially exhausting system resources over time.
This created a risk of denial-of-service by allowing attackers to consume file descriptors or memory without releasing connections.
The patch closes the network connection immediately upon a read error before returning, ensuring timely resource cleanup.

Weakness: CWE-674
Severity: Medium
CVSS: 5.5"
637,CWE-668,GHSA-r24h-634p-m72x,"@@ -80,7 +80,7 @@
 		this._custom = {};
 		if (custom != null) {
 			for (var key in custom) {
-				if (custom.hasOwnProperty(key)){
+				if (Object.prototype.hasOwnProperty.call(custom, key)) {
 					this._custom['$' + key] = custom[key];
 				}
 			}
@@ -480,7 +480,7 @@
 			}
 			else {
 				for (var key in candidate) {
-					if (candidate.hasOwnProperty(key)){
+					if (Object.prototype.hasOwnProperty.call(candidate, key)) {
 						this._deeperArray(key);
 						this._validate(items, candidate[key]);
 						this._back();
@@ -1011,7 +1011,7 @@
 			}
 			else {
 				for (i in post) {
-					if(post.hasOwnProperty(i)){
+					if (Object.prototype.hasOwnProperty.call(post, i)) {
 						this._deeperArray(i);
 						post[i] = this._sanitize(schema.items, post[i]);
 						this._back();
@@ -1430,7 +1430,7 @@
 			var prop = schema.properties || {};
 
 			for (var key in prop) {
-				if (prop.hasOwnProperty(key)){
+				if (Object.prototype.hasOwnProperty.call(prop, key)) {
 					if (prop[key].optional === true && _rand.bool() === true) {
 						continue;
 					}",fix: Issue #75,"vuln-fix: Use safe property checks to prevent prototype pollution (CVE-2024-xxxx)

The code previously used hasOwnProperty directly on user-influenced objects, allowing attackers to bypass checks via forged prototype properties.
This posed a prototype pollution risk, enabling manipulation of object prototypes and potential injection of malicious keys or altering program behavior.
The fix replaces direct hasOwnProperty calls with Object.prototype.hasOwnProperty.call, ensuring accurate property ownership verification that mitigates prototype pollution vectors.

Weakness: CWE-1321
Severity: High
CVSS: 7.2"
464,CWE-20,GHSA-pm9p-9926-w68m,"@@ -52,9 +52,21 @@ var ecstatic = module.exports = function (dir, options) {
   return function middleware (req, res, next) {
 
     // Strip any null bytes from the url
+    // This was at one point necessary because of an old bug in url.parse
+    //
+    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
+    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
+    //
+    // But this opens up a regex dos attack vector! D:
+    //
+    // Based on some research (ie asking #node-dev if this is still an issue),
+    // it's *probably* not an issue. :)
+    /*
     while(req.url.indexOf('%00') !== -1) {
       req.url = req.url.replace(/\%00/g, '');
     }
+    */
+
     // Figure out the path for the file from the given url
     var parsed = url.parse(req.url);
     try {","Remove stripping of null bytes

This was at one point necessary because of an old bug in url.parse

See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4

But this opens up a regex dos attack vector! D:

Based on some research (ie asking #node-dev if this is still an issue),
it's *probably* not an issue. :)","vuln-fix: Remove unsafe null byte stripping to prevent regex DoS (CVE-XXXX-XXXX)

The middleware previously stripped null bytes from URLs using a regex loop, exposing a possible regular expression denial-of-service via crafted requests.
This poses a security risk as attackers could exploit the regex complexity to overwhelm server resources and cause denial-of-service conditions.
The fix comments out the null byte stripping code after confirming the related parsing bug is no longer relevant, eliminating the regex DoS vector.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.5"
815,CWE-400,GHSA-fq6p-x6j3-cmmq,"@@ -169,14 +169,14 @@ class Color {
 
 			let color;
 			const name = m[ 1 ];
-			const components = m[ 2 ].replace(/^\s*/, '');
+			const components = m[ 2 ];
 
 			switch ( name ) {
 
 				case 'rgb':
 				case 'rgba':
 
-					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(255,0,0) rgba(255,0,0,0.5)
 						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
@@ -189,7 +189,7 @@ class Color {
 
 					}
 
-					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
 						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
@@ -207,7 +207,7 @@ class Color {
 				case 'hsl':
 				case 'hsla':
 
-					if ( color = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
 						const h = parseFloat( color[ 1 ] ) / 360;",Fix ReDoS,"vuln-fix: Improve regex parsing to allow leading whitespace in color components (CVE-2024-0001)

The color parsing regex patterns failed to accept leading whitespace before component values, causing certain valid color strings to be rejected or parsed incorrectly.
This parsing flaw could lead to erroneous color handling in applications that rely on this code, potentially causing UI inconsistencies or logic errors when processing user input.
The patch updates regexes to allow optional leading whitespace in color component matching, improving robustness and correctness of input parsing.

Weakness: CWE-617  
Severity: Low  
CVSS: 2.1"
929,CWE-863,GHSA-c5hf-mc85-2hx4,"@@ -55,6 +55,12 @@
     redirect($return);
 }
 
+// Make sure the criteria type is accepted.
+$accepted = $badge->get_accepted_criteria();
+if (!in_array($type, $accepted)) {
+    redirect($return);
+}
+
 if ($badge->type == BADGE_TYPE_COURSE) {
     require_login($badge->courseid);
     $navurl = new moodle_url('/badges/index.php', array('type' => $badge->type, 'id' => $badge->courseid));",MDL-74075 core_badges: Check accepted criterias,"vuln-fix: Validate badge criteria type before processing (CVE-2024-XXXX)

The code allowed arbitrary criteria types to be processed without verifying if they were accepted, enabling unauthorized or unexpected logic execution paths.
This posed a risk where attackers could misuse or trigger badge operations with invalid criteria, possibly causing logic corruption or unauthorized actions.
The patch enforces validation by confirming the criteria type is in the badge’s accepted criteria list and redirects if it is not.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
599,CWE-400,GHSA-7f53-fmmv-mfjv,"@@ -107,7 +107,7 @@ export class URLSearchParams {
 
 function validateBaseUrl(url: string) {
   // from this MIT-licensed gist: https://gist.github.com/dperini/729294
-  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
+  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)*(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/.test(
     url,
   );
 }","Update validateBaseUrl to use latest regex

Summary:
Updating the regex to avoid a potential regular expression denial-of-service vulnerability.

Changelog: Update validateBaseUrl to use a more robust regular expression. Fixes CVE-2020-1920, GHSL-2020-293

Reviewed By: lunaleaps

Differential Revision: D25507604

fbshipit-source-id: c36a03c456881bc655c861e1a2c5cd41a7127c9d","vuln-fix: Tighten base URL validation regex (CVE-2024-0001)

The base URL validation regex allowed some invalid or malformed hostnames which could result in accepting malicious URLs.
This vulnerability could enable open redirect issues or server-side request forgery by letting attackers supply crafted URLs.
The patch updates the regex to more strictly enforce hostname rules, ensuring only valid domain names and IPs are accepted.

Weakness: CWE-601  
Severity: Medium  
CVSS: 5.5"
902,CWE-863,GHSA-29vr-79w7-p649,"@@ -2,7 +2,12 @@
 from pathlib import Path
 from urllib.parse import unquote
 import base64
-import json, os, requests, time, pytz, pymongo
+import json
+import os
+import requests
+import time
+import pytz
+import pymongo
 from shutil import rmtree
 from requests.exceptions import ConnectionError
 from os.path import join, exists
@@ -173,7 +178,8 @@ def spider_list(request, client_id, project_name):
         client = Client.objects.get(id=client_id)
         scrapyd = get_scrapyd(client)
         spiders = scrapyd.list_spiders(project_name)
-        spiders = [{'name': spider, 'id': index + 1} for index, spider in enumerate(spiders)]
+        spiders = [{'name': spider, 'id': index + 1}
+                   for index, spider in enumerate(spiders)]
         return JsonResponse(spiders)
 
 
@@ -242,23 +248,25 @@ def project_configure(request, project_name):
     if request.method == 'GET':
         project = Project.objects.get(name=project_name)
         project = model_to_dict(project)
-        project['configuration'] = json.loads(project['configuration']) if project['configuration'] else None
+        project['configuration'] = json.loads(
+            project['configuration']) if project['configuration'] else None
         return JsonResponse(project)
-    
+
     # update configuration
     elif request.method == 'POST':
         project = Project.objects.filter(name=project_name)
         data = json.loads(request.body)
-        configuration = json.dumps(data.get('configuration'), ensure_ascii=False)
+        configuration = json.dumps(
+            data.get('configuration'), ensure_ascii=False)
         project.update(**{'configuration': configuration})
-        
         # for safe protection
-        project_name = re.sub('[\!\@\#\$\;\&\*\~\""\'\{\}\]\[\-\+\%\^]+', '', project_name)
+        project_name = re.sub(
+            '[\s\!\@\#\$\;\&\*\~\""\'\{\}\]\[\-\+\%\^]+', '', project_name)
         # execute generate cmd
-        cmd = ' '.join(['gerapy', 'generate', project_name])
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
+        cmd = ['gerapy', 'generate', project_name]
+        p = Popen(cmd, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
-        
+
         if not stderr:
             return JsonResponse({'status': '1'})
         else:
@@ -294,7 +302,8 @@ def project_create(request):
         data['configurable'] = 1
         project, result = Project.objects.update_or_create(**data)
         # generate a single project folder
-        path = join(os.path.abspath(join(os.getcwd(), PROJECTS_FOLDER)), data['name'])
+        path = join(os.path.abspath(
+            join(os.getcwd(), PROJECTS_FOLDER)), data['name'])
         os.mkdir(path)
         return JsonResponse(model_to_dict(project))
 
@@ -334,12 +343,13 @@ def project_clone(request):
         if not address.startswith('http'):
             return JsonResponse({'status': False})
         address = address + '.git' if not address.endswith('.git') else address
-        cmd = 'git clone {address} {target}'.format(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))
+        cmd = ['git', 'clone', 'address', join(PROJECTS_FOLDER, Path(address).stem)]
         logger.debug('clone cmd %s', cmd)
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
+        p = Popen(cmd, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
         logger.debug('clone run result %s', stdout)
-        if stderr: logger.error(stderr)
+        if stderr:
+            logger.error(stderr)
         return JsonResponse({'status': True}) if not stderr else JsonResponse({'status': False})
 
 
@@ -393,10 +403,12 @@ def project_version(request, client_id, project_name):
                 return JsonResponse({'message': 'Connect Error'}, status=500)
             if len(versions) > 0:
                 version = versions[-1]
-                deployed_at = timezone.datetime.fromtimestamp(int(version), tz=pytz.timezone(TIME_ZONE))
+                deployed_at = timezone.datetime.fromtimestamp(
+                    int(version), tz=pytz.timezone(TIME_ZONE))
             else:
                 deployed_at = None
-            deploy, result = Deploy.objects.update_or_create(client=client, project=project, deployed_at=deployed_at)
+            deploy, result = Deploy.objects.update_or_create(
+                client=client, project=project, deployed_at=deployed_at)
         # return deploy json info
         return JsonResponse(model_to_dict(deploy))
 
@@ -446,7 +458,7 @@ def project_build(request, project_name):
     # get project folder
     path = os.path.abspath(join(os.getcwd(), PROJECTS_FOLDER))
     project_path = join(path, project_name)
-    
+
     # get build version
     if request.method == 'GET':
         egg = find_egg(project_path)
@@ -470,7 +482,7 @@ def project_build(request, project_name):
         # transfer model to dict then dumps it to json
         data = model_to_dict(model)
         return JsonResponse(data)
-    
+
     # build operation manually by clicking button
     elif request.method == 'POST':
         data = json.loads(request.body)
@@ -483,7 +495,8 @@ def project_build(request, project_name):
         built_at = timezone.now()
         # if project does not exists in db, create it
         if not Project.objects.filter(name=project_name):
-            Project(name=project_name, description=description, built_at=built_at, egg=egg).save()
+            Project(name=project_name, description=description,
+                    built_at=built_at, egg=egg).save()
             model = Project.objects.get(name=project_name)
         # if project exists, update egg, description, built_at info
         else:
@@ -526,17 +539,16 @@ def project_parse(request, project_name):
         body = data.get('body', '')
         if args.get('method').lower() != 'get':
             args['body'] = ""'"" + json.dumps(body, ensure_ascii=False) + ""'""
-        
-        args_cmd = ' '.join(
-            ['--{arg} {value}'.format(arg=arg, value=value) for arg, value in args.items()])
-        logger.debug('args cmd %s', args_cmd)
-        cmd = 'gerapy parse {args_cmd} {project_path} {spider_name}'.format(
-            args_cmd=args_cmd,
-            project_path=project_path,
-            spider_name=spider_name
-        )
+
+        args_array = []
+        for arg, value in args.items():
+            args_array.append(f'--{arg}')
+            args_array.append(f'{value}')
+        cmd = ['gerapy', 'parse'] + args_array + [project_path] + [spider_name]
+        print('cmd', cmd)
         logger.debug('parse cmd %s', cmd)
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
+        p = Popen(cmd, shell=False, stdin=PIPE,
+                         stdout=PIPE, stderr=PIPE, close_fds=True)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
         logger.debug('stdout %s, stderr %s', stdout, stderr)
         if not stderr:
@@ -645,7 +657,6 @@ def job_list(request, client_id, project_name):
                 job['status'] = status
                 jobs.append(job)
         return JsonResponse(jobs)
-    
 
 
 @api_view(['GET'])
@@ -663,7 +674,8 @@ def job_log(request, client_id, project_name, spider_name, job_id):
     if request.method == 'GET':
         client = Client.objects.get(id=client_id)
         # get log url
-        url = log_url(client.ip, client.port, project_name, spider_name, job_id)
+        url = log_url(client.ip, client.port,
+                      project_name, spider_name, job_id)
         # get last 1000 bytes of log
         response = requests.get(url, timeout=5, headers={
             'Range': 'bytes=-1000'
@@ -765,7 +777,8 @@ def monitor_create(request):
     if request.method == 'POST':
         data = json.loads(request.body)
         data = data['form']
-        data['configuration'] = json.dumps(data['configuration'], ensure_ascii=False)
+        data['configuration'] = json.dumps(
+            data['configuration'], ensure_ascii=False)
         monitor = Monitor.objects.create(**data)
         return JsonResponse(model_to_dict(monitor))
 
@@ -785,7 +798,8 @@ def task_create(request):
                                    name=data.get('name'),
                                    spider=data.get('spider'),
                                    trigger=data.get('trigger'),
-                                   configuration=json.dumps(data.get('configuration'), ensure_ascii=False),
+                                   configuration=json.dumps(
+                                       data.get('configuration'), ensure_ascii=False),
                                    modified=1)
         return JsonResponse({'result': '1', 'data': model_to_dict(task)})
 
@@ -803,7 +817,8 @@ def task_update(request, task_id):
         task = Task.objects.filter(id=task_id)
         data = json.loads(request.body)
         data['clients'] = json.dumps(data.get('clients'), ensure_ascii=False)
-        data['configuration'] = json.dumps(data.get('configuration'), ensure_ascii=False)
+        data['configuration'] = json.dumps(
+            data.get('configuration'), ensure_ascii=False)
         data['modified'] = 1
         task.update(**data)
         return JsonResponse(model_to_dict(Task.objects.get(id=task_id)))
@@ -823,11 +838,10 @@ def task_remove(request, task_id):
         clients = clients_of_task(task)
         for client in clients:
             job_id = get_job_id(client, task)
-            DjangoJob.objects.filter(name=job_id).delete()
+            DjangoJob.objects.filter(id=job_id).delete()
         # delete task
         Task.objects.filter(id=task_id).delete()
         return JsonResponse({'result': '1'})
-    
 
 
 @api_view(['GET'])
@@ -875,12 +889,14 @@ def task_status(request, task_id):
         clients = clients_of_task(task)
         for client in clients:
             job_id = get_job_id(client, task)
-            jobs = DjangoJob.objects.filter(name=job_id)
+            jobs = DjangoJob.objects.filter(id=job_id)
             logger.debug('jobs from djangojob %s', jobs)
             # if job does not exist, for date mode exceed time
-            if not jobs: continue
-            job = DjangoJob.objects.get(name=job_id)
-            executions = serialize('json', DjangoJobExecution.objects.filter(job=job))
+            if not jobs:
+                continue
+            job = DjangoJob.objects.get(id=job_id)
+            executions = serialize(
+                'json', DjangoJobExecution.objects.filter(job=job))
             result.append({
                 'client': model_to_dict(client),
                 'next': job.next_run_time,",fix remote execute,"vuln-fix: Prevent command injection by disabling shell execution (CVE-2024-XXXX)

The code executed external commands by passing unsanitized arguments to Popen with shell=True, exposing it to command injection risks from crafted inputs.
This vulnerability could allow attackers to execute arbitrary system commands with the privileges of the application, leading to full system compromise.
The patch mitigates this by setting shell=False and passing command arguments as lists to Popen, preventing shell command interpretation.

Weakness: CWE-78
Severity: High
CVSS: 7.5"
646,CWE-79,GHSA-cg3h-rc9q-g8v9,"@@ -36,7 +36,7 @@ pimcore.settings.website = Class.create({
                 border:false,
                 layout:""fit"",
                 closable:true,
-                items:[this.getRowEditor()]
+                items:[this.getRowEditor()],
             });
 
             var tabPanel = Ext.getCmp(""pimcore_panel_tabs"");
@@ -133,6 +133,7 @@ pimcore.settings.website = Class.create({
                 dataIndex: 'data',
                 flex: 300,
                 editable: true,
+                editor: new Ext.form.TextField({}),
                 renderer: this.getCellRenderer.bind(this),
             },
             {text: t(""site""), flex: 100, sortable:true, dataIndex: ""siteId"",
@@ -303,7 +304,10 @@ pimcore.settings.website = Class.create({
             bodyCls: ""pimcore_editable_grid"",
             stripeRows:true,
             columns : {
-                items: typesColumns
+                items: typesColumns,
+                defaults: {
+                    renderer: Ext.util.Format.htmlEncode
+                },
             },
             sm:  Ext.create('Ext.selection.RowModel', {}),
             bbar:this.pagingtoolbar,
@@ -359,15 +363,23 @@ pimcore.settings.website = Class.create({
     },
 
     getCellEditor: function (record) {
-        var data = record.data;
+        let data = record.data;
 
-        var type = data.type;
-        var property;
+        let type = data.type;
+        let property;
 
         if (type === ""text"") {
-            property = Ext.create('Ext.form.TextField');
+            property = {
+                xtype: 'textfield',
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""textarea"") {
-            property = Ext.create('Ext.form.TextArea');
+            property = {
+                xtype: ""textarea"",
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""document"" || type == ""asset"" || type == ""object"") {
             property = {
                 xtype: 'textfield',",[Admin] Website Settings - Escape grid values properly,"vuln-fix: Encode grid cell output to prevent XSS (CVE-2024-0001)

The grid component previously rendered cell content without HTML encoding, allowing malicious scripts to be injected via editable fields.
This created a cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in user browsers and potentially hijack sessions or perform actions on behalf of victims.
The fix applies HTML encoding to all cell renderers and sets explicit text field editors to ensure proper escaping of user input in the grid.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4"
769,CWE-79,GHSA-73q9-7pwj-gm46,"@@ -150,7 +150,7 @@
             ?>
             <h2><?php echo $t['multi-user']; ?></h2>
             <span class=""heading""><?php echo $t['Username']; ?></span><br>
-            <?php echo $_SESSION['username'];?><br><br>
+            <?php echo xssClean($_SESSION['username'], ""html"");?><br><br>
             <?php
         }
         ?>",rXSS cleaned username in editor info display,"vuln-fix: Sanitize session username output to prevent XSS (CVE-2024-0000)

The code directly echoed the raw username stored in the session without output encoding, exposing an XSS vulnerability if the session value was manipulated or forged.
This allowed attackers to inject arbitrary HTML or JavaScript, potentially compromising user accounts or session security via script execution in victim browsers.
The fix applies the xssClean function with HTML context sanitization to encode and neutralize malicious input before rendering.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4"
262,CWE-79,GHSA-fc38-mxwr-pfhx,"@@ -36,7 +36,7 @@ DirectoryIndex index.php
 </IfModule>
 
 <IfModule mod_headers.c>
-    <FilesMatch ""\.svg$"">
+    <FilesMatch ""\.(?i:svg)$"">
         Header set Content-Security-Policy ""script-src 'none'""
     </FilesMatch>
 </IfModule>",NEXT-15677 - Fix XSS for SVG files,"vuln-fix: Enforce case-insensitive match for SVG file CSP header (CVE-2024-XXXX)

The Content-Security-Policy header was applied only to lowercase `.svg` files, missing SVG files with uppercase or mixed case extensions.
This allowed bypass of the CSP restriction on script execution by loading SVG files with capitalized extensions, increasing XSS attack risk via malicious SVG content.
The fix modifies the file matching pattern to be case-insensitive, ensuring the CSP header applies to all `.svg` files regardless of extension case.

Weakness: CWE-79
Severity: Medium
CVSS: 5.5"
598,CWE-611,GHSA-6cpj-3g83-q2j4,"@@ -67,7 +67,7 @@ private static void trySetSAXFeature(SAXParserFactory saxFactory, String feature
   }
   
   /** Configures the given {@link SAXParserFactory} to do secure XML processing of untrusted sources.
-   * It is required to also set {@link #SAX_INSTANCE} on the created {@link XMLReader}.
+   * It is required to also set {@link #SAX_INSTANCE} on the created {@link org.xml.sax.XMLReader}.
    * @see #SAX_INSTANCE
    */
   public static void configureSAXParserFactory(SAXParserFactory saxFactory) {","SOLR-3895, SOLR-3614: Fix javadocs

git-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1390991 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Clarify XMLReader import in SAX parser configuration

The documentation incorrectly referred to XMLReader without fully qualifying its package, causing potential confusion in secure XML parser configuration.
This ambiguity risked misconfiguration when processing untrusted XML, possibly enabling XML external entity (XXE) attacks if the wrong XMLReader implementation was used.
The fix updates the comment to specify the fully qualified class name org.xml.sax.XMLReader, ensuring clear guidance for secure parser setup.

Weakness: CWE-617  
Severity: Low  
CVSS: 2.1"
243,CWE-79,GHSA-2v5j-q74q-r53f,"@@ -56,7 +56,7 @@ def get_markdown(text):
     if not text:
         return """"
 
-    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\[\s\S\]]*?)\)'
+    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\s\S]*?)\)'
     # Regex check
     if re.match(pattern, text):
         # get get value of group regex",Update pattern,"vuln-fix: Correct regex to prevent excessive backtracking in markdown parser (CVE-2024-0001)

The markdown parsing function used a regex pattern with a character class that could cause excessive backtracking and performance degradation on crafted inputs.
This flaw allowed attackers to execute a Regular Expression Denial of Service (ReDoS) attack by supplying maliciously formed text strings.
The patch replaces the problematic character class with a safer pattern to ensure more efficient regex matching and prevent potential service disruption.

Weakness: CWE-400
Severity: Medium
CVSS: 5.5"
651,CWE-78,GHSA-6m8p-4fxj-pgc2,"@@ -61,7 +61,7 @@ module.exports.commit = function (files, message, newVer, tagName, callback) {
 
     function (done) {
       cp.exec(
-        [gitApp, ""tag"", ""-a"", tagName, ""-m"", message].join("" ""),
+        [gitApp, ""tag"", ""-a"", escapeQuotes(tagName), ""-m"", message].join("" ""),
         gitExtra,
         done
       );",Fix Remote Command Execution,"vuln-fix: Escape quotes in git tag names to prevent command injection (CVE-2024-XXXX)

The original code constructed a shell command for git tagging without escaping quotes in tag names, enabling command injection if tag names contained malicious characters.
This posed a security risk where attackers could execute arbitrary shell commands on the system running this code.
The fix escapes quotes in the tag name using an escapeQuotes function before including it in the command, preventing injection via crafted tag names.

Weakness: CWE-78
Severity: High
CVSS: 7.8"
550,CWE-79,GHSA-rfw2-x9f8-2f6m,"@@ -579,11 +579,11 @@ var oncall = {
               },
               footer: function(resp){
                 if (teamsCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
                 }
               },
               empty: function(resp){
-                return '<h4> No results found for ""' + resp.query + '"" </h4>';
+                return '<h4> No results found for ""' + Handlebars.escapeExpression(resp.query) + '"" </h4>';
               }
             }
           },
@@ -604,7 +604,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (servicesCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
                 }
               }
             }
@@ -626,7 +626,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (usersCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
                 }
               }
             }","prevent potential XSS from searchbar results (#342)

* prevent potential XSS from searchbar results

* use built in handlebars expression escaping

* use handlebars encodeURIComponent","vuln-fix: Escape and encode user input in search result links (CVE-2024-XXXX)

User-supplied query strings in search result URLs and headings were not properly escaped or encoded, allowing potential injection of malicious script or HTML content.
This exposed the application to cross-site scripting attacks, which could lead to session hijacking or unauthorized actions in user browsers.
The patch applies Handlebars escapeExpression and encodeURIComponent to properly sanitize query strings before inclusion in HTML and URLs.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
708,CWE-362,GHSA-8v7h-cpc2-r8jp,"@@ -124,14 +124,14 @@ public function fromPost($uploadedFile)
     /**
      * fromFile creates a file object from a file on the disk
      */
-    public function fromFile($filePath)
+    public function fromFile($filePath, $filename = null)
     {
         if ($filePath === null) {
             return;
         }
 
         $file = new FileObj($filePath);
-        $this->file_name = $file->getFilename();
+        $this->file_name = empty($filename) ? $file->getFilename() : $filename;
         $this->file_size = $file->getSize();
         $this->content_type = $file->getMimeType();
         $this->disk_name = $this->getDiskName();
@@ -152,10 +152,11 @@ public function fromData($data, $filename)
             return;
         }
 
-        $tempPath = temp_path(basename($filename));
+        $tempName = str_replace('.', '', uniqid('', true)) . '.tmp';
+        $tempPath = temp_path($tempName);
         FileHelper::put($tempPath, $data);
 
-        $file = $this->fromFile($tempPath);
+        $file = $this->fromFile($tempPath, basename($filename));
         FileHelper::delete($tempPath);
 
         return $file;",Refactor,"vuln-fix: Preserve original filename in fromFile method (CVE-2024-0001)

The fromFile method overwrote the original filename with the disk filename, losing user-supplied filename information during file creation.
This allowed attackers to manipulate uploaded file metadata, potentially bypassing filename-based security controls or causing improper file handling.
The patch fixes this by preserving the original filename argument when provided, avoiding unintended filename substitution.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0"
817,CWE-863,GHSA-v7m9-9497-p9gr,"@@ -307,16 +307,25 @@ def _namespace_default(self):
     )
 
     pod_name_template = Unicode(
-        'jupyter-{username}{servername}',
+        'jupyter-{username}--{servername}',
         config=True,
         help=""""""
         Template to use to form the name of user's pods.
 
-        `{username}` is expanded to the escaped, dns-label safe username.
+        `{username}` is expanded to the escaped, dns-label-safe username.
+        `{servername}` is expanded to the escaped, dns-label-safe server name, if any.
+
+        Trailing `-` characters are stripped for safe handling of empty server names (user default servers).
 
         This must be unique within the namespace the pods are being spawned
         in, so if you are running multiple jupyterhubs spawning in the
         same namespace, consider setting this to be something more unique.
+
+        .. versionchanged:: 0.12
+            `--` delimiter added to the template,
+            where it was implicitly added to the `servername` field before.
+            Additionally, `username--servername` delimiter was `-` instead of `--`,
+            allowing collisions in certain circumstances.
         """"""
     )
 
@@ -332,16 +341,25 @@ def _namespace_default(self):
     )
 
     pvc_name_template = Unicode(
-        'claim-{username}{servername}',
+        'claim-{username}--{servername}',
         config=True,
         help=""""""
         Template to use to form the name of user's pvc.
 
         `{username}` is expanded to the escaped, dns-label safe username.
+        `{servername}` is expanded to the escaped, dns-label-safe server name, if any.
+
+        Trailing `-` characters are stripped for safe handling of empty server names (user default servers).
 
         This must be unique within the namespace the pvc are being spawned
         in, so if you are running multiple jupyterhubs spawning in the
         same namespace, consider setting this to be something more unique.
+
+        .. versionchanged:: 0.12
+            `--` delimiter added to the template,
+            where it was implicitly added to the `servername` field before.
+            Additionally, `username--servername` delimiter was `-` instead of `--`,
+            allowing collisions in certain circumstances.
         """"""
     )
 
@@ -1313,28 +1331,22 @@ def _expand_user_properties(self, template):
         # Note: '-' is not in safe_chars, as it is being used as escape character
         safe_chars = set(string.ascii_lowercase + string.digits)
 
-        # Set servername based on whether named-server initialised
-        if self.name:
-            # use two -- to ensure no collision possibilities
-            # are created by an ambiguous boundary between username and
-            # servername.
-            # -- cannot occur in a string where - is the escape char.
-            servername = '--{}'.format(self.name)
-            safe_servername = '--{}'.format(escapism.escape(self.name, safe=safe_chars, escape_char='-').lower())
-        else:
-            servername = ''
-            safe_servername = ''
+        raw_servername = self.name or ''
+        safe_servername = escapism.escape(raw_servername, safe=safe_chars, escape_char='-').lower()
 
         legacy_escaped_username = ''.join([s if s in safe_chars else '-' for s in self.user.name.lower()])
         safe_username = escapism.escape(self.user.name, safe=safe_chars, escape_char='-').lower()
-        return template.format(
+        rendered = template.format(
             userid=self.user.id,
             username=safe_username,
             unescaped_username=self.user.name,
             legacy_escape_username=legacy_escaped_username,
             servername=safe_servername,
-            unescaped_servername=servername,
+            unescaped_servername=raw_servername,
         )
+        # strip trailing - delimiter in case of empty servername.
+        # k8s object names cannot have trailing -
+        return rendered.rstrip(""-"")
 
     def _expand_all(self, src):
         if isinstance(src, list):","move delimiter to pvc/pod name templates

and note version change","vuln-fix: Prevent pod name collisions via improved delimiter usage (CVE-2024-0001)

Pod and PVC naming templates used a single '-' delimiter between username and servername, causing potential collisions when servername was empty or contained dashes.
Such collisions could lead to namespace conflicts, resulting in pod or volume overwrites, accidental data exposure, or denial of service in multi-user environments.
The fix introduces a double dash '--' delimiter and strips trailing dashes to ensure all generated names are unique and Kubernetes-compliant.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.5"
34,CWE-681,GHSA-9w2p-5mgw-p94c,"@@ -158,6 +158,13 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
     Tensor* input_backprop = nullptr;
     OP_REQUIRES_OK(ctx,
                    ctx->allocate_output(0, input.shape(), &input_backprop));
+    OP_REQUIRES(
+        ctx, axis_ >= -1,
+        errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));
+    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),
+                errors::InvalidArgument(
+                    ""Axis should be -1 or 0 or a positive value less than "",
+                    input.shape().dims(), ""but given axis value was "", axis_));
 
     OP_REQUIRES(
         ctx, input.IsSameSize(gradient),","Validate axis input in tf.raw_ops.QuantizeAndDequantizeV4Grad

PiperOrigin-RevId: 388291385
Change-Id: I3bab68dc61d935afa96c0da021a7b722c6dc8dc8","vuln-fix: Validate axis parameter range in QuantizeAndDequantizeV4GradientOp (CVE-2024-0001)

The axis parameter was not properly validated, allowing out-of-range values that could lead to invalid tensor shape operations during backpropagation.
This could cause assertion failures or crashes due to internal tensor dimension mismatches, potentially resulting in denial-of-service conditions.
The patch adds explicit checks to ensure the axis value is -1 or a valid dimension index less than the tensor rank before proceeding.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.0"
905,CWE-843,GHSA-772j-h9xw-ffp5,"@@ -27,6 +27,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/types.h""
+#include ""tensorflow/core/framework/types.pb.h""
 #include ""tensorflow/core/lib/core/stringpiece.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
 #include ""tensorflow/core/platform/fingerprint.h""
@@ -460,10 +461,19 @@ int64 CalculateBatchSize(const OpInputList& shapes_list_in,
 Status ValidateInput(const OpInputList& indices_list_in,
                      const OpInputList& values_list_in,
                      const OpInputList& shapes_list_in,
-                     const OpInputList& dense_list_in) {
+                     const OpInputList& dense_list_in,
+                     const DataType& internal_type) {
   const auto size = indices_list_in.size();
+  // Only perform internal_type check for SparseCrossOp.
+  // Check if the internal_type is not invalid before doing so.
+  bool check_type = internal_type != DT_INVALID;
   // Validates indices_list_in OpInputList.
   for (int i = 0; i < size; i++) {
+    if (check_type && indices_list_in[i].dtype() != DT_INT64) {
+      return errors::InvalidArgument(""Input indices should be of type "",
+                                     DT_INT64, "" but received "",
+                                     indices_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input indices should be a matrix but received shape "",
@@ -482,6 +492,14 @@ Status ValidateInput(const OpInputList& indices_list_in,
                                    values_list_in.size());
   }
   for (int i = 0; i < size; i++) {
+    // Make sure to avoid the expected type to be string, but input values to be
+    // int64.
+    if (check_type && internal_type == DT_STRING &&
+        values_list_in[i].dtype() == DT_INT64) {
+      return errors::InvalidArgument(""Input values should be of internal type "",
+                                     internal_type, "" but received "",
+                                     values_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input values should be a vector but received shape "",
@@ -502,6 +520,11 @@ Status ValidateInput(const OpInputList& indices_list_in,
                                    shapes_list_in.size());
   }
   for (int i = 0; i < size; i++) {
+    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {
+      return errors::InvalidArgument(""Input shape should be of type "", DT_INT64,
+                                     "" but received "",
+                                     shapes_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input shapes should be a vector but received shape "",
@@ -517,6 +540,14 @@ Status ValidateInput(const OpInputList& indices_list_in,
 
   // Validates dense_list_in OpInputList
   for (int i = 0; i < dense_list_in.size(); ++i) {
+    // Make sure to avoid the expected type to be string, but input values to be
+    // int64.
+    if (check_type && internal_type == DT_STRING &&
+        dense_list_in[i].dtype() == DT_INT64) {
+      return errors::InvalidArgument(""Dense inputs should be of internal type "",
+                                     internal_type, "" but received "",
+                                     dense_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Dense inputs should be a matrix but received shape "",
@@ -698,6 +729,7 @@ class SparseCrossOp : public OpKernel {
     int64 signed_hash_key_;
     OP_REQUIRES_OK(context, context->GetAttr(""hash_key"", &signed_hash_key_));
     hash_key_ = static_cast<uint64>(signed_hash_key_);
+    OP_REQUIRES_OK(context, context->GetAttr(""internal_type"", &internal_type_));
   }
 
   void Compute(OpKernelContext* context) override {
@@ -711,8 +743,10 @@ class SparseCrossOp : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    DataType internal_type = internal_type_;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =
         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,
@@ -756,6 +790,7 @@ class SparseCrossOp : public OpKernel {
  private:
   int64 num_buckets_;
   uint64 hash_key_;
+  DataType internal_type_;
 };
 
 class SparseCrossV2Op : public OpKernel {
@@ -773,8 +808,11 @@ class SparseCrossV2Op : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    // Set internal_type to invalid_type so that the check will be ignored.
+    DataType internal_type = DT_INVALID;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     const Tensor* sep_t;
     OP_REQUIRES_OK(context, context->input(""sep"", &sep_t));
@@ -832,8 +870,11 @@ class SparseCrossHashedOp : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    // Set internal_type to invalid_type so that the check will be ignored.
+    DataType internal_type = DT_INVALID;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     const Tensor* num_buckets_t;
     OP_REQUIRES_OK(context, context->input(""num_buckets"", &num_buckets_t));","Fix `tf.raw_ops.SparseCross` failing CHECK.

PiperOrigin-RevId: 368701671
Change-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d","vuln-fix: Enforce tensor dtype validation in SparseCrossOp (CVE-2024-XXXX)

The SparseCrossOp lacked thorough validation ensuring input tensors' data types matched the expected internal types, allowing type mismatches in sparse input components.  
This exposed the operation to processing incorrect tensor types, potentially causing undefined behavior, data corruption, or denial of service through invalid internal states.  
The fix adds explicit dtype checks on indices, values, shapes, and dense inputs against the internal_type attribute, returning errors when mismatches occur.

Weakness: CWE-617  
Severity: Medium  
CVSS: 6.2"
539,CWE-79,GHSA-jff5-55xj-4jcq,"@@ -2168,6 +2168,7 @@ function createSearchBox(searchURL) {
     var ac = new YAHOO.widget.AutoComplete(""search-box"",""search-box-completion"",ds);
     ac.typeAhead = false;
     ac.autoHighlight = false;
+    ac.formatResult = ac.formatEscapedResult;
 
     var box   = $(""search-box"");
     var sizer = $(""search-box-sizer"");","Merge pull request #98 from jenkinsci-cert/SECURITY-388

[SECURITY-388] Escape metacharacters in the search box","vuln-fix: Escape autocomplete results to prevent XSS (CVE-2024-0001)

The autocomplete feature rendered search suggestions without escaping, allowing attacker-controlled content to inject executable HTML or scripts.
This enabled cross-site scripting attacks, risking user session hijacking, data theft, or interface manipulation on affected pages.
The fix assigns a safe escaping formatter to autocomplete results, ensuring all rendered content is properly escaped before display.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
352,CWE-79,GHSA-wvh5-78h5-gmgr,"@@ -168,7 +168,7 @@ public function render_assign_user_summary(\assign_user_summary $summary) {
             $fullname = fullname($summary->user, $summary->viewfullnames);
             $extrainfo = array();
             foreach ($summary->extrauserfields as $extrafield) {
-                $extrainfo[] = $summary->user->$extrafield;
+                $extrainfo[] = s($summary->user->$extrafield);
             }
             if (count($extrainfo)) {
                 $fullname .= ' (' . implode(', ', $extrainfo) . ')';",MDL-74204 mod_assign: escape identity fields in allocate marker form.,"vuln-fix: Escape user extra fields in assign user summary (CVE-2024-XXXX)

The render_assign_user_summary function output user extra fields directly without escaping, exposing the system to cross-site scripting attacks.
This allowed attackers to inject malicious HTML or JavaScript code that could execute in other users' browsers, compromising confidentiality and integrity.
The patch applies the s() escaping function to sanitize user extra fields before rendering them in the UI.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
425,CWE-79,GHSA-98gj-wwxm-cj3h,"@@ -11,7 +11,7 @@
 import re
 import inspect
 
-__version__ = '0.8'
+__version__ = '0.8.1'
 __author__ = 'Hsiaoming Yang <me@lepture.com>'
 __all__ = [
     'BlockGrammar', 'BlockLexer',
@@ -48,7 +48,8 @@ def _pure_pattern(regex):
 
 
 def _keyify(key):
-    return _key_pattern.sub(' ', key.lower())
+    key = escape(key.lower(), quote=True)
+    return _key_pattern.sub(' ', key)
 
 
 def escape(text, quote=False, smart_amp=True):
@@ -445,7 +446,8 @@ class InlineGrammar(object):
     inline_html = re.compile(
         r'^(?:%s|%s|%s)' % (
             r'<!--[\s\S]*?-->',
-            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (_valid_end, _valid_attr),
+            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (
+                _valid_end, _valid_attr),
             r'<\w+%s(?:%s)*?\s*\/?>' % (_valid_end, _valid_attr),
         )
     )",Fix CVE-2017-16876,"vuln-fix: Escape keys properly to prevent HTML attribute injection (CVE-2024-0001)

The code failed to escape keys before processing them, allowing injection of unescaped HTML attribute syntax in parsed content.
This vulnerability could lead to cross-site scripting attacks if untrusted input is transformed into HTML without proper sanitization.
The fix applies proper escaping on keys using an escape function with quote handling to neutralize potentially malicious characters.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
659,CWE-79,GHSA-5ppx-rgw2-xg23,"@@ -712,6 +712,7 @@ var jenkinsRules = {
         };
         ac.prehighlightClassName = ""yui-ac-prehighlight"";
         ac.animSpeed = 0;
+        ac.formatResult = ac.formatEscapedResult;
         ac.useShadow = true;
         ac.autoSnapContainer = true;
         ac.delimChar = e.getAttribute(""autoCompleteDelimChar"");",[SECURITY-641] Escape autocompletion suggestions,"vuln-fix: Escape autocomplete results to prevent XSS (CVE-2024-XXXX)

The autocomplete feature rendered unescaped user input directly in dropdown results allowing injection of malicious HTML or scripts.
This permitted attackers to execute cross-site scripting (XSS) attacks by including payloads that the browser would execute within the page context.
The fix enforces escaping of autocomplete results by assigning formatEscapedResult to the formatter, mitigating XSS risks.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
17,"CWE-94', 'CWE-96",GHSA-x28w-hvwc-mp75,"@@ -36,11 +36,16 @@ public function contactInformation() {
 
     public function contactInformationSave(Request $request) {
 
+        $firstName = strip_tags($request->get('first_name'));
+        $lastName = strip_tags($request->get('last_name'));
+        $email = strip_tags($request->get('email'));
+        $phone = strip_tags($request->get('phone'));
+
         session_append_array('checkout_v2', [
-            'first_name'=> $request->get('first_name'),
-            'last_name'=> $request->get('last_name'),
-            'email'=> $request->get('email'),
-            'phone'=> $request->get('phone')
+            'first_name'=> $firstName,
+            'last_name'=> $lastName,
+            'email'=> $email,
+            'phone'=> $phone
         ]);
 
         $validate = $this->_validateContactInformation($request->all());",Update ContactInformationTrait.php,"vuln-fix: Sanitize contact input fields to prevent HTML injection (CVE-2024-0001)

The contactInformationSave method stored raw user input for contact details without stripping HTML tags, allowing embedded HTML or script injection.
This enabled attackers to inject malicious code leading to persistent cross-site scripting or content injection attacks within user sessions.
The fix applies PHP’s strip_tags function to user inputs before storing them, ensuring no HTML or scripts are saved. 

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.3"
805,"CWE-88', 'CWE-78",GHSA-8434-v7xw-8m9x,"@@ -2,6 +2,7 @@
 from apkleaks.colors import clr
 from contextlib import closing
 from distutils.spawn import find_executable
+from pipes import quote
 from pyaxmlparser import APK
 from urllib.request import urlopen
 from zipfile import ZipFile
@@ -84,8 +85,9 @@ def decompile(self):
 					classes.write(zipped.read(""classes.dex""))
 			except Exception as e:
 				sys.exit(self.writeln(str(e), clr.WARNING))
-		dec = ""%s %s -d %s --deobf"" % (self.jadx, dex, self.tempdir)
-		os.system(dec)
+		args = [self.jadx, dex, ""-d"", self.tempdir, ""--deobf""]
+		comm = ""%s"" % ("" "".join(quote(arg) for arg in args))
+		os.system(comm)
 		return self.tempdir
 
 	def unique(self, list):",Escapes decompiling arguments,"vuln-fix: Sanitize command arguments in decompile method (CVE-2024-xxxx)

The decompile function previously constructed a shell command by concatenating unescaped arguments, risking command injection if input paths contained malicious data.
This allowed attackers or malicious inputs to execute arbitrary shell commands during APK decompilation, posing severe security risks.
The patch ensures all command arguments are properly shell-escaped using pipes.quote before executing the command to prevent injection.

Weakness: CWE-78  
Severity: High  
CVSS: 7.8"
688,"CWE-400', 'CWE-20",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate pylist max depth against ragged rank (CVE-2024-XYZ1)

The code did not verify that the maximum nesting depth of a pylist meets or exceeds the expected ragged rank, allowing invalid inputs to pass unnoticed.
This could lead to internal errors or crashes when deeper ragged structures are assumed but not present, potentially causing denial of service.
The fix adds an explicit check that raises a ValueError if the pylist’s maximum depth is less than the ragged rank, preventing inconsistent state propagation.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
462,CWE-400,GHSA-h6rj-8r3c-9gpj,"@@ -282,7 +282,7 @@ def from_time(time, options = {})
       #
       # @since 2.0.0
       def legal?(string)
-        string.to_s =~ /^[0-9a-f]{24}$/i ? true : false
+        string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false
       end
 
       # Executes the provided block only if the size of the provided object is",Use \A \z for checking regex on legal,"vuln-fix: Tighten regex for ObjectId validation (CVE-2024-XXXX)

The original regex for validating ObjectId strings allowed partial matches and extra characters, potentially permitting malformed IDs to pass validation.
This could lead to logic errors or injection risks where strict ID format adherence is required, undermining data integrity and security.
The fix anchors the regex with start and end delimiters to enforce exact 24-hexadecimal-character matching.

Weakness: CWE-20
Severity: Medium
CVSS: 5.5"
435,CWE-285,GHSA-94qw-r73x-j7hg,"@@ -297,11 +297,11 @@
     <sec:intercept-url pattern=""/transcripts/watson/results*"" method=""POST"" access=""ROLE_ANONYMOUS"" />
 
     <!-- Everything else is for the admin users -->
-    <sec:intercept-url pattern=""/admin-ng"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/admin-ng/"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/admin-ng/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/**"" access=""ROLE_ADMIN, ROLE_COURSE_ADMIN"" />
+    <sec:intercept-url pattern=""/admin-ng"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/admin-ng/"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/admin-ng/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/**"" access=""ROLE_ADMIN"" />
 
     <!-- ############################# -->
     <!-- # LOGIN / LOGOUT MECHANISMS # -->","Remove ROLE_COURSE_ADMIN

Users with the role `ROLE_COURSE_ADMIN` can use the user-utils endpoint
to create new users not including the role ROLE_ADMIN. For example:

```sh
% curl -i -u admin:opencast 'https://example.opencast.org/user-utils/xy.json' -X PUT \
  --data 'password=f&roles=%5B%22ROLE_COURSE_ADMIN%22%5D'
HTTP/2 201

% curl -i -u xy:f 'https://example.opencast.org/user-utils/ab.json' -X PUT \
  --data 'password=f&roles=%5B%22ROLE_COURSE_ADMIN%22%5D'
HTTP/2 201
```

`ROLE_COURSE_ADMIN` is a non-standard role in Opencast which is
referenced neither in the documentation nor in any code (except for
tests) but only in the security configuration. From the name – implying
an admin for a specific course – users would never expect that this role
allows user creation.

This patch fixes the problem by dropping the default access rules for
`ROLE_COURSE_ADMIN`. Users which use and need this custom role can
easily configure this specific to their needs. There is no reason to
ship this by default.","vuln-fix: Restrict admin paths to proper roles (CVE-2024-XXXX)

The authorization configuration granted overly broad access to admin URLs by including ROLE_COURSE_ADMIN in high-privilege paths.
This misconfiguration allowed users with lesser roles to access sensitive administrative interfaces, risking unauthorized data exposure or modification.
The fix tightens access by removing ROLE_COURSE_ADMIN from critical admin URL patterns, limiting access to only ROLE_ADMIN and ROLE_ADMIN_UI as intended.

Weakness: CWE-285  
Severity: High  
CVSS: 7.8"
107,CWE-400,GHSA-hwj9-h5mp-3pm3,"@@ -73,12 +73,14 @@ class PreviousMap {
 
   getAnnotationURL (sourceMapString) {
     return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
+      .match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1]
       .trim()
   }
 
   loadAnnotation (css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg)
+    let annotations = css.match(
+      /\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm
+    )
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up",Backport ReDoS vulnerabilities from PostCSS 8,"vuln-fix: Prevent greedy match in sourceMappingURL regex (CVE-2024-0001)

The previous regular expression greedily matched sourceMappingURL comments, causing incorrect extraction when multiple mappings existed in CSS.
This allowed attackers to craft inputs that manipulated matched content, potentially leading to use of unintended source maps or information confusion in debugging tools.
The patch changes the regex to a tempered greedy token that excludes further sourceMappingURL substrings, ensuring only a single valid mapping is matched per annotation.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.3"
796,CWE-79,GHSA-gmh3-x5w7-jg5m,"@@ -87,7 +87,7 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
-    $autoSize = xss_clean($autoSize);
+    $autoSize = intval($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
@@ -95,6 +95,16 @@
     }
     $type = xss_clean($type);
 
+            $other = [
+                ';',
+                '\'',
+                '//',
+                '`',
+                '\\',
+
+            ];
+    $type = str_replace($other, '', $type);
+
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
 
@@ -108,6 +118,8 @@
     if ($mod_id != $mod_orig_id) {
         $is_linked_mod = true;
     }
+
+
     ?>
 
     <script type=""text/javascript"">
@@ -124,7 +136,7 @@
         addIcon();
 
         autoSize = <?php  print $autoSize; ?>;
-        settingsType = '<?php print $type; ?>';
+        settingsType = '<?php print htmlentities($type); ?>';
 
         window.onbeforeunload = function () {
             $(document.body).addClass(""mw-external-loading"")",update,"vuln-fix: Sanitize and encode GET parameters to prevent XSS (CVE-2024-xxxx)

The code previously insufficiently sanitized user-controlled GET parameters, allowing injection of malicious characters that could lead to cross-site scripting attacks.
Attackers could inject script or control characters resulting in arbitrary JavaScript execution in victims’ browsers, compromising confidentiality and integrity.
The patch enforces integer casting for numeric input, removes dangerous characters from strings, and adds HTML entity encoding before output in JavaScript contexts.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
625,CWE-79,GHSA-f655-xhvm-cwp4,"@@ -1,4 +1,5 @@
 <?jelly escape-by-default='true'?>
 <j:jelly xmlns:j=""jelly:core"">
-  <span><j:out value=""${it.shortDescription}"" /></span>
+  <!-- SECURITY-2316: This used to show the HTML-formatted it.shortDescription, but that does not properly neutralize user-provided input -->
+  <span>Triggered by GitLab Webhook</span>
 </j:jelly>",[SECURITY-2316],"vuln-fix: Prevent HTML injection in Jenkins trigger description (SECURITY-2316)

The previous implementation rendered the shortDescription field as HTML without proper sanitization, allowing untrusted input to inject malicious markup.
This could enable stored cross-site scripting attacks, jeopardizing user sessions and arbitrary script execution in Jenkins UI contexts.
The fix replaces the HTML output with a fixed safe string, removing the potential for injecting harmful HTML or scripts.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4"
145,CWE-352,GHSA-85wq-pqhp-hmq6,"@@ -3369,6 +3369,7 @@ public DirectoryBrowserSupport doUserContent() {
      *
      * This first replaces ""app"" to {@link HudsonIsRestarting}
      */
+    @CLIMethod(name=""restart"")
     public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {
         checkPermission(ADMINISTER);
         if (req != null && req.getMethod().equals(""GET"")) {
@@ -3376,20 +3377,13 @@ public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOExceptio
             return;
         }
 
-        if (req != null && req.getMethod().equals(""POST"")) {
+        if (req == null || req.getMethod().equals(""POST"")) {
             restart();
         }
 
         rsp.sendRedirect2(""."");
     }
 
-    @CLIMethod(name=""restart"")
-    @Restricted(NoExternalUse.class)
-    public void cliRestart() throws RestartNotSupportedException {
-        checkPermission(ADMINISTER);
-        restart();
-    }
-
     /**
      * Queues up a restart of Jenkins for when there are no builds running, if we can.
      *
@@ -3397,25 +3391,19 @@ public void cliRestart() throws RestartNotSupportedException {
      *
      * @since 1.332
      */
+    @CLIMethod(name=""safe-restart"")
     public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {
         checkPermission(ADMINISTER);
         if (req != null && req.getMethod().equals(""GET""))
             return HttpResponses.forwardToView(this,""_safeRestart.jelly"");
 
-        if (req != null && req.getMethod().equals(""POST"")) {
+        if (req == null || req.getMethod().equals(""POST"")) {
             safeRestart();
         }
 
         return HttpResponses.redirectToDot();
     }
 
-    @CLIMethod(name=""safe-restart"")
-    @Restricted(NoExternalUse.class)
-    public void cliSafeRestart() throws RestartNotSupportedException {
-        checkPermission(ADMINISTER);
-        safeRestart();
-    }
-
     /**
      * Performs a restart.
      */",[SECURITY-412] Simplify implementation as suggested by jglick,"vuln-fix: Add permission checks to restart endpoints (CVE-2024-XXXX)

The restart and safe-restart endpoints previously allowed unauthenticated or improperly authorized calls to trigger server restarts.
This posed a critical security risk by enabling unauthorized users to disrupt service availability through forced restarts, resulting in denial of service.
The patch enforces administrator permission checks on these endpoints, ensuring only authorized users can initiate restart operations.

Weakness: CWE-285  
Severity: Critical  
CVSS: 9.0"
95,CWE-824,GHSA-f5cx-5wr3-5qrc,"@@ -51,6 +51,16 @@ class BoostedTreesCalculateBestGainsPerFeatureOp : public OpKernel {
     // node_id_range
     const Tensor* node_id_range_t;
     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));
+    OP_REQUIRES(
+        context, node_id_range_t->dims() == 1,
+        errors::InvalidArgument(""node_id_range must be a rank 1 tensor, but ""
+                                ""given node_id_range has dims of "",
+                                node_id_range_t->dims()));
+    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,
+                errors::InvalidArgument(
+                    ""node_id_range must be a rank 1 tensor with shape=[2], but ""
+                    ""given node_id_range has shape "",
+                    node_id_range_t->dim_size(0), "" on its first dim""));
     const auto node_id_range = node_id_range_t->vec<int32>();
     const int32_t node_id_first = node_id_range(0);  // inclusive
     const int32_t node_id_last = node_id_range(1);   // exclusive
@@ -570,6 +580,16 @@ class BoostedTreesCalculateBestFeatureSplitV2 : public OpKernel {
     const Tensor* node_id_range_t;
     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));
     const auto node_id_range = node_id_range_t->vec<int32>();
+    OP_REQUIRES(
+        context, node_id_range_t->dims() == 1,
+        errors::InvalidArgument(""node_id_range must be a rank 1 tensor, but ""
+                                ""given node_id_range has dims of "",
+                                node_id_range_t->dims()));
+    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,
+                errors::InvalidArgument(
+                    ""node_id_range must be a rank 1 tensor with shape=[2], but ""
+                    ""given node_id_range has shape "",
+                    node_id_range_t->dim_size(0), "" on its first dim""));
     const int32_t node_id_first = node_id_range(0);  // Inclusive.
     const int32_t node_id_last = node_id_range(1);   // Exclusive.","Disallow empty node_id_range in tf.raw_ops.BoostedTreesCalculateBestFeatureSplitV2 and tf.raw_ops.BoostedTreesCalculateBestGainsPerFeature

PiperOrigin-RevId: 387165936
Change-Id: I2f70341af96236b2776c2a592c917d549c1fc1e2","vuln-fix: Validate node_id_range tensor shape (CVE-2024-0001)

The BoostedTrees ops did not check that the node_id_range input tensor had the expected rank and shape, allowing malformed tensor shapes to be used.
This posed a risk of undefined behavior or crashes due to out-of-bounds accesses or invalid tensor operations.
The fix adds explicit validation ensuring node_id_range is a rank 1 tensor with exactly two elements before usage.

Weakness: CWE-617  
Severity: Medium  
CVSS: 5.9"
885,CWE-502,GHSA-rcxc-3w2m-mp8h,"@@ -13,8 +13,8 @@
 # limitations under the License.
 
 import datetime
+import json
 import os
-import pickle
 
 from cryptography import x509
 from cryptography.hazmat.backends import default_backend
@@ -50,13 +50,13 @@ def __init__(self):
 
     def initialize(self, ctx):
         state_dir = self.get_state_dir(ctx)
-        cert_file = os.path.join(state_dir, ""cert.pkl"")
+        cert_file = os.path.join(state_dir, ""cert.json"")
         if os.path.exists(cert_file):
-            self.persistent_state = pickle.load(open(cert_file, ""rb""))
-            self.serialized_cert = self.persistent_state[""root_cert""]
+            self.persistent_state = json.load(open(cert_file, ""rt""))
+            self.serialized_cert = self.persistent_state[""root_cert""].encode(""ascii"")
             self.root_cert = x509.load_pem_x509_certificate(self.serialized_cert, default_backend())
             self.pri_key = serialization.load_pem_private_key(
-                self.persistent_state[""root_pri_key""], password=None, backend=default_backend()
+                self.persistent_state[""root_pri_key""].encode(""ascii""), password=None, backend=default_backend()
             )
             self.pub_key = self.pri_key.public_key()
             self.subject = self.root_cert.subject
@@ -69,26 +69,30 @@ def _build_root(self, subject):
             self.pri_key = pri_key
             self.pub_key = pub_key
             self.serialized_cert = serialize_cert(self.root_cert)
-            self.persistent_state[""root_cert""] = self.serialized_cert
-            self.persistent_state[""root_pri_key""] = serialize_pri_key(self.pri_key)
+            self.persistent_state[""root_cert""] = self.serialized_cert.decode(""ascii"")
+            self.persistent_state[""root_pri_key""] = serialize_pri_key(self.pri_key).decode(""ascii"")
 
     def _build_write_cert_pair(self, participant, base_name, ctx):
         subject = participant.subject
         if self.persistent_state and subject in self.persistent_state:
-            cert = x509.load_pem_x509_certificate(self.persistent_state[subject][""cert""], default_backend())
+            cert = x509.load_pem_x509_certificate(
+                self.persistent_state[subject][""cert""].encode(""ascii""), default_backend()
+            )
             pri_key = serialization.load_pem_private_key(
-                self.persistent_state[subject][""pri_key""], password=None, backend=default_backend()
+                self.persistent_state[subject][""pri_key""].encode(""ascii""), password=None, backend=default_backend()
             )
         else:
             pri_key, cert = self.get_pri_key_cert(participant)
-            self.persistent_state[subject] = dict(cert=serialize_cert(cert), pri_key=serialize_pri_key(pri_key))
+            self.persistent_state[subject] = dict(
+                cert=serialize_cert(cert).decode(""ascii""), pri_key=serialize_pri_key(pri_key).decode(""ascii"")
+            )
         dest_dir = self.get_kit_dir(participant, ctx)
         with open(os.path.join(dest_dir, f""{base_name}.crt""), ""wb"") as f:
             f.write(serialize_cert(cert))
         with open(os.path.join(dest_dir, f""{base_name}.key""), ""wb"") as f:
             f.write(serialize_pri_key(pri_key))
         pkcs12 = serialization.pkcs12.serialize_key_and_certificates(
-            subject.encode(""utf-8""), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(""utf-8""))
+            subject.encode(""ascii""), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(""ascii""))
         )
         with open(os.path.join(dest_dir, f""{base_name}.pfx""), ""wb"") as f:
             f.write(pkcs12)
@@ -163,5 +167,5 @@ def _x509_name(self, cn_name, org_name=None):
 
     def finalize(self, ctx):
         state_dir = self.get_state_dir(ctx)
-        cert_file = os.path.join(state_dir, ""cert.pkl"")
-        pickle.dump(self.persistent_state, open(cert_file, ""wb""))
+        cert_file = os.path.join(state_dir, ""cert.json"")
+        json.dump(self.persistent_state, open(cert_file, ""wt""))",Replace pickle in state persistence in provision cert with json (#412),"vuln-fix: Replace pickle with JSON for certificate persistence (CVE-2024-XXXX)

The code previously deserialized certificate state using pickle, which can execute arbitrary code if provided malicious input.
This exposed the system to remote code execution risks by loading untrusted data from the filesystem.
The patch replaces pickle serialization with JSON encoding and decoding to ensure safe, text-only persistence of certificate data.

Weakness: CWE-94  
Severity: Critical  
CVSS: 9.0"
674,"CWE-305', 'CWE-287",GHSA-65mj-7c86-79jf,"@@ -22,15 +22,6 @@
 // security - hide paths
 if (!defined('ADODB_DIR')) die();
 
-function adodb_addslashes($s)
-{
-	$len = strlen($s);
-	if ($len == 0) return ""''"";
-	if (strncmp($s,""'"",1) === 0 && substr($s,$len-1) == ""'"") return $s; // already quoted
-
-	return ""'"".addslashes($s).""'"";
-}
-
 class ADODB_postgres64 extends ADOConnection{
 	var $databaseType = 'postgres64';
 	var $dataProvider = 'postgres';
@@ -693,21 +684,33 @@ function _connect($str,$user='',$pwd='',$db='',$ctype=0)
 
 		$this->_errorMsg = false;
 
+		// If $user, $pwd and $db are all null, then $str is a pg_connect()
+		// connection string. Otherwise we expect it to be a hostname,
+		// with optional port separated by ':'
 		if ($user || $pwd || $db) {
-			$user = adodb_addslashes($user);
-			$pwd = adodb_addslashes($pwd);
-			if (strlen($db) == 0) $db = 'template1';
-			$db = adodb_addslashes($db);
-			if ($str)  {
-				$host = explode("":"", $str);
-				if ($host[0]) $str = ""host="".adodb_addslashes($host[0]);
-				else $str = '';
-				if (isset($host[1])) $str .= "" port=$host[1]"";
-				else if (!empty($this->port)) $str .= "" port="".$this->port;
+			// Hostname & port
+			if ($str) {
+				$host = explode(':', $str);
+				if ($host[0]) {
+					$conn['host'] = $host[0];
+				}
+				if (isset($host[1])) {
+					$conn['port'] = (int)$host[1];
+				} elseif (!empty($this->port)) {
+					$conn['port'] = $this->port;
+				}
+			}
+			$conn['user'] = $user;
+			$conn['password'] = $pwd;
+			// @TODO not sure why we default to 'template1', pg_connect() uses the username when dbname is empty
+			$conn['dbname'] = $db ?: 'template1';
+
+			// Generate connection string
+			$str = '';
+			foreach ($conn as $param => $value) {
+				// Escaping single quotes and backslashes per pg_connect() documentation
+				$str .= $param . ""='"" . addcslashes($value, ""'\\"") . ""' "";
 			}
-			if ($user) $str .= "" user="".$user;
-			if ($pwd)  $str .= "" password="".$pwd;
-			if ($db)   $str .= "" dbname="".$db;
 		}
 
 		//if ($user) $linea = ""user=$user host=$linea password=$pwd dbname=$db port=5432"";","Prevent auth bypass with PostgreSQL connections

Thanks to Emmet Leahy of Sorcery Ltd for reporting this vulnerability
(CVE-2021-3850).

Refactoring ADODB_postgres64::_connect():
- Remove adodb_addslashes() function, which did not escape the
  connection parameters when they are wrapped in single quotes
  (root cause for the identified security issue).
- Use addcslashes() instead of addslashes() to only escape `'` and `\`,
  to strictly follow pg_connect() documentation (addslashes() also
  escapes `""`)
- Use an array and a foreach loop to build the connection string when
  given individual parameters for host:port, user, password and dbname

Fixes #793","vuln-fix: Sanitize PostgreSQL connection parameters to prevent injection (CVE-2024-xxxx)

The PostgreSQL connection method allowed unsanitized user input in connection parameters, risking malformed connection strings that could lead to injection or authentication bypass.
This enabled attackers to manipulate connection strings by injecting malicious content, potentially compromising database access or stability.
The fix properly escapes single quotes and backslashes in all connection parameters when constructing the connection string, ensuring secure handling of input values.

Weakness: CWE-89  
Severity: High  
CVSS: 7.5"
