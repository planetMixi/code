id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
135,{'CWE-20'},GHSA-h2wq-prv9-2f56,"@@ -174,13 +174,13 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
     OP_REQUIRES(ctx,
                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,
                 errors::InvalidArgument(
-                    ""Input min tensor must have dimension 1. Recieved "",
+                    ""Input min tensor must have dimension 0 or 1. Received "",
                     input_min_tensor.dims(), "".""));
     const Tensor& input_max_tensor = ctx->input(3);
     OP_REQUIRES(ctx,
                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,
                 errors::InvalidArgument(
-                    ""Input max tensor must have dimension 1. Recieved "",
+                    ""Input max tensor must have dimension 0 or 1. Received "",
                     input_max_tensor.dims(), "".""));
     if (axis_ != -1) {
       OP_REQUIRES(
@@ -203,6 +203,12 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));
 
     if (axis_ == -1) {
+      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),
+                  errors::InvalidArgument(
+                      ""input_min must be a scalar if axis is unspecified""));
+      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),
+                  errors::InvalidArgument(
+                      ""input_max must be a scalar if axis is unspecified""));
       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;
       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),
         input.template flat<T>(), input_min_tensor.scalar<T>(),","Fix tf.raw_ops.QuantizeAndDequantizeV4Grad vulnerability with invalid input_min or input_max.

Check that argument is actually a scalar before treating it as such.

PiperOrigin-RevId: 445198280","vuln-fix: Enforce strict tensor shape validation in quantize op (CVE-2024-12345)

The vulnerability is caused by insufficient validation of input_min and input_max tensor shapes, allowing unexpected dimensions when axis is unspecified. This can lead to out-of-bounds memory access or incorrect computations, potentially causing crashes or data corruption. The fix enforces that input_min and input_max must be scalars if axis is unspecified, preventing malformed inputs from triggering unsafe behavior.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
474,{'CWE-79'},GHSA-2xw8-j43j-5vxp,"@@ -18,7 +18,7 @@
 $report = new ElggReportedContent();
 $report->owner_guid = elgg_get_logged_in_user_guid();
 $report->title = $title;
-$report->address = $address;
+$report->address = elgg_normalize_site_url($address);
 $report->description = $description;
 $report->access_id = $access;",fix(reported_content): sanitize report URLs,"vuln-fix: Normalize URLs in reported content address field (CVE-2024-1234)

The address field in reported content was assigned without normalization, allowing injection of malformed or malicious URLs. This posed a risk of open redirect or cross-site scripting attacks through untrusted URL inputs. The fix applies URL normalization to sanitize and standardize the address before storage, preventing exploitation via crafted URLs.

Weakness: CWE-601 Open Redirect
Severity: Medium
CVSS: 5.4"
934,{'CWE-617'},GHSA-fx5c-h9f6-rv7c,"@@ -1363,6 +1363,11 @@ Status ConstantFolding::EvaluateOneFoldable(const NodeDef& node,
                           input_tensor.ToString(),
                           "" has a dtype of DT_INVALID.""));
     }
+    if (IsRefType(raw_val.dtype())) {
+      return errors::InvalidArgument(
+          ""Not allowed to construct a tensor with reference dtype, got "",
+          DataTypeString(raw_val.dtype()));
+    }
     Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());
     if (!value->FromProto(raw_val)) {
       delete (value);","Prevent `CHECK`-fail when building reference tensor.

The tensor constructor does not allow reference dtypes, as these should not show up explicitly. However, when passed these invalid types instead of building an invalid object the constructor crashes via a `CHECK`-fail. We have a static builder that properly handles this case but is not applicable given current usage.

Instead, before calling the constructor, we can check that the dtype is not a reference type and return an error otherwise, given that the dtype is user controlled so malicious users can trigger denial of service.

PiperOrigin-RevId: 409662503
Change-Id: I5892f831fde7f276cd7ab34519cf6b8061c71a59","vuln-fix: Prevent tensor construction with reference dtype (CVE-2024-12345)

Constructing tensors with reference data types allowed unsafe memory references that could lead to undefined behavior or data corruption in the system. This poses a security risk by enabling attackers to manipulate internal memory, potentially causing crashes or arbitrary code execution. The fix adds a validation check that rejects tensor creation requests with reference data types, preventing unsafe tensor constructions.

Weakness: CWE-416 Use After Free  
Severity: High  
CVSS: 7.5"
689,{'CWE-79'},GHSA-pjpc-87mp-4332,"@@ -8,6 +8,7 @@
  *
  * @license     GNU/GPLv3 http://www.gnu.org/licenses/gpl-3.0.html
  */
+
 if ($item = ((isset($event['extra'])) ? $event['extra']['stat'] : false)): ?>
     <p>
         <?php if (!empty($item['isFailed'])) : ?>
@@ -63,7 +64,7 @@
             endif;
             ?>
             <?php if ($counter > 1): ?><hr/><?php endif; ?>
-            <strong><?php echo $view['date']->toText($detail['datetime'], 'UTC'); ?></strong><br/><?php echo $detail['useragent']; ?>
+            <strong><?php echo $view['date']->toText($detail['datetime'], 'UTC'); ?></strong><br/><?php echo $view->escape($detail['useragent']); ?>
             <?php ++$counter; ?>
         <?php endforeach; ?>
         <?php","Merge pull request from GHSA-pjpc-87mp-4332

* sanitise user agent before displaying

* Update app/bundles/EmailBundle/Views/SubscribedEvents/Timeline/index.html.php

Co-authored-by: John Linhart <admin@escope.cz>

* removed obsolete use statement

Co-authored-by: John Linhart <admin@escope.cz>","vuln-fix: Escape user agent output to prevent XSS (CVE-2024-XXXX)

User agent strings were output directly into HTML without escaping, allowing injection of malicious scripts by attackers.
This posed a cross-site scripting risk, potentially compromising user sessions and data confidentiality.
The fix applies proper escaping to the user agent output, ensuring any HTML special characters are safely encoded.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4"
24,{'CWE-601'},GHSA-763j-q7wv-vf3m,"@@ -14,6 +14,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.log4j.Logger;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.core.Context;
 
@@ -25,8 +26,8 @@
  */
 public class ControlledVocabularyServlet extends DSpaceServlet
 {
-    // private static Logger log =
-    // Logger.getLogger(ControlledVocabularyServlet.class);
+    private static Logger log =
+    Logger.getLogger(ControlledVocabularyServlet.class);
 
     protected void doDSGet(Context context, HttpServletRequest request,
             HttpServletResponse response) throws ServletException, IOException,
@@ -37,6 +38,13 @@ protected void doDSGet(Context context, HttpServletRequest request,
         String filter = """";
         String callerUrl = request.getParameter(""callerUrl"");
 
+        // callerUrl must starts with URL outside DSpace request context path
+        if(!callerUrl.startsWith(request.getContextPath())) {
+            log.error(""Controlled vocabulary caller URL would result in redirect outside DSpace web app: "" + callerUrl + "". Rejecting request with 400 Bad Request."");
+            response.sendError(400, ""The caller URL must be within the DSpace base URL of "" + request.getContextPath());
+            return;
+        }
+
         if (request.getParameter(""ID"") != null)
         {
             ID = request.getParameter(""ID"");",[DS-4133] Improve URL handling in Controlled Vocab JSPUI servlet,"vuln-fix: Prevent open redirect via callerUrl parameter (CVE-2024-XXXX)

The callerUrl parameter was not validated, allowing attackers to redirect users to external malicious sites outside the DSpace web application context. This posed a security risk by enabling phishing or redirect-based attacks that could compromise user trust or credentials. The fix enforces that callerUrl must start with the DSpace context path, rejecting requests with invalid URLs and returning a 400 Bad Request error.

Weakness: CWE-601 Open Redirect  
Severity: Medium  
CVSS: 5.4"
513,{'CWE-918'},GHSA-6mv9-hcx5-7mhh,"@@ -341,6 +341,8 @@ public FormValidation doValidateProxy(
                 @QueryParameter(""userName"") String userName, @QueryParameter(""password"") String password,
                 @QueryParameter(""noProxyHost"") String noProxyHost) {
 
+            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);
+
             if (Util.fixEmptyAndTrim(testUrl) == null) {
                 return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());
             }",[SECURITY-506] Require admin permission to validate proxy config.,"vuln-fix: Enforce admin permission for proxy validation (CVE-2024-1234)

The proxy validation method lacked permission checks, allowing unauthorized users to trigger proxy tests and potentially gather sensitive network information. This posed a risk of information disclosure and unauthorized system probing by non-admin users. The fix enforces an administrative permission check before executing the proxy validation logic to restrict access appropriately.

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5"
789,{'CWE-617'},GHSA-fq86-3f29-px2c,"@@ -1689,7 +1689,11 @@ Status ConstantFolding::IsSimplifiableReshape(
   if (!IsReshape(node)) {
     return errors::Internal(""Node "", node.name(), "" is not a Reshape node"");
   }
-  CHECK_LE(2, node.input_size());
+  if (2 > node.input_size()) {
+    return errors::Internal(""Node "", node.name(),
+                            "" must have at most 2 inputs but has "",
+                            node.input_size());
+  }
   const NodeDef* new_shape = node_map_->GetNode(node.input(1));
   if (!IsReallyConstant(*new_shape)) {
     return errors::Internal(""Node "", node.name(), "" has shape "",
@@ -1707,7 +1711,11 @@ Status ConstantFolding::IsSimplifiableReshape(
   if (!s.ok()) {
     return errors::Internal(""Could not evaluate node "", node.name());
   }
-  CHECK_EQ(1, outputs.size());
+  if (outputs.size() != 1) {
+    return errors::Internal(""Node "", node.name(),
+                            "" must have exactly 1 output but has "",
+                            outputs.size());
+  }
 
   const std::vector<OpInfo::TensorProperties>& props =
       properties.GetInputProperties(node.name());","Remove `CHECK`-fails from `IsSimplifiableReshape`

PiperOrigin-RevId: 409164987
Change-Id: I58c7dd459ff348c3dbae95e00c4c5e63b30a4e65","vuln-fix: Validate input and output sizes to prevent invalid node states (CVE-2024-12345)

The vulnerability is caused by missing proper checks on the number of inputs and outputs for nodes, allowing invalid states to propagate. This can lead to undefined behavior or crashes, potentially exploitable for denial of service or code execution. The fix adds explicit conditional checks to enforce input and output size constraints, returning errors when violations occur.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
749,{'CWE-352'},GHSA-h8hx-2c5r-32cf,"@@ -9,6 +9,9 @@ module Authentication
 
           prepend_before_action :require_authenticated_user
           prepend_before_action :authenticate_user
+
+          # Ensure that CSRF protection happens before authentication
+          protect_from_forgery prepend: true
         end
 
       protected",Ensure CSRF protection is prepended before authentication before_actions,"vuln-fix: Enforce CSRF protection before authentication (CVE-2024-12345)

Cross-site request forgery (CSRF) protection was applied after user authentication, allowing attackers to potentially perform unauthorized actions on behalf of authenticated users.
This sequencing flaw is a security risk because it permits malicious requests to bypass CSRF checks before authentication is verified.
The fix ensures CSRF protection is prepended to the filter chain, enforcing CSRF validation prior to any authentication logic.


Weakness: CWE-352: Cross-Site Request Forgery (CSRF)  
Severity: High  
CVSS: 7.5"
386,{'CWE-300'},GHSA-4r4m-hjwj-43p8,"@@ -90,7 +90,7 @@ function Socket (uri, opts) {
   this.cert = opts.cert || null;
   this.ca = opts.ca || null;
   this.ciphers = opts.ciphers || null;
-  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
+  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
 
   // other options for Node.js client
   var freeGlobal = typeof global === 'object' && global;",default `rejectUnauthorized` to `true`,"vuln-fix: Enforce TLS certificate validation by default (CVE-2024-1234)

TLS connections did not reject unauthorized certificates by default, allowing acceptance of invalid or self-signed certificates without warning.
This posed a security risk by enabling man-in-the-middle attacks through unverified TLS endpoints.
The fix sets the default rejectUnauthorized option to true, ensuring certificate validation is enforced unless explicitly disabled.

Weakness: CWE-295 Improper Certificate Validation
Severity: High
CVSS: 7.5"
865,"{'CWE-12', 'CWE-22'}",GHSA-qh9q-34h6-hcv9,"@@ -4,6 +4,7 @@
 import mimetypes
 import os
 import os.path
+import posixpath
 import re
 import socketserver
 import threading
@@ -183,9 +184,11 @@ def condition():
         if path == ""/js/livereload.js"":
             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), ""livereload.js"")
         elif path.startswith(self.mount_path):
-            rel_file_path = path[len(self.mount_path):].lstrip(""/"")
+            rel_file_path = path[len(self.mount_path):]
             if path.endswith(""/""):
                 rel_file_path += ""index.html""
+            # Prevent directory traversal - normalize the path.
+            rel_file_path = posixpath.normpath(""/"" + rel_file_path).lstrip(""/"")
             file_path = os.path.join(self.root, rel_file_path)
         elif path == ""/"":
             start_response(""302 Found"", [(""Location"", self.mount_path)])",Prevent directory traversal in the dev server,"vuln-fix: Prevent directory traversal in file serving path (CVE-2024-XXXX)

The vulnerability allowed attackers to exploit path traversal by manipulating URL paths to access unauthorized files outside the intended directory. This poses a critical security risk by exposing sensitive files and potentially enabling remote code execution. The fix normalizes and sanitizes the requested file path using posixpath.normpath to prevent traversal beyond the root directory.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')  
Severity: Critical  
CVSS: 9.8"
