id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
0,"{'CWE-665', 'CWE-20'}",GHSA-9rpc-5v9q-5r7f,"@@ -26,6 +26,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_util.h""
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,6 +39,17 @@ class SparseReshapeOp : public OpKernel {
   explicit SparseReshapeOp(OpKernelConstruction* context) : OpKernel(context) {}
 
   void Compute(OpKernelContext* context) override {
+    const Tensor& input_indices_in = context->input(0);
+    const Tensor& input_shape_in = context->input(1);
+
+    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),
+                errors::InvalidArgument(""Input must be a matrix.""));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),
+                errors::InvalidArgument(""Input shape must be a vector.""));
+    OP_REQUIRES(context,
+                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),
+                errors::InvalidArgument(
+                    ""Input tensor rank must match input shape length.""));
     ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),
                                 context->input(2), 0 /* output indices index */,
                                 1 /* output shape index */);","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseReshape`.

PiperOrigin-RevId: 371218558
Change-Id: I6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45","vuln-fix: Validate input tensor shapes in SparseReshapeOp

The vulnerability was missing validation of input tensor shapes, allowing malformed inputs to proceed unchecked in the sparse reshape operation. This posed a risk of undefined behavior or crashes due to shape mismatches leading to memory corruption or denial of service. The fix adds explicit checks ensuring input indices are matrices, input shapes are vectors, and their dimensions align before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
1,"{'CWE-908', 'CWE-200'}",GHSA-3wcq-x3mq-6r9p,"@@ -74,7 +74,8 @@ name.decode = function (buf, offset) {
 name.decode.bytes = 0
 
 name.encodingLength = function (n) {
-  return Buffer.byteLength(n) + 2
+  if (n === '.') return 1
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 var string = {}",backport encodingLength fix to v1,"vuln-fix: Prevent buffer length miscalculation for dot-only strings

The vulnerability was an incorrect calculation of buffer length when the input string was a single dot, causing potential buffer overflows or memory corruption during encoding. This is a security risk because it can lead to out-of-bounds memory access, enabling attackers to crash the application or execute arbitrary code. The fix adds a special case for single dot strings and trims leading and trailing dots before length calculation to ensure accurate buffer size estimation.

Weakness: Improper Calculation of Buffer Size (CWE-131)
Severity: High
CVSS: 7.5"
2,"{'CWE-200', 'CWE-287'}",GHSA-cchx-mfrc-fwqr,"@@ -120,6 +120,6 @@ protected function generateCookieValue($class, $username, $expires, $password)
      */
     protected function generateCookieHash($class, $username, $expires, $password)
     {
-        return hash_hmac('sha256', $class.$username.$expires.$password, $this->getSecret());
+        return hash_hmac('sha256', $class.self::COOKIE_DELIMITER.$username.self::COOKIE_DELIMITER.$expires.self::COOKIE_DELIMITER.$password, $this->getSecret());
     }
 }",[Security] Add a separator in the remember me cookie hash,"vuln-fix: Prevent cookie hash collision by adding delimiters

The cookie hash was generated by concatenating fields without delimiters, causing potential hash collisions for different input combinations.
This flaw could allow attackers to craft different cookie values that produce identical hashes, leading to authentication bypass or session hijacking.
The fix inserts explicit delimiters between fields before hashing, ensuring unique and unambiguous input to the HMAC function.

Weakness: CWE-347: Improper Verification of Cryptographic Signature
Severity: High
CVSS: 7.5"
3,{'CWE-200'},GHSA-xc7v-wxcw-j472,"@@ -128,7 +128,7 @@ TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
   if (connectOptions.proxyAuth) {
     connectOptions.headers = connectOptions.headers || {}
     connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
-        new Buffer(connectOptions.proxyAuth).toString('base64')
+        Buffer.from(connectOptions.proxyAuth).toString('base64')
   }
 
   debug('making CONNECT request')",Use .from,"vuln-fix: Replace deprecated Buffer constructor to prevent security risks

Using the deprecated Buffer constructor can lead to uninitialized memory exposure or unexpected behavior when encoding sensitive data like proxy authentication headers. This poses a security risk by potentially leaking credentials or causing application instability. The fix replaces the deprecated constructor with the safer Buffer.from method to ensure proper and secure encoding of authentication data.

Weakness: Use of Deprecated Buffer Constructor (CWE-676)  
Severity: Medium  
CVSS: 5.3"
4,{'CWE-200'},GHSA-hxf9-7h4c-f5jv,"@@ -2,6 +2,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -40,8 +41,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -77,8 +83,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.","vuln-fix: Prevent timing attacks on webhook basic authentication

The webhook basic authentication compared credentials using standard string comparison, exposing it to timing attacks that could leak sensitive authentication data. Timing attacks allow attackers to infer valid credentials by measuring response time differences, compromising webhook security. The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure uniform comparison time and prevent timing-based information leaks.

Weakness: CWE-208: Exposure of Sensitive Information Through Timing Discrepancy  
Severity: High  
CVSS: 7.5"
5,{'CWE-203'},GHSA-434h-p4gx-jm89,"@@ -833,6 +833,12 @@ def auth_user_db(self, username, password):
         if user is None:
             user = self.find_user(email=username)
         if user is None or (not user.is_active):
+            # Balance failure and success
+            check_password_hash(
+                ""pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118""
+                ""c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c"",
+                ""password"",
+            )
             log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))
             return None
         elif check_password_hash(user.password, password):",fix: auth balance (#1634),"vuln-fix: Prevent timing attacks on user authentication

The authentication function leaked timing information by returning early on missing or inactive users, enabling attackers to infer valid usernames through response time differences. This risk was mitigated by adding a dummy password hash check to equalize response times regardless of user existence or status. The fix balances failure and success paths to prevent attackers from distinguishing valid users based on authentication timing.

Weakness: CWE- timing side-channel vulnerability  
Severity: Medium  
CVSS: 5.3"
6,{'CWE-200'},GHSA-23cm-x6j7-6hq3,"@@ -101,6 +101,13 @@ interface IPayload extends Partial<IMessage> {
 }
 /* eslint-enable camelcase */
 
+interface SharedWithData {
+    // The identity key of the device we shared with
+    deviceKey: string;
+    // The message index of the ratchet we shared with that device
+    messageIndex: number;
+}
+
 /**
  * @private
  * @constructor
@@ -115,12 +122,12 @@ interface IPayload extends Partial<IMessage> {
  *
  * @property {object} sharedWithDevices
  *    devices with which we have shared the session key
- *        userId -> {deviceId -> msgindex}
+ *        userId -> {deviceId -> SharedWithData}
  */
 class OutboundSessionInfo {
     public useCount = 0;
     public creationTime: number;
-    public sharedWithDevices: Record<string, Record<string, number>> = {};
+    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};
     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};
 
     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {
@@ -150,11 +157,11 @@ class OutboundSessionInfo {
         return false;
     }
 
-    public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {
+    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {
         if (!this.sharedWithDevices[userId]) {
             this.sharedWithDevices[userId] = {};
         }
-        this.sharedWithDevices[userId][deviceId] = chainIndex;
+        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };
     }
 
     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {
@@ -572,6 +579,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
         payload: IPayload,
     ): Promise<void> {
         const contentMap = {};
+        const deviceInfoByDeviceId = new Map<string, DeviceInfo>();
 
         const promises = [];
         for (let i = 0; i < userDeviceMap.length; i++) {
@@ -584,6 +592,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const userId = val.userId;
             const deviceInfo = val.deviceInfo;
             const deviceId = deviceInfo.deviceId;
+            deviceInfoByDeviceId.set(deviceId, deviceInfo);
 
             if (!contentMap[userId]) {
                 contentMap[userId] = {};
@@ -636,7 +645,10 @@ class MegolmEncryption extends EncryptionAlgorithm {
                 for (const userId of Object.keys(contentMap)) {
                     for (const deviceId of Object.keys(contentMap[userId])) {
                         session.markSharedWithDevice(
-                            userId, deviceId, chainIndex,
+                            userId,
+                            deviceId,
+                            deviceInfoByDeviceId.get(deviceId).getIdentityKey(),
+                            chainIndex,
                         );
                     }
                 }
@@ -719,8 +731,8 @@ class MegolmEncryption extends EncryptionAlgorithm {
             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);
             return;
         }
-        const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];
-        if (sentChainIndex === undefined) {
+        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];
+        if (sessionSharedData === undefined) {
             logger.debug(
                 ""megolm session ID "" + sessionId + "" never shared with device "" +
                 userId + "":"" + device.deviceId,
@@ -728,10 +740,18 @@ class MegolmEncryption extends EncryptionAlgorithm {
             return;
         }
 
+        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {
+            logger.warn(
+                `Session has been shared with device ${device.deviceId} but with identity ` +
+                `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,
+            );
+            return;
+        }
+
         // get the key from the inbound session: the outbound one will already
         // have been ratcheted to the next chain index.
         const key = await this.olmDevice.getInboundGroupSessionKey(
-            this.roomId, senderKey, sessionId, sentChainIndex,
+            this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,
         );
 
         if (!key) {
@@ -882,7 +902,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const deviceId = deviceInfo.deviceId;
 
             session.markSharedWithDevice(
-                userId, deviceId, key.chain_index,
+                userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,
             );
         }",Verify target device key on reshare,"vuln-fix: Verify device identity key when accessing shared session keys

The code did not verify that the device identity key matched the one used when sharing the session key, allowing potential unauthorized access if a device key changed or was spoofed. This is a security risk because an attacker could impersonate a device and decrypt messages not intended for them. The fix stores the device identity key alongside the message index and checks for a key match before allowing access to the session key, preventing unauthorized decryption.

Weakness: Improper Authentication (CWE-287)
Severity: High
CVSS: 7.5"
7,{'CWE-209'},GHSA-pwwm-pwx2-2hw7,"@@ -87,6 +87,8 @@ public function sendResetLinkEmail(Request $request)
             \Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );
         }
 
+        // Prevent timing attack to enumerate users.
+        usleep(500000 + random_int(0, 1500000));
 
         if ($response === \Password::RESET_LINK_SENT) {
             \Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');","Added usleep :(

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent timing attack in password reset endpoint

The password reset function leaked timing information that allowed attackers to enumerate valid usernames by measuring response delays. This vulnerability could enable attackers to identify registered users and target them for further attacks. The fix introduces a randomized delay to normalize response times, mitigating timing side-channel information leaks.

Weakness: CWE-203: Information Exposure Through Timing Discrepancy  
Severity: Medium  
CVSS: 5.3"
8,{'CWE-200'},GHSA-7wv8-g97r-432h,"@@ -63,9 +63,9 @@
 
 });
 
-api_expose('users/search_authors', function ($params = false) {
+api_expose_admin('users/search_authors', function ($params = false) {
 
-    $return = array();
+    $return = array(); 
 
     $kw = false;
     if (isset($params['kw'])) {",search_authors only admins,"vuln-fix: Restrict user search authors API to admin access only

The users/search_authors API endpoint was accessible to all authenticated users without proper role restrictions.
This allowed unauthorized users to query author information, potentially exposing sensitive user data to attackers.
The fix restricts the endpoint to admin users by changing the exposure function to api_expose_admin, enforcing access control.


Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5"
9,{'CWE-203'},GHSA-mr6r-82x4-f4jj,"@@ -136,7 +136,17 @@ public function sign($msg, $key, $enc = null, $options = null)
             if( $k->cmpn(1) <= 0 || $k->cmp($ns1) >= 0 )
                 continue;
 
-            $kp = $this->g->mul($k);
+            // Fix the bit-length of the random nonce,
+            // so that it doesn't leak via timing.
+            // This does not change that ks = k mod k
+            $ks = $k->add($this->n);
+            $kt = $ks->add($this->n);
+            if ($ks->bitLength() === $this->n->bitLength()) {
+                $kp = $this->g->mul($kt);
+            } else {
+                $kp = $this->g->mul($ks);
+            }
+
             if( $kp->isInfinity() )
                 continue;","ecdsa: Apply nonce bit-length mitigation to stop timing leakage.

Ported from elliptic-js: https://github.com/indutny/elliptic/pull/203","vuln-fix: Prevent timing leak in nonce bit-length during signature

The vulnerability involved leaking the bit-length of the random nonce through timing variations in the signature computation process. This timing leak could allow attackers to infer secret key information by analyzing operation durations, compromising cryptographic security. The fix normalizes nonce bit-length by adjusting the nonce before multiplication, ensuring constant-time execution and preventing information leakage.

Weakness: Timing Side Channel (CWE-208)  
Severity: High  
CVSS: 7.5"
10,{'CWE-209'},GHSA-hhrj-wp42-32v3,"@@ -5,10 +5,12 @@
 use EloquentFilter\Filterable;
 use Illuminate\Database\Eloquent\Model;
 use MicroweberPackages\Content\Models\ModelFilters\ContentFilter;
+use MicroweberPackages\Core\Models\HasSearchableTrait;
 
 class Comment extends Model
 {
     use Filterable;
+    use HasSearchableTrait;
 
     public $table = 'comments';
 
@@ -21,6 +23,13 @@ class Comment extends Model
         'comment_body',
     ];
 
+    protected $searchable = [
+        'comment_name',
+        'comment_email',
+        'comment_website',
+        'comment_body',
+    ];
+
     public function modelFilter()
     {
         return $this->provideFilter(ContentFilter::class);",Update Comment.php,"vuln-fix: Add searchable trait with controlled fields to Comment model

The Comment model was missing explicit control over searchable fields, potentially exposing sensitive or unintended data to search queries. This could allow attackers to infer or manipulate data through unfiltered search inputs, increasing the risk of information disclosure or injection attacks. The fix introduces a searchable trait with a defined whitelist of safe fields, restricting search operations to only intended attributes and improving data access control.

Weakness: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor  
Severity: Medium  
CVSS: 5.3"
11,{'CWE-201'},GHSA-3p92-886g-qxpq,"@@ -28,7 +28,7 @@ module.exports = function(options){
 
     if(writes.length > windowSize) writes.shift();
 
-    data = data instanceof Buffer ? data : new Buffer(data);
+    data = data instanceof Buffer ? data : new Buffer(data+'');
     bufLen += data.length;
 
     buf.push(data);",adding fix for exposing uninitalized memory found by @chalker,"vuln-fix: Prevent buffer overflow by normalizing input to string before buffer conversion

The vulnerability arises from directly converting non-buffer data to a Buffer without ensuring it is a string, which can cause unexpected buffer sizes and potential overflow. This is a security risk because attackers could exploit improper buffer length calculations to trigger memory corruption or denial of service. The fix ensures all non-buffer inputs are first converted to strings before creating a Buffer, preventing malformed buffer lengths and improving input handling safety.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
12,{'CWE-20'},GHSA-f7f4-hqp2-7prc,"@@ -3,6 +3,7 @@
  */
 
 var util = require('util');
+var url = require('url');
 var _ = require('@sailshq/lodash');
 var semver = require('semver');
 var parseSdkMetadata = require('./parse-sdk-metadata');
@@ -105,6 +106,8 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+
       method  : options.eventName,
 
       // Attached data becomes simulated HTTP body (`req.body`)",Define req.path for socket requests.,"vuln-fix: Parse and validate URL path from incoming messages

The vulnerability involved using the full URL string without extracting the path component, which could lead to improper routing or injection attacks. This is a security risk because attackers might exploit unvalidated URL parts to bypass access controls or inject malicious payloads. The fix extracts and uses only the pathname from the URL, ensuring safer and more precise request handling.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
13,{'CWE-20'},GHSA-hrg5-737c-2p56,"@@ -92,6 +92,9 @@ class UnsortedSegmentJoinOp : public OpKernel {
     const Tensor& num_segments_tensor = context->input(2);
     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
+    OP_REQUIRES(context,
+                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
+                errors::InvalidArgument(""Number of segments must be a scalar""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(","Fix tf.raw_ops.UnsortedSegmentJoin vulnerability with invalid num_segments.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445206880","vuln-fix: Enforce scalar input for number of segments parameter

The vulnerability allowed non-scalar tensors for the number of segments input, which could cause unexpected behavior or memory corruption during kernel execution. This poses a security risk by enabling malformed inputs to trigger undefined states or crashes, potentially exploitable for denial of service or code execution. The fix adds a strict check to ensure the number of segments input is a scalar tensor, rejecting invalid shapes early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
14,{'CWE-20'},GHSA-h5g4-ppwx-48q2,"@@ -134,6 +134,8 @@ class DeleteSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""`handle` must be scalar""));
     const string& name = handle.scalar<tstring>()();
     auto session_state = ctx->session_state();
     OP_REQUIRES(ctx, session_state != nullptr,","Fix tf.raw_ops.DeleteSessionTensor vulnerability with invalid `handle`.

Check that `handle` input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445228994","vuln-fix: Enforce scalar tensor shape for session handle input

The vulnerability was caused by missing validation on the shape of the session handle tensor input, allowing non-scalar tensors to be processed. This posed a security risk as malformed inputs could lead to unexpected behavior or memory corruption in session management. The fix adds a strict check to ensure the handle tensor is scalar, rejecting invalid inputs early in the computation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
15,{'CWE-20'},GHSA-g25h-jr74-qp5j,"@@ -113,7 +113,50 @@ class QuantizeV2Op : public OpKernel {
 
     int num_slices = 1;
     if (axis_ > -1) {
+      OP_REQUIRES(
+          ctx, input.dims() > axis_,
+          errors::InvalidArgument(
+              ""Axis is on a zero-based index, so its value must always be less ""
+              ""than number of input's dims, but given axis value was "",
+              axis_, "" and input's dims was "", input.dims()));
       num_slices = input.dim_size(axis_);
+      OP_REQUIRES(ctx, input_min_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range dims are "",
+                      input_min_range.dims()));
+      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range is a 1-D tensor of size "",
+                      input_min_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+      OP_REQUIRES(ctx, input_max_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range dims are "",
+                      input_max_range.dims()));
+      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range is a 1-D tensor of size "",
+                      input_max_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+    } else {
+      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, min_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_min_range.NumElements(), "" elements""));
+      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, max_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_max_range.NumElements(), "" elements""));
     }
 
     const TensorShape& minmax_shape = ctx->input(1).shape();","Secure tf.raw_ops.QuantizeV2

Validate size and shape of min_range and max_range
Ensure axis is within input dims limits

PiperOrigin-RevId: 387232799
Change-Id: I36975281f7b5758e9e31a8dcc73fe610ef456318","vuln-fix: Validate tensor dimensions to prevent out-of-bounds access

The vulnerability is due to missing validation of tensor dimensions and axis values, which could lead to out-of-bounds memory access or crashes during quantization operations. This poses a security risk as it may allow attackers to cause denial of service or potentially execute arbitrary code by triggering invalid memory reads. The fix adds strict checks on axis bounds and tensor dimension sizes, ensuring inputs conform to expected shapes before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
16,{'CWE-200'},GHSA-f5fj-7265-jxhj,"@@ -1,4 +1,5 @@
 // Copyright 2016 The Gogs Authors. All rights reserved.
+// Copyright 2018 The Gitea Authors. All rights reserved.
 // Use of this source code is governed by a MIT-style
 // license that can be found in the LICENSE file.
 
@@ -87,7 +88,9 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 		names = append(names, participants[i].Name)
 	}
 
-	SendIssueCommentMail(issue, doer, content, comment, tos)
+	for _, to := range tos {
+		SendIssueCommentMail(issue, doer, content, comment, []string{to})
+	}
 
 	// Mail mentioned people and exclude watchers.
 	names = append(names, doer.Name)
@@ -99,7 +102,12 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 
 		tos = append(tos, mentions[i])
 	}
-	SendIssueMentionMail(issue, doer, content, comment, getUserEmailsByNames(e, tos))
+
+	emails := getUserEmailsByNames(e, tos)
+
+	for _, to := range emails {
+		SendIssueMentionMail(issue, doer, content, comment, []string{to})
+	}
 
 	return nil
 }",Don't disclose emails of all users when sending out emails (#4664),"vuln-fix: Prevent email header injection via bulk recipient fields

The vulnerability allowed sending emails with multiple recipients in a single call, risking email header injection and unintended disclosure of participant email addresses. This posed a security risk by enabling attackers to manipulate email headers or expose private user information through mass email fields. The fix sends emails individually to each recipient, isolating headers and preventing injection or leakage of other recipients’ addresses.

Weakness: CWE-93: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')  
Severity: High  
CVSS: 7.5"
17,"{'CWE-915', 'CWE-20'}",GHSA-66rh-8fw6-59q6,"@@ -37,7 +37,7 @@ function extend(target, obj) {
   assignSymbols(target, obj);
 
   for (var key in obj) {
-    if (key !== '__proto__' && hasOwn(obj, key)) {
+    if (isValidKey(key) && hasOwn(obj, key)) {
       var val = obj[key];
       if (isObject(val)) {
         if (typeOf(target[key]) === 'undefined' && typeOf(val) === 'function') {
@@ -68,6 +68,14 @@ function hasOwn(obj, key) {
   return Object.prototype.hasOwnProperty.call(obj, key);
 }
 
+/**
+ * Returns true if the given `key` is a valid key that can be used for assigning properties.
+ */
+
+function isValidKey(key) {
+  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
+}
+
 /**
  * Expose `assign`
  */",ensure keys are valid,"vuln-fix: Prevent prototype pollution by restricting property keys

The vulnerability allowed assignment of dangerous keys like 'constructor' and 'prototype', enabling prototype pollution attacks that can alter object behavior globally. This is a critical security risk as it can lead to arbitrary code execution or denial of service by tampering with object prototypes. The fix introduces a key validation function that blocks assignment of '__proto__', 'constructor', and 'prototype' keys, preventing prototype pollution. 

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: Critical  
CVSS: 9.1"
18,{'CWE-20'},GHSA-9m95-8hx6-7p9v,"@@ -404,6 +404,11 @@ func (te *TarExtractor) UnpackEntry(root string, hdr *tar.Header, r io.Reader) (
 	if filepath.Join(""/"", hdr.Name) == ""/"" {
 		// If we got an entry for the root, then unsafeDir is the full path.
 		unsafeDir, file = hdr.Name, "".""
+		// If we're being asked to change the root type, bail because they may
+		// change it to a symlink which we could inadvertently follow.
+		if hdr.Typeflag != tar.TypeDir {
+			return errors.New(""malicious tar entry -- refusing to change type of root directory"")
+		}
 	}
 	dir, err := securejoin.SecureJoinVFS(root, unsafeDir, te.fsEval)
 	if err != nil {","layer: don't permit / type to be changed on extraction

If users can change the type of / to a symlink, they can cause umoci to
overwrite host files. This is obviously bad, and is not caught by the
rest of our directory escape detection code because the root itself has
been changed to a different directory.

Fixes: CVE-2021-29136
Reported-by: Robin Peraglie <robin@cure53.de>
Tested-by: Daniel Dao <dqminh89@gmail.com>
Reviewed-by: Tycho Andersen <tycho@tycho.pizza>
Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>","vuln-fix: Prevent root directory type change in tar extraction

The vulnerability allows a malicious tar archive to change the root directory type to a symlink or other type during extraction. This poses a security risk by enabling symlink attacks that could lead to arbitrary file access or overwriting critical files. The fix rejects any tar entry attempting to change the root directory type unless it remains a directory, preventing unsafe type changes.

Weakness: CWE-59: Improper Link Resolution Before File Access
Severity: High
CVSS: 7.5"
19,{'CWE-200'},GHSA-5r2v-6gm6-vpvh,"@@ -112,6 +112,15 @@ func reqRepoWriter() macaron.Handler {
 	}
 }
 
+func reqRepoAdmin() macaron.Handler {
+	return func(c *context.Context) {
+		if !c.Repo.IsAdmin() {
+			c.Error(http.StatusForbidden)
+			return
+		}
+	}
+}
+
 func orgAssignment(args ...bool) macaron.Handler {
 	var (
 		assignOrg  bool
@@ -236,12 +245,12 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateHookOption{}), repo.CreateHook)
 					m.Combo(""/:id"").Patch(bind(api.EditHookOption{}), repo.EditHook).
 						Delete(repo.DeleteHook)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/collaborators"", func() {
 					m.Get("""", repo.ListCollaborators)
 					m.Combo(""/:collaborator"").Get(repo.IsCollaborator).Put(bind(api.AddCollaboratorOption{}), repo.AddCollaborator).
 						Delete(repo.DeleteCollaborator)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Get(""/raw/*"", context.RepoRef(), repo.GetRawFile)
 				m.Get(""/archive/*"", repo.GetArchive)
 				m.Get(""/forks"", repo.ListForks)
@@ -260,7 +269,7 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateKeyOption{}), repo.CreateDeployKey)
 					m.Combo(""/:id"").Get(repo.GetDeployKey).
 						Delete(repo.DeleteDeploykey)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/issues"", func() {
 					m.Combo("""").Get(repo.ListIssues).Post(bind(api.CreateIssueOption{}), repo.CreateIssue)
 					m.Group(""/comments"", func() {
@@ -300,8 +309,8 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Delete(reqRepoWriter(), repo.DeleteMilestone)
 				})
 
-				m.Patch(""/issue-tracker"", bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
-				m.Post(""/mirror-sync"", repo.MirrorSync)
+				m.Patch(""/issue-tracker"", reqRepoWriter(), bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
+				m.Post(""/mirror-sync"", reqRepoWriter(), repo.MirrorSync)
 				m.Get(""/editorconfig/:filename"", context.RepoRef(), repo.GetEditorconfig)
 			}, repoAssignment())
 		}, reqToken())","routes/api: fix permission checks for routes

Reported by @ManassehZhou #5764","vuln-fix: Enforce admin-only access for sensitive repository routes

Certain repository routes previously used a generic admin check that did not verify repository-specific admin rights, allowing unauthorized users to access sensitive operations. This posed a security risk by potentially exposing critical repository management functions to non-admin users. The fix introduces a repository-specific admin check middleware and applies it to sensitive routes, ensuring only repository admins can perform these actions.

Weakness: Improper Access Control (CWE-284)
Severity: High
CVSS: 7.5"
20,{'CWE-20'},GHSA-v82p-hv3v-p6qp,"@@ -49,35 +49,45 @@ class MklRequantizePerChannelOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     try {
       const Tensor& input = ctx->input(kInputTensorIndex);
+      OP_REQUIRES(
+          ctx, input.dims() == 4,
+          errors::InvalidArgument(""Current RequantizePerChannel operator""
+                                  ""supports 4D tensors only.""));
+
       const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);
+      size_t depth = input_min_vec.NumElements();
       float* input_min_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_min_vec.flat<float>().data()));
+
       const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);
+      OP_REQUIRES(
+          ctx, input_max_vec.NumElements() == depth,
+          errors::InvalidArgument(""input_max has incorrect size, expected "",
+                                  depth, "" was "", input_max_vec.NumElements()));
       float* input_max_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_max_vec.flat<float>().data()));
 
       const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_min must be a scalar""));
       const float input_requested_min_float =
           input_requested_min.flat<float>()(0);
+
       const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_max must be a scalar""));
       const float input_requested_max_float =
           input_requested_max.flat<float>()(0);
 
-      size_t depth = input_min_vec.NumElements();
-      OP_REQUIRES(
-          ctx, input.dims() == 4,
-          errors::InvalidArgument(""Current RequantizePerChannel operator""
-                                  ""supports 4D tensors only.""));
-      OP_REQUIRES(
-          ctx, input_min_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_min has incorrect size, expected "",
-                                  depth, "" was "", input_min_vec.dim_size(0)));
-      OP_REQUIRES(
-          ctx, input_max_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_max has incorrect size, expected "",
-                                  depth, "" was "", input_max_vec.dim_size(0)));
-
-      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);
+      if (out_type_ == DT_QINT8) {
+        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,
+                    errors::InvalidArgument(
+                        ""If out_type is QINT8, requested_output_max must be ""
+                        ""non negative, got "",
+                        input_requested_min_float));
+      }
 
       const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;
       const float requested_min_max =","Reorganize and add more validation to MKL requantization

PiperOrigin-RevId: 387901341
Change-Id: I2515b9034c64e113db0bcec8337d30643ab0a0f1","vuln-fix: Validate tensor dimensions and input sizes in requantize op

The vulnerability is due to missing strict validation of tensor dimensions and input vector sizes in the requantize per-channel operator, allowing malformed inputs to proceed. This poses a security risk as it can lead to out-of-bounds memory access or undefined behavior, potentially causing crashes or exploitable conditions. The fix adds explicit checks for 4D tensor inputs, matching vector sizes, scalar constraints, and value ranges to ensure input integrity before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
21,{'CWE-20'},GHSA-2p9q-h29j-3f5v,"@@ -36,6 +36,10 @@ class SummaryTensorOpV2 : public OpKernel {
                 errors::InvalidArgument(""tag must be scalar""));
     const Tensor& tensor = c->input(1);
     const Tensor& serialized_summary_metadata_tensor = c->input(2);
+    OP_REQUIRES(
+        c,
+        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),
+        errors::InvalidArgument(""serialized_summary_metadata must be scalar""));
 
     Summary s;
     Summary::Value* v = s.add_value();","Fix tf.raw_ops.TensorSummaryV2 vulnerability with invalid serialized_summary_metadata.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445197183","vuln-fix: Validate serialized_summary_metadata tensor shape to prevent misuse

The vulnerability is the lack of validation for the shape of serialized_summary_metadata tensor, allowing non-scalar inputs to be processed incorrectly. This is a security risk because malformed inputs could lead to unexpected behavior or memory corruption in downstream processing. The fix enforces a scalar shape check on serialized_summary_metadata tensor and rejects invalid inputs early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
22,{'CWE-209'},GHSA-hm37-9xh2-q499,"@@ -221,7 +221,9 @@ def from_bytes(
 
         Raises:
             ValueError: The provided byte string is not an ``openssh-key-v1``
-                key list or the declared key count is negative.
+                key list, when the declared key count is negative, or when an
+                EOF is found while parsing the key.
+
             UserWarning: The check numbers in the decrypted private byte string
                 do not match (likely due to an incorrect passphrase), the key
                 type or parameter values of a private key do not match that of
@@ -229,110 +231,117 @@ def from_bytes(
                 at the end of the decrypted private byte string are not as
                 expected.
         """"""
-        byte_stream = PascalStyleByteStream(byte_string)
+        try:
+            byte_stream = PascalStyleByteStream(byte_string)
 
-        header = byte_stream.read_from_format_instructions_dict(
-            cls.HEADER_FORMAT_INSTRUCTIONS_DICT
-        )
+            header = byte_stream.read_from_format_instructions_dict(
+                cls.HEADER_FORMAT_INSTRUCTIONS_DICT
+            )
+
+            if header['auth_magic'] != b'openssh-key-v1\x00':
+                raise ValueError('Not an openssh-key-v1 key')
 
-        if header['auth_magic'] != b'openssh-key-v1\x00':
-            raise ValueError('Not an openssh-key-v1 key')
+            num_keys = header['num_keys']
 
-        num_keys = header['num_keys']
+            if num_keys < 0:
+                raise ValueError('Cannot parse negative number of keys')
 
-        if num_keys < 0:
-            raise ValueError('Cannot parse negative number of keys')
+            public_key_list = []
+            for i in range(num_keys):
+                public_key_bytes = byte_stream.read_from_format_instruction(
+                    PascalStyleFormatInstruction.BYTES
+                )
+                public_key_list.append(
+                    PublicKey.from_bytes(public_key_bytes)
+                )
 
-        public_key_list = []
-        for i in range(num_keys):
-            public_key_bytes = byte_stream.read_from_format_instruction(
+            cipher_bytes = byte_stream.read_from_format_instruction(
                 PascalStyleFormatInstruction.BYTES
             )
-            public_key_list.append(
-                PublicKey.from_bytes(public_key_bytes)
-            )
 
-        cipher_bytes = byte_stream.read_from_format_instruction(
-            PascalStyleFormatInstruction.BYTES
-        )
-
-        kdf_class = get_kdf_options_class(header['kdf'])
-        kdf_options = kdf_class(
-            PascalStyleByteStream(
-                header['kdf_options']
-            ).read_from_format_instructions_dict(
-                kdf_class.FORMAT_INSTRUCTIONS_DICT
+            kdf_class = get_kdf_options_class(header['kdf'])
+            kdf_options = kdf_class(
+                PascalStyleByteStream(
+                    header['kdf_options']
+                ).read_from_format_instructions_dict(
+                    kdf_class.FORMAT_INSTRUCTIONS_DICT
+                )
             )
-        )
 
-        cipher_class = get_cipher_class(header['cipher'])
+            cipher_class = get_cipher_class(header['cipher'])
 
-        if kdf_class == NoneKDFOptions:
-            passphrase = ''
-        elif passphrase is None:
-            passphrase = getpass.getpass('Key passphrase: ')
+            if kdf_class == NoneKDFOptions:
+                passphrase = ''
+            elif passphrase is None:
+                passphrase = getpass.getpass('Key passphrase: ')
 
-        if issubclass(cipher_class, ConfidentialityIntegrityCipher):
-            cipher_bytes += byte_stream.read_fixed_bytes(
-                cipher_class.TAG_LENGTH
-            )
-
-        decipher_bytes = cipher_class.decrypt(
-            kdf_class(kdf_options),
-            passphrase,
-            cipher_bytes
-        )
-
-        decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
+            if issubclass(cipher_class, ConfidentialityIntegrityCipher):
+                cipher_bytes += byte_stream.read_fixed_bytes(
+                    cipher_class.TAG_LENGTH
+                )
 
-        decipher_bytes_header = \
-            decipher_byte_stream.read_from_format_instructions_dict(
-                cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
+            decipher_bytes = cipher_class.decrypt(
+                kdf_class(kdf_options),
+                passphrase,
+                cipher_bytes
             )
 
-        if decipher_bytes_header['check_int_1'] \
-                != decipher_bytes_header['check_int_2']:
-            warnings.warn('Cipher header check numbers do not match')
+            decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
 
-        initlist = []
-        for i in range(num_keys):
-            initlist.append(
-                PublicPrivateKeyPair(
-                    public_key_list[i],
-                    PrivateKey.from_byte_stream(decipher_byte_stream)
-                )
-            )
-            if initlist[i].public.header['key_type'] \
-                    != initlist[i].private.header['key_type']:
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'key types for key {i}'
+            decipher_bytes_header = \
+                decipher_byte_stream.read_from_format_instructions_dict(
+                    cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
                 )
-            if not all(
-                (
-                    initlist[i].public.params[k] ==
-                    initlist[i].private.params[k]
-                ) for k in (
-                    initlist[i].public.params.keys() &
-                    initlist[i].private.params.keys()
+
+            if decipher_bytes_header['check_int_1'] \
+                    != decipher_bytes_header['check_int_2']:
+                warnings.warn('Cipher header check numbers do not match')
+
+            initlist = []
+            for i in range(num_keys):
+                initlist.append(
+                    PublicPrivateKeyPair(
+                        public_key_list[i],
+                        PrivateKey.from_byte_stream(decipher_byte_stream)
+                    )
                 )
+                if initlist[i].public.header['key_type'] \
+                        != initlist[i].private.header['key_type']:
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'key types for key {i}'
+                    )
+                if not all(
+                    (
+                        initlist[i].public.params[k] ==
+                        initlist[i].private.params[k]
+                    ) for k in (
+                        initlist[i].public.params.keys() &
+                        initlist[i].private.params.keys()
+                    )
+                ):
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'values for key {i}'
+                    )
+
+            decipher_padding = decipher_byte_stream.read()
+
+            if (
+                len(decipher_byte_stream.getvalue()) %
+                    cipher_class.BLOCK_SIZE != 0
+            ) or not (
+                bytes(
+                    range(1, 1 + cipher_class.BLOCK_SIZE)
+                ).startswith(decipher_padding)
             ):
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'values for key {i}'
-                )
-
-        decipher_padding = decipher_byte_stream.read()
-
-        if (
-            len(decipher_byte_stream.getvalue()) %
-                cipher_class.BLOCK_SIZE != 0
-        ) or not (
-            bytes(
-                range(1, 1 + cipher_class.BLOCK_SIZE)
-            ).startswith(decipher_padding)
-        ):
-            warnings.warn('Incorrect padding at end of ciphertext')
+                warnings.warn('Incorrect padding at end of ciphertext')
+        except ValueError as e:
+            raise e
+        except EOFError as e:
+            raise ValueError('Premature EOF detected while parsing key.')
+        except e:
+            raise ValueError('Unexpected error condition reached.')
 
         return cls(
             initlist,",Improved error handling to prevent unhandled exceptions in calling code.,"vuln-fix: Prevent premature EOF and improve key parsing validation

The vulnerability is that the key parsing function did not handle premature EOF errors, allowing incomplete or malformed keys to be processed without proper error reporting. This is a security risk because it could lead to corrupted key data being accepted, potentially causing undefined behavior or cryptographic failures. The fix adds explicit EOF detection and raises a ValueError on premature EOF, along with enhanced validation of key counts and header fields to ensure robust parsing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
23,{'CWE-200'},GHSA-fcxw-hhxq-48wx,"@@ -42,6 +42,11 @@
 import java.net.URISyntaxException;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -1411,6 +1416,34 @@ public void addNote(String note, String namespace ) throws GitException, Interru
         createNote(note,namespace,""add"");
     }
 
+    private File createTempFileInSystemDir(String prefix, String suffix) throws IOException {
+        if (isWindows()) {
+            return Files.createTempFile(prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(prefix, suffix, fileAttribute).toFile();
+    }
+
+    private File createTempFile(String prefix, String suffix) throws IOException {
+        if (workspace == null) {
+            return createTempFileInSystemDir(prefix, suffix);
+        }
+        File workspaceTmp = new File(workspace.getAbsolutePath() + ""@tmp"");
+        if (!workspaceTmp.isDirectory() && !workspaceTmp.mkdirs()) {
+            if (!workspaceTmp.isDirectory()) {
+                return createTempFileInSystemDir(prefix, suffix);
+            }
+        }
+        Path tmpPath = Paths.get(workspaceTmp.getAbsolutePath());
+        if (isWindows()) {
+            return Files.createTempFile(tmpPath, prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(tmpPath, prefix, suffix, fileAttribute).toFile();
+    }
+
     private void deleteTempFile(File tempFile) {
         if (tempFile != null && !tempFile.delete() && tempFile.exists()) {
             listener.getLogger().println(""[WARNING] temp file "" + tempFile + "" not deleted"");
@@ -1420,7 +1453,7 @@ private void deleteTempFile(File tempFile) {
     private void createNote(String note, String namespace, String command ) throws GitException, InterruptedException {
         File msg = null;
         try {
-            msg = File.createTempFile(""git-note"", ""txt"", workspace);
+            msg = createTempFile(""git-note"", "".txt"");
             FileUtils.writeStringToFile(msg,note);
             launchCommand(""notes"", ""--ref="" + namespace, command, ""-F"", msg.getAbsolutePath());
         } catch (IOException | GitException e) {
@@ -1561,7 +1594,7 @@ private String launchCommandWithCredentials(ArgumentListBuilder args, File workD
     }
 
     private File createSshKeyFile(SSHUserPrivateKey sshUser) throws IOException, InterruptedException {
-        File key = File.createTempFile(""ssh"", ""key"");
+        File key = createTempFile(""ssh"", "".key"");
         try (PrintWriter w = new PrintWriter(key, Charset.defaultCharset().toString())) {
             List<String> privateKeys = sshUser.getPrivateKeys();
             for (String s : privateKeys) {
@@ -1597,7 +1630,7 @@ private String quoteUnixCredentials(String str) {
     }
 
     private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".bat"");
+        File ssh = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             // avoid echoing command as part of the password
             w.println(""@echo off"");
@@ -1610,7 +1643,7 @@ private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOExcepti
     }
 
     private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".sh"");
+        File ssh = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""echo '"" + quoteUnixCredentials(Secret.toString(sshUser.getPassphrase())) + ""'"");
@@ -1621,7 +1654,7 @@ private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException
 
     /* Package protected for testability */
     File createWindowsBatFile(String userName, String password) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".bat"");
+        File askpass = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""@set arg=%~1"");
             w.println(""@if (%arg:~0,8%)==(Username) echo "" + escapeWindowsCharsForUnquotedString(userName));
@@ -1636,7 +1669,7 @@ private File createWindowsStandardAskpass(StandardUsernamePasswordCredentials cr
     }
 
     private File createUnixStandardAskpass(StandardUsernamePasswordCredentials creds) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".sh"");
+        File askpass = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""case \""$1\"" in"");
@@ -1766,7 +1799,7 @@ private File getSSHExeFromGitExeParentDir(String userGitExe) {
     }
 
     private File createWindowsGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".bat"");
+        File ssh = createTempFile(""ssh"", "".bat"");
 
         File sshexe = getSSHExecutable();
 
@@ -1779,7 +1812,7 @@ private File createWindowsGitSSH(File key, String user) throws IOException {
     }
 
     private File createUnixGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".sh"");
+        File ssh = createTempFile(""ssh"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             // ${SSH_ASKPASS} might be ignored if ${DISPLAY} is not set
@@ -2383,7 +2416,7 @@ public void branch(String name) throws GitException, InterruptedException {
     public void commit(String message) throws GitException, InterruptedException {
         File f = null;
         try {
-            f = File.createTempFile(""gitcommit"", "".txt"");
+            f = createTempFile(""gitcommit"", "".txt"");
             try (OutputStream out = Files.newOutputStream(f.toPath())) {
                 out.write(message.getBytes(Charset.defaultCharset().toString()));
             }","[Fix SECURITY-445] better protect temporary files

Temporary files were previously written to the system temporary directory
with default permissions.  A malicious actor could have captured sensitive
information by reading files from the temporary directory.  The temporary
files typically are only on the file system for the duration of a single
command line git invocation, but cloning a large git repo could require
an extended time with those sensitive files in the temporary directory.

This change sets permissions on the temporary files to be readable only by
the file owner. If a workspace is available, a temporary directory adjacent
to the workspace is used instead of the system temporary directory.","vuln-fix: Restrict temporary file permissions to owner only

Temporary files were created without explicit permission restrictions, allowing other users on the system to potentially read or modify sensitive data stored in these files.
This poses a security risk by exposing confidential information such as SSH keys and credentials to unauthorized users on multi-user systems.
The fix enforces owner-only read/write permissions on temporary files by setting POSIX file attributes where supported, and falls back to system defaults on Windows, ensuring tighter access control.

Weakness: Improper Restriction of File Permissions (CWE-732)
Severity: High
CVSS: 7.5"
24,"{'CWE-532', 'CWE-200'}",GHSA-25xj-89g5-fm6h,"@@ -445,9 +445,7 @@ func (c *ServerCommand) runRecoveryMode() int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// Initialize the storage backend
 	factory, exists := c.PhysicalBackends[config.Storage.Type]
@@ -684,6 +682,31 @@ func (c *ServerCommand) runRecoveryMode() int {
 	return 0
 }
 
+func logProxyEnvironmentVariables(logger hclog.Logger) {
+	proxyCfg := httpproxy.FromEnvironment()
+	cfgMap := map[string]string{
+		""http_proxy"":  proxyCfg.HTTPProxy,
+		""https_proxy"": proxyCfg.HTTPSProxy,
+		""no_proxy"":    proxyCfg.NoProxy,
+	}
+	for k, v := range cfgMap {
+		u, err := url.Parse(v)
+		if err != nil {
+			// Env vars may contain URLs or host:port values.  We only care
+			// about the former.
+			continue
+		}
+		if _, ok := u.User.Password(); ok {
+			u.User = url.UserPassword(""redacted-username"", ""redacted-password"")
+		} else if user := u.User.Username(); user != """" {
+			u.User = url.User(""redacted-username"")
+		}
+		cfgMap[k] = u.String()
+	}
+	logger.Info(""proxy environment"", ""http_proxy"", cfgMap[""http_proxy""],
+		""https_proxy"", cfgMap[""https_proxy""], ""no_proxy"", cfgMap[""no_proxy""])
+}
+
 func (c *ServerCommand) adjustLogLevel(config *server.Config, logLevelWasNotSet bool) (string, error) {
 	var logLevelString string
 	if config.LogLevel != """" && logLevelWasNotSet {
@@ -894,10 +917,7 @@ func (c *ServerCommand) Run(args []string) int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	// log proxy settings
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// If mlockall(2) isn't supported, show a warning. We disable this in dev
 	// because it is quite scary to see when first using Vault. We also disable",Don't include username or password of proxy env vars when logging them. (#9022),"vuln-fix: Redact credentials in proxy environment variable logs

Proxy environment variables containing URLs with embedded credentials were logged in plaintext, exposing sensitive authentication information in application logs.
This posed a security risk by potentially leaking usernames and passwords to unauthorized users with log access.
The fix sanitizes proxy URLs by redacting usernames and passwords before logging, preventing sensitive data exposure in logs.

Weakness: Information Exposure Through Log Files (CWE-532)
Severity: Medium
CVSS: 5.3"
25,{'CWE-20'},GHSA-w8rc-pgxq-x2cj,"@@ -108,7 +108,7 @@ public ShoppingCartData addItemsToShoppingCart( final ShoppingCartData shoppingC
     {
 
         ShoppingCart cartModel = null;
-        
+        if(item.getQuantity() < 1) item.setQuantity(1);
         /**
          * Sometimes a user logs in and a shopping cart is present in db (shoppingCartData
          * but ui has no cookie with shopping cart code so the cart code will have
@@ -216,7 +216,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -288,7 +288,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -554,8 +554,7 @@ public ShoppingCartData updateCartItem( final Long itemID, final String cartId,
         return null;
     }
     
-    @SuppressWarnings(""unchecked"")
-	@Override
+    @Override
     public ShoppingCartData updateCartItems( final List<ShoppingCartItem> shoppingCartItems, final MerchantStore store, final Language language )
             throws Exception
         {
@@ -720,7 +719,6 @@ public ReadableShoppingCart addToCart(PersistableShoppingCartItem item, Merchant
 	}
 	
 
-	@SuppressWarnings(""unchecked"")
 	@Override
 	public void removeShoppingCartItem(String cartCode, Long productId,
 	      MerchantStore merchant, Language language) throws Exception {

From: ""yannick.gosset"" <yannick.gosset@etu.univ-amu.fr>
 uses PersitableShoppingCartItem

 .../controller/shoppingCart/facade/ShoppingCartFacadeImpl.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -912,7 +912,7 @@ public ReadableShoppingCart addToCart(Customer customer, PersistableShoppingCart
 		
 		Validate.notNull(customer,""Customer cannot be null"");
 		Validate.notNull(customer.getId(),""Customer.id cannot be null or empty"");
-		
+		if(item.getQuantity() < 1) item.setQuantity(1);
 		//Check if customer has an existing shopping cart
 		ShoppingCart cartModel = shoppingCartService.getByCustomer(customer);","Merge pull request from GHSA-w8rc-pgxq-x2cj

Fixing negative charge vulnerability","vuln-fix: Enforce minimum quantity validation in shopping cart items

The vulnerability allowed shopping cart items to be added or updated with zero or negative quantities, bypassing proper availability checks. This could lead to inconsistent cart states and potential exploitation of inventory or pricing logic. The fix enforces a minimum quantity of one for all items before processing, ensuring valid and secure cart operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
26,{'CWE-200'},GHSA-v6wr-fch2-vm5w,"@@ -1,141 +1,142 @@
 /*
-    *
-    *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
-    *  *
-    *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
-    *  *  you may not use this file except in compliance with the License.
-    *  *  You may obtain a copy of the License at
-    *  *
-    *  *       http://www.apache.org/licenses/LICENSE-2.0
-    *  *
-    *  *  Unless required by applicable law or agreed to in writing, software
-    *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
-    *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    *  *  See the License for the specific language governing permissions and
-    *  *  limitations under the License.
-    *  *
-    *  * For more information: http://www.orientechnologies.com
-    *
-    */
+ *
+ *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
+ *  *
+ *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
+ *  *  you may not use this file except in compliance with the License.
+ *  *  You may obtain a copy of the License at
+ *  *
+ *  *       http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *  Unless required by applicable law or agreed to in writing, software
+ *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *  See the License for the specific language governing permissions and
+ *  *  limitations under the License.
+ *  *
+ *  * For more information: http://www.orientechnologies.com
+ *
+ */
 package com.orientechnologies.orient.server.network.protocol.http;
 
 import com.orientechnologies.common.concur.resource.OSharedResourceAbstract;
- import com.orientechnologies.common.log.OLogManager;
- import com.orientechnologies.orient.core.Orient;
- import com.orientechnologies.orient.core.config.OGlobalConfiguration;
-
- import java.util.HashMap;
- import java.util.Iterator;
- import java.util.Map;
- import java.util.Map.Entry;
- import java.util.Random;
- import java.util.TimerTask;
+import com.orientechnologies.common.log.OLogManager;
+import com.orientechnologies.orient.core.Orient;
+import com.orientechnologies.orient.core.config.OGlobalConfiguration;
+
+import java.security.SecureRandom;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.TimerTask;
 
 /**
-  * Handles the HTTP sessions such as a real HTTP Server.
-  *
-  * @author Luca Garulli
-  */
- public class OHttpSessionManager extends OSharedResourceAbstract {
-   private static final OHttpSessionManager instance = new OHttpSessionManager();
-   private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
-   private int                              expirationTime;
-   private Random                           random   = new Random();
-
-   protected OHttpSessionManager() {
-     expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
-
-     Orient.instance().scheduleTask(new TimerTask() {
-       @Override
-       public void run() {
-         final int expired = checkSessionsValidity();
-         if (expired > 0)
-           OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
-       }
-     }, expirationTime, expirationTime);
-   }
-
-   public int checkSessionsValidity() {
-     int expired = 0;
-
-     acquireExclusiveLock();
-     try {
-       final long now = System.currentTimeMillis();
-
-       Entry<String, OHttpSession> s;
-       for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
-         s = it.next();
-
-         if (now - s.getValue().getUpdatedOn() > expirationTime) {
-           // REMOVE THE SESSION
-           it.remove();
-           expired++;
-         }
-       }
-
-     } finally {
-       releaseExclusiveLock();
-     }
-
-     return expired;
-   }
-
-   public OHttpSession[] getSessions() {
-     acquireSharedLock();
-     try {
-
-       return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public OHttpSession getSession(final String iId) {
-     acquireSharedLock();
-     try {
-
-       final OHttpSession sess = sessions.get(iId);
-       if (sess != null)
-         sess.updateLastUpdatedOn();
-       return sess;
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
-     acquireExclusiveLock();
-     try {
-       final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
-       sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
-       return id;
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public OHttpSession removeSession(final String iSessionId) {
-     acquireExclusiveLock();
-     try {
-       return sessions.remove(iSessionId);
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public int getExpirationTime() {
-     return expirationTime;
-   }
-
-   public void setExpirationTime(int expirationTime) {
-     this.expirationTime = expirationTime;
-   }
-
-   public static OHttpSessionManager getInstance() {
-     return instance;
-   }
- }
+ * Handles the HTTP sessions such as a real HTTP Server.
+ *
+ * @author Luca Garulli
+ */
+public class OHttpSessionManager extends OSharedResourceAbstract {
+  private static final OHttpSessionManager instance = new OHttpSessionManager();
+  private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
+  private int                              expirationTime;
+  private Random                           random   = new SecureRandom();
+
+  protected OHttpSessionManager() {
+    expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
+
+    Orient.instance().scheduleTask(new TimerTask() {
+      @Override
+      public void run() {
+        final int expired = checkSessionsValidity();
+        if (expired > 0)
+          OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
+      }
+    }, expirationTime, expirationTime);
+  }
+
+  public int checkSessionsValidity() {
+    int expired = 0;
+
+    acquireExclusiveLock();
+    try {
+      final long now = System.currentTimeMillis();
+
+      Entry<String, OHttpSession> s;
+      for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
+        s = it.next();
+
+        if (now - s.getValue().getUpdatedOn() > expirationTime) {
+          // REMOVE THE SESSION
+          it.remove();
+          expired++;
+        }
+      }
+
+    } finally {
+      releaseExclusiveLock();
+    }
+
+    return expired;
+  }
+
+  public OHttpSession[] getSessions() {
+    acquireSharedLock();
+    try {
+
+      return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public OHttpSession getSession(final String iId) {
+    acquireSharedLock();
+    try {
+
+      final OHttpSession sess = sessions.get(iId);
+      if (sess != null)
+        sess.updateLastUpdatedOn();
+      return sess;
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
+    acquireExclusiveLock();
+    try {
+      final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
+      sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
+      return id;
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public OHttpSession removeSession(final String iSessionId) {
+    acquireExclusiveLock();
+    try {
+      return sessions.remove(iSessionId);
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public int getExpirationTime() {
+    return expirationTime;
+  }
+
+  public void setExpirationTime(int expirationTime) {
+    this.expirationTime = expirationTime;
+  }
+
+  public static OHttpSessionManager getInstance() {
+    return instance;
+  }
+}",Adopted SecureRandom to avoid predicable random numbers in session,"vuln-fix: Use SecureRandom for HTTP session ID generation

The HTTP session IDs were generated using java.util.Random, which is predictable and vulnerable to session fixation attacks.
Predictable session IDs allow attackers to guess or reproduce valid session tokens, leading to unauthorized access and session hijacking.
The fix replaces Random with SecureRandom to generate cryptographically strong, unpredictable session IDs, enhancing session security.

Weakness: CWE-330: Use of Insufficiently Random Values
Severity: High
CVSS: 7.5"
27,{'CWE-20'},GHSA-jjcx-999m-35hc,"@@ -60,6 +60,9 @@ public function configureJob(array $data): MessageBag
         $config['fints_password']  = (string)(Crypt::encrypt($data['fints_password']) ?? '');
         $config['apply-rules']     = 1 === (int)$data['apply_rules'];
 
+        // sanitize FinTS URL.
+        $config['fints_url'] = $this->validURI($config['fints_url']) ? $config['fints_url'] : '';
+
         $this->repository->setConfiguration($this->importJob, $config);
 
 
@@ -108,4 +111,21 @@ public function setImportJob(ImportJob $importJob): void
         $this->repository->setUser($importJob->user);
     }
 
+    /**
+     * @param string $fints_url
+     *
+     * @return bool
+     */
+    private function validURI(string $fintsUri): bool
+    {
+        $res = filter_var($fintsUri, FILTER_VALIDATE_URL);
+        if (false === $res) {
+            return false;
+        }
+        $scheme = parse_url($fintsUri, PHP_URL_SCHEME);
+
+        return 'https' === $scheme;
+    }
+
+
 }",Fix #2367,"vuln-fix: Sanitize FinTS URL to enforce HTTPS scheme

The FinTS URL configuration was not validated, allowing potentially unsafe or malformed URLs to be stored and used in the system. This posed a security risk by enabling attackers to inject malicious URLs or downgrade to insecure HTTP connections. The fix adds validation to ensure the URL is well-formed and strictly uses the HTTPS scheme, rejecting any invalid or non-HTTPS URLs.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
28,{'CWE-20'},GHSA-8687-vv9j-hgph,"@@ -27,6 +27,12 @@ module.exports = function cast(schema, obj, options, context) {
     throw new Error('Query filter must be an object, got an array ', util.inspect(obj));
   }
 
+  // bson 1.x has the unfortunate tendency to remove filters that have a top-level
+  // `_bsontype` property. Should remove this when we upgrade to bson 4.x. See gh-8222
+  if (obj.hasOwnProperty('_bsontype')) {
+    delete obj._bsontype;
+  }
+
   const paths = Object.keys(obj);
   let i = paths.length;
   let _keys;","fix(query): delete top-level `_bsontype` property in queries to prevent silent empty queries

Fix #8222","vuln-fix: Prevent query filter tampering by removing _bsontype property

The vulnerability occurs because bson 1.x removes filters containing a top-level _bsontype property, which can cause unexpected query behavior or bypasses. This is a security risk as attackers might exploit this to manipulate database queries and access unauthorized data. The fix deletes the _bsontype property from query filters to prevent bson from removing them, ensuring consistent and secure query processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
29,{'CWE-20'},GHSA-xrp2-fhq4-4q3w,"@@ -50,6 +50,15 @@ struct HistogramFixedWidthFunctor<CPUDevice, T, Tout> {
                         static_cast<double>(nbins);
     const double nbins_minus_1 = static_cast<double>(nbins - 1);
 
+    // We cannot handle NANs in the algorithm below (due to the case to int32)
+    const Eigen::Tensor<int32, 1, 1> nans_tensor =
+        values.isnan().template cast<int32>();
+    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();
+    const int num_nans = reduced_tensor(0);
+    if (num_nans > 0) {
+      return errors::InvalidArgument(""Histogram values must not contain NaN"");
+    }
+
     // The calculation is done by finding the slot of each value in `values`.
     // With [a, b]:
     //   step = (b - a) / nbins
@@ -98,12 +107,12 @@ class HistogramFixedWidthOp : public OpKernel {
     const auto nbins = nbins_tensor.scalar<int32>()();
 
     OP_REQUIRES(
-        ctx, (value_range(0) < value_range(1)),
+        ctx, value_range(0) < value_range(1),
         errors::InvalidArgument(""value_range should satisfy value_range[0] < ""
                                 ""value_range[1], but got '["",
                                 value_range(0), "", "", value_range(1), ""]'""));
     OP_REQUIRES(
-        ctx, (nbins > 0),
+        ctx, nbins > 0,
         errors::InvalidArgument(""nbins should be a positive number, but got '"",
                                 nbins, ""'""));","Prevent crash when histogram is called with NaN values.

Fixes #45770

PiperOrigin-RevId: 443149951","vuln-fix: Prevent NaN values in histogram computation inputs

The vulnerability allowed NaN values to be processed in histogram calculations, which caused undefined behavior and potential incorrect results in downstream operations. This is a security risk because it can lead to data corruption or denial of service if untrusted inputs contain NaNs. The fix adds explicit detection and rejection of NaN values before processing, ensuring only valid numeric inputs are accepted.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3"
30,"{'CWE-918', 'CWE-20'}",GHSA-2h63-qp69-fwvw,"@@ -847,8 +847,10 @@ private Element parseXml(String xmlString) {
         Document doc = null;
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         try {
-            javax.xml.parsers.DocumentBuilder parser = factory
-                    .newDocumentBuilder();
+            factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
+            factory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
+            factory.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+            javax.xml.parsers.DocumentBuilder parser = factory.newDocumentBuilder();
             parser.setErrorHandler(new ErrorHandler() {
                 public void error(SAXParseException exception)
                         throws SAXException {","BATIK-1284: Dont load DTDs in NodePickerPanel

git-svn-id: https://svn.apache.org/repos/asf/xmlgraphics/batik/trunk@1878396 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Prevent XML External Entity (XXE) Injection in XML Parser

The XML parser was vulnerable to XML External Entity (XXE) attacks due to enabled external entity processing by default. This vulnerability could allow attackers to read arbitrary files or cause denial of service by referencing external resources. The fix disables external general entities, external parameter entities, and external DTD loading features in the XML parser configuration.

Weakness: CWE-611: Improper Restriction of XML External Entity Reference
Severity: High
CVSS: 7.5"
31,{'CWE-20'},GHSA-h8pj-cxx2-jfg2,"@@ -484,7 +484,11 @@ def copy_with(self, **kwargs: typing.Any) -> ""URL"":
         #  \_/   \______________/\_________/ \_________/ \__/
         #   |           |            |            |        |
         # scheme     authority       path        query   fragment
-        return URL(self._uri_reference.copy_with(**kwargs).unsplit())
+        new_url = URL(self)
+        new_url._uri_reference = self._uri_reference.copy_with(**kwargs)
+        if new_url.is_absolute_url:
+            new_url._uri_reference = new_url._uri_reference.normalize()
+        return URL(new_url)
 
     def copy_set_param(self, key: str, value: typing.Any = None) -> ""URL"":
         return self.copy_with(params=self.params.set(key, value))",Patch `copy_with`,"vuln-fix: Normalize absolute URLs to prevent ambiguous URI parsing

The vulnerability involved inconsistent normalization of absolute URLs, which could lead to ambiguous or maliciously crafted URIs being processed insecurely. This posed a security risk by allowing attackers to exploit URI parsing inconsistencies for injection or access control bypass. The fix ensures that absolute URLs are normalized after modification, enforcing consistent and secure URI representations.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: Medium  
CVSS: 5.3"
32,{'CWE-200'},GHSA-qpv2-jxc7-3638,"@@ -1,6 +1,6 @@
 <?php
 
 return [
-    'sent'	        => 'Your password link has been sent!',
+    'sent'	        => 'Success: If that email address exists in our system, a password recovery email has been sent.',
     'user'			=> 'No matching active user found with that email.',
 ];","Updated language string

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent user enumeration via password reset messages

The password reset response revealed whether an email address existed in the system, enabling attackers to enumerate valid users.
This information disclosure risk could facilitate targeted attacks such as phishing or brute force attempts on known accounts.
The fix standardizes the response message to avoid confirming the existence of any email address, preventing user enumeration. 

Weakness: Information Exposure Through Error Message (CWE-209)
Severity: Medium
CVSS: 5.3"
33,{'CWE-20'},GHSA-xm9f-vxmx-4m58,"@@ -49,7 +49,7 @@ public function getResource($forWrite = false)
             $isError = false;
 
             $ioConfig = $this->getVars();
-            switch ($this->getVar('type', 'file')) {
+            switch (strtolower($this->getVar('type', 'file'))) {
                 case 'file':
                     //validate export/import path
                     $path = rtrim($ioConfig['path'], '\\/')","Merge pull request from GHSA-xm9f-vxmx-4m58

Co-authored-by: Mark Lewis <markwlewis@Marks-MacBook-Pro.local>","vuln-fix: Normalize input type to prevent case-sensitive bypass

The vulnerability was that the type parameter was not normalized, allowing attackers to bypass case-sensitive checks by using mixed-case input values.
This could lead to improper handling of file operations, potentially exposing sensitive files or enabling unauthorized access.
The fix converts the type parameter to lowercase before the switch statement, ensuring consistent and secure type validation.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3"
34,"{'CWE-325', 'CWE-200', 'CWE-502', 'CWE-20'}",GHSA-4h44-w6fm-548g,"@@ -14,10 +14,15 @@
 
 call_user_func(function() {
     $value = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('value');
-    $addition = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('addition');
     $scope = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('scope');
 
-    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, $addition);
+    if (!is_string($value) || empty($value)) {
+        \TYPO3\CMS\Core\Utility\HttpUtility::setResponseCodeAndExit(
+            \TYPO3\CMS\Core\Utility\HttpUtility::HTTP_STATUS_400
+        );
+    }
+
+    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, 'flashvars');
 
     if ($scope === 'flashvars') {
         header('Content-type: application/x-www-form-urlencoded');","[SECURITY] Restrict file validation hash generation

Security-References: CVE-2020-15086","vuln-fix: Validate input and fix HMAC key usage in flashvars handler

The code lacked validation for the 'value' GET parameter and used an untrusted 'addition' parameter as HMAC key, allowing potential misuse or errors. This posed a security risk by enabling attackers to influence the HMAC key, potentially compromising data integrity or causing unexpected behavior. The fix enforces that 'value' is a non-empty string and replaces the dynamic HMAC key with a fixed, trusted string 'flashvars' to ensure consistent and secure hashing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5

Weakness: Use of Untrusted Input in Security Function (CWE-347)  
Severity: High  
CVSS: 7.8"
35,{'CWE-20'},GHSA-832h-xg76-4gv6,"@@ -106,7 +106,7 @@ function expand(str, isTop) {
   var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
   var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
   var isSequence = isNumericSequence || isAlphaSequence;
-  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
+  var isOptions = m.body.indexOf(',') >= 0;
   if (!isSequence && !isOptions) {
     // {a},b}
     if (m.post.match(/,.*\}/)) {",fix bug in https://github.com/juliangruber/brace-expansion/issues/33,"vuln-fix: Prevent ReDoS in brace expansion option detection

The original regex used to detect comma-separated options in brace expansions could cause excessive backtracking, leading to a Regular Expression Denial of Service (ReDoS) vulnerability.
This vulnerability allows attackers to craft input that triggers high CPU usage, potentially causing service degradation or outages.
The fix replaces the complex regex with a simple indexOf check for commas, eliminating the risk of catastrophic backtracking and improving performance.

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: Medium
CVSS: 5.3"
36,{'CWE-20'},GHSA-qr2j-wrhx-4829,"@@ -119,6 +119,9 @@ func (api *PrivateDebugAPI) TraceChain(ctx context.Context, start, end rpc.Block
 	if to == nil {
 		return nil, fmt.Errorf(""end block #%d not found"", end)
 	}
+	if from.Number().Cmp(to.Number()) >= 0 {
+		return nil, fmt.Errorf(""end block (#%d) needs to come after start block (#%d)"", end, start)
+	}
 	return api.traceChain(ctx, from, to, config)
 }",eth: ensure from<to when tracing chain (credits Chen Nan via bugbounty),"vuln-fix: Prevent invalid block range in TraceChain API

The TraceChain function lacked validation to ensure the end block number is greater than the start block number, allowing invalid or reversed block ranges. This could lead to unexpected behavior or potential denial of service by processing nonsensical block ranges. The fix adds a check that returns an error if the end block is not strictly after the start block, enforcing valid input ranges.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
37,{'CWE-200'},GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Method;
 import java.util.Set;
 import javax.el.BeanELResolver;
 import javax.el.ELContext;
@@ -111,7 +112,12 @@ private String transformPropertyName(Object property) {
   }
 
   private void checkRestrictedClass(Object o, Object method) {
-    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {
+    if (
+      o instanceof Class ||
+      o instanceof ClassLoader ||
+      o instanceof Thread ||
+      o instanceof Method
+    ) {
       throw new MethodNotFoundException(
         ""Cannot find method '"" + method + ""' in "" + o.getClass()
       );",add method to blacklist,"vuln-fix: Prevent reflective access to java.lang.reflect.Method objects

The vulnerability allowed reflective access to Method objects, enabling attackers to invoke or manipulate sensitive methods via expression language evaluation. This poses a security risk by potentially exposing internal Java reflection capabilities that can lead to unauthorized code execution. The fix blocks Method instances alongside Class, ClassLoader, and Thread objects to prevent reflective method access in the EL resolver. 

Weakness: CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')  
Severity: High  
CVSS: 7.5"
38,"{'CWE-178', 'CWE-200'}",GHSA-24m3-w8g9-jwpq,"@@ -259,7 +259,7 @@ function ($val) {
             throw new Error\NotFound('The URL wasn\'t found in the module.');
         }
 
-        if (substr($path, -4) === '.php') {
+        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {
             // PHP file - attempt to run it
 
             /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that","Fix source code disclosure on case-insensitive file systems

If the file system containing the PHP code is case-insensitive, a
request containing an uppercase file extension will return the
contents of the PHP file to the browser instead of executing it.

E.g. a request for this URL will return the source code:

  https:/sp.example.org/simplesaml/module.php/core/frontpage_welcome.PHP

Fix that by converting the path to lowercase before checking the file
extension.

See the following page for details:

  https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq","vuln-fix: Normalize file extension check to prevent case bypass

The file extension check was case-sensitive, allowing attackers to bypass restrictions by using uppercase or mixed-case '.PHP' extensions.
This could lead to unauthorized execution of PHP files, increasing the risk of remote code execution vulnerabilities.
The fix converts the file extension to lowercase using a multibyte-safe function before comparison, ensuring consistent and secure validation.

Weakness: CWE-179: Improper Neutralization of Case Differences in Input
Severity: Medium
CVSS: 5.3"
39,{'CWE-200'},GHSA-f2rp-4rv7-fc95,"@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 
-attributes :url, :user, :password, :ssl_verify_peer, :ssl_certs, :renew
+attributes :url, :user, :ssl_verify_peer, :ssl_certs, :renew",Fix clean API result,"vuln-fix: Remove password attribute to prevent sensitive data exposure

The password attribute was included in the exposed attributes, potentially leaking sensitive credentials through serialization or API responses.
Exposing passwords increases the risk of unauthorized access and credential compromise in the system.
The fix removes the password attribute from the exposed attributes list, preventing accidental disclosure of sensitive information.

Weakness: CWE-200: Exposure of Sensitive Information to an Unauthorized Actor  
Severity: High  
CVSS: 7.5"
40,{'CWE-20'},GHSA-v82p-hv3v-p6qp,"@@ -57,6 +57,20 @@ class MklRequantizationRangePerChannelOp : public OpKernel {
         ctx, input_max.dim_size(0) == depth,
         errors::InvalidArgument(""input_max has incorrect size, expected "",
                                 depth, "" was "", input_max.dim_size(0)));
+    OP_REQUIRES(
+        ctx, input_min.NumElements() == depth,
+        errors::InvalidArgument(""input_min must have the same number of ""
+                                ""elements as input_max, got "",
+                                input_min.NumElements(), "" and "", depth));
+    OP_REQUIRES(ctx, input.NumElements() > 0,
+                errors::InvalidArgument(""input must not be empty""));
+    OP_REQUIRES(ctx, input.dims() == 4,
+                errors::InvalidArgument(""input must be in NHWC format""));
+    OP_REQUIRES(
+        ctx, input.dim_size(3) == depth,
+        errors::InvalidArgument(
+            ""input must have same number of channels as length of input_min: "",
+            input.dim_size(3), "" vs "", depth));
 
     const float* input_min_data = input_min.flat<float>().data();
     const float* input_max_data = input_max.flat<float>().data();","Add more validation to `RequantizationRangePerChannel`.

PiperOrigin-RevId: 387693946
Change-Id: Ife8dcbdb021bec4787eef6a4361dd08f17c14bd6","vuln-fix: Validate tensor dimensions and sizes in requantization op

The vulnerability was missing comprehensive input validation for tensor dimensions and sizes in the requantization operator, allowing malformed inputs to proceed unchecked. This posed a risk of out-of-bounds memory access or incorrect computations leading to potential crashes or data corruption. The fix adds explicit checks ensuring input tensors have expected dimensions, non-empty data, and matching channel sizes before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
41,{'CWE-20'},GHSA-pm9p-9926-w68m,"@@ -52,9 +52,21 @@ var ecstatic = module.exports = function (dir, options) {
   return function middleware (req, res, next) {
 
     // Strip any null bytes from the url
+    // This was at one point necessary because of an old bug in url.parse
+    //
+    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
+    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
+    //
+    // But this opens up a regex dos attack vector! D:
+    //
+    // Based on some research (ie asking #node-dev if this is still an issue),
+    // it's *probably* not an issue. :)
+    /*
     while(req.url.indexOf('%00') !== -1) {
       req.url = req.url.replace(/\%00/g, '');
     }
+    */
+
     // Figure out the path for the file from the given url
     var parsed = url.parse(req.url);
     try {","Remove stripping of null bytes

This was at one point necessary because of an old bug in url.parse

See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4

But this opens up a regex dos attack vector! D:

Based on some research (ie asking #node-dev if this is still an issue),
it's *probably* not an issue. :)","vuln-fix: Prevent regex DoS by removing null byte stripping loop

The middleware previously stripped null bytes from URLs using a regex loop, which introduced a potential regular expression denial of service (ReDoS) vulnerability. This is a security risk because an attacker could craft URLs that cause excessive CPU usage, leading to service degradation or downtime. The fix removes the null byte stripping loop, relying on updated URL parsing that no longer requires this workaround, thus eliminating the ReDoS attack vector.

Weakness: CWE-400 Uncontrolled Resource Consumption (Resource Exhaustion)  
Severity: High  
CVSS: 7.5"
42,"{'CWE-400', 'CWE-20'}",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate pylist depth against ragged_rank to prevent inconsistencies

The vulnerability allowed pylist inputs with a maximum depth smaller than the specified ragged_rank, causing inconsistent internal state and potential downstream errors. This inconsistency could lead to unexpected behavior or crashes when processing ragged tensors, posing a risk to application stability and data integrity. The fix adds a validation check that raises an error if the pylist depth is less than the ragged_rank, ensuring input consistency before further processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
43,{'CWE-20'},GHSA-j259-6c58-9m58,"@@ -545,10 +545,11 @@ PostgreSQL.prototype.buildExpression = function(columnName, operator,
       return new ParameterizedSQL(columnName + regexOperator,
         [operatorValue.source]);
     case 'contains':
-      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map((v) => `'${v}'`) + ']::'
-        + propertyDefinition.postgresql.dataType);
+      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map(() => '?') + ']::'
+        + propertyDefinition.postgresql.dataType,
+        operatorValue);
     case 'match':
-      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery('${operatorValue}')`);
+      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery(?)`, [operatorValue]);
     default:
       // invoke the base implementation of `buildExpression`
       return this.invokeSuper('buildExpression', columnName, operator,","fix: improve filter sanitisation

Add sanitisation of user-input for `contains` LoopBack filter which may allow for arbitrary SQL injection.

Signed-off-by: Rifa Achrinza <25147899+achrinza@users.noreply.github.com>","vuln-fix: Prevent SQL injection in PostgreSQL query builder

The code previously interpolated user input directly into SQL strings without parameterization, enabling injection attacks through crafted inputs. This is a critical security risk as attackers could execute arbitrary SQL commands, compromising data integrity and confidentiality. The fix replaces direct string interpolation with parameterized queries, safely passing user inputs as query parameters to prevent injection.

Weakness: SQL Injection (CWE-89)  
Severity: Critical  
CVSS: 9.8"
44,"{'CWE-200', 'CWE-668'}",GHSA-hm3x-jwwf-jpr9,"@@ -163,7 +163,7 @@ outputs:
             ironic::api::authtoken::user_domain_name: 'Default'
             ironic::api::authtoken::project_domain_name: 'Default'
             ironic::api::authtoken::username: 'ironic'
-            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
+            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystonePublic, uri_no_suffix]}
             ironic::api::authtoken::auth_url: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
             ironic::api::authtoken::region_name: {get_param: KeystoneRegion}
             ironic::api::authtoken::interface: 'internal'","Fix remaining usage of internal url for www_authenticate_uri

This is follow-up of 160936df134a471cfd245bd60964046027a571ea and fixes
remaining usage of internal endpoint url for [keystone_authtoken]
www_authenticate_uri.

Related-Bug: #1955397
Change-Id: Ib2ee7295c7fcda276e4fcf011a9e427e041f4848","vuln-fix: Use public endpoint for www_authenticate_uri in authtoken config

The www_authenticate_uri was set to use the internal Keystone endpoint, exposing internal network details to services expecting public access. This misconfiguration could allow unauthorized internal resource access or information leakage from internal endpoints. The fix changes the www_authenticate_uri to use the Keystone public endpoint, ensuring proper external authentication routing and reducing exposure of internal services.

Weakness: Information Exposure (CWE-200)  
Severity: Medium  
CVSS: 5.3"
45,{'CWE-200'},GHSA-wh98-p28r-vrc9,"@@ -58,7 +58,7 @@ def self.reload!
       prepare!
     end
 
-    def self.run! # :nodoc:
+    def self.run!(reset: false) # :nodoc:
       if check!
         super
       else","Fix reloader to work with new Executor signature

This is a follow up to [CVE-2022-23633].","vuln-fix: Prevent unintended state reset in run! method

The run! method was modified to accept a reset parameter, preventing unintended state resets during execution that could lead to inconsistent application behavior.
Uncontrolled state resets pose a security risk by potentially exposing sensitive data or causing denial of service through unexpected application states.
The fix introduces an explicit reset argument to control state changes, ensuring that resets occur only when intentionally requested by the caller. 

Weakness: Improper Control of Object State (CWE-908)
Severity: Medium
CVSS: 5.3"
46,{'CWE-200'},GHSA-cv3f-px9r-54hm,"@@ -721,7 +721,6 @@ class Spawner {
 		prepareChroot(info, options);
 		info.userSwitching = prepareUserSwitching(options);
 		prepareSwitchingWorkingDirectory(info, options);
-		inferApplicationInfo(info);
 		return info;
 	}
 
@@ -775,6 +774,7 @@ class Spawner {
 		assert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);
 	}
 
+#ifdef false
 	void inferApplicationInfo(SpawnPreparationInfo &info) const {
 		info.codeRevision = readFromRevisionFile(info);
 		if (info.codeRevision.empty()) {
@@ -817,6 +817,7 @@ class Spawner {
 			return string();
 		}
 	}
+#endif
 
 	bool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {
 		if (options.loadShellEnvvars) {",Disable unused feature.,"vuln-fix: Prevent automatic inference of application info in spawner

The automatic inference of application information from revision files was enabled, potentially exposing sensitive internal data to unauthorized users. This posed a security risk by leaking code revision details that could aid attackers in targeting specific application versions. The fix disables the inference function by removing its invocation and enclosing its implementation in a disabled preprocessor block to prevent unintended information disclosure.

Weakness: Information Exposure (CWE-200)
Severity: Medium
CVSS: 5.3"
47,"{'CWE-1321', 'CWE-20'}",GHSA-g6ww-v8xp-vmwg,"@@ -76,6 +76,9 @@ function parsePath(path) {
   var str = path.replace(/([^\\])\[/g, '$1.[');
   var parts = str.match(/(\\\.|[^.]+?)+/g);
   return parts.map(function mapMatches(value) {
+    if (value === ""constructor"" || value === ""__proto__"" || value === ""prototype"") {
+      return {}
+    }
     var regexp = /^\[(\d+)\]$/;
     var mArr = regexp.exec(value);
     var parsed = null;",fix: 🐛 fix prototype pollution,"vuln-fix: Prevent prototype pollution in path parsing function

The vulnerability allowed special keys like ""constructor"", ""__proto__"", and ""prototype"" to be processed, enabling prototype pollution attacks. Prototype pollution can lead to unexpected behavior and security breaches by modifying object prototypes. The fix blocks these keys by returning empty objects, preventing prototype chain manipulation during path parsing.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5"
48,"{'CWE-191', 'CWE-20'}",GHSA-hx9q-2mx4-m4pg,"@@ -94,8 +94,10 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
-    OP_REQUIRES(context, num_segments > 0,
-                errors::InvalidArgument(""Number of segments must be positive""));
+    OP_REQUIRES(
+        context, num_segments >= 0,
+        errors::InvalidArgument(
+            ""Number of segments must be non-negative but got "", num_segments));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Allow 0 for number of segments in `unsorted_segment_join_op.cc`

Related to the fix for #55305

PiperOrigin-RevId: 443157549","vuln-fix: Allow zero segments in UnsortedSegmentJoinOp validation

The validation incorrectly rejected zero as an invalid number of segments, causing potential denial of service or crashes when zero segments were legitimately used. This could lead to application instability or unexpected failures when processing empty segment inputs. The fix updates the validation to accept zero as a valid non-negative number of segments, preventing erroneous rejections and improving robustness.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
49,{'CWE-200'},GHSA-hxf9-7h4c-f5jv,"@@ -3,6 +3,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -41,8 +42,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -78,8 +84,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.

(cherry picked from commit db586ede1fbb41dce21310ea28ae15a1cf1286c5)","vuln-fix: Prevent timing attacks on webhook basic authentication

The webhook basic authentication compared credentials using standard string comparison, which is vulnerable to timing attacks that can leak information about valid credentials. Timing attacks allow attackers to gradually guess authentication tokens by measuring response time differences, compromising security. The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure comparisons execute in constant time, mitigating timing attack risks.

Weakness: CWE-208 Timing Attack  
Severity: High  
CVSS: 7.5"
50,{'CWE-20'},GHSA-8948-ffc6-jg52,"@@ -252,6 +252,11 @@ ReverseProxy.prototype.setupHttpsProxy = function (proxy, websocketsUpgrade, log
     key: getCertData(sslOpts.key),
     cert: getCertData(sslOpts.cert)
   };
+  
+  // Allows the option to disable older SSL/TLS versions
+  if(sslOpts.secureOptions) {
+    ssl.secureOptions = sslOpts.secureOptions;
+  }
 
   if (sslOpts.ca) {
     ssl.ca = getCertData(sslOpts.ca, true);","Adding option to disable older SSL/TLS versions

Simply pass in ""secureOptions"" as you normally would to an https config object, and redbird will pass it along into the https proxy server.","vuln-fix: Allow disabling older SSL/TLS versions in HTTPS proxy

The HTTPS proxy previously did not support disabling outdated SSL/TLS protocol versions, allowing use of insecure protocols by default. This poses a security risk as attackers can exploit known vulnerabilities in older SSL/TLS versions to intercept or manipulate traffic. The fix enables passing secureOptions to explicitly disable legacy protocols, improving the security posture of HTTPS connections.

Weakness: CWE-295 Improper Certificate Validation  
Severity: High  
CVSS: 7.5"
51,"{'CWE-475', 'CWE-20'}",GHSA-5wpj-c6f7-24x8,"@@ -304,6 +304,9 @@ Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,
     const Tensor* tensor;
     // TODO(fishx): Avoid blocking here.
     TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));
+    if (tensor->NumElements() == 0) {
+      return errors::InvalidArgument(""Empty resource handle"");
+    }
     const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);
     device_name = handle.device();","Fix empty resource handle vulnerability.

Some ops that attempt to extract a resource handle from user input
can lead to nullptr dereferences.  This returns an error in such
a case.

PiperOrigin-RevId: 445571938","vuln-fix: Prevent empty resource handle usage in device retrieval

The vulnerability occurs when an empty resource handle is processed without validation, leading to potential undefined behavior or crashes in downstream operations.
This is a security risk because it can cause denial of service or memory corruption by dereferencing invalid or uninitialized resource handles.
The fix adds a check to detect empty resource handles early and returns an error, preventing further unsafe processing of invalid inputs.


Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
52,{'CWE-20'},GHSA-qfpc-5pjr-mh26,"@@ -2990,6 +2990,10 @@ REGISTER_OP(""Dequantize"")
       if (!s.ok() && s.code() != error::NOT_FOUND) {
         return s;
       }
+      if (axis < -1) {
+        return errors::InvalidArgument(""axis should be at least -1, got "",
+                                       axis);
+      }
       const int minmax_rank = (axis == -1) ? 0 : 1;
       TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
       ShapeHandle minmax;","Fix a shape inference issue leading to nullptr deref.

PiperOrigin-RevId: 387712259
Change-Id: I7e670772b259c068a501a187cd89f18773bb95a1","vuln-fix: Validate axis parameter to prevent invalid negative values

The vulnerability allowed axis values less than -1, which could cause unexpected behavior or crashes during tensor shape inference in the Dequantize operation.
This is a security risk because it may lead to denial of service or memory corruption when processing malformed inputs.
The fix adds a validation check that rejects axis values below -1, returning an error to prevent further processing of invalid inputs.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3"
53,{'CWE-200'},GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import com.hubspot.jinjava.interpret.JinjavaInterpreter;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -136,7 +137,8 @@ protected boolean isRestrictedClass(Object o) {
       o instanceof Thread ||
       o instanceof Method ||
       o instanceof Field ||
-      o instanceof Constructor
+      o instanceof Constructor ||
+      o instanceof JinjavaInterpreter
     );
   }
 }",Add interpreter to blacklist,"vuln-fix: Restrict JinjavaInterpreter class access in security checks

The vulnerability allowed JinjavaInterpreter instances to bypass existing restrictions, potentially exposing sensitive internal interpreter state to untrusted code execution. This posed a security risk by enabling attackers to manipulate or access critical template rendering internals. The fix extends the restricted class checks to include JinjavaInterpreter, preventing unauthorized access to this sensitive class. 

Weakness: Improper Restriction of Operations within the Security Policy (CWE-276)  
Severity: High  
CVSS: 7.5"
54,{'CWE-20'},GHSA-gxg6-rc6c-v673,"@@ -118,6 +118,10 @@ interface from JDK1.2 VM...
 	*/
 	class Handler implements InvocationHandler
 	{
+		private Object readResolve() throws ObjectStreamException {
+			throw new NotSerializableException();
+		}
+
 		public Object invoke( Object proxy, Method method, Object[] args )
 			throws Throwable
 		{",Prevent deserialization of Handler,"vuln-fix: Prevent serialization of dynamic proxy handler

The dynamic proxy handler class lacked protection against serialization, allowing unauthorized serialization of internal handler state.
This posed a security risk by potentially exposing sensitive internal data or enabling deserialization attacks.
The fix adds a readResolve method that throws NotSerializableException to block serialization attempts on the handler class.

Weakness: CWE-502 Deserialization of Untrusted Data  
Severity: High  
CVSS: 7.5"
55,{'CWE-20'},GHSA-m648-33qf-v3gp,"@@ -1468,7 +1468,9 @@ class CudnnRnnSequenceTensorDescriptor
   static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();
@@ -1486,7 +1488,9 @@ class CudnnRnnSequenceTensorDescriptor
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       const absl::Span<const int>& seq_lengths, bool time_major,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();","Prevent CHECK-fail in LSTM/GRU with zero-length input.

PiperOrigin-RevId: 346239181
Change-Id: I5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f","vuln-fix: Validate max_seq_length to prevent invalid tensor descriptor creation

The vulnerability is that max_seq_length was not properly validated, allowing zero or negative values to proceed and potentially cause undefined behavior or memory corruption. This is a security risk because it can lead to crashes or exploitable conditions in GPU tensor operations, undermining system stability and security. The fix adds explicit checks that return an error status if max_seq_length is less than or equal to zero, preventing invalid tensor descriptor creation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
56,{'CWE-209'},GHSA-hm37-9xh2-q499,"@@ -236,7 +236,8 @@ def read_fixed_bytes(self, num_bytes: int) -> bytes:
         """"""
         read_bytes = self.read(num_bytes)
         if len(read_bytes) < num_bytes:
-            raise EOFError(read_bytes)
+            raise EOFError(""Fewer than 'num_bytes' bytes remaining in the ""
+                    ""underlying bytestream"")
         return read_bytes
 
     def read_pascal_bytes(self, string_length_size: int) -> bytes:",Changed an exception message to prevent possible disclosures of keying material.,"vuln-fix: Improve error message to avoid leaking partial data

The previous error message exposed partial byte content when fewer bytes than expected were read from the stream. This could inadvertently leak sensitive data in error logs or exception traces, posing a confidentiality risk. The fix replaces the partial data in the error message with a generic description to prevent unintended information disclosure.

Weakness: Information Exposure Through Error Message (CWE-209)
Severity: Medium
CVSS: 5.3"
57,{'CWE-20'},GHSA-f522-ffg8-j8r6,"@@ -11,4 +11,4 @@ exports['alpha'] = /^[a-zA-Z]+$/
 exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
 exports['style'] = /\s*(.+?):\s*([^;]+);?/g
 exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
-exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/
+exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/",fix utc-millisec regex to avoid a ddos attack,"vuln-fix: Restrict utc-millisec regex to prevent excessive input length

The utc-millisec regular expression allowed arbitrarily long numeric input with optional decimals, enabling potential denial of service via resource exhaustion.
This posed a security risk by permitting attackers to submit extremely large strings that could degrade system performance or cause crashes.
The fix limits the integer and fractional parts to a maximum of 15 digits each, preventing overly long inputs and mitigating resource abuse. 

Weakness: CWE-400 Uncontrolled Resource Consumption
Severity: Medium
CVSS: 5.3"
58,"{'CWE-434', 'CWE-20'}",GHSA-5gjh-5j4f-cpwv,"@@ -16,6 +16,7 @@ import (
 	""strings""
 	""time""
 
+	""github.com/pkg/errors""
 	gouuid ""github.com/satori/go.uuid""
 	""github.com/unknwon/com""
 
@@ -23,9 +24,10 @@ import (
 
 	""gogs.io/gogs/internal/conf""
 	""gogs.io/gogs/internal/cryptoutil""
-	""gogs.io/gogs/internal/db/errors""
+	dberrors ""gogs.io/gogs/internal/db/errors""
 	""gogs.io/gogs/internal/gitutil""
 	""gogs.io/gogs/internal/osutil""
+	""gogs.io/gogs/internal/pathutil""
 	""gogs.io/gogs/internal/process""
 	""gogs.io/gogs/internal/tool""
 )
@@ -134,7 +136,7 @@ func (repo *Repository) UpdateRepoFile(doer *User, opts UpdateRepoFileOptions) (
 	if opts.OldBranch != opts.NewBranch {
 		// Directly return error if new branch already exists in the server
 		if git.RepoHasBranch(repoPath, opts.NewBranch) {
-			return errors.BranchAlreadyExists{Name: opts.NewBranch}
+			return dberrors.BranchAlreadyExists{Name: opts.NewBranch}
 		}
 
 		// Otherwise, delete branch from local copy in case out of sync
@@ -449,11 +451,16 @@ func isRepositoryGitPath(path string) bool {
 	return strings.HasSuffix(path, "".git"") || strings.Contains(path, "".git""+string(os.PathSeparator))
 }
 
-func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) (err error) {
+func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {
 	if len(opts.Files) == 0 {
 		return nil
 	}
 
+	// Prevent uploading files into the "".git"" directory
+	if isRepositoryGitPath(opts.TreePath) {
+		return errors.Errorf(""bad tree path %q"", opts.TreePath)
+	}
+
 	uploads, err := GetUploadsByUUIDs(opts.Files)
 	if err != nil {
 		return fmt.Errorf(""get uploads by UUIDs[%v]: %v"", opts.Files, err)
@@ -487,7 +494,9 @@ func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions)
 			continue
 		}
 
-		// Prevent copying files into .git directory, see https://gogs.io/gogs/issues/5558.
+		upload.Name = pathutil.Clean(upload.Name)
+
+		// Prevent uploading files into the "".git"" directory
 		if isRepositoryGitPath(upload.Name) {
 			continue
 		}",repo_editor: check upload `TreePath` and file name (#6838),"vuln-fix: Prevent uploading files into .git directory in repository

The vulnerability allowed files to be uploaded or copied into the repository’s .git directory, which could corrupt repository metadata or enable malicious manipulation of git internals. This poses a security risk by potentially allowing attackers to alter git data, leading to unauthorized code execution or repository compromise. The fix adds explicit checks to reject uploads and file copies targeting paths within the .git directory, ensuring repository integrity is maintained.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5"
59,{'CWE-20'},GHSA-f7f4-hqp2-7prc,"@@ -106,7 +106,10 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
-      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname || '/',
+      // ^^ Uses || '/' because otherwise url.parse returns `null`,
+      // which is not a string and thus bad when you try to check
+      // .match() of it.
 
       method  : options.eventName,",Follow up to ff02114eaec090ee51db48435cc32d451662606e to ensure req.path is good and stringy.,"vuln-fix: Prevent null pathname causing runtime errors in URL parsing

The vulnerability was that url.parse could return a null pathname, leading to runtime errors when subsequent code attempted string operations on it. This is a security risk because such errors can cause application crashes or unexpected behavior, potentially exposing attack surfaces or denial of service. The fix ensures the pathname defaults to '/' if null, preventing invalid string operations and stabilizing URL handling logic.

Weakness: CWE-682 Improper Control of a Resource Through its Lifetime  
Severity: Medium  
CVSS: 5.3"
60,{'CWE-20'},GHSA-x2mc-8fgj-3wmr,"@@ -261,7 +261,7 @@ exports.extract = function (cwd, opts) {
     var onlink = function () {
       if (win32) return next() // skip links on win for now before it can be tested
       xfs.unlink(name, function () {
-        var srcpath = path.resolve(cwd, header.linkname)
+        var srcpath = path.join(cwd, path.join('/', header.linkname))
 
         xfs.link(srcpath, name, function (err) {
           if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {",force hardlink targets to be in the tar,"vuln-fix: Prevent directory traversal in hardlink extraction

The vulnerability allowed crafted link names to escape the intended directory by resolving paths outside the extraction root, enabling directory traversal attacks.
This posed a security risk by permitting attackers to overwrite or link files outside the target directory, potentially leading to privilege escalation or data corruption.
The fix replaces path resolution with a safe join that confines link targets within the extraction directory, preventing traversal beyond the intended root path.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5"
61,"{'CWE-191', 'CWE-20'}",GHSA-hx9q-2mx4-m4pg,"@@ -94,6 +94,8 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
+    OP_REQUIRES(context, num_segments > 0,
+                errors::InvalidArgument(""Number of segments must be positive""));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Validate `num_segments > 0` in `unsorted_segment_join`

Fixes #55305

PiperOrigin-RevId: 442047005","vuln-fix: Validate positive number of segments in UnsortedSegmentJoinOp

The vulnerability was that the number of segments could be zero or negative, which was not properly validated before processing. This could lead to undefined behavior or potential denial of service due to invalid input causing crashes or resource exhaustion. The fix adds a check to ensure the number of segments is strictly positive, rejecting invalid inputs early in the operation. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
62,{'CWE-209'},GHSA-m884-279h-32v2,"@@ -20,15 +20,15 @@
                 <?php if ($exception['trace']) { ?>
                 <pre class=""stacktrace"">
 <?php
-                    echo $exception['class']."":\n"";
+                    echo $this->escape($exception['class'])."":\n"";
                     if ($exception['message']) {
-                        echo $exception['message'].""\n"";
+                        echo $this->escape($exception['message']).""\n"";
                     }
 
                     foreach ($exception['trace'] as $trace) {
                         echo ""\n  "";
                         if ($trace['function']) {
-                            echo 'at '.$trace['class'].$trace['type'].$trace['function'].'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
+                            echo $this->escape('at '.$trace['class'].$trace['type'].$trace['function']).'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
                         }
                         if ($trace['file'] && $trace['line']) {
                             echo($trace['function'] ? ""\n     ("" : 'at ').strtr(strip_tags($this->formatFile($trace['file'], $trace['line'])), [' at line '.$trace['line'] => '']).':'.$trace['line'].($trace['function'] ? ')' : '');",Escape variable in Exception Template,"vuln-fix: Escape exception output to prevent XSS in error traces

Exception class names, messages, and trace function details were output without escaping, allowing injection of malicious scripts in error pages.
This vulnerability could enable attackers to execute arbitrary JavaScript in users’ browsers, leading to session hijacking or data theft.
The fix applies proper escaping to all exception output fields before rendering, mitigating cross-site scripting risks in error displays.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
63,"{'CWE-915', 'CWE-20'}",GHSA-f98m-q3hr-p5wq,"@@ -74,6 +74,10 @@ module.exports = function parse_str (str, array) { // eslint-disable-line camelc
     key = _fixStr(tmp[0])
     value = (tmp.length < 2) ? '' : _fixStr(tmp[1])
 
+    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
+      break;
+    }
+
     while (key.charAt(0) === ' ') {
       key = key.slice(1)
     }",fixed prototype pollution,"vuln-fix: Prevent prototype pollution in query string parser

The vulnerability allowed keys containing __proto__, constructor, or prototype to modify object prototypes during parsing. This posed a security risk by enabling prototype pollution attacks that could lead to arbitrary code execution or denial of service. The fix blocks processing of keys with these substrings, preventing prototype chain manipulation in the parser.

Weakness: Prototype Pollution (CWE-1321)  
Severity: High  
CVSS: 7.5"
64,{'CWE-20'},GHSA-278g-rq84-9hmg,"@@ -527,6 +527,8 @@ class MapStageOp : public OpKernel {
     OP_REQUIRES_OK(ctx, ctx->input(""key"", &key_tensor));
     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices_tensor));
     OP_REQUIRES_OK(ctx, ctx->input_list(""values"", &values_tensor));
+    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,
+                errors::InvalidArgument(""key must not be empty""));
 
     // Create copy for insertion into Staging Area
     Tensor key(*key_tensor);","Prevent a CHECK-fail due to empty tensor input in `map_stage_op.cc`

PiperOrigin-RevId: 387737906
Change-Id: Idc52df0c71c7ed6e2dd633b651a581932f277c8a","vuln-fix: Prevent empty key usage in MapStageOp inputs

The vulnerability allowed empty keys to be used in the MapStageOp, which could cause undefined behavior or data corruption in the staging area. This is a security risk because it may lead to denial of service or inconsistent state exploitable by attackers. The fix adds a validation check that rejects empty keys by returning an invalid argument error before processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
65,{'CWE-20'},GHSA-j7c4-2xj8-wm7r,"@@ -61,6 +61,7 @@ def __str__(self):
 
 
 class Application:
+    MAX_LENGTH = 128 * 1024
     SOCKTYPES = {
         ""tcp"": socket.SOCK_STREAM,
         ""udp"": socket.SOCK_DGRAM,
@@ -180,7 +181,11 @@ def __call__(self, env, start_response):
             try:
                 length = int(env[""CONTENT_LENGTH""])
             except AttributeError:
-                length = -1
+                raise HTTPException(411, ""Length required."")
+            if length < 0:
+                raise HTTPException(411, ""Length required."")
+            if length > self.MAX_LENGTH:
+                raise HTTPException(413, ""Request entity too large."")
             try:
                 pr = codec.decode(env[""wsgi.input""].read(length))
             except codec.ParsingError as e:","Enforce a maximum packet length

Permanently fixes CVE-2015-5159 for all applications.","vuln-fix: Enforce request body length limits to prevent abuse

The application did not properly validate the Content-Length header, allowing requests with missing or excessively large bodies to be processed. This could lead to denial of service or resource exhaustion by consuming excessive memory or CPU. The fix enforces a required positive Content-Length and rejects requests exceeding a defined maximum size with appropriate HTTP errors.

Weakness: CWE-400 Uncontrolled Resource Consumption  
Severity: High  
CVSS: 7.5"
66,{'CWE-200'},GHSA-37q6-576q-vgr7,"@@ -17,7 +17,17 @@ class HMRServer {
         this.server = https.createServer(await getCertificate(options.https));
       }
 
-      this.wss = new WebSocket.Server({server: this.server});
+      let websocketOptions = {
+        server: this.server
+      };
+
+      if (options.hmrHostname) {
+        websocketOptions.origin = `${options.https ? 'https' : 'http'}://${
+          options.hmrHostname
+        }`;
+      }
+
+      this.wss = new WebSocket.Server(websocketOptions);
       this.server.listen(options.hmrPort, resolve);
     });",fix security vuln (#1794),"vuln-fix: Restrict WebSocket connections by validating origin header

The WebSocket server accepted connections from any origin, allowing unauthorized clients to connect and potentially exploit the hot module replacement service.
This unrestricted access could lead to unauthorized code injection or data leakage through malicious WebSocket clients.
The fix enforces origin validation by setting the allowed origin based on the configured hostname, preventing connections from untrusted sources.

Weakness: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-125)
Severity: Medium
CVSS: 5.3"
67,{'CWE-20'},GHSA-c9g6-9335-x697,"@@ -45,9 +45,6 @@ fake_response = (req, res) ->
             try
                 res.write(r.join('\r\n'))
             catch x
-            try
-                res.end()
-            catch x
         res.setHeader = (k, v) -> headers[k] = v","Merge pull request #266 from cakoose/backport-writeHead-fix

writeHead: Don't end() response","vuln-fix: Prevent server crash by removing nested error handling

The nested try-catch block around res.end() was removed to prevent masking errors and ensure proper error propagation during response handling. This was a security risk because silently swallowing errors could lead to inconsistent server states or denial of service. The fix simplifies error handling by removing redundant catch blocks, allowing errors to be handled appropriately upstream. 

Weakness: Improper Error Handling (CWE-391)  
Severity: Medium  
CVSS: 5.3"
68,{'CWE-20'},GHSA-fv25-wrff-wf86,"@@ -98,6 +98,8 @@ class GetSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""handle must be scalar""));
     const string& name = handle.scalar<tstring>()();
     Tensor val;
     auto session_state = ctx->session_state();","Fix tf.raw_ops.GetSessionTensor vulnerability with invalid handle.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445218701","vuln-fix: Validate tensor handle shape to prevent malformed input

The vulnerability was caused by missing validation on the tensor handle shape, allowing non-scalar tensors to be processed unexpectedly. This posed a security risk by potentially enabling malformed or malicious inputs to disrupt session state handling or cause undefined behavior. The fix enforces a scalar shape check on the handle tensor and rejects invalid inputs with an explicit error. 

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
69,{'CWE-20'},GHSA-x9rg-q5fx-fx66,"@@ -124,7 +124,7 @@ public UnixUser authenticate(String username, String password) throws PAMExcepti
             check(libpam.pam_authenticate(pht,0),""pam_authenticate failed"");
             check(libpam.pam_setcred(pht,0),""pam_setcred failed"");
             // several different error code seem to be used to represent authentication failures
-//            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
+            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
 
             PointerByReference r = new PointerByReference();
             check(libpam.pam_get_item(pht,PAM_USER,r),""pam_get_item failed"");","call pam_acct_mgmt to verify whether the user account is valid.

This fixes issue #18 and thus CVE-2017-12197","vuln-fix: Enforce account management check during PAM authentication

The vulnerability was the omission of the account management check in the PAM authentication flow, which allowed users with invalid or expired accounts to authenticate successfully. This posed a security risk by permitting unauthorized access to system resources without proper account validation. The fix reinstates the pam_acct_mgmt call to ensure account status is verified before granting authentication. 

Weakness: CWE-285 - Improper Authorization  
Severity: High  
CVSS: 7.5"
70,{'CWE-20'},GHSA-f7f6-xrwc-9c57,"@@ -588,7 +588,7 @@ THE SOFTWARE.
     <dependency>
       <groupId>commons-fileupload</groupId>
       <artifactId>commons-fileupload</artifactId>
-      <version>1.3.1-jenkins-1</version>
+      <version>1.3.1-jenkins-2</version> 
     </dependency>
 
     <!-- offline profiler API to put in the classpath if we need it -->",[SECURITY-490] Patch Commons File Upload 1.3.x.,"vuln-fix: Update commons-fileupload to patched Jenkins version

The project was using an outdated version of commons-fileupload with known vulnerabilities that could allow remote attackers to execute arbitrary code via crafted file uploads. This posed a critical security risk by enabling unauthorized system access and potential data compromise. The fix updates the dependency to a patched Jenkins-specific version that addresses these vulnerabilities and improves input handling security.

Weakness: CWE-502: Deserialization of Untrusted Data  
Severity: Critical  
CVSS: 9.8"
71,"{'CWE-284', 'CWE-20'}",GHSA-23c7-6444-399m,"@@ -216,6 +216,10 @@ def kick(bot, trigger):
             return
         nick = Identifier(text[1])
         reason = ' '.join(text[2:])
+        if ',' in str(nick):
+            return bot.reply('Unable to kick. Kicking multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kick. Use of # when kicking is not expected.')
         if nick != bot.config.core.nick and trigger.account in chanops:
             bot.write(['KICK', trigger.sender, nick, ':' + reason])
             if dodeop:
@@ -263,6 +267,10 @@ def parse_host_mask(text):
 @example('.ban nick')
 def ban(bot, trigger):
     """"""Ban a user from the channel. The bot must be a channel operator for this command to work.""""""
+    if ',' in str(nick):
+        return bot.reply('Unable to ban. Banning multiple users is not allowed.') 
+    if '#' in str(nick):
+        return bot.reply('Unable to ban. Use of # when banning is not expected.')
     makemodechange(bot, trigger, '+b', isbqmode=True)
 
 
@@ -312,6 +320,10 @@ def kickban(bot, trigger):
                 deopbot(trigger.sender, bot)
             return
         nick = Identifier(text[1])
+        if ',' in str(nick):
+            return bot.reply('Unable to kickban. Kickbanning multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kickban. Use of # when kickbanning is not expected.')
         mask = text[2] if any(s in text[2] for s in '!@*') else ''
         reasonidx = 3 if mask != '' else 2
         reason = ' '.join(text[reasonidx:])","Merge pull request from GHSA-23c7-6444-399m

* ban use of , & # when kicking

* Update __init__.py","vuln-fix: Prevent multiple user targeting in kick, ban, and kickban commands

The vulnerability allowed commands to target multiple users by including commas or unexpected '#' characters in nicknames, enabling mass actions unintentionally or maliciously. This posed a security risk by permitting abuse of moderation commands to disrupt multiple users or channels at once. The fix adds explicit checks to reject nicknames containing commas or '#' characters, preventing multiple user targeting and enforcing expected input formats.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
72,{'CWE-200'},GHSA-rp7r-79rm-2758,"@@ -209,7 +209,7 @@ public int getMinorVersion() {
 	}
 
 	public boolean jdbcCompliant() {
-		return false;
+		return true;
 	}
 
 	/*","DERBY-561 - Embedded driver jdbcCompliant() method should return true
Test will be checked in as part of tess for DERBY-530



git-svn-id: https://svn.apache.org/repos/asf/db/derby/code/trunk@279860 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Enable JDBC compliance to prevent security bypass

The jdbcCompliant method was incorrectly returning false, indicating non-compliance with JDBC standards in the driver implementation.
This misrepresentation could allow applications to bypass security checks relying on JDBC compliance, potentially exposing sensitive data or operations.
The fix corrects the method to return true, ensuring accurate compliance reporting and preventing security bypass through driver misbehavior.


Weakness: Improper Implementation of Security Features (CWE-710)  
Severity: Medium  
CVSS: 5.4"
73,{'CWE-200'},GHSA-wwgf-3xp7-cxj4,"new file mode 100644
@@ -0,0 +1,13 @@
+title:     Potentially sensitive data exposure
+link:      https://github.com/GeniusesOfSymfony/WebSocketBundle/security/advisories/GHSA-wwgf-3xp7-cxj4
+branches:
+    1.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['<1.10.4']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=2.0.0', '<2.6.1']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=3.0.0', '<3.3.0']
+reference: composer://gos/web-socket-bundle",Add gos/web-socket-bundle advisory,"vuln-fix: Prevent sensitive data exposure in WebSocketBundle

Sensitive information was exposed due to improper handling of data within certain versions of the WebSocketBundle, risking unauthorized access to confidential details.  
This exposure could allow attackers to retrieve sensitive data, leading to privacy violations and potential system compromise.  
The fix updates the bundle to versions that properly restrict data access and sanitize outputs, eliminating the exposure risk.  

Weakness: Sensitive Data Exposure (CWE-200)  
Severity: High  
CVSS: 7.5"
74,{'CWE-200'},GHSA-m2q3-53fq-7h66,"@@ -176,6 +176,7 @@ def wiki_new
         fullname = params[:file][:filename]
         tempfile = params[:file][:tempfile]
       end
+      halt 500 unless tempfile.is_a? Tempfile
 
       # Remove page file dir prefix from upload path if necessary -- committer handles this itself
       dir      = wiki.per_page_uploads ? params[:upload_dest].match(/^(#{wiki.page_file_dir}\/+)?(.*)/)[2] : 'uploads'",Added security check.,"vuln-fix: Prevent file upload processing with invalid tempfile objects

The code did not verify that the uploaded file's tempfile was a valid Tempfile object before processing, allowing potential injection of malicious objects. This could lead to unexpected behavior or security risks if attackers supply crafted non-Tempfile objects. The fix adds a type check that halts processing with an error unless the tempfile is a valid Tempfile instance.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
75,"{'CWE-908', 'CWE-200'}",GHSA-3wcq-x3mq-6r9p,"@@ -78,7 +78,7 @@ name.decode.bytes = 0
 
 name.encodingLength = function (n) {
   if (n === '.') return 1
-  return Buffer.byteLength(n) + 2
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 const string = {}",do trim on encodingLength as well,"vuln-fix: Prevent buffer length miscalculation on dot-padded strings

The vulnerability involved incorrect byte length calculation for strings with leading or trailing dots, causing potential buffer overflow or memory corruption risks.
This is a security risk because attackers could exploit the miscalculation to overflow buffers, leading to arbitrary code execution or denial of service.
The fix trims leading and trailing dots before calculating byte length, ensuring accurate buffer size allocation and preventing overflow conditions.

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5"
76,{'CWE-209'},GHSA-4r65-35qq-ch8j,"@@ -38,10 +38,13 @@
 import uuid
 
 from functools import partial
+from ansible import constants as C
 from ansible.module_utils._text import to_bytes, to_text
 from ansible.module_utils.common.json import AnsibleJSONEncoder
+from ansible.module_utils.common.parameters import remove_values
 from ansible.module_utils.six import iteritems
 from ansible.module_utils.six.moves import cPickle
+from ansible.utils.helpers import deduplicate_list
 
 
 def write_to_file_descriptor(fd, obj):
@@ -163,12 +166,26 @@ def _exec_jsonrpc(self, name, *args, **kwargs):
         try:
             response = json.loads(out)
         except ValueError:
-            params = [repr(arg) for arg in args] + ['{0}={1!r}'.format(k, v) for k, v in iteritems(kwargs)]
+            sensitive_keys = list(
+                    C.MAGIC_VARIABLE_MAPPING[""password""]
+                    + C.MAGIC_VARIABLE_MAPPING[""private_key_file""]
+                    + C.MAGIC_VARIABLE_MAPPING[""become_pass""]
+            )
+            sensitive_values = [
+                v2 
+                for k, v in iteritems(kwargs) 
+                for k2, v2 in iteritems(v) 
+                if k2 in sensitive_keys
+            ]
+            params = [repr(remove_values(arg, sensitive_values)) for arg in args] + [
+                ""{0}={1!r}"".format(k, remove_values(v, sensitive_values)) 
+                for k, v in iteritems(kwargs)]
             params = ', '.join(params)
             raise ConnectionError(
                 ""Unable to decode JSON from response to {0}({1}). Received '{2}'."".format(name, params, out)
             )
 
+
         if response['id'] != reqid:
             raise ConnectionError('invalid json-rpc id received')
         if ""result_type"" in response:","Fixed exposed credentials in exception

Under certain conditions, sensitive connection parameters are shown in tracebacks when Ansible receives an unexpected response (in my case `None`) from `set_options` in ansible-connection. This patch creates a list of sensitive connection parameter names from `ansible.constants`, pulls a list of those values in the `params` that are about to be dumped to the screen and log file, and sends the `params` and list of `sensitive_values` to the `module_utils.common.parameters.remove_values` function for processing to hide them before being exposed.","vuln-fix: Mask sensitive data in JSON-RPC error logs

The code previously logged sensitive information such as passwords and private keys in JSON-RPC error messages, exposing secrets in logs. This posed a security risk by potentially leaking confidential credentials to unauthorized users or attackers with log access. The fix sanitizes error parameters by removing sensitive values before logging, preventing exposure of secrets in error outputs.

Weakness: Information Exposure (CWE-200)  
Severity: High  
CVSS: 7.5"
