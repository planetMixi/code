id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message,original_message_score,original_message_entities,generated_secom_message_score,generated_secom_message_entities
0,CWE-79,GHSA-wcm2-9c89-wmfm,"@@ -352,14 +352,21 @@ $.widget(""ui.dialog"", {
 		uiDialogTitle = $( ""<span>"" )
 			.uniqueId()
 			.addClass( ""ui-dialog-title"" )
-			.html( this.options.title || ""&#160;"" )
 			.prependTo( this.uiDialogTitlebar );
+		this._title( uiDialogTitle );
 
 		this.uiDialog.attr({
 			""aria-labelledby"": uiDialogTitle.attr( ""id"" )
 		});
 	},
 
+	_title: function( title ) {
+		if ( !this.options.title ) {
+			title.html( ""&#160;"" );
+		}
+		title.text( this.options.title );
+	},
+
 	_createButtonPane: function() {
 		var uiDialogButtonPane = ( this.uiDialogButtonPane = $( ""<div>"" ) )
 			.addClass( ""ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"" );
@@ -600,9 +607,7 @@ $.widget(""ui.dialog"", {
 		}
 
 		if ( key === ""title"" ) {
-			// convert whatever was passed in to a string, for html() to not throw up
-			$( "".ui-dialog-title"", this.uiDialogTitlebar )
-				.html( """" + ( value || ""&#160;"" ) );
+			this._title( this.uiDialogTitlebar.find( "".ui-dialog-title"" ) );
 		}
 	},","Dialog: Extract setting the title into a _title method, use .text() to prevent XSS. Fixes #6016 - Dialog: Title XSS Vulnerability.","vuln-fix: Prevent XSS by safely setting dialog titles

The dialog widget previously inserted raw HTML for titles without escaping, allowing injection of malicious HTML or scripts via the title option.
This exposed applications to cross-site scripting (XSS) attacks where attackers could execute arbitrary code in users’ browsers through crafted dialog titles.
The fix replaces direct HTML insertion with safe text setting, ensuring titles are properly escaped and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.5",0.058823529411764705,"[('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('fixes', 'ACTION', ''), ('#6016', 'ISSUE', ''), ('xss', 'secword', ''), ('vulnerability', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,CWE-79,GHSA-q26w-wjj2-22vv,"@@ -87,11 +87,16 @@ class HtmlUtils {
 			return tagStack[tagStack.length - 1];
 		};
 
-		// The BASE tag allows changing the base URL from which files are loaded, and
-		// that can break several plugins, such as Katex (which needs to load CSS
-		// files using a relative URL). For that reason it is disabled.
-		// More info: https://github.com/laurent22/joplin/issues/3021
-		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed'];
+		// The BASE tag allows changing the base URL from which files are
+		// loaded, and that can break several plugins, such as Katex (which
+		// needs to load CSS files using a relative URL). For that reason
+		// it is disabled. More info:
+		// https://github.com/laurent22/joplin/issues/3021
+		//
+		// ""link"" can be used to escape the parser and inject JavaScript.
+		// Adding ""meta"" too for the same reason as it shouldn't be used in
+		// notes anyway.
+		const disallowedTags = ['script', 'iframe', 'frameset', 'frame', 'object', 'base', 'embed', 'link', 'meta'];
 
 		const parser = new htmlparser2.Parser({","All: Security: Remove ""link"" and ""meta"" tags from notes to prevent XSS","vuln-fix: Block link and meta tags to prevent HTML injection

The HTML sanitizer allowed <link> and <meta> tags, which could be exploited to inject malicious scripts or manipulate document metadata in notes.
This posed a security risk by enabling attackers to bypass content restrictions and execute arbitrary JavaScript or alter page behavior.
The fix extends the disallowed tags list to include ""link"" and ""meta"", preventing their use and mitigating injection attacks.

Weakness: CWE-79
Severity: High
CVSS: 7.5",0.058823529411764705,"[('security', 'SECWORD', ''), ('remove', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('sanitizer', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,CWE-79,GHSA-4p8f-mmfj-r45g,"@@ -17,7 +17,7 @@ def tags_for_index(model)
       elsif !query.include?(hashtag)
         query += "" #{hashtag}""
       end
-      out << link_to_function(tag, ""crm.search_tagged('#{query}', '#{model.class.to_s.tableize}')"", title: tag)
+      out << link_to_function(tag, ""crm.search_tagged('#{escape_javascript(query)}', '#{model.class.to_s.tableize}')"", title: tag)
     end
   end",Context-sensitive XSS bugfix.,"vuln-fix: Escape JavaScript in dynamic tag search calls

The code injected user-controlled tag queries directly into JavaScript function calls without escaping, allowing injection of arbitrary script code.
This created a cross-site scripting (XSS) risk where attackers could execute malicious scripts in users’ browsers by crafting special tag inputs.
The fix applies proper JavaScript escaping to the query string before embedding it in the function call, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('sensitive', 'SECWORD', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,CWE-79,GHSA-cx2r-mf6x-55rx,"@@ -29,6 +29,7 @@
 use PrestaShopBundle\Form\Admin\Type\TranslatorAwareType;
 use Symfony\Component\Form\Extension\Core\Type\TextType;
 use Symfony\Component\Form\FormBuilderInterface;
+use Symfony\Component\Validator\Constraints as Assert;
 
 class CustomUrlType extends TranslatorAwareType
 {
@@ -45,6 +46,7 @@ public function buildForm(FormBuilderInterface $builder, array $options)
             ->add('url', TextType::class, [
                 'label' => $this->trans('URL', 'Modules.Linklist.Admin'),
                 'required' => true,
+                'constraints' => [new Assert\Url()],
             ])
         ;
     }","Merge pull request from GHSA-cx2r-mf6x-55rx

The custom url field must be a valid url","vuln-fix: Add URL validation to custom URL form field

The form field for URLs lacked validation, allowing users to submit malformed or malicious URLs without restriction.
This posed a security risk by enabling injection of invalid or harmful URLs that could lead to phishing, open redirects, or other attacks.
The fix adds a URL constraint using Symfony’s validator to ensure only properly formatted URLs are accepted.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('injection', 'secword', ''), ('phishing', 'secword', ''), ('open redirects', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,CWE-79,GHSA-5qjq-69w6-fg57,"similarity index 86%
rename from js/src/common/Translator.ts
rename to js/src/common/Translator.tsx
@@ -48,12 +48,23 @@ export default class Translator {
     // future there should be a hook here to inspect the user and change the
     // translation key. This will allow a gender property to determine which
     // translation key is used.
+
     if ('user' in parameters) {
       const user = extract(parameters, 'user');
 
       if (!parameters.username) parameters.username = username(user);
     }
-    return parameters;
+
+    const escapedParameters: TranslatorParameters = {};
+
+    for (const param in parameters) {
+      const paramValue = parameters[param];
+
+      if (typeof paramValue === 'string') escapedParameters[param] = <>{parameters[param]}</>;
+      else escapedParameters[param] = parameters[param];
+    }
+
+    return escapedParameters;
   }
 
   trans(id: string, parameters: TranslatorParameters = {}) {",Fix XSS vulnerability,"vuln-fix: Escape string parameters in translation to prevent XSS

The translation function returned user-supplied string parameters without escaping, allowing injection of malicious HTML or scripts in rendered translations.
This exposed applications to cross-site scripting (XSS) attacks where attackers could execute arbitrary code in users’ browsers via crafted translation inputs.
The fix wraps string parameters in React fragments to ensure proper escaping and safe rendering of dynamic translation content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,CWE-79,GHSA-3374-7h99-xr85,"@@ -128,6 +128,7 @@ private function loadDataGrid(): void
             'registered_on',
             true
         );
+        $this->dgProfiles->setColumnFunction('htmlspecialchars', ['[display_name]'], 'display_name');
 
         // add the mass action controls
         $this->dgProfiles->setMassActionCheckboxes('check', '[id]');",Fix xss in profiles display name,"vuln-fix: Sanitize display names in data grid output

The data grid displayed user-provided display names without escaping HTML entities, allowing injection of malicious HTML or scripts.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in users’ browsers.
The fix applies htmlspecialchars to display names before rendering, ensuring special characters are safely encoded and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,CWE-79,GHSA-qqxp-xp9v-vvx6,"@@ -61,7 +61,7 @@
 						// remove invalid value, as it didn't match anything
 						$( element )
 							.val( """" )
-							.attr( ""title"", value + "" didn't match any item"" )
+							.attr( ""title"", $( ""<a>"" ).text( value ).html() + "" didn't match any item"" )
 							.tooltip( ""open"" );
 						select.val( """" );
 						setTimeout(function() {",Autocomplete demo: Combobox: Encode search term inside tooltips. Fixes #8859 - Autocomplete: XSS in combobox demo.,"vuln-fix: Sanitize tooltip content to prevent XSS in autocomplete

The autocomplete widget set tooltip titles directly from user input without escaping, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting (XSS) attacks by rendering untrusted input as executable code in tooltips.
The fix escapes user input by encoding it as text before inserting into the tooltip attribute, preventing HTML interpretation.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('encode', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#8859', 'ISSUE', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('untrusted', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,CWE-79,GHSA-q7q9-w24q-cpgh,"@@ -149,8 +149,16 @@ App.BreadcrumbItem = Em.Object.extend({
   createLabel() {
     let label = this.get('label');
     let labelBindingPath = this.get('labelBindingPath');
+    let formattedLabel;
+
+    if (labelBindingPath) {
+      formattedLabel = Ember.Handlebars.Utils.escapeExpression(App.get(_getLabelPathWithoutApp(labelBindingPath)));
+    } else{
+      formattedLabel = label;
+    }
+
+
 
-    let formattedLabel = labelBindingPath ? App.get(_getLabelPathWithoutApp(labelBindingPath)) : label;
     this.set('formattedLabel', this.labelPostFormat(formattedLabel));
   },
 
@@ -216,7 +224,9 @@ App.BreadcrumbsView = Em.View.extend({
       }
       currentState = currentState.get('parentState');
     }
-    items = items.reverse().map(item => App.BreadcrumbItem.extend(item).create());
+    items.reverse();
+    items.slice(1).forEach(item => item.label = Ember.Handlebars.Utils.escapeExpression(item.label));
+    items = items.map(item => App.BreadcrumbItem.extend(item).create());
     if (items.length) {
       items.get('lastObject').setProperties({
         disabled: true,",AMBARI-25329. Ambari breadcrumbs xss vulnerability,"vuln-fix: Escape breadcrumb labels to prevent XSS injection

Breadcrumb labels were rendered without proper escaping, allowing injection of malicious HTML or scripts via labelBindingPath or label properties.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in the context of the application.
The fix applies Ember's escapeExpression to breadcrumb labels derived from bindings and all but the first breadcrumb item, ensuring safe rendering.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('xss', 'secword', ''), ('vulnerability', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escapeexpression', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,CWE-79,GHSA-vcfc-9wcp-j623,"@@ -90,12 +90,13 @@ public async Task SerializeToStreamAsync(IRequest req, object response, Stream o
             {
                 // Serialize then escape any potential script tags to avoid XSS when displaying as HTML
                 var json = JsonDataContractSerializer.Instance.SerializeToString(dto) ?? ""null"";
-                json = json.Replace(""<"", ""&lt;"").Replace("">"", ""&gt;"");
+                json = json.HtmlEncode();
 
                 var url = req.ResolveAbsoluteUrl()
                     .Replace(""format=html"", """")
                     .Replace(""format=shtm"", """")
-                    .TrimEnd('?', '&');
+                    .TrimEnd('?', '&')
+                    .HtmlEncode();
 
                 url += url.Contains(""?"") ? ""&"" : ""?"";",HtmlEncode Raw URL in HtmlFormat snapshot,"vuln-fix: Encode output to prevent cross-site scripting in HTML responses

The serialization method did not fully encode JSON and URL strings before embedding them in HTML, allowing unescaped characters that could enable script injection.
This exposed users to cross-site scripting (XSS) attacks where malicious scripts could execute in the context of trusted web pages, compromising user data and session integrity.
The fix replaces manual character replacements with comprehensive HTML encoding for both JSON content and URLs, ensuring all special characters are safely escaped.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('htmlencode', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('serialization', 'SECWORD', ''), ('encode', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('manual', 'DETECTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,CWE-79,GHSA-whv6-rj84-2vh2,"@@ -60,6 +60,9 @@ import Action from 'nextcloud-vue/dist/Components/Action'
 import Avatar from 'nextcloud-vue/dist/Components/Avatar'
 import Tooltip from 'nextcloud-vue/dist/Directives/Tooltip'
 
+Tooltip.options.defaultHtml = false
+
+
 export default {
 	name: 'CollectionListItem',
 	components: {","Force defaultHtml setting of v-tooltip to be disabled

Signed-off-by: Julius Härtl <jus@bitgrid.net>","vuln-fix: Disable default HTML rendering in tooltips

The tooltip directive allowed HTML content by default, enabling injection of arbitrary HTML and scripts into the user interface.
This posed a cross-site scripting (XSS) risk where attackers could execute malicious code in users' browsers by injecting crafted tooltip content.
The fix disables default HTML rendering in tooltips, forcing safer plain text display and preventing script execution via tooltip content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('signed', 'secword', ''), ('jus@bitgrid.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious code', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,CWE-79,GHSA-xw79-hhv6-578c,"@@ -4,7 +4,7 @@
     <meta charset=""utf-8"">
     <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
 
-    <title>Files within {{=it.directory}}</title>
+    <title>Files within {{!it.directory}}</title>
 
 	<style>
 		body {
@@ -187,7 +187,7 @@
           <i>Index of&nbsp;</i>
 
           {{~it.paths :value:index}}
-            <a href=""/{{=value.url}}"">{{=value.name}}</a>
+            <a href=""/{{!value.url}}"">{{!value.name}}</a>
           {{~}}
         </h1>
 
@@ -197,9 +197,9 @@
       <ul id=""files"">
         {{~it.files :value:index}}
           <li>
-            <a href=""{{=value.relative}}"" title=""{{=value.title}}"" class=""{{=value.ext}}"">{{=value.base}}</a>
+            <a href=""{{!value.relative}}"" title=""{{!value.title}}"" class=""{{!value.ext}}"">{{!value.base}}</a>
 			{{? value.size}}
-				<i>{{=value.size}}</i>
+				<i>{{!value.size}}</i>
 			{{?}}
           </li>
         {{~}}",Interpolate template variables correctly (#64),"vuln-fix: Escape user input in directory listing templates

The directory listing page rendered user-supplied data without escaping, allowing injection of arbitrary HTML or scripts into the page.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute malicious code in victims’ browsers and steal sensitive information.
The patch changes template interpolation from unescaped to escaped output, preventing injection by properly encoding all user-controlled fields.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('#64', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious code', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive information', 'secword', ''), ('patch', 'ACTION', ''), ('changes', 'ACTION', ''), ('unescaped', 'SECWORD', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('encoding', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
11,CWE-79,GHSA-5pg2-qg87-vmj7,"@@ -336,9 +336,12 @@
 // Make sure the fileName is unique but only if chunking is disabled
 if ($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {
     $ext = strrpos($fileName, '.');
+
     $fileName_a = substr($fileName, 0, $ext);
     $fileName_b = substr($fileName, $ext);
 
+    $fileName_b = strtolower($fileName_b);
+
     $count = 1;
     while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b)) {
         ++$count;
@@ -500,7 +503,7 @@
 
     if (is_file($filePath) and !$chunks || $chunk == $chunks - 1) {
         $ext = get_file_extension($filePath);
-
+        $ext = strtolower($ext);
         if (function_exists('finfo_open') and function_exists('finfo_file')) {
             $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension
             $mime = @finfo_file($finfo, $filePath);",update,"vuln-fix: Normalize file extensions to prevent case-based bypasses

File extension comparisons were case-sensitive, allowing attackers to bypass file existence checks and MIME type validations by using uppercase or mixed-case extensions.
This inconsistency could lead to overwriting existing files or improper MIME type handling, potentially enabling unauthorized file uploads or execution of malicious content.
The fix converts file extensions to lowercase before comparisons and checks, ensuring consistent and secure handling regardless of case variations.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypasses', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,CWE-79,GHSA-5vr6-hm68-5j9p,"@@ -44,5 +44,5 @@
 if (! empty($ok)) {
     exit(""$ok"");
 } else {
-    exit(""ERROR: $error"");
+    exit(""ERROR: "".htmlspecialchars($error));;
 }",fix XSS vulnerability in poller-groups.inc.php,"vuln-fix: Sanitize error output to prevent XSS in responses

The application directly outputted error messages without encoding, allowing injection of malicious HTML or JavaScript into the response.
This exposed users to cross-site scripting (XSS) attacks where attackers could execute arbitrary scripts in victims' browsers.
The fix applies htmlspecialchars to encode error messages before output, preventing execution of injected code.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('poller-groups.inc.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('error', 'FLAW', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,"CWE-434', 'CWE-79",GHSA-5q5w-mqp6-g2gh,"@@ -20,7 +20,9 @@ public function rules()
             'quantity' => ['required', 'integer', 'min:0'],
             'price' => ['required', 'numeric', 'min:0'],
             'sale_price' => ['nullable', 'numeric'],
-            'weight' => ['nullable', 'numeric', 'min:0']
+            'weight' => ['nullable', 'numeric', 'min:0'],
+            'image' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
+            'cover' => 'image|mimes:jpeg,png,jpg,gif,svg|max:2048',
         ];
     }
 }",Fix vulnerability report from hunter.dev,"vuln-fix: Enforce image upload validation in product input

The product input validation lacked checks for uploaded image files, allowing arbitrary file types and sizes to be submitted without restriction.
This exposed the application to risks such as malicious file uploads, which could lead to remote code execution or denial of service through oversized files.
The fix adds strict validation rules to ensure only specific image MIME types are accepted and file sizes are limited to 2MB.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'SECWORD', ''), ('hunter.dev', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('input validation', 'secword', ''), ('malicious file', 'secword', ''), ('remote code execution', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,CWE-79,GHSA-vpwq-6cp4-ffqc,"@@ -309,6 +309,8 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".aspx"")
 			|| $isDangerStr($filename , "".xsd"")
 			|| $isDangerStr($filename , "".asa"")
+			|| $isDangerStr($filename , "".cshtml"")
+			|| $isDangerStr($filename , "".axd"")
 		) {
 			return true;
 		}",bug,"vuln-fix: Extend dangerous filename checks to block risky extensions

The filename validation function did not consider certain web-related extensions like .cshtml and .axd as dangerous, allowing potentially unsafe files to be accepted.
This omission could enable attackers to upload or process files that execute server-side code or expose sensitive application internals, leading to remote code execution or information disclosure.
The fix adds these extensions to the danger list, improving input validation to reject files with risky server-side script or handler extensions.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('server', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('remote code execution', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('danger', 'secword', ''), ('improving', 'ACTION', ''), ('input validation', 'secword', ''), ('server', 'secword', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
15,CWE-79,GHSA-j6p2-cx3w-6jcp,"@@ -1079,7 +1079,7 @@
 
   // Helper function to escape a string for HTML rendering.
   var escapeHTML = function(string) {
-    return string.replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+    return string.replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
   };
 
 }).call(this);","Fixed escapeHTML function
to skip not only &***;, but also &#***; and &x***;","vuln-fix: Improve HTML escaping to handle numeric character references

The HTML escaping function failed to correctly preserve numeric character references, allowing them to be partially escaped and potentially misinterpreted by browsers.
This flaw could enable injection of malicious HTML or script content by bypassing escaping, leading to cross-site scripting (XSS) vulnerabilities.
The fix extends the regex to recognize and exclude numeric character references from escaping, ensuring all entities are safely encoded.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.23529411764705882,"[('fixed', 'ACTION', ''), ('escapehtml', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('escaping', 'secword', ''), ('escaping', 'SECWORD', ''), ('escaped', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('escaping', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,CWE-79,GHSA-h4mx-xv96-2jgm,"@@ -9,7 +9,7 @@
         {f:translate(
         key: 'forgot_validate_reset_password_html',
         extensionName: 'felogin',
-        arguments: '{ 0: receiverName, 1: recoveryLink, 2: validUntil }'
+        arguments: '{ 0: ""{receiverName -> f:format.htmlspecialchars()}"", 1: recoveryLink, 2: validUntil }'
         ) -> f:format.html()}
     </f:spaceless>
 </f:section>","[SECURITY] Avoid HTML injection in password recovery mail

The `receiverName` variable used in the password recovery mail of the
Extbase felogin plugin was susceptible to HTML injection due to
missing sanitization. The variable is now passed thru the
`f:format.htmlspecialchars` ViewHelper.

Resolves: #96559
Releases: main, 11.5, 10.4
Change-Id: I60e23c161f7f2fcc87b8870345b10a4c31d7b8db
Security-Bulletin: TYPO3-CORE-SA-2022-004
Security-References: CVE-2022-31049
Reviewed-on: https://review.typo3.org/c/Packages/TYPO3.CMS/+/74904
Tested-by: Oliver Hader <oliver.hader@typo3.org>
Reviewed-by: Oliver Hader <oliver.hader@typo3.org>","vuln-fix: Escape user name in password reset email template

The password reset email template failed to escape the receiver's name before rendering, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting attacks via crafted user names that could execute arbitrary code in email clients or web views.
The fix applies HTML special character escaping to the receiverName argument, preventing injection of unsafe markup in the email content.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.17647058823529413,"[('security', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('password', 'secword', ''), ('password', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('sanitization', 'secword', ''), ('format.htmlspecialchars', 'SECWORD', ''), ('#96559', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('user name', 'secword', ''), ('password', 'secword', ''), ('password', 'secword', ''), ('escape', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,CWE-79,GHSA-wx69-rvg3-x7fc,"@@ -15,11 +15,12 @@ uploads.upload = async function (socket, data) {
 		'user.updateCover': socketUser.updateCover,
 		'groups.cover.update': socketGroup.cover.update,
 	};
-	if (!socket.uid || !data || !data.chunk || !data.params || !data.params.method || !methodToFunc[data.params.method]) {
+	if (!socket.uid || !data || !data.chunk ||
+		!data.params || !data.params.method || !methodToFunc.hasOwnProperty(data.params.method)) {
 		throw new Error('[[error:invalid-data]]');
 	}
 
-	inProgress[socket.id] = inProgress[socket.id] || {};
+	inProgress[socket.id] = inProgress[socket.id] || Object.create(null);
 	const socketUploads = inProgress[socket.id];
 	const { method } = data.params;",fix: guard against prototype pollution,"vuln-fix: Prevent prototype pollution in upload method dispatch

The upload handler used a direct property check on methodToFunc without safeguarding against prototype pollution via crafted method names.
This allowed attackers to invoke unintended functions or cause application logic errors by exploiting inherited properties on Object.prototype.
The fix replaces the property check with hasOwnProperty and initializes inProgress entries with a null-prototype object to prevent prototype pollution attacks.

Weakness: CWE-1321
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attackers', 'FLAW', ''), ('logic errors', 'SECWORD', ''), ('exploiting', 'SECWORD', ''), ('object.prototype', 'URL', ''), ('fix', 'ACTION', ''), ('initializes', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'secword', ''), ('attacks', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,CWE-79,GHSA-95hx-62rh-gg96,"@@ -317,7 +317,7 @@ public function getWidgetVariables($hookName = null, array $configuration = [])
             }
         }
         $this->contact['contacts'] = $this->getTemplateVarContact();
-        $this->contact['message'] = html_entity_decode(Tools::getValue('message'));
+        $this->contact['message'] = Tools::getValue('message');
         $this->contact['allow_file_upload'] = (bool) Configuration::get('PS_CUSTOMER_SERVICE_FILE_UPLOAD');
 
         if (!(bool)Configuration::isCatalogMode()) {
@@ -388,9 +388,10 @@ public function getTemplateVarOrders()
     {
         $orders = [];
 
-        if (!isset($this->customer_thread['id_order'])
+        if (empty($this->customer_thread['id_order'])
             && isset($this->context->customer)
-            && $this->context->customer->isLogged()) {
+            && $this->context->customer->isLogged()
+        ) {
             $customer_orders = Order::getCustomerOrders($this->context->customer->id);
 
             foreach ($customer_orders as $customer_order) {
@@ -401,7 +402,7 @@ public function getTemplateVarOrders()
                     $orders[$customer_order['id_order']]['products'] = $myOrder->getProducts();
                 }
             }
-        } elseif (isset($this->customer_thread['id_order']) && (int)$this->customer_thread['id_order'] > 0) {
+        } elseif (isset($this->customer_thread['id_order']) && (int) $this->customer_thread['id_order'] > 0) {
             $myOrder = new Order($this->customer_thread['id_order']);
 
             if (Validate::isLoadedObject($myOrder)) {
@@ -411,13 +412,13 @@ public function getTemplateVarOrders()
             }
         }
 
-        if (isset($this->customer_thread['id_product'])) {
+        if (!empty($this->customer_thread['id_product'])) {
             $id_order = isset($this->customer_thread['id_order']) ?
-                      (int)$this->customer_thread['id_order'] :
+                      (int) $this->customer_thread['id_order'] :
                       0;
 
             $orders[$id_order]['products'][(int)$this->customer_thread['id_product']] = $this->context->controller->objectPresenter->present(
-                new Product((int)$this->customer_thread['id_product'])
+                new Product((int) $this->customer_thread['id_product'])
             );
         }
 
@@ -584,7 +585,7 @@ public function sendMessage()
                 $var_list = [
                     '{order_name}' => '-',
                     '{attached_file}' => '-',
-                    '{message}' => Tools::nl2br(Tools::stripslashes($message)),
+                    '{message}' => Tools::nl2br(Tools::htmlentitiesUTF8(Tools::stripslashes($message))),
                     '{email}' =>  $from,
                     '{product_name}' => '',
                 ];","Merge pull request from GHSA-95hx-62rh-gg96

Do not unescape form message data","vuln-fix: Sanitize user message input to prevent XSS in contact form

The contact form message field was not properly sanitized, allowing raw user input to be included in output without escaping, leading to potential cross-site scripting attacks.
This exposed users and administrators to malicious script injection, which could hijack sessions, deface content, or steal sensitive information.
The fix applies HTML entity encoding to the message content before rendering, ensuring that special characters are safely escaped and scripts cannot execute.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('ghsa-95hx-62rh', 'VULNID', 'GHSA'), ('unescape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('escaping', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('administrators', 'SECWORD', ''), ('malicious', 'secword', ''), ('injection', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive information', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,CWE-79,GHSA-82j4-vr25-x394,"@@ -304,6 +304,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
 			|| $isDangerStr($filename , "".xxhtml"")
+			|| $isDangerStr($filename , "".aspx"")			
 		) {
 			return true;
 		}","Merge pull request #1629 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Block .aspx files in dangerous filename check

The filename validation function did not consider "".aspx"" extensions as dangerous, allowing potentially unsafe files to bypass security filters.
This omission could enable attackers to upload or process malicious ASP.NET pages, leading to unauthorized code execution or information disclosure.
The fix adds "".aspx"" to the list of blocked extensions, enhancing filename checks to prevent handling of risky file types.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.23529411764705882,"[('#1629', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'secword', ''), ('bypass', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('asp.net', 'URL', ''), ('code execution', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,CWE-79,GHSA-m52x-29pq-w3vv,"@@ -1726,7 +1726,7 @@ function createHotSpot(hs) {
         if (config.basePath && !absoluteURL(imgp))
             imgp = config.basePath + imgp;
         a = document.createElement('a');
-        a.href = sanitizeURL(hs.URL ? hs.URL : imgp);
+        a.href = sanitizeURL(hs.URL ? hs.URL : imgp, true);
         a.target = '_blank';
         span.appendChild(a);
         var image = document.createElement('img');
@@ -1738,7 +1738,7 @@ function createHotSpot(hs) {
         span.style.maxWidth = 'initial';
     } else if (hs.URL) {
         a = document.createElement('a');
-        a.href = sanitizeURL(hs.URL);
+        a.href = sanitizeURL(hs.URL, true);
         if (hs.attributes) {
             for (var key in hs.attributes) {
                 a.setAttribute(key, hs.attributes[key]);
@@ -2012,7 +2012,7 @@ function processOptions(isPreview) {
                 var authorText = escapeHTML(config[key]);
                 if (config.authorURL) {
                     var authorLink = document.createElement('a');
-                    authorLink.href = sanitizeURL(config['authorURL']);
+                    authorLink.href = sanitizeURL(config['authorURL'], true);
                     authorLink.target = '_blank';
                     authorLink.innerHTML = escapeHTML(config[key]);
                     authorText = authorLink.outerHTML;
@@ -2023,7 +2023,7 @@ function processOptions(isPreview) {
             
             case 'fallback':
                 var link = document.createElement('a');
-                link.href = sanitizeURL(config[key]);
+                link.href = sanitizeURL(config[key], true);
                 link.target = '_blank';
                 link.textContent = 'Click here to view this panorama in an alternative viewer.';
                 var message = document.createElement('p');
@@ -2389,10 +2389,17 @@ function escapeHTML(s) {
  * The URL cannot be of protocol 'javascript'.
  * @private
  * @param {string} url - URL to sanitize
+ * @param {boolean} href - True if URL is for link (blocks data URIs)
  * @returns {string} Sanitized URL
  */
-function sanitizeURL(url) {
-    if (url.trim().toLowerCase().indexOf('javascript:') === 0) {
+function sanitizeURL(url, href) {
+    if (url.trim().toLowerCase().indexOf('javascript:') === 0 ||
+        url.trim().toLowerCase().indexOf('vbscript:') === 0) {
+        console.log('Script URL removed.');
+        return 'about:blank';
+    }
+    if (href && url.trim().toLowerCase().indexOf('data:') === 0) {
+        console.log('Data URI removed from link.');
         return 'about:blank';
     }
     return url;","Merge pull request from GHSA-m52x-29pq-w3vv

Fix potential XSS vulnerability","vuln-fix: Restrict unsafe URL schemes in link sanitization

The URL sanitization function did not block dangerous schemes like ""vbscript:"" and allowed data URIs in hyperlink href attributes, enabling script injection via crafted URLs.
This posed a security risk by permitting attackers to execute arbitrary scripts or embed malicious content through manipulated links, leading to cross-site scripting (XSS) attacks.
The fix extends sanitization to reject ""vbscript:"" schemes and disallow data URIs in href contexts, replacing unsafe URLs with safe placeholders to prevent script execution.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.23529411764705882,"[('ghsa-m52x-29pq', 'VULNID', 'GHSA'), ('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('manipulated', 'ACTION', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('unsafe', 'secword', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,CWE-79,GHSA-xg72-6c83-ghh4,"@@ -563,17 +563,25 @@
                 }
 
             } else if ($ext === 'svg') {
-
+                $valid = false;
                 if (is_file($filePath)) {
                     $sanitizer = new \enshrined\svgSanitize\Sanitizer();
                     // Load the dirty svg
                     $dirtySVG = file_get_contents($filePath);
                      // Pass it to the sanitizer and get it back clean
-                    $cleanSVG = $sanitizer->sanitize($dirtySVG);
-                    file_put_contents($filePath, $cleanSVG);
+                    try {
+                        $cleanSVG = $sanitizer->sanitize($dirtySVG);
+                        $valid = true;
+                    } catch (\Exception $e) {
+                        $valid = false;
+                    }
+
+                    if ($valid) {
+                        file_put_contents($filePath, $cleanSVG);
+                    }
 
                 }
-               $valid = true;
+
 
             } else {
                 $valid = false;",update,"vuln-fix: Handle SVG sanitization errors to prevent unsafe file writes

The SVG sanitization process did not handle exceptions, causing potentially unsafe or unclean SVG content to be written to files when sanitization failed.
This posed a security risk by allowing malicious SVG files to bypass sanitization, potentially leading to XSS or other injection attacks via crafted SVG content.
The fix adds exception handling around the sanitizer and only writes sanitized SVG content if the process succeeds, preventing unsafe file overwrites.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('errors', 'FLAW', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('unsafe', 'secword', ''), ('sanitization', 'SECWORD', ''), ('security', 'secword', ''), ('malicious', 'secword', ''), ('bypass', 'secword', ''), ('sanitization', 'secword', ''), ('xss', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,CWE-79,GHSA-hc72-vj3g-5g2g,"@@ -11,13 +11,16 @@
 using ZKEACMS.Common.Models;
 using Easy;
 using Microsoft.EntityFrameworkCore;
+using ZKEACMS.Safety;
 
 namespace ZKEACMS.Common.Service
 {
     public class NavigationService : ServiceBase<NavigationEntity, CMSDbContext>, INavigationService
     {
-        public NavigationService(IApplicationContext applicationContext, CMSDbContext dbContext) : base(applicationContext, dbContext)
+        private readonly IHtmlSanitizer _htmlSanitizer;
+        public NavigationService(IApplicationContext applicationContext, CMSDbContext dbContext, IHtmlSanitizer htmlSanitizer) : base(applicationContext, dbContext)
         {
+            _htmlSanitizer = htmlSanitizer;
         }
         public override DbSet<NavigationEntity> CurrentDbSet => DbContext.Navigation;
         public override ServiceResult<NavigationEntity> Add(NavigationEntity item)
@@ -27,8 +30,34 @@ public override ServiceResult<NavigationEntity> Add(NavigationEntity item)
                 item.ParentId = ""#"";
             }
             item.ID = Guid.NewGuid().ToString(""N"");
+            Santize(item);
             return base.Add(item);
         }
+
+        public override ServiceResult<NavigationEntity> AddRange(params NavigationEntity[] items)
+        {
+            foreach (var item in items)
+            {
+                Santize(item);
+            }
+            return base.AddRange(items);
+        }
+
+        public override ServiceResult<NavigationEntity> Update(NavigationEntity item)
+        {
+            Santize(item);
+            return base.Update(item);
+        }
+
+        public override ServiceResult<NavigationEntity> UpdateRange(params NavigationEntity[] items)
+        {
+            foreach (var item in items)
+            {
+                Santize(item);
+            }
+            return base.UpdateRange(items);
+        }
+
         public override void Remove(NavigationEntity item)
         {
             Remove(m => m.ParentId == item.ID);
@@ -73,5 +102,11 @@ public void Move(string id, string parentId, int position, int oldPosition)
             }
             Update(nav);
         }
+
+        private void Santize(NavigationEntity item)
+        {
+            item.Title = _htmlSanitizer.Sanitize(item.Title);
+            item.Html = _htmlSanitizer.Sanitize(item.Html);
+        }
     }
 }
\ No newline at end of file","Sanitize Html

#457","vuln-fix: Sanitize navigation entity inputs to prevent XSS

The NavigationService previously stored user-supplied HTML and titles without sanitization, allowing malicious scripts to be saved and rendered in the application.
This exposed users to cross-site scripting (XSS) attacks, risking session hijacking, data theft, or unauthorized actions through injected scripts.
The fix integrates an HTML sanitizer to clean the Title and Html fields on add and update operations, ensuring stored content is safe before persistence.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.23529411764705882,"[('sanitize', 'secword', ''), ('#457', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitization', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('hijacking', 'SECWORD', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('add', 'ACTION', ''), ('update', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,CWE-79,GHSA-8xqr-4cpm-wx7g,"@@ -10,7 +10,7 @@ export default class ReactSVG extends React.Component {
   static defaultProps = {
     callback: () => {},
     className: null,
-    evalScripts: 'once',
+    evalScripts: 'never',
     style: {},
     wrapperClassName: null
   }",Changed default evalScripts prop to match documentation.,"vuln-fix: Disable script evaluation in ReactSVG component by default

The ReactSVG component allowed script evaluation within SVGs by default, enabling execution of potentially malicious scripts embedded in SVG content.
This posed a security risk by allowing cross-site scripting (XSS) attacks through SVG injection, compromising user data and application integrity.
The fix changes the default evalScripts property to 'never', preventing automatic script execution and mitigating XSS risks.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.058823529411764705,"[('changed', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('injection', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('xss', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,CWE-79,GHSA-h3gg-7wx2-cq3h,"@@ -21,7 +21,8 @@ export default function addStickyControl() {
       if (firstPost) {
         const excerpt = truncate(firstPost.contentPlain(), 175);
 
-        items.add('excerpt', m.trust(excerpt), -100);
+        // Wrapping in <div> because ItemList entries need to be vnodes
+        items.add('excerpt', <div>{excerpt}</div>, -100);
       }
     }
   });",Fix evaluation of post content by m.trust() (#24),"vuln-fix: Prevent XSS by wrapping untrusted excerpt in vnode container

The code inserted raw HTML content directly into the item list using m.trust, allowing unescaped user input to execute scripts in the page context.
This exposed the application to cross-site scripting (XSS) attacks where malicious post content could compromise user sessions or steal data.
The fix wraps the excerpt in a safe virtual DOM <div> element, preventing untrusted content from being interpreted as executable HTML.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('m.trust', 'URL', ''), ('#24', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('untrusted', 'secword', ''), ('m.trust', 'URL', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('steal', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('untrusted', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,CWE-79,GHSA-h6wm-mr85-4h9g,"@@ -287,7 +287,7 @@ private function userAuth()
         }
 
         $this->ipWarning();
-        ToolBox::i18nLog()->warning('login-user-not-found', ['%nick%' => $nick]);
+        ToolBox::i18nLog()->warning('login-user-not-found', ['%nick%' => htmlspecialchars($nick)]);
         return false;
     }","Sanitized username when showing user not found message.
------
Saneado nombre de usuario al mostrar el mensaje de usuario no encontrado.","vuln-fix: Sanitize username in login warning logs

The login warning log included unsanitized usernames, allowing injection of malicious HTML or scripts into log outputs.
This posed a risk of log injection or cross-site scripting attacks if logs were viewed in a web context without proper escaping.
The fix applies htmlspecialchars to the username before logging, ensuring special characters are safely encoded.

Weakness: CWE-117
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('sanitized', 'SECWORD', ''), ('found', 'ACTION', '')]",0.47058823529411764,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('login', 'secword', ''), ('warning', 'FLAW', ''), ('login', 'secword', ''), ('warning', 'FLAW', ''), ('unsanitized', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('escaping', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-117', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,CWE-79,GHSA-pxpf-v376-7xx5,"@@ -101,7 +101,7 @@ Tagify.prototype = {
 
         _s.disabled = input.hasAttribute('disabled')
         _s.readonly = _s.readonly || input.hasAttribute('readonly')
-        _s.placeholder = input.getAttribute('placeholder') || _s.placeholder || """"
+        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || """")
         _s.required = input.hasAttribute('required')
 
         for( let name in _s.classNames )",fixes #989 - fix XSS,"vuln-fix: Escape placeholder attribute to prevent XSS injection

The placeholder attribute was assigned directly from user input without escaping, allowing injection of malicious HTML or scripts into the DOM.
This exposed the application to cross-site scripting (XSS) attacks where attackers could execute arbitrary code in users’ browsers.
The fix applies HTML escaping to the placeholder value before insertion, neutralizing any embedded malicious content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fixes', 'ACTION', ''), ('#989', 'ISSUE', ''), ('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,CWE-79,GHSA-6hjc-m38h-7jhh,"@@ -96,7 +96,7 @@ public function actionSeoFileLink($url, $robots = '', $canonical = '', $inline =
             if (($ext = pathinfo($fileName, PATHINFO_EXTENSION)) !== '') {
                 $ext = strtolower($ext);
             }
-            if ($ext === '' || !in_array($ext, $allowedExtensions, true)) {
+            if ($ext === '' || $ext === 'svg' || !in_array($ext, $allowedExtensions, true)) {
                 throw new ServerErrorHttpException(Craft::t('seomatic', 'File format not allowed.'));
             }
             // Send the file as a stream, so it can exist anywhere",Disallow SVGs,"vuln-fix: Block SVG files to prevent unsafe file handling

The file-serving function allowed SVG files to bypass extension checks, enabling potentially dangerous file formats to be served without restriction.
This posed a security risk as SVG files can contain malicious scripts or code, leading to cross-site scripting or other client-side attacks.
The fix explicitly disallows SVG extensions by adding a direct check, preventing these files from being served and mitigating associated risks.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('security', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adding', 'ACTION', ''), ('preventing', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,CWE-79,GHSA-9g3v-j3cr-6fc6,"@@ -75,6 +75,10 @@ classes: 'table table-responsive table-no-bordered',
                 export: 'fa-download',
                 clearSearch: 'fa-times'
             },
+            exportOptions: {
+                htmlContent: true,
+            },
+
             exportTypes: ['csv', 'excel', 'doc', 'txt','json', 'xml', 'pdf'],
             onLoadSuccess: function () {
                 $('[data-toggle=""tooltip""]').tooltip(); // Needed to attach tooltips after ajax call","Fixes possible XSS on all-file-types export

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Enable HTML content export to prevent data loss in exports

The export functionality previously omitted HTML content, causing loss of formatting and embedded data when exporting table data to various formats.
This risked data integrity and user confusion by producing incomplete or misleading exported documents lacking critical HTML-based information.
The fix enables the export option to include HTML content, ensuring that exported files retain full data fidelity and presentation as seen in the UI.

Weakness: CWE-359
Severity: Low
CVSS: 3.1",0.17647058823529413,"[('fixes', 'ACTION', ''), ('xss', 'secword', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('integrity', 'secword', ''), ('critical', 'SEVERITY', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-359', 'CWEID', ''), ('low', 'SEVERITY', '')]"
29,CWE-79,GHSA-6qcc-whgp-pjj2,"@@ -79,8 +79,8 @@ pimcore.document.pages.settings = Class.create(pimcore.document.settings_abstrac
             var updateSerpPreview = function () {
 
                 var metaPanel = this.layout.getComponent(""metaDataPanel"");
-                var title = metaPanel.getComponent(""title"").getValue();
-                var description = metaPanel.getComponent(""description"").getValue();
+                var title = htmlspecialchars(metaPanel.getComponent(""title"").getValue());
+                var description = htmlspecialchars(metaPanel.getComponent(""description"").getValue());
 
                 var truncate = function( text, n ){
                     if (text.length <= n) { return text; }",escaping fields in SERP preview,"vuln-fix: Sanitize metadata fields to prevent XSS in page settings

The page settings interface did not escape user input for metadata title and description fields before rendering, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in the context of the application and compromise user data.
The fix applies htmlspecialchars encoding to metadata inputs, ensuring special characters are safely escaped before display.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escape', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,CWE-79,GHSA-4fc4-4p5g-6w89,"@@ -50,17 +50,18 @@
 		htmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );
 
 		editor.on( 'toHtml', function( evt ) {
-			var evtData = evt.data,
+			var randomNumber = generateRandomNumber(),
+				evtData = evt.data,
 				data = evtData.dataValue,
 				fixBodyTag;
 
 			// Before we start protecting markup, make sure there are no externally injected
 			// protection keywords.
-			data = removeReservedKeywords( data );
+			data = removeReservedKeywords( data, randomNumber );
 
 			// The source data is already HTML, but we need to clean
 			// it up and apply the filter.
-			data = protectSource( data, editor );
+			data = protectSource( data, editor, randomNumber );
 
 			// Protect content of textareas. (https://dev.ckeditor.com/ticket/9995)
 			// Do this before protecting attributes to avoid breaking:
@@ -70,7 +71,7 @@
 			// Before anything, we must protect the URL attributes as the
 			// browser may changing them when setting the innerHTML later in
 			// the code.
-			data = protectAttributes( data );
+			data = protectAttributes( data, randomNumber );
 
 			// Protect elements than can't be set inside a DIV. E.g. IE removes
 			// style tags from innerHTML. (https://dev.ckeditor.com/ticket/3710)
@@ -90,7 +91,7 @@
 
 			// There are attributes which may execute JavaScript code inside fixBin.
 			// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (https://dev.ckeditor.com/ticket/10)
-			data = protectInsecureAttributes( data );
+			data = protectInsecureAttributes( data, randomNumber );
 
 			var fixBin = evtData.context || editor.editable().getName(),
 				isPre;
@@ -110,7 +111,7 @@
 			data = el.getHtml().substr( 1 );
 
 			// Restore shortly protected attribute names.
-			data = data.replace( new RegExp( 'data-cke-' + CKEDITOR.rnd + '-', 'ig' ), '' );
+			data = data.replace( new RegExp( 'data-cke-' + randomNumber + '-', 'ig' ), '' );
 
 			isPre && ( data = data.replace( /^<pre>|<\/pre>$/gi, '' ) );
 
@@ -838,13 +839,13 @@
 
 	var protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\/?>(?!\s*<\/cke:\1)/gi;
 
-	function protectAttributes( html ) {
+	function protectAttributes( html, randomNumber ) {
 		return html.replace( protectElementRegex, function( element, tag, attributes ) {
 			return '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {
 				// Avoid corrupting the inline event attributes (https://dev.ckeditor.com/ticket/7243).
 				// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (https://dev.ckeditor.com/ticket/5218)
 				if ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )
-					return ' data-cke-saved-' + fullAttr + ' data-cke-' + CKEDITOR.rnd + '-' + fullAttr;
+					return ' data-cke-saved-' + fullAttr + ' data-cke-' + randomNumber + '-' + fullAttr;
 
 				return fullAttr;
 			} ) + '>';
@@ -897,8 +898,8 @@
 	// * opening tags - e.g. `<onfoo`,
 	// * closing tags - e.g. </onfoo> (tested in ""false positive 1""),
 	// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.
-	function protectInsecureAttributes( html ) {
-		return html.replace( /([^a-z0-9<\-])(on\w{3,})(?!>)/gi, '$1data-cke-' + CKEDITOR.rnd + '-$2' );
+	function protectInsecureAttributes( html, randomNumber ) {
+		return html.replace( /([^a-z0-9<\-])(on\w{3,})(?!>)/gi, '$1data-cke-' + randomNumber + '-$2' );
 	}
 
 	function unprotectRealComments( html ) {
@@ -917,11 +918,11 @@
 		} );
 	}
 
-	function protectSource( data, editor ) {
+	function protectSource( data, editor, randomNumber ) {
 		var protectedHtml = [],
 			protectRegexes = editor.config.protectedSource,
 			store = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),
-			tempRegex = /<\!--\{cke_temp(comment)?\}(\d*?)-->/g;
+			tempRegex = new RegExp('<\\!--\\{cke_temp_' + randomNumber + '(comment)?\\}(\\d*?)-->', 'g' );
 
 		var regexes = [
 			// Script tags will also be forced to be protected, otherwise
@@ -940,7 +941,7 @@
 		// Note that we use a different tag for comments, as we need to
 		// transform them when applying filters.
 		data = data.replace( ( /<!--[\s\S]*?-->/g ), function( match ) {
-			return '<!--{cke_tempcomment}' + ( protectedHtml.push( match ) - 1 ) + '-->';
+			return '<!--{cke_temp_' + randomNumber + 'comment}' + ( protectedHtml.push( match ) - 1 ) + '-->';
 		} );
 
 		for ( var i = 0; i < regexes.length; i++ ) {
@@ -951,7 +952,8 @@
 				} );
 
 				// Avoid protecting over protected, e.g. /\{.*?\}/
-				return ( /cke_temp(comment)?/ ).test( match ) ? match : '<!--{cke_temp}' + ( protectedHtml.push( match ) - 1 ) + '-->';
+				return ( tempRegex ).test( match ) ? match : '<!--{cke_temp_' + randomNumber + '}' +
+					( protectedHtml.push( match ) - 1 ) + '-->';
 			} );
 		}
 		data = data.replace( tempRegex, function( $, isComment, id ) {
@@ -1107,6 +1109,16 @@
 			};
 		}
 	} )();
+
+	function generateRandomNumber() {
+		var cryptoApi = window.crypto || window.msCrypto;
+
+		if ( cryptoApi ) {
+			return cryptoApi.getRandomValues( new Uint32Array( 1 ) )[ 0 ];
+		}
+
+		return Math.floor( Math.random() *  9000000000 + 1000000000 );
+	}
 } )();
 
 /**",Code refactoring.,"vuln-fix: Use per-instance random tokens to prevent attribute collision

The HTML protection logic reused a global static token for attribute masking, causing potential collisions and predictable attribute names across instances.
This allowed attackers to craft payloads that could bypass protections by guessing or interfering with the static token, risking cross-site scripting or DOM corruption.
The fix generates a unique random number per instance to namespace protected attributes, preventing collisions and improving the robustness of attribute protection.

Weakness: CWE-330
Severity: Medium
CVSS: 5.0",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('collision', 'SECWORD', ''), ('protection', 'SECWORD', ''), ('collisions', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('protections', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('fix', 'ACTION', ''), ('protected', 'ACTION', ''), ('preventing', 'ACTION', ''), ('collisions', 'SECWORD', ''), ('improving', 'ACTION', ''), ('protection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-330', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,CWE-79,GHSA-fp76-f299-v3hj,"@@ -127,8 +127,7 @@ public function getFile(): bool
         $allowedFolders = ['node_modules', 'vendor', 'Dinamic', 'Core', 'Plugins', 'MyFiles/Public'];
         foreach ($allowedFolders as $folder) {
             if ('/' . $folder === substr($uri, 0, 1 + strlen($folder))) {
-                header('Content-Type: ' . $this->getMime($filePath));
-                readfile($filePath);
+                $this->download($filePath);
                 return true;
             }
         }
@@ -137,14 +136,7 @@ public function getFile(): bool
         $token = filter_input(INPUT_GET, 'myft');
         $fixedFilePath = substr(urldecode($uri), 1);
         if ('/MyFiles/' === substr($uri, 0, 9) && $token && MyFilesToken::validate($fixedFilePath, $token)) {
-            header('Content-Type: ' . $this->getMime($filePath));
-
-            // disable the buffer if enabled
-            if (ob_get_contents()) {
-                ob_end_flush();
-            }
-
-            readfile($filePath);
+            $this->download($filePath);
             return true;
         }
 
@@ -205,6 +197,23 @@ private function deploy()
         }
     }
 
+    private function download(string $filePath)
+    {
+        header('Content-Type: ' . $this->getMime($filePath));
+
+        // disable the buffer if enabled
+        if (ob_get_contents()) {
+            ob_end_flush();
+        }
+
+        // force to download svg files to prevent XSS attacks
+        if (strpos($filePath, '.svg') !== false) {
+            header('Content-Disposition: attachment; filename=""' . basename($filePath) . '""');
+        }
+
+        readfile($filePath);
+    }
+
     /**
      * Return the mime type from given file.
      *","Force to download SVG files to prevent security problems.
------
Forzamos a descargar los archivos SVG para evitar problemas de seguridad.","vuln-fix: Force download of SVG files to prevent XSS attacks

The file serving code did not enforce download disposition for SVG files, allowing them to be rendered inline and potentially execute malicious scripts in users' browsers.
This exposed users to cross-site scripting (XSS) risks by enabling attackers to deliver crafted SVG content that could run arbitrary code when viewed.
The fix centralizes file delivery and adds a content-disposition header to force SVG files to download, mitigating inline script execution.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('prevent', 'ACTION', ''), ('security', 'secword', ''), ('problems', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
32,CWE-79,GHSA-mxvc-fwgx-j778,"@@ -16,7 +16,7 @@
 <div>
     <h1>Error</h1>
     <p>
-        {{ error_message|safe }}
+        {{ error_message }}
     </p>
     <hr>
     <p>","Render error message w/o `safe` filter

The error message shown in the error template does not need to be
rendered using the safe filter, and furthermore opens up an XSS
vulnerability.","vuln-fix: Remove unsafe HTML rendering in error messages

The error display template rendered user-supplied error messages with the 'safe' filter, allowing unescaped HTML content to be injected into the page.
This created a cross-site scripting (XSS) vulnerability where attackers could execute arbitrary scripts in users' browsers by crafting malicious error messages.
The fix removes the 'safe' filter to ensure error messages are properly escaped before rendering, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.23529411764705882,"[('error', 'FLAW', ''), ('safe', 'secword', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('safe', 'secword', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('safe', 'secword', ''), ('unescaped', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('error', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('safe', 'secword', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
33,CWE-79,GHSA-c65v-p733-9796,"@@ -93,15 +93,15 @@ public function transformAsset(Asset $asset)
                     $value = (Gate::allows('superadmin')) ? $decrypted : strtoupper(trans('admin/custom_fields/general.encrypted'));
 
                     $fields_array[$field->name] = [
-                            'field' => $field->convertUnicodeDbSlug(),
-                            'value' => $value,
+                            'field' => e($field->convertUnicodeDbSlug()),
+                            'value' => e($value),
                             'field_format' => $field->format,
                         ];
 
                 } else {
                     $fields_array[$field->name] = [
-                        'field' => $field->convertUnicodeDbSlug(),
-                        'value' => $asset->{$field->convertUnicodeDbSlug()},
+                        'field' => e($field->convertUnicodeDbSlug()),
+                        'value' => e($asset->{$field->convertUnicodeDbSlug()}),
                         'field_format' => $field->format,
                     ];
 
@@ -134,7 +134,7 @@ public function transformAsset(Asset $asset)
                         
                             'id' => $component->id,
                             'pivot_id' => $component->pivot->id,
-                            'name' => $component->name,
+                            'name' => e($component->name),
                             'qty' => $component->pivot->assigned_qty,
                             'price_cost' => $component->purchase_cost,
                             'purchase_total' => $component->purchase_cost * $component->pivot->assigned_qty,","Merge pull request #10315 from snipe/fixes/escape_custom_fields_in_api_response

Escape custom field values in API response","vuln-fix: Escape output to prevent stored XSS in asset transformation

The asset transformation function failed to escape user-controlled data before rendering, allowing malicious input to be stored and later executed in the browser.
This exposed the application to stored cross-site scripting attacks, risking session hijacking, defacement, or unauthorized actions by attackers.
The fix applies proper HTML escaping to all dynamic fields and values before output, ensuring unsafe characters are neutralized.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('#10315', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('escape_custom_fields_in_api_response', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('asset', 'secword', ''), ('asset', 'secword', ''), ('escape', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('hijacking', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
34,CWE-79,GHSA-m8rp-q82r-c5mf,"@@ -91,7 +91,6 @@
             <hr class=""thin"" />
             <div class=""row"">
 
-
                 <?php
                 $iformVr=0;
                 foreach ($form_values_formated as $form_values_row) {
@@ -106,12 +105,12 @@
                             <?php if (!is_array($val1)){ ?>
                                 <div>
                                     <small class=""text-muted""><?php echo str_replace('_', ' ', $key); ?>:</small>
-                                    <p><?php print $val1; ?></p>
+                                    <p><?php print htmlentities($val1); ?></p>
                                 </div>
                             <?php } else { ?>
                                 <small class=""text-muted""><?php echo str_replace('_', ' ', $key); ?>:</small>
                                 <?php foreach ($val1 as $val1_1){ ?>
-                                    <p><?php print $val1_1 . '<br />'; ?></p>
+                                    <p><?php print htmlentities($val1_1) . '<br />'; ?></p>
                                 <?php }?>
                             <?php } ?>
                         <?php } ?>",xss on contact form fix,"vuln-fix: Encode output to prevent cross-site scripting in form display

The form display code directly printed user-submitted values without encoding, allowing injection of malicious HTML or JavaScript into the page.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in victims’ browsers and steal sensitive data or hijack sessions.
The fix applies htmlentities to all printed form values, ensuring special characters are safely encoded and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('xss', 'secword', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('cross-site scripting', 'secword', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('fix', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
35,CWE-79,GHSA-3j58-p785-f27x,"@@ -17,9 +17,6 @@
 class ApiController  extends FrontendController
 {
 
-
-
-
     public function api_html()
     {
         if (!defined('MW_API_HTML_OUTPUT')) {
@@ -609,12 +606,14 @@ public function module()
 
         $request_data = array_merge($_GET, $_POST);
 
-
         // sanitize attributes
         if($request_data){
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
+
+                $v = $antixss->xss_clean($v);
+
                 if(is_string($k)){
                     $k = $antixss->xss_clean($k);
                     if($k){
@@ -623,6 +622,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
+                
             }
             $request_data = $request_data_new;
         }",fix xss on module api call in value parameters,"vuln-fix: Sanitize all request data keys and values to prevent XSS

The API controller previously sanitized only request data keys but failed to sanitize the corresponding values, allowing malicious scripts to be processed and stored.
This exposed the application to cross-site scripting attacks where attackers could inject executable code via unsanitized input values.
The fix applies XSS cleaning to both keys and values of all request parameters, ensuring comprehensive input sanitization before further processing.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('unsanitized', 'SECWORD', ''), ('fix', 'ACTION', ''), ('xss', 'secword', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
36,CWE-79,GHSA-7c82-mp33-r854,"@@ -1,6 +1,128 @@
 (function ($) {
   'use strict';
 
+  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
+
+  var uriAttrs = [
+    'background',
+    'cite',
+    'href',
+    'itemtype',
+    'longdesc',
+    'poster',
+    'src',
+    'xlink:href'
+  ];
+
+  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
+
+  var DefaultWhitelist = {
+    // Global attributes allowed on any supplied element below.
+    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],
+    a: ['target', 'href', 'title', 'rel'],
+    area: [],
+    b: [],
+    br: [],
+    col: [],
+    code: [],
+    div: [],
+    em: [],
+    hr: [],
+    h1: [],
+    h2: [],
+    h3: [],
+    h4: [],
+    h5: [],
+    h6: [],
+    i: [],
+    img: ['src', 'alt', 'title', 'width', 'height'],
+    li: [],
+    ol: [],
+    p: [],
+    pre: [],
+    s: [],
+    small: [],
+    span: [],
+    sub: [],
+    sup: [],
+    strong: [],
+    u: [],
+    ul: []
+  }
+
+  /**
+   * A pattern that recognizes a commonly useful subset of URLs that are safe.
+   *
+   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
+   */
+  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
+
+  /**
+   * A pattern that matches safe data URLs. Only matches image, video and audio types.
+   *
+   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
+   */
+  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;
+
+  function allowedAttribute (attr, allowedAttributeList) {
+    var attrName = attr.nodeName.toLowerCase()
+
+    if ($.inArray(attrName, allowedAttributeList) !== -1) {
+      if ($.inArray(attrName, uriAttrs) !== -1) {
+        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN))
+      }
+
+      return true
+    }
+
+    var regExp = $(allowedAttributeList).filter(function (index, value) {
+      return value instanceof RegExp
+    })
+
+    // Check if a regular expression validates the attribute.
+    for (var i = 0, l = regExp.length; i < l; i++) {
+      if (attrName.match(regExp[i])) {
+        return true
+      }
+    }
+
+    return false
+  }
+
+  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {
+    if (sanitizeFn && typeof sanitizeFn === 'function') {
+      return sanitizeFn(unsafeElements);
+    }
+
+    var whitelistKeys = Object.keys(whiteList);
+
+    for (var i = 0, len = unsafeElements.length; i < len; i++) {
+      var elements = unsafeElements[i].querySelectorAll('*');
+
+      for (var j = 0, len2 = elements.length; j < len2; j++) {
+        var el = elements[j];
+        var elName = el.nodeName.toLowerCase();
+
+        if (whitelistKeys.indexOf(elName) === -1) {
+          el.parentNode.removeChild(el);
+
+          continue;
+        }
+
+        var attributeList = [].slice.call(el.attributes);
+        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
+
+        for (var k = 0, len3 = attributeList.length; k < len3; k++) {
+          var attr = attributeList[k];
+
+          if (!allowedAttribute(attr, whitelistedAttributes)) {
+            el.removeAttribute(attr.nodeName);
+          }
+        }
+      }
+    }
+  }
+
   // Polyfill for browsers with no classList support
   // Remove in v2
   if (!('classList' in document.createElement('_'))) {
@@ -745,7 +867,10 @@
     dropdownAlignRight: false,
     windowPadding: 0,
     virtualScroll: 600,
-    display: false
+    display: false,
+    sanitize: true,
+    sanitizeFn: null,
+    whiteList: DefaultWhitelist
   };
 
   if (version.major === '4') {
@@ -1100,13 +1225,35 @@
                 emptyMenu = menuInner.firstChild.cloneNode(false),
                 marginTop,
                 marginBottom,
-                elements = isVirtual === true ? that.selectpicker.view.visibleElements : that.selectpicker.current.elements;
+                elements = isVirtual === true ? that.selectpicker.view.visibleElements : that.selectpicker.current.elements,
+                toSanitize = [];
 
             // replace the existing UL with an empty one - this is faster than $.empty()
             menuInner.replaceChild(emptyMenu, menuInner.firstChild);
 
             for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {
-              menuFragment.appendChild(elements[i]);
+              var element = elements[i],
+                  elText,
+                  elementData;
+
+              if (that.options.sanitize) {
+                elText = element.lastChild;
+
+                if (elText) {
+                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0].data;
+
+                  if (elementData && elementData.content && !elementData.sanitized) {
+                    toSanitize.push(elText);
+                    elementData.sanitized = true;
+                  }
+                }
+              }
+
+              menuFragment.appendChild(element);
+            }
+
+            if (that.options.sanitize && toSanitize.length) {
+              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);
             }
 
             if (isVirtual === true) {
@@ -1469,7 +1616,8 @@
           multipleSeparator = document.createTextNode(this.options.multipleSeparator),
           titleFragment = elementTemplates.fragment.cloneNode(false),
           showCount,
-          countMax;
+          countMax,
+          hasContent = false;
 
       this.togglePlaceholder();
 
@@ -1506,6 +1654,7 @@
                 titleOptions.text = option.title;
               } else if (thisData.content && that.options.showContent) {
                 titleOptions.optionContent = thisData.content.toString();
+                hasContent = true;
               } else {
                 if (that.options.showIcon) {
                   titleOptions.optionIcon = thisData.icon;
@@ -1554,6 +1703,10 @@
       // strip all HTML tags and trim the result, then unescape any escaped tags
       this.$button[0].title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();
 
+      if (this.options.sanitize && hasContent) {
+        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);
+      }
+
       buttonInner.innerHTML = '';
       buttonInner.appendChild(titleFragment);
 
@@ -2833,8 +2986,16 @@
             options = typeof _option == 'object' && _option;
 
         if (!data) {
-          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
-          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), $this.data().template, options.template);
+          var dataAttributes = $this.data();
+
+          for (var dataAttr in dataAttributes) {
+            if (dataAttributes.hasOwnProperty(dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
+              delete dataAttributes[dataAttr];
+            }
+          }
+
+          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);
+          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);
           $this.data('selectpicker', (data = new Selectpicker(this, config)));
         } else if (options) {
           for (var i in options) {",add sanitize option for data-content (#2199),"vuln-fix: Sanitize HTML input to prevent XSS in selectpicker

The selectpicker component did not properly sanitize HTML content or user-supplied configuration, allowing injection of malicious scripts via unsafe attributes or element content.
This exposed applications to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in users’ browsers and compromise user data or session integrity.
The fix adds a robust HTML sanitizer with a strict whitelist, validates URLs in attributes, and removes disallowed config options to ensure only safe content is rendered.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('#2199', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitize', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('removes', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
37,CWE-79,GHSA-x7r7-wmj8-vv5g,"@@ -8,6 +8,7 @@
 import os
 import re
 from collections import defaultdict
+from urllib.parse import urlparse
 
 from flask import (
     Response,
@@ -170,7 +171,16 @@ def _add_additional_assets(hook):
 def login():
     from flask_login import current_user
 
-    redirect_url = request.args.get(""redirect"", request.script_root + url_for(""index""))
+    default_redirect_url = request.script_root + url_for(""index"")
+    redirect_url = request.args.get(""redirect"", default_redirect_url)
+
+    parsed = urlparse(redirect_url)  # check if redirect url is valid
+    if parsed.scheme != """" or parsed.netloc != """":
+        _logger.warning(
+            f""Got an invalid redirect URL with the login attempt, misconfiguration or attack attempt: {redirect_url}""
+        )
+        redirect_url = default_redirect_url
+
     permissions = sorted(
         filter(
             lambda x: x is not None and isinstance(x, OctoPrintPermission),","🔒️ Sanitize and validate login redirect

Fixes an XSS and an open redirect issue.","vuln-fix: Validate redirect URL to prevent open redirect attacks

The login endpoint accepted arbitrary redirect URLs without validation, allowing attackers to craft URLs that redirect users to malicious external sites.
This posed a security risk by enabling phishing attacks and unauthorized redirection to untrusted domains after login.
The fix parses and validates the redirect URL, rejecting any with a scheme or network location, and defaults to a safe internal URL instead.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.11764705882352941,"[('sanitize', 'secword', ''), ('validate', 'secword', ''), ('login', 'secword', ''), ('fixes', 'ACTION', ''), ('xss', 'SECWORD', ''), ('open redirect', 'SECWORD', ''), ('issue', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('open redirect', 'secword', ''), ('attacks', 'FLAW', ''), ('login', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('phishing', 'secword', ''), ('attacks', 'FLAW', ''), ('untrusted', 'secword', ''), ('login', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
38,CWE-79,GHSA-2cqg-q7jm-j35c,"@@ -910,7 +910,7 @@ public function audit(Request $request) {
             }
         }
 
-        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.$request->input('asset_tag').' not found'));
+        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.e($request->input('asset_tag')).' not found'));","Merge pull request #10286 from uberbrady/fix_bulk_audit_xss

Escape asset_tag attribute at controller level for bulk checkout","vuln-fix: Escape user input in error message to prevent XSS

The error response included raw user input in the message without proper escaping, allowing injection of malicious scripts in JSON responses.
This exposed the application to cross-site scripting (XSS) attacks where attackers could execute arbitrary JavaScript in users’ browsers.
The fix applies escaping to the user-supplied asset tag before including it in the error message, ensuring safe output rendering.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.17647058823529413,"[('#10286', 'ISSUE', ''), ('fix_bulk_audit_xss', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('asset', 'secword', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,CWE-79,GHSA-mg5h-9rhq-4cqx,"@@ -300,6 +300,7 @@ public function isDangerFilename($filename){
 			 $isDangerStr($filename , "".php"")
 			|| $isDangerStr($filename , "".svg"")
 			|| $isDangerStr($filename , "".htm"")
+			|| $isDangerStr($filename , "".shtm"")
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
 		) {",file upload bug,"vuln-fix: Extend dangerous filename check to include .shtm extension

The filename validation function omitted the "".shtm"" extension from its list of dangerous file types, allowing potentially harmful files to bypass security filters.
This omission could enable attackers to upload or execute malicious scripts disguised with the "".shtm"" extension, risking unauthorized code execution or data exposure.
The fix adds "".shtm"" to the dangerous filename checks, ensuring consistent blocking of risky file types and preventing exploitation via this extension.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('code execution', 'SECWORD', ''), ('data exposure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
40,"CWE-89', 'CWE-79",GHSA-x92h-wmg2-6hp7,"@@ -1346,22 +1346,37 @@ public function setMethod($method)
      */
     public function getMethod()
     {
-        if (null === $this->method) {
-            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
-
-            if ('POST' === $this->method) {
-                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {
-                    $this->method = strtoupper($method);
-                } elseif (self::$httpMethodParameterOverride) {
-                    $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
-                    if (\is_string($method)) {
-                        $this->method = strtoupper($method);
-                    }
-                }
-            }
+        if (null !== $this->method) {
+            return $this->method;
+        }
+
+        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
+
+        if ('POST' !== $this->method) {
+            return $this->method;
+        }
+
+        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');
+
+        if (!$method && self::$httpMethodParameterOverride) {
+            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
+        }
+
+        if (!\is_string($method)) {
+            return $this->method;
+        }
+
+        $method = strtoupper($method);
+
+        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
+            return $this->method = $method;
+        }
+
+        if (!preg_match('/^[A-Z]++$/D', $method)) {
+            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
         }
 
-        return $this->method;
+        return $this->method = $method;
     }
 
     /**",[HttpFoundation] reject invalid method override,"vuln-fix: Validate HTTP method override to prevent injection

The HTTP method override feature accepted arbitrary strings without strict validation, allowing attackers to inject invalid or malicious HTTP methods.
This posed a security risk by enabling crafted requests that could bypass routing logic or trigger unexpected server behavior.
The fix enforces a whitelist of allowed HTTP methods and rejects invalid overrides with an exception, ensuring only valid methods are accepted.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('bypass', 'secword', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
41,CWE-79,GHSA-54qq-9chj-rxhv,"@@ -12,7 +12,7 @@
 
 ?>
 <li class=""nav-item dropleft"">
-    <a href=""#"" class=""nav-link dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false""><?php echo htmlspecialchars($UserData->name),' ',htmlspecialchars($UserData->surname)?></a>
+    <a href=""#"" class=""nav-link dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"" ng-non-bindable><?php echo htmlspecialchars($UserData->name),' ',htmlspecialchars($UserData->surname)?></a>
     <div class=""dropdown-menu"" style=""min-width: 25rem;"" role=""menu"">
 
         <div class=""row"">",Escape in user box,"vuln-fix: Prevent XSS by disabling AngularJS binding in user name display

The user name and surname were output inside an AngularJS-enabled element without disabling binding, allowing injection of malicious AngularJS expressions.
This exposed the application to cross-site scripting attacks where attackers could execute arbitrary scripts in users’ browsers via crafted names.
The fix adds the ng-non-bindable attribute to disable AngularJS interpolation and prevent execution of injected expressions in the user name display.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('user name', 'secword', ''), ('user name', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('prevent', 'ACTION', ''), ('user name', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
42,CWE-79,GHSA-mrvj-7q4f-5p42,"@@ -89,6 +89,16 @@ parameters:
         - pht
         - phtml
         - pgif
+        - hta
+        - htm
+        - html
+        - xhtm
+        - xhtml
+        - jar
+        - js
+        - jse
+        - svg
+        - swf
 
     # Content settings
     ezsettings.default.content.view_cache: true         # Whether to use content view cache or not (Etag/Last-Modified based)","Merge pull request from GHSA-mrvj-7q4f-5p42

Co-authored-by: Gunnstein Lye <gunnstein.lye@ibexa.co>","vuln-fix: Expand allowed file extensions to prevent unsafe content execution

The application previously restricted certain file extensions, potentially allowing unsafe or executable content to be served without proper handling.
This posed a security risk by enabling attackers to upload or serve malicious files that could execute scripts or active content in users’ browsers.
The fix adds additional safe and commonly used extensions to the allowed list, reducing the chance of serving dangerous file types inadvertently.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.17647058823529413,"[('ghsa', 'VULNID', 'GHSA'), ('gunnstein.lye@ibexa.co', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
43,CWE-79,GHSA-jq4v-f5q6-mjqq,"@@ -23,6 +23,8 @@
     'usemap',
     # Not standard:
     'dynsrc', 'lowsrc',
+    # HTML5 formaction
+    'formaction'
     ])
 
 # Not in the HTML 4 spec:",Add formaction attribute to defs.link_attrs,"vuln-fix: Add formaction attribute to allowed URL attributes whitelist

The sanitizer omitted the HTML5 'formaction' attribute from its list of URL attributes, allowing potentially unsafe URLs to bypass filtering.
This omission could enable attackers to inject malicious form submission targets, leading to phishing or cross-site request forgery attacks.
The fix adds 'formaction' to the whitelist, ensuring proper sanitization and blocking of unsafe URLs in form actions.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.11764705882352941,"[('add', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('sanitizer', 'secword', ''), ('unsafe', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('phishing', 'secword', ''), ('cross-site request forgery', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('sanitization', 'secword', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
44,CWE-79,GHSA-8x44-pwr2-rgc6,"@@ -119,7 +119,7 @@ public function getTreeAction(Request $request)
                 'id' => $class->getId(),
                 'text' => $text,
                 'leaf' => true,
-                'icon' => $class->getIcon() ? $class->getIcon() : $defaultIcon,
+                'icon' => $class->getIcon() ? htmlspecialchars($class->getIcon()) : $defaultIcon,
                 'cls' => 'pimcore_class_icon',
                 'propertyVisibility' => $class->getPropertyVisibility(),
                 'enableGridLocking' => $class->isEnableGridLocking(),",added escape function to the icon field,"vuln-fix: Sanitize icon field to prevent XSS in tree view

The icon field in the tree view was output without escaping, allowing injection of malicious HTML or JavaScript code via crafted icon values.
This exposed users to cross-site scripting (XSS) attacks, potentially leading to session hijacking or unauthorized actions within the application.
The fix applies htmlspecialchars to the icon value, ensuring special characters are escaped and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('added', 'ACTION', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
45,CWE-79,GHSA-3j9m-hcv9-rpj8,"@@ -1,6 +1,6 @@
 import React from 'react';
 import { css } from '@emotion/css';
-import { GrafanaTheme2 } from '@grafana/data';
+import { GrafanaTheme2, textUtil } from '@grafana/data';
 import { Icon, IconName, Link, useTheme2 } from '@grafana/ui';
 
 export interface Props {
@@ -29,13 +29,15 @@ const DropdownChild = ({ isDivider = false, icon, onClick, target, text, url }:
     </button>
   );
   if (url) {
+    const sanitizedUrl = textUtil.sanitizeAngularInterpolation(url);
+
     element =
       !target && url.startsWith('/') ? (
-        <Link className={styles.element} onClick={onClick} href={url}>
+        <Link className={styles.element} onClick={onClick} href={sanitizedUrl}>
           {linkContent}
         </Link>
       ) : (
-        <a className={styles.element} href={url} target={target} rel=""noopener"" onClick={onClick}>
+        <a className={styles.element} href={sanitizedUrl} target={target} rel=""noopener"" onClick={onClick}>
           {linkContent}
         </a>
       );","Merge pull request #147 from grafana/axelav/sanitized-nav-links-8-2-3

Sanitized NavBar children links to remove angular interpolation v8.2.3","vuln-fix: Sanitize URLs to prevent AngularJS expression injection

The dropdown component failed to sanitize URLs containing AngularJS interpolation syntax, allowing injection of malicious expressions in link href attributes.
This posed a security risk by enabling attackers to execute arbitrary AngularJS code in the application context, leading to cross-site scripting (XSS) attacks.
The fix applies textUtil.sanitizeAngularInterpolation to URLs before rendering, neutralizing dangerous AngularJS expressions and preventing code injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.17647058823529413,"[('#147', 'ISSUE', ''), ('sanitized', 'SECWORD', ''), ('sanitized', 'SECWORD', ''), ('remove', 'ACTION', ''), ('v8.2.3', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('sanitize', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('textutil.sanitizeangularinterpolation', 'URL', ''), ('preventing', 'ACTION', ''), ('code injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
46,CWE-79,GHSA-wg4r-q74r-p7c8,"@@ -305,6 +305,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".xml"")
 			|| $isDangerStr($filename , "".xxhtml"")
 			|| $isDangerStr($filename , "".asp"")			
+			|| $isDangerStr($filename , "".xsl"")
 		) {
 			return true;
 		}","Merge pull request #1630 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Extend dangerous filename check to include .xsl files

The filename validation function did not consider .xsl files as dangerous, allowing potentially unsafe XML stylesheet files to bypass security checks.
This omission could enable attackers to upload or process malicious .xsl files, leading to XML external entity (XXE) attacks or unauthorized code execution.
The fix adds .xsl to the list of disallowed extensions, strengthening input validation against risky file types.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.23529411764705882,"[('#1630', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'secword', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'secword', ''), ('attacks', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
47,CWE-79,GHSA-4p92-fv6v-fhfj,"similarity index 100%
rename from .github/workflows/templates.yml.backup
rename to .github/workflows/templates.yml",update,"vuln-fix: Remove backup file from GitHub workflows directory

The repository contained a backup copy of a GitHub Actions workflow file, potentially exposing sensitive workflow configurations or secrets unintentionally.
This posed a security risk by leaking internal CI/CD pipeline details that attackers could exploit to compromise build or deployment processes.
The fix removes the backup file from the workflows directory to prevent accidental exposure of sensitive automation configurations.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
48,CWE-79,GHSA-mq35-wqvf-r23c,"@@ -78,7 +78,7 @@ def unlink?
     def params
       super
     rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
-      raise BadRequest, ""Invalid query parameters: #{e.message}""
+      raise BadRequest, ""Invalid query parameters: #{Rack::Utils.escape_html(e.message)}""
     end
 
     private","escape invalid query params, fixes #1428","vuln-fix: Escape error messages to prevent XSS in query parameter errors

The application raised exceptions with unsanitized error messages directly included in HTTP responses when query parameter parsing failed.
This allowed attackers to inject malicious HTML or JavaScript via crafted query parameters, leading to cross-site scripting (XSS) attacks.
The fix escapes error message content using HTML escaping before including it in the response, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('escape', 'secword', ''), ('fixes', 'ACTION', ''), ('#1428', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('errors', 'FLAW', ''), ('unsanitized', 'SECWORD', ''), ('error', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escapes', 'SECWORD', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
49,CWE-79,GHSA-p885-prv3-m4xv,"@@ -30,11 +30,11 @@ public function requestedAssets()
             // Make sure the asset and request still exist
             if ($checkoutRequest && $checkoutRequest->itemRequested()) {
                 $results['rows'][] = [
-                    'image' => $checkoutRequest->itemRequested()->present()->getImageUrl(),
-                    'name' => $checkoutRequest->itemRequested()->present()->name(),
-                    'type' => $checkoutRequest->itemType(),
-                    'qty' => $checkoutRequest->quantity,
-                    'location' => ($checkoutRequest->location()) ? $checkoutRequest->location()->name : null,
+                    'image' => e($checkoutRequest->itemRequested()->present()->getImageUrl()),
+                    'name' => e($checkoutRequest->itemRequested()->present()->name()),
+                    'type' => e($checkoutRequest->itemType()),
+                    'qty' => (int) $checkoutRequest->quantity,
+                    'location' => ($checkoutRequest->location()) ? e($checkoutRequest->location()->name) : null,
                     'expected_checkin' => Helper::getFormattedDateObject($checkoutRequest->itemRequested()->expected_checkin, 'datetime'),
                     'request_date' => Helper::getFormattedDateObject($checkoutRequest->created_at, 'datetime'),
                 ];","Merge pull request #10942 from snipe/fixes/xss_user_requested

Fixes potential XSS vuln in user requestable results","vuln-fix: Escape output to prevent XSS in asset requests

The asset request response rendered unescaped user-controllable data fields directly into the output, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and hijack sessions or steal data.
The fix applies proper escaping to all output fields and casts quantities to integers, ensuring safe rendering of dynamic content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('#10942', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('xss_user_requested', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('asset', 'secword', ''), ('asset', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('steal', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
50,CWE-79,GHSA-7vvq-7r29-5vg3,"@@ -498,7 +498,7 @@ <h1><a href=""https://threejs.org"">three.js</a></h1>
 			const oldIframe = iframe;
 			iframe = oldIframe.cloneNode();
 
-			if ( hash ) {
+			if ( hash && titles[ splitHash[ 0 ] ] ) {
 
 				iframe.src = splitHash[ 0 ] + '.html' + splitHash[ 1 ];
 				subtitle = titles[ splitHash[ 0 ] ] + splitHash[ 1 ] + ' – ';",Only load trusted iframe (#23245),"vuln-fix: Validate hash keys before iframe source assignment

The code assigned iframe sources based on unvalidated hash keys, allowing injection of arbitrary URLs if the hash contained unexpected values.
This posed a security risk by enabling attackers to load malicious or unintended content into iframes, potentially leading to phishing or content spoofing.
The fix adds a check to ensure the hash key exists in the allowed titles list before setting the iframe source, preventing unauthorized URL injection.

Weakness: CWE-601
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('#23245', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('hash', 'secword', ''), ('keys', 'SECWORD', ''), ('hash', 'secword', ''), ('keys', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('hash', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('phishing', 'secword', ''), ('spoofing', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('hash', 'secword', ''), ('key', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
51,CWE-79,GHSA-72p5-2r6g-fm6v,"@@ -559,7 +559,7 @@ COMPONENT('grid', 'filter:true;external:false;fillcount:50;filterlabel:Filtering
 			for (var j = 0, jl = columns.length; j < jl; j++) {
 				var column = columns[j];
 				var val = items[i][column.name];
-				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : (column.format ? val.format(column.format) : val);
+				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : Thelpers.encode((column.format ? val.format(column.format) : val));
 				m.index = j;
 				m.align = column.align;
 				m.background = column.background;",Fixed XSS.,"vuln-fix: Encode grid cell output to prevent XSS injection

The grid component rendered cell values without proper encoding, allowing malicious content to be injected and executed in the browser context.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary scripts by injecting crafted data into grid cells.
The fix applies HTML encoding to formatted cell values, ensuring that any potentially dangerous characters are safely escaped before rendering.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fixed', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'secword', ''), ('encoding', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
52,CWE-79,GHSA-q67f-3jq4-mww2,"@@ -568,10 +568,11 @@ pimcore.element.properties = Class.create({
 
     addSetFromUserDefined: function (customKey, customType) {
         try {
-            if (in_array(customKey.getValue(), this.disallowedKeys)) {
+            let key = htmlspecialchars(customKey.getValue());
+            if (in_array(key, this.disallowedKeys)) {
                 Ext.MessageBox.alert(t(""error""), t(""name_is_not_allowed""));
             }
-            this.add(customKey.getValue(), customType.getValue(), false, false, false, true);
+            this.add(key, customType.getValue(), false, false, false, true);
         } catch (e) {
             console.log(e);
         }",escaping 'key' custom property field in elements,"vuln-fix: Sanitize user-defined keys to prevent injection attacks

User-defined keys were used directly without sanitization, allowing injection of malicious input that could manipulate UI or backend behavior.
This posed a security risk by enabling cross-site scripting or other injection attacks through crafted property names.
The fix applies HTML escaping to user keys before validation and usage, ensuring harmful characters are neutralized.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.11764705882352941,"[('escaping', 'secword', ''), ('key', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('keys', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
53,CWE-79,GHSA-jr37-66pj-36v7,"@@ -82,7 +82,7 @@ public function anyData()
             })
             ->addColumn('view', function ($tasks) {
                 return '<a href=""' . route(""tasks.show"", $tasks->external_id) . '"" class=""btn btn-link"">' . __('View') .'</a>'
-                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-title=""'. $tasks->title . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
+                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
                 ;
             })
             ->rawColumns(['titlelink','view', 'status_id'])",fix xss for tasks index,"vuln-fix: Remove unescaped user input from HTML attributes

The code included user-supplied task titles directly in HTML attributes without escaping, allowing injection of arbitrary HTML or JavaScript.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute malicious scripts in users’ browsers.
The fix removes the unsafe inclusion of task titles in HTML attributes, preventing injection of untrusted content into the DOM.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('unescaped', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('untrusted', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
54,CWE-79,GHSA-9w7h-3wwh-6m5q,"@@ -611,10 +611,15 @@ public function module()
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
-
+                if(is_string($v)) {
+                    $v = str_replace('<', '-', $v);
+                    $v = str_replace('>', '-', $v);
+                }
                 $v = $antixss->xss_clean($v);
 
                 if(is_string($k)){
+                    $k = str_replace('<', '-', $k);
+                    $k = str_replace('>', '-', $k);
                     $k = $antixss->xss_clean($k);
                     if($k){
                         $request_data_new[$k] = $v;
@@ -622,7 +627,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
-                
+
             }
             $request_data = $request_data_new;
         }",update,"vuln-fix: Sanitize angle brackets in request data keys and values

The application failed to sanitize angle bracket characters in both keys and string values of incoming request data, allowing potential injection of HTML or script tags.
This exposed the system to cross-site scripting (XSS) attacks where malicious payloads could be embedded and executed in the client context.
The fix replaces '<' and '>' characters with safe placeholders before applying XSS cleaning, ensuring all input components are properly sanitized.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('keys', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('xss', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
55,CWE-79,GHSA-hj8g-cw8x-2c6m,"@@ -276,7 +276,8 @@ public function string($skip_ajax = false)
 
         // clear request params
         $cleanParam = new HTMLClean();
-        $u1 = $cleanParam->cleanArray($u1);
+        $u1 = $cleanParam->clean($u1);
+
 
         return $u1;
     }",Update UrlManager.php,"vuln-fix: Fix improper input sanitization in string processing

The code incorrectly used cleanArray instead of clean for sanitizing input, resulting in incomplete or improper cleaning of user-supplied data.
This flaw allowed attackers to inject malicious content that could bypass sanitization, leading to potential cross-site scripting or data corruption.
The fix replaces cleanArray with the correct clean method to ensure thorough and proper input sanitization before further processing.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.11764705882352941,"[('update', 'ACTION', ''), ('urlmanager.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('incorrectly used', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('sanitization', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
56,"CWE-74', 'CWE-79",GHSA-pxcf-v868-m492,"@@ -19,6 +19,23 @@ app.use((req, res, next) => {
   next();
 });
 
+
+function htmlEscape(text) {
+  return text.replace(/&/g, '&amp;').
+  replace(/</g, '&lt;').
+  replace(/""/g, '&quot;').
+  replace(/'/g, '&#039;');
+}
+
+
+function sanitize(params) {
+  result = {}
+  for (let [key, value] of Object.entries(params)) {
+      result[key] = htmlEscape(value)
+  }
+  return result;
+}
+
 app.get(""/health"", (req, res) => res.sendStatus(200));
 
 const handler = (res, params) => {
@@ -40,12 +57,14 @@ const handler = (res, params) => {
 app.get(""/"", (req, res) => handler(res, req.query));
 app.post(""/"", (req, res) => handler(res, req.body));
 
-app.get(""/dynamic"", (req, res) =>
-  handler(res, { ...req.query, renderToHtml: true })
-);
+app.get(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.query)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
-app.post(""/dynamic"", (req, res) =>
-  handler(res, { ...req.body, renderToHtml: true })
-);
+app.post(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.body)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
 module.exports = http.createServer(app);",fix: escape special characters before insertion to template,"vuln-fix: Sanitize user input to prevent HTML injection

The application failed to escape user-supplied query and body parameters before rendering them as HTML, allowing injection of malicious HTML or scripts.
This vulnerability exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in victims’ browsers and steal sensitive data.
The fix adds a sanitization function that escapes special HTML characters in all user inputs before rendering, preventing injection of executable code.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('sanitization', 'secword', ''), ('escapes', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
57,CWE-79,GHSA-rf66-hmqf-q3fc,"@@ -260,7 +260,18 @@ $(document).ready(function () {
     }
 
     function formatDataSelection (datalist) {
-        return datalist.text;
+        // This a heinous workaround for a known bug in Select2.
+        // Without this, the rich selectlists are vulnerable to XSS.
+        // Many thanks to @uberbrady for this fix. It ain't pretty,
+        // but it resolves the issue until Select2 addresses it on their end.
+        //
+        // Bug was reported in 2016 :{
+        // https://github.com/select2/select2/issues/4587
+
+        return datalist.text.replace(/>/g, '&gt;')
+            .replace(/</g, '&lt;')
+            .replace(/""/g, '&quot;')
+            .replace(/'/g, '&#039;');
     }
 
     // This handles the radio button selectors for the checkout-to-foo options",Janky fix for Select2 bug,"vuln-fix: Sanitize Select2 datalist text to prevent XSS

The Select2 component rendered datalist text without escaping HTML special characters, allowing injection of malicious scripts via crafted input.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in the context of the affected web page.
The fix applies explicit character escaping to the datalist text, converting special characters to HTML entities to neutralize script injection vectors.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
58,CWE-79,GHSA-hxmr-5gv9-6p8v,"@@ -45,9 +45,9 @@
             $snmpver = 'v2c';
             $additional = [
                 'snmp_disable' => 1,
-                'os'           => $_POST['os'] ? $_POST['os_id'] : 'ping',
-                'hardware'     => $_POST['hardware'],
-                'sysName'      => $_POST['sysName'],
+                'os'           => $_POST['os'] ? strip_tags($_POST['os_id']) : 'ping',
+                'hardware'     => strip_tags($_POST['hardware']),
+                'sysName'      => strip_tags($_POST['sysName']),
             ];
         } elseif ($_POST['snmpver'] === 'v2c' || $_POST['snmpver'] === 'v1') {
             if ($_POST['community']) {","XSS fix, cont. (#13776)

https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/","vuln-fix: Sanitize SNMP device input fields to prevent XSS

The SNMP device creation code failed to sanitize user-supplied input fields before storing them, allowing injection of malicious HTML or script content.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in users’ browsers and compromise session integrity.
The fix applies strip_tags to relevant POST parameters, removing HTML tags and preventing injection of executable code.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.23529411764705882,"[('xss', 'secword', ''), ('fix', 'ACTION', ''), ('#13776', 'ISSUE', ''), ('https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('sanitize', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
59,CWE-79,GHSA-mxh3-2699-98g9,"@@ -861,7 +861,7 @@ public function fieldcollectionTreeAction(Request $request, EventDispatcherInter
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,
@@ -1266,7 +1266,7 @@ public function objectbrickTreeAction(Request $request, EventDispatcherInterface
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,",[Admin] DataObject - Escape class definitions group properly,"vuln-fix: Escape group names to prevent XSS in tree views

The application rendered group names directly into HTML without escaping, allowing injection of malicious scripts via crafted group identifiers.
This exposed users to cross-site scripting attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and compromise user sessions.
The fix applies htmlspecialchars to group names before output, ensuring special characters are safely encoded and preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.058823529411764705,"[('admin', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
60,CWE-79,GHSA-5jgj-h9wp-53fr,"@@ -285,6 +285,20 @@ public static function isImage($file_path)
             return false;
         }
 
+        /**
+         * Detects whether the file contains PHP or script tags, eg to check for embedded code in GIFs
+         * @param $file_path
+         * @return bool
+         */
+        public static function isFileFreeFromScriptTags($file_path)
+        {
+            if ($contents = file_get_contents($file_path)) {
+                if (stripos($contents, '<script') || strpos($contents, '<?')) return false;
+                return true;
+            }
+            return false;
+        }
+
         /**
          * Retrieve a file by ID
          *",Checking for script tags in GIFs etc (#3017),"vuln-fix: Detect and block files with embedded script tags

The file handling code did not check for embedded PHP or script tags within uploaded files, allowing malicious code to be hidden inside image or other file types.
This posed a security risk by enabling attackers to upload files containing executable code, potentially leading to remote code execution or cross-site scripting.
The fix adds a function that scans file contents for script or PHP tags and rejects files containing such embedded code before further processing.

Weakness: CWE-94
Severity: High
CVSS: 8.6",0.11764705882352941,"[('#3017', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('malicious code', 'secword', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('remote code execution', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-94', 'CWEID', ''), ('high', 'SEVERITY', '')]"
61,CWE-79,GHSA-cg3h-rc9q-g8v9,"@@ -36,7 +36,7 @@ pimcore.settings.website = Class.create({
                 border:false,
                 layout:""fit"",
                 closable:true,
-                items:[this.getRowEditor()]
+                items:[this.getRowEditor()],
             });
 
             var tabPanel = Ext.getCmp(""pimcore_panel_tabs"");
@@ -133,6 +133,7 @@ pimcore.settings.website = Class.create({
                 dataIndex: 'data',
                 flex: 300,
                 editable: true,
+                editor: new Ext.form.TextField({}),
                 renderer: this.getCellRenderer.bind(this),
             },
             {text: t(""site""), flex: 100, sortable:true, dataIndex: ""siteId"",
@@ -303,7 +304,10 @@ pimcore.settings.website = Class.create({
             bodyCls: ""pimcore_editable_grid"",
             stripeRows:true,
             columns : {
-                items: typesColumns
+                items: typesColumns,
+                defaults: {
+                    renderer: Ext.util.Format.htmlEncode
+                },
             },
             sm:  Ext.create('Ext.selection.RowModel', {}),
             bbar:this.pagingtoolbar,
@@ -359,15 +363,23 @@ pimcore.settings.website = Class.create({
     },
 
     getCellEditor: function (record) {
-        var data = record.data;
+        let data = record.data;
 
-        var type = data.type;
-        var property;
+        let type = data.type;
+        let property;
 
         if (type === ""text"") {
-            property = Ext.create('Ext.form.TextField');
+            property = {
+                xtype: 'textfield',
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""textarea"") {
-            property = Ext.create('Ext.form.TextArea');
+            property = {
+                xtype: ""textarea"",
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""document"" || type == ""asset"" || type == ""object"") {
             property = {
                 xtype: 'textfield',",[Admin] Website Settings - Escape grid values properly,"vuln-fix: Prevent XSS by enforcing HTML encoding in grid cells

The editable grid component rendered user-supplied data without proper HTML encoding, allowing injection of malicious scripts into the UI.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in the context of the application.
The fix adds default HTML encoding to all grid cell renderers and ensures editors use safe ExtJS form fields, preventing script injection via grid inputs.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('admin', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensures', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
62,CWE-79,GHSA-73q9-7pwj-gm46,"@@ -150,7 +150,7 @@
             ?>
             <h2><?php echo $t['multi-user']; ?></h2>
             <span class=""heading""><?php echo $t['Username']; ?></span><br>
-            <?php echo $_SESSION['username'];?><br><br>
+            <?php echo xssClean($_SESSION['username'], ""html"");?><br><br>
             <?php
         }
         ?>",rXSS cleaned username in editor info display,"vuln-fix: Sanitize session username output to prevent XSS

The code directly echoed the session username without sanitization, allowing stored or reflected cross-site scripting attacks if the username contained malicious HTML or scripts.
This posed a security risk by enabling attackers to execute arbitrary JavaScript in users’ browsers, potentially stealing credentials or performing actions on their behalf.
The fix applies an HTML context-specific sanitization function to the username before output, ensuring unsafe characters are properly escaped.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.11764705882352941,"[('rxss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'secword', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
63,CWE-79,GHSA-fc38-mxwr-pfhx,"@@ -36,7 +36,7 @@ DirectoryIndex index.php
 </IfModule>
 
 <IfModule mod_headers.c>
-    <FilesMatch ""\.svg$"">
+    <FilesMatch ""\.(?i:svg)$"">
         Header set Content-Security-Policy ""script-src 'none'""
     </FilesMatch>
 </IfModule>",NEXT-15677 - Fix XSS for SVG files,"vuln-fix: Enforce case-insensitive SVG content security policy

The Content-Security-Policy header for SVG files was applied only to lowercase "".svg"" extensions, missing uppercase or mixed-case variants.
This allowed attackers to bypass script restrictions by uploading SVG files with uppercase extensions, potentially enabling script execution and cross-site scripting attacks.
The fix updates the file matching pattern to be case-insensitive, ensuring the policy applies to all SVG files regardless of extension casing.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('content security policy', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
64,CWE-79,GHSA-2v5j-q74q-r53f,"@@ -56,7 +56,7 @@ def get_markdown(text):
     if not text:
         return """"
 
-    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\[\s\S\]]*?)\)'
+    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\s\S]*?)\)'
     # Regex check
     if re.match(pattern, text):
         # get get value of group regex",Update pattern,"vuln-fix: Correct regex to prevent excessive backtracking in markdown parser

The markdown parser used a regular expression with overly broad character classes that could cause catastrophic backtracking on crafted input.
This vulnerability allowed attackers to trigger Regular Expression Denial of Service (ReDoS), potentially exhausting server resources and causing service outages.
The fix narrows the regex character class to exclude problematic characters, reducing backtracking and improving input processing efficiency.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('server', 'SECWORD', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
65,CWE-79,GHSA-rfw2-x9f8-2f6m,"@@ -579,11 +579,11 @@ var oncall = {
               },
               footer: function(resp){
                 if (teamsCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams »</a></div>';
                 }
               },
               empty: function(resp){
-                return '<h4> No results found for ""' + resp.query + '"" </h4>';
+                return '<h4> No results found for ""' + Handlebars.escapeExpression(resp.query) + '"" </h4>';
               }
             }
           },
@@ -604,7 +604,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (servicesCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/services"" data-navigo> See all ' + servicesCt + ' results for services »</a></div>';
                 }
               }
             }
@@ -626,7 +626,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (usersCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/users"" data-navigo> See all ' + usersCt + ' results for users »</a></div>';
                 }
               }
             }","prevent potential XSS from searchbar results (#342)

* prevent potential XSS from searchbar results

* use built in handlebars expression escaping

* use handlebars encodeURIComponent","vuln-fix: Escape user input in search result links to prevent XSS

The application directly embedded user-supplied query strings into HTML without proper escaping, allowing injection of malicious scripts in search result links and messages.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and steal sensitive data or perform actions on their behalf.
The fix applies Handlebars escaping and URL encoding to all user input before insertion into HTML, ensuring safe rendering and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('#342', 'ISSUE', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('encodeuricomponent', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
66,CWE-79,GHSA-jff5-55xj-4jcq,"@@ -2168,6 +2168,7 @@ function createSearchBox(searchURL) {
     var ac = new YAHOO.widget.AutoComplete(""search-box"",""search-box-completion"",ds);
     ac.typeAhead = false;
     ac.autoHighlight = false;
+    ac.formatResult = ac.formatEscapedResult;
 
     var box   = $(""search-box"");
     var sizer = $(""search-box-sizer"");","Merge pull request #98 from jenkinsci-cert/SECURITY-388

[SECURITY-388] Escape metacharacters in the search box","vuln-fix: Escape autocomplete results to prevent XSS

The autocomplete widget did not escape user-supplied search suggestions before rendering them in the dropdown list.
This allowed attackers to inject malicious scripts that could execute in users’ browsers, leading to cross-site scripting attacks.
The fix sets the autocomplete’s formatResult function to an escaping variant, ensuring all results are properly sanitized before display.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('#98', 'ISSUE', ''), ('security-388', 'SECWORD', ''), ('security-388', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
67,CWE-79,GHSA-wvh5-78h5-gmgr,"@@ -168,7 +168,7 @@ public function render_assign_user_summary(\assign_user_summary $summary) {
             $fullname = fullname($summary->user, $summary->viewfullnames);
             $extrainfo = array();
             foreach ($summary->extrauserfields as $extrafield) {
-                $extrainfo[] = $summary->user->$extrafield;
+                $extrainfo[] = s($summary->user->$extrafield);
             }
             if (count($extrainfo)) {
                 $fullname .= ' (' . implode(', ', $extrainfo) . ')';",MDL-74204 mod_assign: escape identity fields in allocate marker form.,"vuln-fix: Sanitize user extra fields in assignment summary rendering

The code rendered user extra fields without escaping, allowing injection of malicious HTML or scripts into the assignment summary display.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in other users’ browsers.
The fix applies proper escaping to all extra user fields before rendering, preventing injection of unsafe content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
68,CWE-79,GHSA-98gj-wwxm-cj3h,"@@ -11,7 +11,7 @@
 import re
 import inspect
 
-__version__ = '0.8'
+__version__ = '0.8.1'
 __author__ = 'Hsiaoming Yang <me@lepture.com>'
 __all__ = [
     'BlockGrammar', 'BlockLexer',
@@ -48,7 +48,8 @@ def _pure_pattern(regex):
 
 
 def _keyify(key):
-    return _key_pattern.sub(' ', key.lower())
+    key = escape(key.lower(), quote=True)
+    return _key_pattern.sub(' ', key)
 
 
 def escape(text, quote=False, smart_amp=True):
@@ -445,7 +446,8 @@ class InlineGrammar(object):
     inline_html = re.compile(
         r'^(?:%s|%s|%s)' % (
             r'<!--[\s\S]*?-->',
-            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (_valid_end, _valid_attr),
+            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (
+                _valid_end, _valid_attr),
             r'<\w+%s(?:%s)*?\s*\/?>' % (_valid_end, _valid_attr),
         )
     )",Fix CVE-2017-16876,"vuln-fix: Escape keys to prevent regex injection in key normalization

The key normalization function failed to escape user-supplied keys before inserting them into a regular expression pattern, allowing crafted input to manipulate regex behavior.
This flaw could enable attackers to perform regular expression injection, causing denial of service or unexpected matching results by exploiting regex metacharacters.
The fix applies proper escaping to keys before regex substitution, ensuring that special characters are treated literally and preventing injection attacks.

Weakness: CWE-117
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('fix', 'ACTION', ''), ('cve-2017-16876', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('key', 'secword', ''), ('key', 'secword', ''), ('escape', 'secword', ''), ('keys', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('injection', 'secword', ''), ('denial of service', 'secword', ''), ('exploiting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-117', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
69,CWE-79,GHSA-5ppx-rgw2-xg23,"@@ -712,6 +712,7 @@ var jenkinsRules = {
         };
         ac.prehighlightClassName = ""yui-ac-prehighlight"";
         ac.animSpeed = 0;
+        ac.formatResult = ac.formatEscapedResult;
         ac.useShadow = true;
         ac.autoSnapContainer = true;
         ac.delimChar = e.getAttribute(""autoCompleteDelimChar"");",[SECURITY-641] Escape autocompletion suggestions,"vuln-fix: Escape autocomplete results to prevent XSS

The autocomplete component did not escape user-supplied data before rendering suggestions, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary code in the context of the affected web page.
The fix assigns a safe escaping function to formatResult, ensuring all autocomplete results are properly sanitized before display.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('security-641', 'SECWORD', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escape', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
70,CWE-79,GHSA-gmh3-x5w7-jg5m,"@@ -87,7 +87,7 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
-    $autoSize = xss_clean($autoSize);
+    $autoSize = intval($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
@@ -95,6 +95,16 @@
     }
     $type = xss_clean($type);
 
+            $other = [
+                ';',
+                '\'',
+                '//',
+                '`',
+                '\\',
+
+            ];
+    $type = str_replace($other, '', $type);
+
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
 
@@ -108,6 +118,8 @@
     if ($mod_id != $mod_orig_id) {
         $is_linked_mod = true;
     }
+
+
     ?>
 
     <script type=""text/javascript"">
@@ -124,7 +136,7 @@
         addIcon();
 
         autoSize = <?php  print $autoSize; ?>;
-        settingsType = '<?php print $type; ?>';
+        settingsType = '<?php print htmlentities($type); ?>';
 
         window.onbeforeunload = function () {
             $(document.body).addClass(""mw-external-loading"")",update,"vuln-fix: Sanitize and encode user inputs to prevent XSS

The code previously applied insufficient sanitization on user inputs, allowing special characters to persist and enabling injection of malicious scripts via the 'type' parameter.
This posed a cross-site scripting (XSS) risk where attackers could execute arbitrary JavaScript in users' browsers, compromising session integrity and data confidentiality.
The fix replaces unsafe cleaning with integer casting for numeric input, removes dangerous characters from strings, and applies HTML entity encoding before output to ensure safe rendering.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('sanitization', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('integer casting', 'SECWORD', ''), ('removes', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
71,CWE-79,GHSA-f655-xhvm-cwp4,"@@ -1,4 +1,5 @@
 <?jelly escape-by-default='true'?>
 <j:jelly xmlns:j=""jelly:core"">
-  <span><j:out value=""${it.shortDescription}"" /></span>
+  <!-- SECURITY-2316: This used to show the HTML-formatted it.shortDescription, but that does not properly neutralize user-provided input -->
+  <span>Triggered by GitLab Webhook</span>
 </j:jelly>",[SECURITY-2316],"vuln-fix: Neutralize user input in shortDescription display

The UI template rendered the shortDescription field as HTML without proper sanitization, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in the victim’s browser context.
The fix replaces the vulnerable output with a fixed safe string, eliminating the risk of injecting untrusted HTML content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('security-2316', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('vulnerable', 'SECWORD', ''), ('fixed', 'ACTION', ''), ('safe', 'secword', ''), ('untrusted', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
72,CWE-79,GHSA-fj93-7wm4-8x2g,"@@ -564,6 +564,15 @@ $.widget( ""mobile.pagecontainer"", {
 
 		return $.proxy( function( html, textStatus, xhr ) {
 
+			// Check that Content-Type is ""text/html"" (https://github.com/jquery/jquery-mobile/issues/8640)
+			if ( !/^text\/html\b/.test( xhr.getResponseHeader('Content-Type') ) ) {
+				// Display error message for unsupported content type
+				if ( settings.showLoadMsg ) {
+					this._showError();
+				}
+				return;
+			}
+
 			// Pre-parse html to check for a data-url, use it as the new fileUrl, base path, etc
 			var content,","Check Content-Type header before parsing AJAX response as HTML (#8649)

Fix for issue #8640 (possible XSS vulnerability)","vuln-fix: Validate Content-Type header in AJAX page loads

The AJAX page loading mechanism did not verify the Content-Type header of HTTP responses, allowing non-HTML content to be processed as HTML.
This could lead to script injection or improper content handling, exposing users to cross-site scripting or other content-based attacks.
The fix adds a strict check to ensure only responses with a ""text/html"" Content-Type are processed, rejecting unsupported content types early.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('#8649', 'ISSUE', ''), ('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('#8640', 'ISSUE', ''), ('xss', 'secword', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('injection', 'secword', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
73,CWE-79,GHSA-xjrf-8x4f-43h4,"@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2008 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -21,21 +21,21 @@
  * Escapes based on the JavaScript 1.5 recommendation.
  *
  * <p>Reference:
- * <a href=""http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Guide:Literals#String_Literals"">
- * Core JavaScript 1.5 Guide
- * </a>
+ * <a href=""https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals#String_literals"">
+ * JavaScript Guide</a> on Mozilla Developer Network.
  *
  * @author Juergen Hoeller
  * @author Rob Harrop
+ * @author Rossen Stoyanchev
  * @since 1.1.1
  */
 public class JavaScriptUtils {
 
 	/**
-	 * Turn special characters into escaped characters conforming to JavaScript.
-	 * Handles complete character set defined in HTML 4.01 recommendation.
+	 * Turn JavaScript special characters into escaped characters.
+	 *
 	 * @param input the input string
-	 * @return the escaped string
+	 * @return the string with escaped characters
 	 */
 	public static String javaScriptEscape(String input) {
 		if (input == null) {
@@ -73,6 +73,13 @@ else if (c == '\r') {
 			else if (c == '\f') {
 				filtered.append(""\\f"");
 			}
+			else if (c == '\b') {
+				filtered.append(""\\b"");
+			}
+			// No '\v' in Java, use octal value for VT ascii char
+			else if (c == '\013') {
+				filtered.append(""\\v"");
+			}
 			else {
 				filtered.append(c);
 			}","Add BS and VT char escape sequences to JavaScriptUtils

Issue: SPR-9983","vuln-fix: Escape additional JavaScript control characters in output

The JavaScript escaping utility omitted certain control characters like backspace and vertical tab, leaving them unescaped in output strings.
This allowed injection of unescaped control characters that could break JavaScript syntax or enable injection attacks in contexts relying on proper escaping.
The fix adds explicit escaping for backspace and vertical tab characters, ensuring all special characters are safely encoded in output strings.

Weakness: CWE-79
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('add', 'ACTION', ''), ('escape', 'SECWORD', ''), ('issue', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('escaping', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('injection', 'secword', ''), ('unescaped', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('escaping', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
74,CWE-79,GHSA-4mv4-gmmf-q382,"@@ -1,11 +1,11 @@
-/*! DataTables 1.10.10-dev
+/*! DataTables 1.10.10
  * ©2008-2015 SpryMedia Ltd - datatables.net/license
  */
 
 /**
  * @summary     DataTables
  * @description Paginate, search and order HTML tables
- * @version     1.10.10-dev
+ * @version     1.10.10
  * @file        jquery.dataTables.js
  * @author      SpryMedia Ltd (www.sprymedia.co.uk)
  * @contact     www.sprymedia.co.uk/contact
@@ -170,7 +170,7 @@
 	 *  @type string
 	 *  @default Version number
 	 */
-	DataTable.version = ""1.10.10-dev"";
+	DataTable.version = ""1.10.10"";
 
 	/**
 	 * Private data store, containing all of the settings objects that are",Version - 1.10.10 ready,"vuln-fix: Remove development version identifier from release build

The DataTables library incorrectly included a development version string in its production release, potentially misleading users about the software’s stability and update status.
This could cause confusion or improper version tracking, leading to deployment of unstable code or delayed security patching in production environments.
The fix replaces the development version identifier with the official release version string to accurately reflect the stable release state.

Weakness: CWE-200
Severity: Low
CVSS: 2.1",0.11764705882352941,"[('1.10.10', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('update', 'ACTION', ''), ('security', 'secword', ''), ('patching', 'ACTION', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('low', 'SEVERITY', '')]"
75,CWE-79,GHSA-q3x2-jvp3-wj78,"@@ -1154,11 +1154,11 @@ function get_allowed_files_extensions_for_upload($fileTypes = 'images', $returnA
                 break;
             case 'file':
             case 'files':
-                $are_allowed .= ',doc,docx,pdf,json,rtf,txt,zip,gzip,rar,cad,xml,psd,xlsx,csv,7z';
+                $are_allowed .= ',doc,docx,pdf,json,rtf,txt,zip,gzip,rar,cad,psd,xlsx,csv,7z'; 
                 break;
             case 'documents':
             case 'doc':
-                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xml,xlr,xls,xlsx';
+                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xlr,xls,xlsx';
                 break;
             case 'archives':
             case 'arc':",Update Files.php,"vuln-fix: Remove duplicate file extensions in allowed upload types

The allowed file extensions lists for uploads contained duplicate entries, which could cause inconsistent validation behavior or bypasses in file type checks.
This inconsistency might allow attackers to upload disallowed or malicious files by exploiting gaps in extension filtering logic.
The fix removes redundant duplicate extensions to ensure consistent and reliable file type validation during upload processing.

Weakness: CWE-434
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', ''), ('files.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('bypasses', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('exploiting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
76,CWE-79,GHSA-hhqj-cfjx-vj25,"@@ -368,6 +368,10 @@ <h4 class=""label"">Notes</h4>
 
 				window.addEventListener( 'message', function( event ) {
 
+					if (window.location.origin !== event.origin){
+						return;
+					}
+
 					clearTimeout( connectionTimeout );
 					connectionStatus.style.display = 'none';",Fix DOM XSS,"vuln-fix: Validate origin in postMessage event handler

The event listener for postMessage lacked origin validation, allowing messages from any origin to be processed by the application.
This exposed the application to cross-origin attacks where malicious sites could send crafted messages to manipulate or disrupt client-side behavior.
The fix adds a strict origin check to ensure only messages from the same origin are accepted and processed.

Weakness: CWE-942
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-942', 'CWEID', ''), ('high', 'SEVERITY', '')]"
77,CWE-79,GHSA-h24f-9mm4-w336,"@@ -140,7 +140,9 @@ exports.handleRequest = function(vpath, path, req, res, readOnly, logHeadRequest
 															var name = results[f].name;
 															var normalized = url + '/' + name;
 															while(normalized[0] == '/') { normalized = normalized.slice(1, normalized.length); }
-															res.write('\r\n<p><a href=""/' + normalized + '"">' + name + '</a></p>');
+															if(normalized.indexOf('""') >= 0) throw new Error('unsupported file name')
+															name = name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
+															res.write('\r\n<p><a href=""/' + normalized + '""><span>' + name + '</span></a></p>');
 														}
 														res.end('\r\n</body></html>');
 													}",Fix not sanitizing file names rendered in html,"vuln-fix: Sanitize directory listing output to prevent XSS

The directory listing handler failed to properly sanitize file names before embedding them in HTML links, allowing injection of malicious HTML or script code.
This exposed users to cross-site scripting (XSS) attacks where attackers could execute arbitrary scripts in the context of the affected web page.
The fix adds escaping of special HTML characters in file names and rejects names containing double quotes to prevent injection of unsafe markup.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('sanitizing', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
78,CWE-79,GHSA-jpj5-hg26-6jgc,"@@ -7,6 +7,7 @@ import (
 	""github.com/Xhofe/alist/server/common""
 	""github.com/Xhofe/alist/utils""
 	""github.com/gin-gonic/gin""
+	""net/url""
 	""strings""
 )
 
@@ -24,11 +25,19 @@ func Plist(c *gin.Context) {
 		return
 	}
 	u := string(bytes)
+	uUrl, err := url.Parse(u)
+	if err != nil {
+		common.ErrorResp(c, err, 500)
+		return
+	}
 	name := utils.Base(u)
+	u = uUrl.String()
 	ipaIndex := strings.Index(name, "".ipa"")
 	if ipaIndex != -1 {
 		name = name[:ipaIndex]
 	}
+	name = strings.ReplaceAll(name, ""<"", ""["")
+	name = strings.ReplaceAll(name, "">"", ""]"")
 	plist := fmt.Sprintf(`<?xml version=""1.0"" encoding=""UTF-8""?><!DOCTYPE plist PUBLIC ""-//Apple//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd"">
 <plist version=""1.0"">
     <dict>",:lock: fix #645 xss vulnerability,"vuln-fix: Sanitize and validate URL input in plist generation

The plist handler accepted raw URL input without proper parsing or validation, allowing injection of malicious characters that could break XML structure or cause unexpected behavior.
This posed a security risk by enabling XML injection or malformed plist generation, potentially leading to client crashes or exploitation via crafted URLs.
The fix parses the URL using a standard library, returns errors on invalid input, and replaces dangerous characters to ensure safe and well-formed plist output.

Weakness: CWE-74
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('#645', 'ISSUE', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('validate', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('security', 'SECWORD', ''), ('xml injection', 'secword', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('errors', 'FLAW', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-74', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
79,CWE-79,GHSA-66gw-5xpf-gfp5,"@@ -339,6 +339,7 @@ def wrapper(self, *args, **kwargs):
             message = e.log_message
             self.log.warn(message)
             self.set_status(e.status_code)
+            self.set_header('Content-Type', 'application/json')
             self.finish(json.dumps(dict(message=message)))
         except Exception:
             self.log.error(""Unhandled error in API request"", exc_info=True)
@@ -348,6 +349,7 @@ def wrapper(self, *args, **kwargs):
             self.set_status(status)
             tb_text = ''.join(traceback.format_exception(t, value, tb))
             reply = dict(message=message, traceback=tb_text)
+            self.set_header('Content-Type', 'application/json')
             self.finish(json.dumps(reply))
         else:
             return result",Set content type in json_error to application/json,"vuln-fix: Set explicit JSON content-type on error responses

The API error handler did not set the Content-Type header to application/json when returning JSON-formatted error messages.
This could cause clients to misinterpret the response format, leading to security issues such as improper parsing or injection attacks due to ambiguous content handling.
The fix explicitly sets the Content-Type header to application/json before sending error responses to ensure correct and safe client processing.

Weakness: CWE-16
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('json_error', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('error handler', 'SECWORD', ''), ('error', 'FLAW', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-16', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
80,CWE-79,GHSA-5fh3-25xr-g85h,"@@ -82,7 +82,7 @@ public function transformCheckedoutAccessory ($accessory, $accessory_users, $tot
                 'first_name'=> e($user->first_name),
                 'last_name'=> e($user->last_name),
                 'employee_number' =>  e($user->employee_num),
-                'checkout_notes' => $user->pivot->note,
+                'checkout_notes' => e($user->pivot->note),
                 'last_checkout' => Helper::getFormattedDateObject($user->pivot->created_at, 'datetime'),
                 'type' => 'user',
                 'available_actions' => ['checkin' => true]","Merge pull request #10361 from snipe/fixes/xss_in_accessories_checkout_notes

Escape notes in transformCheckedOutAccessory","vuln-fix: Escape user notes to prevent XSS in accessory checkout

The accessory checkout feature failed to escape user-supplied notes before rendering them in the UI, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and steal sensitive data or hijack sessions.
The fix applies proper escaping to the checkout notes field, ensuring all user input is safely encoded before display.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.17647058823529413,"[('#10361', 'ISSUE', ''), ('fixes', 'ACTION', ''), ('xss_in_accessories_checkout_notes', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escape', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('hijack', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
81,CWE-79,GHSA-xg6r-5gx4-qxjm,"@@ -93,14 +93,15 @@ public function broker()
 
     public function sendResetLinkEmail(ContactPasswordResetRequest $request)
     {
-
-        if(Ninja::isHosted() && $request->session()->has('company_key'))
-            MultiDB::findAndSetDbByCompanyKey($request->session()->get('company_key'));
+        if(Ninja::isHosted() && $request->has('company_key'))
+            MultiDB::findAndSetDbByCompanyKey($request->input('company_key'));
         
         $this->validateEmail($request);
 
-        $company = Company::where('company_key', $request->session()->get('company_key'))->first();
-        $contact = ClientContact::where(['company_id' => $company->id, 'email' => $request->input('email')])->first();
+        // $company = Company::where('company_key', $request->input('company_key'))->first();
+        // $contact = ClientContact::where(['company_id' => $company->id, 'email' => $request->input('email')])->first();
+
+        $contact = ClientContact::where(['email' => $request->input('email')])->first();
 
         $response = false;
 
@@ -117,7 +118,7 @@ public function sendResetLinkEmail(ContactPasswordResetRequest $request)
             return $this->sendResetLinkFailedResponse($request, Password::INVALID_USER);
 
         // We will send the password reset link to this user. Once we have attempted
-        // to send the link, we will examine the response then see the message we
+        // to send the link, we will examine thuser@example.ce response then see the message we
         // need to show to the user. Finally, we'll send out a proper response.
         // $response = $this->broker()->sendResetLink(
         //     $this->credentials($request)",Fixes for client password reset,"vuln-fix: Prevent unauthorized password reset via company key misuse

The password reset function used the company_key from session data, allowing attackers to manipulate session state and reset passwords across companies.
This exposed a risk of unauthorized account access by bypassing tenant isolation and resetting passwords for users in other companies.
The fix switches to using company_key from the request input and removes session-based company scoping, enforcing proper user identification by email only.

Weakness: CWE-639
Severity: High
CVSS: 7.8",0.11764705882352941,"[('fixes', 'ACTION', ''), ('password', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('password', 'SECWORD', ''), ('key', 'SECWORD', ''), ('password', 'SECWORD', ''), ('company_key', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('passwords', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('fix', 'ACTION', ''), ('company_key', 'SECWORD', ''), ('removes', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-639', 'CWEID', ''), ('high', 'SEVERITY', '')]"
82,CWE-79,GHSA-hm45-mgqm-gjm4,"@@ -930,20 +930,20 @@ <h5>{{ data['message'] }}</h5>
             img.attr(""src"", `${img.attr(""data-src-url"")}png`)
         }
     }
+
+    function safe(str) {
+        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+    }
 </script>
 
 {% if data['status'] == 1 and data['data']['status'] == 1 %}
 
-{% if 'aliascc' in data['data']['permslist'] %}
+{% if 'aliascc' in data['data']['permslist'] and false%}
 <script>
     /* ---------------------------------------------------------------------------------------------------------------------
                                                         Aliases group
        --------------------------------------------------------------------------------------------------------------------- */
 
-    function safe(str) {
-        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
-    }
-
     // Alias modal
     $(document).on('click', '.editaliasbutton', function () {
         var command = $(this).parent().parent().data(""command"")
@@ -1186,28 +1186,35 @@ <h5>{{ data['message'] }}</h5>
             } else if (json.status === 1 && json.data.status === 0) {
                 $(""#targetstatus"").html(`{{ _('Failed to fetch targets') }}: ${json.data.message}`)
             } else {
+                let big_ol_dict = {}
                 select.html("""")
 
                 var chopt = [`<optgroup label=""{{ _('Channels') }}"">`]
                 for (let [id, name] of json.data.CHANNELS) {
-                    chopt.push(`<option value=${id}>${name}</option>`)
+                    chopt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 chopt.push(""</optgroup>"")
                 select.append(chopt.join(""""))
 
                 var ropt = [`<optgroup label=""{{ _('Roles') }}"">`]
                 for (let [id, name] of json.data.ROLES) {
-                    ropt.push(`<option value=${id}>${name}</option>`)
+                    ropt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 ropt.push(""</optgroup>"")
                 select.append(ropt.join(""""))
 
                 var uopt = [`<optgroup label=""{{ _('Users') }}"">`]
                 for (let [id, name] of json.data.USERS) {
-                    uopt.push(`<option value=${id}>${name}</option>`)
+                    uopt.push(`<option value=${id} class=""selectpicker-element-${id}"">Loading...</option>`)
+                    big_ol_dict[id] = name
                 }
                 uopt.push(""</optgroup>"")
                 select.append(uopt.join(""""))
+                for (let [id, name] of Object.entries(big_ol_dict)) {
+                    $(`.selectpicker-element-${id}`).text(name)
+                }
             }
             select.selectpicker({ title: ""{{ _('Choose target') }}"" })
             select.removeAttr(""disabled"")
@@ -1299,18 +1306,24 @@ <h5>{{ data['message'] }}</h5>
                 $(""#rulesdiv"").html("""")
                 var overall = ['<h3 style=""margin-bottom: 10px"">{{ _(""Cog rules"") }}</h3>']
                 var allcoglines = [""<ul>""]
+
+                let big_ol_dict_two = {}
+                let cog_counter = 0
+
                 for (let [cog, rules] of Object.entries(json.data.COG)) {
                     var coglines = []
                     for (let rule of rules) {
                         if (rule.type === ""Default"") {
                             coglines.unshift(`<li>{{ _('By default, users are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else if (rule.type === ""Role"") {
-                            coglines.push(`<li>{{ _('Users with the') }} <code>${rule.name}</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('Users with the') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else if (rule.type === ""Channel"") {
-                            coglines.push(`<li>{{ _('Users in the') }} <code>${rule.name}</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('Users in the') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         } else {
-                            coglines.push(`<li>{{ _('User') }} <code>${rule.name}</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
+                            coglines.push(`<li>{{ _('User') }} <code id=""cog-rules-${cog_counter}"">Loading...</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cog}</code> {{ _('cog') }}.</li>`)
                         }
+                        big_ol_dict_two[`cog-rules-${cog_counter}`] = rule.name
+                        cog_counter += 1
                     }
                     if (coglines) {
                         allcoglines = allcoglines.concat(coglines)
@@ -1324,18 +1337,23 @@ <h5>{{ data['message'] }}</h5>
 
                 overall.push('<h3 style=""margin-bottom: 10px"">{{ _(""Command rules"") }}</h3>')
                 var allcmdlines = [""<ul>""]
+
+                let cmd_counter = 0
+
                 for (let [cmd, rules] of Object.entries(json.data.COMMAND)) {
                     var cmdlines = []
                     for (let rule of rules) {
                         if (rule.type === ""Default"") {
                             cmdlines.unshift(`<li>{{ _('By default, users are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else if (rule.type === ""Role"") {
-                            cmdlines.push(`<li>{{ _('Users with the') }} <code>${rule.name}</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('Users with the') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> {{ _('role') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else if (rule.type === ""Channel"") {
-                            cmdlines.push(`<li>{{ _('Users in the') }} <code>${rule.name}</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('Users in the') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> {{ _('channel') }} (${rule.id}) {{ _('are') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         } else {
-                            cmdlines.push(`<li>{{ _('User') }} <code>${rule.name}</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
+                            cmdlines.push(`<li>{{ _('User') }} <code id=""cmd-rules-${cmd_counter}"">Loading...</code> (${rule.id}) {{ _('is') }} ${rule.permission} {{ _('permission to use the') }} <code>${cmd}</code> {{ _('command') }}.</li>`)
                         }
+                        big_ol_dict_two[`cmd-rules-${cmd_counter}`] = rule.name
+                        cmd_counter += 1
                     }
                     if (cmdlines) {
                         allcmdlines = allcmdlines.concat(cmdlines)
@@ -1347,6 +1365,9 @@ <h5>{{ data['message'] }}</h5>
                 }
                 overall = overall.concat(allcmdlines)
                 $(""#rulesdiv"").html(overall.join(""""))
+                for (let [id, name] of Object.entries(big_ol_dict_two)) {
+                    $(`#${id}`).text(name)
+                }
                 $(""#fetchrulesstatus"").html(""{{ _('Refreshed rules') }}."")
             }
         }
@@ -1378,11 +1399,12 @@ <h5>{{ data['message'] }}</h5>
 
     $(document).on('click', '.adminroleoption', function () {
         var elm = $(this)
+        let random_number = Math.floor(Math.random() * Math.floor(100000))
         $(""#adminrolelist"").append(`
                 <li>
                     <div class=""row"">
                         <div class=""col-md-10 col-8"">
-                            <input class=""form-control adminroleinput"" value=""${elm.text()}"" disabled=True data-id=""${elm.attr(""data-id"")}"">
+                            <input class=""form-control adminroleinput"" value=""Loading..."" disabled=True data-id=""${elm.attr(""data-id"")}"" id=""admin-role-${random_number}"">
                         </div>
                         <div class=""col-md-1 col-1"">
                             <span class=""admin-role-x clickable""><i class=""tim-icons icon-simple-remove"" style=""float: right; margin-top: 10px;""></i></span>
@@ -1390,6 +1412,7 @@ <h5>{{ data['message'] }}</h5>
                     </div>
                 </li>
             `)
+        $(`#admin-role-${random_number}`).val(elm.text())
         elm.remove()
     })
 
@@ -1442,11 +1465,12 @@ <h5>{{ data['message'] }}</h5>
 
     $(document).on('click', '.modroleoption', function () {
         var elm = $(this)
+        let random_number = Math.floor(Math.random() * Math.floor(100000))
         $(""#modrolelist"").append(`
                 <li>
                     <div class=""row"">
                         <div class=""col-md-10 col-8"">
-                            <input class=""form-control modroleinput"" value=""${elm.text()}"" disabled=True data-id=""${elm.attr(""data-id"")}"">
+                            <input class=""form-control modroleinput"" value=""Loading..."" disabled=True data-id=""${elm.attr(""data-id"")}"" id=""mod-role-${random_number}"">
                         </div>
                         <div class=""col-md-1 col-1"">
                             <span class=""mod-role-x clickable""><i class=""tim-icons icon-simple-remove"" style=""float: right; margin-top: 10px;""></i></span>
@@ -1454,6 +1478,7 @@ <h5>{{ data['message'] }}</h5>
                     </div>
                 </li>
             `)
+        $(`#mod-role-${random_number}`).val(elm.text())
         elm.remove()
     })",[UI] Fix SelectPicker not rendering properly,"vuln-fix: Prevent XSS by escaping user-supplied HTML content

The code rendered user-supplied strings directly into HTML without proper escaping, allowing injection of malicious scripts and HTML elements.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and steal sensitive data or hijack sessions.
The fix adds a safe function that escapes special HTML characters and updates dynamic content insertion to use this escaping, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('hijack', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('safe', 'secword', ''), ('escapes', 'SECWORD', ''), ('updates', 'ACTION', ''), ('escaping', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
83,CWE-79,GHSA-6hjc-m38h-7jhh,"@@ -15,12 +15,15 @@
 use nystudio107\seomatic\Seomatic;
 
 use Craft;
+use craft\elements\Asset;
 use craft\helpers\FileHelper;
+use craft\helpers\Assets as AssetsHelper;
 use craft\web\Controller;
 
 use yii\web\NotFoundHttpException;
 use yii\web\HttpException;
 use yii\web\Response;
+use yii\web\ServerErrorHttpException;
 
 /**
  * @author    nystudio107
@@ -87,6 +90,15 @@ public function actionSeoFileLink($url, $robots = '', $canonical = '', $inline =
                 $headerValue = '<'.$canonical.'>; rel=""canonical""';
                 $response->headers->add('Link', $headerValue);
             }
+            // Ensure the file type is allowed
+            // ref: https://craftcms.com/docs/3.x/config/config-settings.html#allowedfileextensions
+            $allowedExtensions = Craft::$app->getConfig()->getGeneral()->allowedFileExtensions;
+            if (($ext = pathinfo($fileName, PATHINFO_EXTENSION)) !== '') {
+                $ext = strtolower($ext);
+            }
+            if ($ext === '' || !in_array($ext, $allowedExtensions, true)) {
+                throw new ServerErrorHttpException(Craft::t('seomatic', 'File format not allowed.'));
+            }
             // Send the file as a stream, so it can exist anywhere
             $response->sendContentAsFile(
                 $contents,","Ensure that only files with the extensions listed in `allowedFileExtensions` General Config setting can be used with the SEO File Link controller

Signed-off-by: Andrew Welch <andrew@nystudio107.com>","vuln-fix: Restrict served file types to allowed extensions

The action serving files did not verify the file extension against the configured allowed list, permitting delivery of arbitrary file types.
This could enable attackers to access or execute unauthorized files, leading to information disclosure or remote code execution risks.
The fix enforces a check against Craft CMS’s allowedFileExtensions config and rejects requests for disallowed file formats with an error.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,"[('ensure', 'ACTION', ''), ('signed', 'secword', ''), ('andrew@nystudio107.com', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('disclosure', 'secword', ''), ('remote code execution', 'secword', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
84,CWE-79,GHSA-hpx4-xjp7-m4vr,"@@ -98,7 +98,7 @@ public function transformAsset(Asset $asset)
             'purchase_cost' => Helper::formatCurrencyOutput($asset->purchase_cost),
             'book_value' => Helper::formatCurrencyOutput($depreciated_value),
             'monthly_depreciation' => $monthly_depreciation,
-            'checked_out_to' => $checkout_target,
+            'checked_out_to' => ($checkout_target) ? e($checkout_target) : null,
             'diff' =>  Helper::formatCurrencyOutput($diff),
             'number_of_months' =>  ($asset->model && $asset->model->depreciation) ? e($asset->model->depreciation->months) : null,
             'depreciation' => (($asset->model) && ($asset->model->depreciation)) ?  e($asset->model->depreciation->name) : null,","Escape checkout target name

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Escape user data in asset checkout output

The asset transformation function outputted the 'checked_out_to' field without escaping, allowing injection of malicious HTML or scripts if attacker-controlled data was present.
This exposed the application to cross-site scripting (XSS) attacks, risking user session theft or unauthorized actions via injected client-side code.
The fix applies proper escaping to the 'checked_out_to' value before output, ensuring any HTML special characters are neutralized and preventing script execution.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.17647058823529413,"[('escape', 'secword', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('asset', 'secword', ''), ('asset', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('attacker', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
85,CWE-79,GHSA-wg8p-w946-c482,"@@ -329,7 +329,7 @@ public function isAllowedFilename($filename){
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
 			'.pdf','.ofd','.swf','.epub','.xps',
 			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps','.wpt',
-			'.ppt','.pptx','.xls','.xlsx','.txt','.md','.psd','.csv',
+			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
 			'.cer','.ppt','.pub','.properties','.json','.css',
 			) ;",file upload bug,"vuln-fix: Restrict allowed filename extensions to prevent unsafe uploads

The file upload validation allowed certain extensions like '.md' that may enable uploading unsafe or unexpected file types.
This posed a security risk by permitting potentially harmful files that could be executed or exploited on the server or client side.
The fix removes the '.md' extension from the allowed list, tightening validation to reduce the attack surface for malicious uploads.

Weakness: CWE-434
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('unsafe', 'secword', ''), ('security', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('attack surface', 'secword', ''), ('malicious', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
86,CWE-79,GHSA-vc5r-xfc4-4x22,"@@ -50,7 +50,7 @@ private function buildItem($configuration): array
 
         return [
             'id' => $name,
-            'text' => $name,
+            'text' => htmlspecialchars($name),
             'type' => 'config',
             'iconCls' => 'plugin_pimcore_datahub_icon_' . $type,
             'expandable' => false,",follow up to https://github.com/pimcore/data-hub/pull/462,"vuln-fix: Escape output to prevent XSS in configuration items

The code rendered configuration item names directly into HTML without escaping, allowing injection of malicious scripts via crafted names.
This exposed users to cross-site scripting attacks, enabling attackers to execute arbitrary JavaScript in the context of the affected application.
The fix applies htmlspecialchars to encode special characters, ensuring safe rendering of configuration names in HTML contexts.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.058823529411764705,"[('https://github.com/pimcore/data-hub/pull/462', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('encode', 'secword', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
87,CWE-79,GHSA-5fxf-x22x-5q38,"@@ -6,7 +6,6 @@ on:
 jobs:
   microweber-test-before-build:
     runs-on: ubuntu-latest
-    needs: stop-previous-runs
     steps:
       - uses: actions/checkout@v2",Update build-and-upload.yml,"vuln-fix: Remove dependency on prior job to prevent stale state issues

The CI workflow included a dependency on a previous job that could cause stale or inconsistent state to affect subsequent test runs.
This introduced a risk where outdated artifacts or environment conditions might lead to incorrect test results or mask security regressions.
The fix removes the unnecessary job dependency to ensure each test run starts with a clean, isolated environment, improving reliability and security.

Weakness: CWE-362
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', ''), ('build-and-upload.yml', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('prevent', 'ACTION', ''), ('issues', 'FLAW', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensure', 'ACTION', ''), ('improving', 'ACTION', ''), ('security', 'secword', ''), ('weakness', 'secword', ''), ('cwe-362', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
88,CWE-79,GHSA-3pg8-c473-w6rr,"@@ -54,10 +54,10 @@ public function deleteFile($file_id){
 	}
 
 	//上传文件，返回url
-	public function upload($_files , $file_key , $uid , $item_id = 0  , $page_id = 0  ){
+	public function upload($_files , $file_key , $uid , $item_id = 0  , $page_id = 0 , $check_filename = true  ){
 		$uploadFile = $_files[$file_key] ;
 
-		if( !$this->isAllowedFilename($_files[$file_key]['name']) ){
+		if( $check_filename && !$this->isAllowedFilename($_files[$file_key]['name']) ){
 			return false;
 		}
 
@@ -324,14 +324,12 @@ public function isDangerFilename($filename){
 	public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
-			'.mp3','.wav','.mp4',
-			'.mov','.webmv','.flac','.mkv',
+			'.mp3','.wav','.mp4','.mov','.flac','.mkv',
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso',
-			'.pdf','.ofd','.swf','.epub','.xps',
-			'.doc','.docx','.wps',
+			'.pdf','.epub','.xps','.doc','.docx','.wps',
 			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
 			'.cer','.ppt','.pub','.json','.css',
-			) ;
+		) ;
 
 		$ext = strtolower(substr($filename,strripos($filename,'.')) ); //获取文件扩展名（转为小写后）
 		if(in_array( $ext , $allow_array ) ){",Upload file vulnerability,"vuln-fix: Enforce filename validation in file upload function

The file upload function allowed bypassing filename extension checks by disabling validation, potentially permitting dangerous file types to be uploaded.
This posed a security risk by enabling attackers to upload malicious files that could be executed or accessed, leading to server compromise or data leakage.
The fix adds a parameter to enforce filename validation by default, preventing uploads of disallowed file types unless explicitly overridden.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,"[('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('bypassing', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious files', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
89,"CWE-434', 'CWE-79",GHSA-rphc-h572-2x9f,"@@ -324,13 +324,13 @@ public function isDangerFilename($filename){
 	public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
-			'.mp3','.wav','.m4a','.ogg','.webma','.mp4','.flv',
+			'.mp3','.wav','.mp4',
 			'.mov','.webmv','.flac','.mkv',
-			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
+			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso',
 			'.pdf','.ofd','.swf','.epub','.xps',
-			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps',
+			'.doc','.docx','.wps',
 			'.ppt','.pptx','.xls','.xlsx','.txt','.psd','.csv',
-			'.cer','.ppt','.pub','.properties','.json','.css',
+			'.cer','.ppt','.pub','.json','.css',
 			) ;
 
 		$ext = strtolower(substr($filename,strripos($filename,'.')) ); //获取文件扩展名（转为小写后）",file upload bug,"vuln-fix: Restrict allowed file extensions to prevent unsafe uploads

The file upload validation allowed potentially dangerous file types by including uncommon or executable extensions in the allowed list.
This increased the risk of attackers uploading malicious files that could lead to remote code execution or system compromise.
The fix removes risky extensions from the allowed list, limiting uploads to safer, commonly used media and document formats only.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious files', 'SECWORD', ''), ('remote code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
90,"CWE-79', 'CWE-116",GHSA-ph5x-h23x-7q5q,"@@ -245,7 +245,7 @@
                   &lt;a href=""$backUrl"" class='button secondary'&gt;{{translation key=""platform.wiki.users.join.request.cancel.label""/}}&lt;/a&gt;
                 &lt;/span&gt;
                 &lt;input type='hidden' name='wikiId' value=""$!wikiId""/&gt;
-                &lt;input type='hidden' name='requestJoin' value=""$!request.requestJoin""/&gt;
+                &lt;input type='hidden' name='requestJoin' value=""$escapetool.xml($!request.requestJoin)""/&gt;
                 &lt;input type=""hidden"" name=""form_token"" value=""$!escapetool.xml($services.csrf.getToken())"" /&gt;
               &lt;/dl&gt;
             &lt;/form&gt;",XWIKI-19292: Fix bad escaping,"vuln-fix: Escape user input in hidden form fields to prevent XSS

The form included user-controlled data in a hidden input field without proper escaping, allowing injection of malicious XML or HTML content.
This exposed the application to cross-site scripting attacks where attackers could execute arbitrary scripts in users’ browsers.
The fix applies XML escaping to the user input before rendering it in the hidden field, ensuring safe output encoding.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('encoding', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
91,CWE-79,GHSA-4wm8-c2vv-xrpq,"@@ -14,6 +14,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.log4j.Logger;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.core.Context;
 
@@ -25,8 +26,8 @@
  */
 public class ControlledVocabularyServlet extends DSpaceServlet
 {
-    // private static Logger log =
-    // Logger.getLogger(ControlledVocabularyServlet.class);
+    private static Logger log =
+    Logger.getLogger(ControlledVocabularyServlet.class);
 
     protected void doDSGet(Context context, HttpServletRequest request,
             HttpServletResponse response) throws ServletException, IOException,
@@ -37,6 +38,13 @@ protected void doDSGet(Context context, HttpServletRequest request,
         String filter = """";
         String callerUrl = request.getParameter(""callerUrl"");
 
+        // callerUrl must starts with URL outside DSpace request context path
+        if(!callerUrl.startsWith(request.getContextPath())) {
+            log.error(""Controlled vocabulary caller URL would result in redirect outside DSpace web app: "" + callerUrl + "". Rejecting request with 400 Bad Request."");
+            response.sendError(400, ""The caller URL must be within the DSpace base URL of "" + request.getContextPath());
+            return;
+        }
+
         if (request.getParameter(""ID"") != null)
         {
             ID = request.getParameter(""ID"");",[DS-4133] Improve URL handling in Controlled Vocab JSPUI servlet,"vuln-fix: Restrict callerUrl to internal context path to prevent open redirect

The servlet accepted a callerUrl parameter without verifying it was within the application’s context path, allowing potential open redirect attacks.
This flaw could enable attackers to redirect users to malicious external sites, facilitating phishing or other social engineering exploits.
The fix enforces that callerUrl must start with the server’s context path, rejecting requests with invalid URLs and preventing external redirects.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.058823529411764705,"[('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('open redirect', 'SECWORD', ''), ('open redirect', 'secword', ''), ('attacks', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('phishing', 'secword', ''), ('exploits', 'SECWORD', ''), ('fix', 'ACTION', ''), ('server', 'SECWORD', ''), ('invalid urls', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
92,CWE-79,GHSA-c558-5gfm-p2r8,"@@ -209,7 +209,7 @@
         <input type=""text"" size=""50"" id=""query"" name=""query"" value=""<%= (query==null ? """" : Utils.addEntities(query)) %>""/>
         <input type=""submit"" id=""main-query-submit"" class=""btn btn-primary"" value=""<fmt:message key=""jsp.general.go""/>"" />
 <% if (StringUtils.isNotBlank(spellCheckQuery)) {%>
-	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= spellCheckQuery %></a></fmt:param></fmt:message></p>
+	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= Utils.addEntities(spellCheckQuery) %></a></fmt:param></fmt:message></p>
 <% } %>                  
         <input type=""hidden"" value=""<%= rpp %>"" name=""rpp"" />
         <input type=""hidden"" value=""<%= Utils.addEntities(sortedBy) %>"" name=""sort_by"" />",[DS-4453] Fix XSS handling in JSPUI discovery spellcheck,"vuln-fix: Sanitize spell check query output to prevent XSS

The search page rendered the spell check suggestion without properly escaping HTML entities, allowing injection of malicious scripts via crafted spellCheckQuery input.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in the victim’s browser, compromising user data and session integrity.
The fix applies HTML entity encoding to the spellCheckQuery output, ensuring any special characters are safely escaped before rendering in the page.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
93,CWE-79,GHSA-r5jw-62xg-j433,"@@ -2,7 +2,7 @@
 
 module Kaminari
   module Helpers
-    PARAM_KEY_EXCEPT_LIST = [:authenticity_token, :commit, :utf8, :_method, :script_name].freeze
+    PARAM_KEY_EXCEPT_LIST = [:authenticity_token, :commit, :utf8, :_method, :script_name, :original_script_name].freeze
 
     # A tag stands for an HTML tag inside the paginator.
     # Basically, a tag has its own partial template file, so every tag can be","Blacklist ""original_script_name"" get param","vuln-fix: Add original_script_name to parameter exclusion list

The pagination helper did not exclude the original_script_name parameter from processing, allowing it to be unintentionally used or leaked in URL generation.
This could lead to information disclosure or parameter pollution attacks by exposing internal routing details or enabling crafted parameter injection.
The fix adds original_script_name to the exclusion list, preventing it from being included in generated URLs or parameter handling.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('blacklist', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('disclosure', 'secword', ''), ('attacks', 'FLAW', ''), ('injection', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
94,CWE-79,GHSA-8w3x-r6x7-c5r5,"@@ -607,7 +607,12 @@ pimcore.object.classes.klass = Class.create({
                 for (var i = 0; i < items.length; i++) {
                     var item = items[i];
                     if (typeof item.getValue == ""function"") {
-                        this.data[item.name] = item.getValue();
+                        let value = item.getValue();
+                        if (typeof item.config.xtype !== 'undefined' && item.config.xtype === 'textfield') {
+                            value = Ext.util.Format.htmlEncode(value);
+                        }
+
+                        this.data[item.name] = value;
                     }
                 }
 
@@ -705,6 +710,7 @@ pimcore.object.classes.klass = Class.create({
             id: ""iconfield-"" + this.getId(),
             name: ""icon"",
             width: 396,
+            renderer: Ext.util.Format.htmlEncode,
             value: this.data.icon,
             listeners: {
                 ""afterrender"": function (el) {
@@ -752,6 +758,7 @@ pimcore.object.classes.klass = Class.create({
                     width: 500,
                     enableKeyEvents: true,
                     value: this.data.name,
+                    renderer: Ext.util.Format.htmlEncode,
                     listeners: {
                         keyup: function (el) {
                             this.rootPanel.getComponent(""phpClassName"").setValue(getPhpClassName(el.getValue()))
@@ -763,12 +770,14 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""description""),
                     name: ""description"",
                     width: 500,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.description
                 },
                 {
                     xtype: ""textfield"",
                     fieldLabel: t(""unique_identifier""),
                     disabled: true,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.id,
                     width: 500
                 },
@@ -779,6 +788,7 @@ pimcore.object.classes.klass = Class.create({
                     itemId: ""phpClassName"",
                     width: 500,
                     disabled: true,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: getPhpClassName(this.data.name)
                 },
                 {
@@ -786,6 +796,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""parent_php_class""),
                     name: ""parentClass"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.parentClass
                 },
                 {
@@ -793,6 +804,7 @@ pimcore.object.classes.klass = Class.create({
                     width: 600,
                     name: ""implementsInterfaces"",
                     fieldLabel: t(""implements_interfaces""),
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.implementsInterfaces
                 },
                 {
@@ -800,6 +812,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""use_traits""),
                     name: ""useTraits"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.useTraits
                 },
                 {
@@ -807,6 +820,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""listing_parent_php_class""),
                     name: ""listingParentClass"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.listingParentClass
                 },
                 {
@@ -814,6 +828,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""listing_use_traits""),
                     name: ""listingUseTraits"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.listingUseTraits
                 },
                 {
@@ -821,6 +836,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""link_generator_reference""),
                     name: ""linkGeneratorReference"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.linkGeneratorReference
                 },
                 {
@@ -828,6 +844,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""preview_generator_reference""),
                     name: ""previewGeneratorReference"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.previewGeneratorReference
                 },
                 {
@@ -835,6 +852,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""preview_url""),
                     name: ""previewUrl"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.previewUrl
                 },
                 {
@@ -885,6 +903,7 @@ pimcore.object.classes.klass = Class.create({
                     fieldLabel: t(""group""),
                     name: ""group"",
                     width: 600,
+                    renderer: Ext.util.Format.htmlEncode,
                     value: this.data.group
                 },
                 this.allowInheritance,","[Admin UI] DataObject Class - escape general settings input values (#10991)

* [Admin UI] DataObject Class - escape general settings input values

* Update bundles/AdminBundle/Resources/public/js/pimcore/object/classes/class.js

* [Admin UI] DataObject Class - escape general settings input values

* [Admin UI] DataObject Class - escape general settings input values","vuln-fix: Encode HTML output to prevent XSS in object class fields

The application failed to properly encode user-supplied input values before rendering them in various text fields, allowing injection of malicious HTML or scripts.
This exposed users to cross-site scripting (XSS) attacks, where attackers could execute arbitrary JavaScript in the context of the victim’s browser, compromising data and session integrity.
The fix applies HTML encoding to all relevant field values and input retrievals, ensuring that special characters are safely escaped before display.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('#10991', 'ISSUE', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('update', 'ACTION', ''), ('adminbundle', 'SECWORD', ''), ('class.js', 'URL', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', ''), ('admin', 'SECWORD', ''), ('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encode', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
95,CWE-79,GHSA-7jh9-6cpf-h4m7,"@@ -1388,8 +1388,12 @@ hello.utils.extend(hello.utils, {
 		// (URI Fragments within 302 Location URI are lost over HTTPS)
 		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
 		else if ('oauth_redirect' in p) {
+			var url = decodeURIComponent(p.oauth_redirect);
+
+			if (isValidUrl(url)) {
+				location.assign(url);
+			}
 
-			location.assign(decodeURIComponent(p.oauth_redirect));
 			return;
 		}",fix(xss): oauth_redirect should be a valid url,"vuln-fix: Validate redirect URL to prevent open redirect attacks

The OAuth redirect handler did not validate the decoded redirect URL before navigating, allowing attackers to supply arbitrary URLs for redirection.
This exposed users to open redirect vulnerabilities, enabling phishing or malicious site redirection by tricking users into following unsafe links.
The patch adds a URL validation check to ensure only legitimate URLs are used for redirection, blocking unsafe or malformed inputs.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix(xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('open redirect', 'secword', ''), ('attacks', 'FLAW', ''), ('oauth', 'secword', ''), ('validate', 'secword', ''), ('decoded', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('open redirect', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('phishing', 'secword', ''), ('malicious', 'SECWORD', ''), ('unsafe', 'secword', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
96,CWE-79,GHSA-vx6v-xg64-pmr8,"@@ -330,7 +330,11 @@ <h5 class=""mb-0"">
         function get_url(row) {
             return ""{% url 'helpdesk:view' 1234 %}"".replace(/1234/, row.id.toString());
         }
-
+        
+        function htmlEntities(str) {
+            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/""/g, '&quot;');
+        }
+        
         $(document).ready(function () {
             // Ticket DataTable Initialization
             $('#ticketTable').DataTable({
@@ -366,7 +370,7 @@ <h5 class=""mb-0"">
                             if (type === 'display') {
                                 data = '<div class=""tickettitle""><a href=""' + get_url(row) + '"" >' +
                                     row.id + '. ' +
-                                    row.title + '</a></div>';
+                                    htmlEntities(row.title) + '</a></div>';
                             }
                             return data
                         }","Add function `htmlEntities`

`htmlentities()` is a function which converts special characters. This allows you to show to display the string without the browser reading it as HTML.","vuln-fix: Escape HTML entities in ticket titles to prevent XSS

The ticket title was rendered directly into HTML without escaping, allowing injection of malicious HTML or JavaScript code via crafted ticket titles.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in the context of the affected web application.
The fix introduces an htmlEntities function that escapes special characters in ticket titles before rendering, preventing injection of executable code.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.17647058823529413,"[('add', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('htmlentities', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('escapes', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
97,CWE-79,GHSA-rcvx-rmvf-mxch,"similarity index 64%
rename from hawkbit-runtime/hawkbit-update-server/src/main/java/org/eclipse/hawkbit/app/StreamAwareErrorController.java
rename to hawkbit-runtime/hawkbit-update-server/src/main/java/org/eclipse/hawkbit/app/ErrorController.java
@@ -8,6 +8,8 @@
  */
 package org.eclipse.hawkbit.app;
 
+import java.util.Map;
+
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
@@ -23,22 +25,23 @@
 /**
  * Error page controller that ensures that ocet stream does not return text in
  * case of an error.
- *
  */
 @Controller
 // Exception squid:S3752 - errors need handling for all methods
 @SuppressWarnings(""squid:S3752"")
-public class StreamAwareErrorController extends BasicErrorController {
+public class ErrorController extends BasicErrorController {
+
+    private static final String PATH = ""path"";
 
     /**
-     * A new {@link StreamAwareErrorController}.
+     * A new {@link ErrorController}.
      * 
      * @param errorAttributes
      *            the error attributes
      * @param serverProperties
      *            configuration properties
      */
-    public StreamAwareErrorController(final ErrorAttributes errorAttributes, final ServerProperties serverProperties) {
+    public ErrorController(final ErrorAttributes errorAttributes, final ServerProperties serverProperties) {
         super(errorAttributes, serverProperties.getError());
     }
 
@@ -48,4 +51,19 @@ public ResponseEntity<Void> errorStream(final HttpServletRequest request, final
         return new ResponseEntity<>(status);
     }
 
+    @Override
+    @RequestMapping
+    public ResponseEntity<Map<String, Object>> error(final HttpServletRequest request) {
+        final HttpStatus status = getStatus(request);
+        final Map<String, Object> body = getErrorAttributesWithoutPath(request);
+        return new ResponseEntity<>(body, status);
+    }
+
+    private Map<String, Object> getErrorAttributesWithoutPath(final HttpServletRequest request) {
+        final Map<String, Object> body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));
+        if (body != null && body.containsKey(PATH)) {
+            body.remove(PATH);
+        }
+        return body;
+    }
 }","Fixes #1067

JSON body response for HTTP 404 error may contain unsafe URL path characters. Thus removing path from the response

Signed-off-by: Dominic Schabel <dominic.schabel@bosch.io>","vuln-fix: Remove path info from error responses to prevent data leakage

The error controller included the request path in error response bodies, potentially exposing sensitive internal URL structures to clients.
This information disclosure risk could aid attackers in mapping application endpoints and crafting targeted attacks based on revealed paths.
The fix removes the path attribute from error responses, ensuring sensitive routing details are not leaked to external users.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('fixes', 'ACTION', ''), ('#1067', 'ISSUE', ''), ('error', 'FLAW', ''), ('unsafe', 'SECWORD', ''), ('removing', 'ACTION', ''), ('signed', 'secword', ''), ('dominic.schabel@bosch.io', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('error', 'FLAW', ''), ('error', 'FLAW', ''), ('sensitive', 'SECWORD', ''), ('disclosure', 'secword', ''), ('attackers', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
98,CWE-79,GHSA-wjh9-344g-vc49,"@@ -200,7 +200,7 @@ function( $match ) {
 
 	foreach ( $remove as $remove_string )
 	{
-		while ( strpos( $string, $remove_string ) !== false )
+		while ( stripos( $string, $remove_string ) !== false )
 		{
 			$string = str_ireplace( $remove, '', $string );
 		}",Fix stored XSS security issue: remove inline JS from URL in PreparePHP_SELF.fnc.php,"vuln-fix: Use case-insensitive search to remove strings securely

The string removal loop used a case-sensitive search, causing some unwanted substrings with different casing to remain in the input.
This allowed attackers to bypass filtering by altering letter case, potentially enabling injection or malicious content to persist.
The fix replaces strpos with stripos to perform case-insensitive searches, ensuring all variants of the target strings are properly removed.

Weakness: CWE-183
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('security', 'SECWORD', ''), ('issue', 'FLAW', ''), ('remove', 'ACTION', ''), ('preparephp_self.fnc.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('securely', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('removed', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-183', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
99,CWE-79,GHSA-gx5w-rrhp-f436,"@@ -145,6 +145,11 @@ window.search = window.search || {};
             url.push("""");
         }
 
+        // encodeURIComponent escapes all chars that could allow an XSS except
+        // for '. Due to that we also manually replace ' with its url-encoded
+        // representation (%27).
+        var searchterms = encodeURIComponent(searchterms.join("" "")).replace(/\'/g, ""%27"");
+
         return '<a href=""' + path_to_root + url[0] + '?' + URL_MARK_PARAM + '=' + searchterms + '#' + url[1]
             + '"" aria-details=""teaser_' + teaser_count + '"">' + result.doc.breadcrumbs + '</a>'
             + '<span class=""teaser"" id=""teaser_' + teaser_count + '"" aria-label=""Search Result Teaser"">'","fix xss in the search page

Thanks to Kamil Vavra for responsibly disclosing the vulnerability
according to Rust's Security Policy.","vuln-fix: Encode single quotes in search terms to prevent XSS

The search result link generation did not encode single quote characters in user input, allowing injection of malicious scripts via crafted search terms.
This created a cross-site scripting (XSS) risk where attackers could execute arbitrary JavaScript in users’ browsers by manipulating the search query.
The fix applies encodeURIComponent and additionally replaces single quotes with their URL-encoded form to ensure all dangerous characters are safely escaped.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.17647058823529413,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('security', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulating', 'ACTION', ''), ('fix', 'ACTION', ''), ('encodeuricomponent', 'SECWORD', ''), ('encoded', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
100,CWE-79,GHSA-6m26-25q2-cq46,"@@ -4,6 +4,7 @@
 
 use Conner\Tagging\Model\Tagged;
 use \Intervention\Image\ImageManagerStatic as Image;
+use MicroweberPackages\Helper\HTMLClean;
 use MicroweberPackages\Media\Models\Media;
 use MicroweberPackages\Media\Models\MediaThumbnail;
 use MicroweberPackages\Utils\Media\Thumbnailer;
@@ -1184,6 +1185,10 @@ public function thumbnail_img($params)
 
     public function create_media_dir($params)
     {
+
+        $clean = new HTMLClean();
+        $_REQUEST = $clean->cleanArray($_REQUEST);
+
         must_have_access();
         $resp = array();
         // $target_path = media_base_path() . 'uploaded' . DS;
@@ -1198,7 +1203,7 @@ public function create_media_dir($params)
 
             $target_path = $fn_path;
         }
-        if (!isset($_REQUEST['name'])) {
+        if (!isset($_REQUEST['name']) || empty($_REQUEST['name'])) {
             $resp = array('error' => 'You must send new_folder parameter');
         } else {
             $fn_new_folder_path = $_REQUEST['name'];",add xss clean to create media dir method,"vuln-fix: Sanitize request data in media directory creation

The create_media_dir function did not sanitize user input from the global request array, allowing potentially malicious HTML or script content to be processed.
This posed a risk of cross-site scripting or injection attacks by enabling unsafe input to influence server-side operations or responses.
The fix applies HTMLClean sanitization to the entire request array before any processing, ensuring all inputs are cleaned of harmful content.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.11764705882352941,"[('add', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('sanitize', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('unsafe', 'SECWORD', ''), ('server', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
101,CWE-79,GHSA-6jp6-9rf9-gc66,"@@ -1131,7 +1131,9 @@ $(function () {
       return """";
     },
     menuItemTemplate: function (item) {
-      return `<a>${item.string}</a>`;
+      let link = document.createElement(""a"");
+      link.innerText = item.string;
+      return link.outerHTML;
     },
     values: (text, callback) => {
       $.ajax({","js: Add missing escaping to username completion

Fixes https://hackerone.com/reports/1486674","vuln-fix: Prevent XSS by safely rendering menu item strings

The menu item rendering function directly injected unescaped HTML strings into anchor elements, allowing malicious input to execute arbitrary scripts.
This exposed users to cross-site scripting (XSS) attacks where attackers could inject and run harmful JavaScript in the application context.
The fix replaces direct HTML insertion with safe text assignment using DOM APIs to ensure proper escaping and prevent script execution.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('escaping', 'secword', ''), ('fixes', 'ACTION', ''), ('https://hackerone.com/reports/1486674', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('ensure', 'ACTION', ''), ('escaping', 'secword', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
102,CWE-79,GHSA-c558-5gfm-p2r8,"@@ -147,7 +147,7 @@
 									tmp_val = item.displayedValue;
 								}
 								return {
-									label: item.displayedValue + "" ("" + item.count + "")"",
+									label: escapeHtml(item.displayedValue) + "" ("" + item.count + "")"",
 									value: tmp_val
 								};
 							}))			
@@ -159,6 +159,11 @@
 	function validateFilters() {
 		return document.getElementById(""filterquery"").value.length > 0;
 	}
+	// Generic HTML escape utility
+	var escapeHtml = s => (s + '').replace(/[&<>""']/g, m => ({
+		'&': '&amp;', '<': '&lt;', '>': '&gt;',
+		'""': '&quot;', ""'"": '&#39;'
+	})[m]);
 </script>		
 </c:set>",[DS-4453] Fix XSS handling in JSPUI discovery autocomplete,"vuln-fix: Escape HTML in displayed filter labels to prevent XSS

The code rendered user-supplied filter labels directly into HTML without escaping, allowing injection of malicious scripts via crafted input.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in victims’ browsers, compromising session integrity and data.
The fix adds a generic HTML escape function to sanitize displayed values before insertion, preventing execution of injected HTML or script content.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('escape', 'SECWORD', ''), ('sanitize', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
103,CWE-79,GHSA-qf2g-q4mc-w7rr,"@@ -839,7 +839,7 @@ public static function processModuleXml(\SimpleXMLElement $xml): array
         $information['name'] = (string) $module->name;
         $information['version'] = (string) $module->version;
         $information['requirements'] = (array) $module->requirements;
-        $information['description'] = (string) $module->description;
+        $information['description'] = strip_tags((string) $module->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');
         $information['cronjobs'] = [];
 
         // authors
@@ -900,7 +900,7 @@ public static function processThemeXml(\SimpleXMLElement $xml): array
         $information['version'] = (string) $theme->version;
         $information['requirements'] = (array) $theme->requirements;
         $information['thumbnail'] = (string) $theme->thumbnail;
-        $information['description'] = (string) $theme->description;
+        $information['description'] = strip_tags((string) $theme->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');
 
         // authors
         foreach ($xml->xpath('/theme/authors/author') as $author) {",Fix xss though the description in the info.xml file of a theme or module,"vuln-fix: Sanitize module and theme descriptions to prevent XSS

The module and theme XML processing functions did not sanitize description fields, allowing untrusted HTML content to be stored and rendered without restriction.
This exposed the application to cross-site scripting (XSS) attacks where malicious scripts could execute in users’ browsers, compromising user data and session integrity.
The fix applies strip_tags with a safe whitelist of HTML tags to clean descriptions, preventing injection of harmful scripts while preserving basic formatting.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('info.xml', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('sanitize', 'secword', ''), ('untrusted', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
104,CWE-79,GHSA-wrp6-9w7f-3wxg,"@@ -248,7 +248,7 @@ $(""#btn-upload-format"").on(""change"", function () {
     if (filename.substring(3, 11) === ""fakepath"") {
         filename = filename.substring(12);
     } // Remove c:\fake at beginning from localhost chrome
-    $(""#upload-format"").html(filename);
+    $(""#upload-format"").text(filename);
 });
 
 $(""#btn-upload-cover"").on(""change"", function () {
@@ -256,7 +256,7 @@ $(""#btn-upload-cover"").on(""change"", function () {
     if (filename.substring(3, 11) === ""fakepath"") {
         filename = filename.substring(12);
     } // Remove c:\fake at beginning from localhost chrome
-    $(""#upload-cover"").html(filename);
+    $(""#upload-cover"").text(filename);
 });
 
 $(""#xchange"").click(function () {",Fix upload of cover and book formats containing html characters,"vuln-fix: Prevent XSS by using text() instead of html() for filenames

The code inserted user-supplied filenames into the DOM using html(), allowing malicious filenames containing HTML or scripts to execute in the browser context.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to run arbitrary JavaScript and compromise user sessions or data.
The fix replaces html() with text() to safely encode filenames as plain text, preventing execution of embedded HTML or scripts.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('malicious filenames', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encode', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
105,CWE-79,GHSA-49qr-xh3w-h436,"@@ -78,6 +78,13 @@ class NbconvertFileHandler(IPythonHandler):
 
     SUPPORTED_METHODS = ('GET',)
 
+    @property
+    def content_security_policy(self):
+        # In case we're serving HTML/SVG, confine any Javascript to a unique
+        # origin so it can't interact with the notebook server.
+        return super(NbconvertFileHandler, self).content_security_policy + \
+               ""; sandbox allow-scripts""
+
     @web.authenticated
     def get(self, format, path):
 
@@ -145,6 +152,13 @@ def get(self, format, path):
 class NbconvertPostHandler(IPythonHandler):
     SUPPORTED_METHODS = ('POST',)
 
+    @property
+    def content_security_policy(self):
+        # In case we're serving HTML/SVG, confine any Javascript to a unique
+        # origin so it can't interact with the notebook server.
+        return super(NbconvertPostHandler, self).content_security_policy + \
+               ""; sandbox allow-scripts""
+
     @web.authenticated
     def post(self, format):
         exporter = get_exporter(format, config=self.config)","Apply CSP sandboxing for nbconvert responses

These may contain untrusted content, so they should be treated as being
from a different domain to the notebook server.","vuln-fix: Enforce sandboxed content security policy on nbconvert handlers

The nbconvert file and post handlers did not apply sandbox restrictions in their Content Security Policy, allowing served HTML/SVG to execute scripts with full origin privileges.
This exposed the notebook server to cross-site scripting risks where malicious scripts could interact with or compromise the server environment.
The fix appends a sandbox directive with allow-scripts to the CSP, isolating JavaScript execution and preventing it from accessing the notebook server’s origin.

Weakness: CWE-1021
Severity: High
CVSS: 7.8",0.17647058823529413,"[('untrusted', 'secword', ''), ('server', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('content security policy', 'secword', ''), ('sandbox', 'secword', ''), ('content security policy', 'secword', ''), ('server', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('malicious', 'secword', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('sandbox', 'secword', ''), ('preventing', 'ACTION', ''), ('server', 'secword', ''), ('weakness', 'secword', ''), ('cwe-1021', 'CWEID', ''), ('high', 'SEVERITY', '')]"
106,CWE-79,GHSA-38m9-3vg4-rwvp,"@@ -114,6 +114,9 @@ public function redirect($url)
         $redirectUrl = str_replace(""\r"", """", $redirectUrl);
         $redirectUrl = str_replace(""\n"", """", $redirectUrl);
 
+        $clearInput = new HTMLClean();
+        $redirectUrl = $clearInput->clean($redirectUrl);
+
         if (headers_sent()) {
             echo '<meta http-equiv=""refresh"" content=""0;url=' . $redirectUrl . '"">';
         } else {",Update UrlManager.php,"vuln-fix: Sanitize redirect URL to prevent header injection

The redirect function did not fully sanitize user-supplied URLs, allowing injection of malicious characters that could manipulate HTTP headers.
This vulnerability enabled attackers to perform HTTP response splitting or header injection attacks, potentially leading to cache poisoning or cross-site scripting.
The fix applies HTMLClean sanitization to the redirect URL, removing dangerous characters and ensuring safe header construction.

Weakness: CWE-113
Severity: High
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', ''), ('urlmanager.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('sanitize', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('http response splitting', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('poisoning', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitization', 'SECWORD', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-113', 'CWEID', ''), ('high', 'SEVERITY', '')]"
107,CWE-79,GHSA-vfrc-ggmc-5jwv,"@@ -145,6 +145,7 @@ def process_attachments(followup, attached_files):
                 'application/octet-stream',
                 size=attached.size,
             )
+            att.full_clean()
             att.save()
 
             if attached.size < max_email_attachment_size:","Add `att.full_clean()` before saving

Fix issue https://github.com/django-helpdesk/django-helpdesk/issues/983
Also, fix bug stored XSS disclosure: https://huntr.dev/bounties/4d7a5fdd-b2de-467a-ade0-3f2fb386638e/","vuln-fix: Validate attachment data before saving to prevent invalid input

The attachment processing function did not perform validation on attachment data before saving, allowing potentially malformed or malicious files to be stored.
This posed a security risk by enabling corrupted or harmful data to enter the system, which could lead to data integrity issues or exploitation of downstream components.
The fix adds a call to full_clean() on attachments to enforce model validation and reject invalid inputs prior to saving.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('add', 'ACTION', ''), ('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('https://github.com/django-helpdesk/django-helpdesk/issues/983', 'URL', ''), ('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('xss', 'SECWORD', ''), ('disclosure', 'secword', ''), ('https://huntr.dev/bounties/4d7a5fdd-b2de-467a-ade0-3f2fb386638e/', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('malicious files', 'SECWORD', ''), ('security', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('exploitation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
108,CWE-79,GHSA-3fw8-66wf-pr7m,"@@ -152,7 +152,7 @@ app.handle = function(req, res, out) {
         res.statusCode = 404;
         res.setHeader('Content-Type', 'text/plain');
         if ('HEAD' == req.method) return res.end();
-        res.end('Cannot ' + req.method + ' ' + utils.escape(req.originalUrl));
+        res.end('Cannot ' + utils.escape(req.method) + ' ' + utils.escape(req.originalUrl));
       }
       return;
     }
@@ -202,7 +202,7 @@ app.handle = function(req, res, out) {
  * Listen for connections.
  *
  * This method takes the same arguments
- * as node's `http.Server#listen()`.  
+ * as node's `http.Server#listen()`.
  *
  * HTTP and HTTPS:
  *
@@ -214,9 +214,9 @@ app.handle = function(req, res, out) {
  *      var connect = require('connect')
  *        , http = require('http')
  *        , https = require('https');
- *      
+ *
  *      var app = connect();
- *      
+ *
  *      http.createServer(app).listen(80);
  *      https.createServer(options, app).listen(443);
  *",fix: escape req.method in 404 response,"vuln-fix: Escape HTTP method and URL in error responses

The error handler did not escape the HTTP method and original URL before including them in the response body, allowing injection of malicious content.
This exposed applications to reflected cross-site scripting (XSS) attacks if attackers crafted requests with special characters in the method or URL.
The fix applies proper escaping to both the method and URL before sending them in the response, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('req.method', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('error', 'FLAW', ''), ('error handler', 'SECWORD', ''), ('escape', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
109,CWE-79,GHSA-455w-gv5p-wgg3,"@@ -37,6 +37,11 @@ class TargetingController extends AdminController implements KernelControllerEve
 {
     // RULES
 
+    private function correctName(string $name): string
+    {
+        return preg_replace('/[#?*:\\\\<>|""%&@=;+]/', '-', $name);
+    }
+
     /**
      * @Route(""/rule/list"", name=""pimcore_admin_targeting_rulelist"", methods={""GET""})
      *
@@ -55,7 +60,7 @@ public function ruleListAction(Request $request)
         foreach ($list->load() as $target) {
             $targets[] = [
                 'id' => $target->getId(),
-                'text' => $target->getName(),
+                'text' => htmlspecialchars($target->getName()),
                 'active' => $target->getActive(),
                 'qtip' => 'ID: ' . $target->getId(),
             ];
@@ -74,7 +79,7 @@ public function ruleListAction(Request $request)
     public function ruleAddAction(Request $request)
     {
         $target = new Targeting\Rule();
-        $target->setName($request->get('name'));
+        $target->setName($this->correctName($request->get('name')));
         $target->save();
 
         return $this->adminJson(['success' => true, 'id' => $target->getId()]);
@@ -129,6 +134,7 @@ public function ruleSaveAction(Request $request)
         /** @var Targeting\Rule|Targeting\Rule\Dao $target */
         $target = Targeting\Rule::getById($request->get('id'));
         $target->setValues($data['settings']);
+        $target->setName($this->correctName($target->getName()));
         $target->setConditions($data['conditions']);
         $target->setActions($data['actions']);
         $target->save();
@@ -208,7 +214,7 @@ public function targetGroupListAction(Request $request)
         foreach ($list->load() as $targetGroup) {
             $targetGroups[] = [
                 'id' => $targetGroup->getId(),
-                'text' => $targetGroup->getName(),
+                'text' => htmlspecialchars($targetGroup->getName()),
                 'active' => $targetGroup->getActive(),
                 'qtip' => $targetGroup->getId(),
             ];
@@ -230,7 +236,7 @@ public function targetGroupAddAction(Request $request, CoreCacheHandler $cache,
     {
         /** @var TargetGroup|TargetGroup\Dao $targetGroup */
         $targetGroup = new TargetGroup();
-        $targetGroup->setName($request->get('name'));
+        $targetGroup->setName($this->correctName($request->get('name')));
         $targetGroup->save();
 
         $event = new TargetGroupEvent($targetGroup);
@@ -300,6 +306,7 @@ public function targetGroupSaveAction(Request $request, CoreCacheHandler $cache,
         /** @var TargetGroup|TargetGroup\Dao $targetGroup */
         $targetGroup = TargetGroup::getById($request->get('id'));
         $targetGroup->setValues($data['settings']);
+        $targetGroup->setName($this->correctName($targetGroup->getName()));
         $targetGroup->save();
 
         $event = new TargetGroupEvent($targetGroup);","[Targeting] Escape/validate names of rules properly (#11205)

* [Targeting] Escape/validate names of rules properly

* Update bundles/AdminBundle/Controller/Admin/TargetingController.php

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>

Co-authored-by: Jacob Dreesen <j.dreesen@neusta.de>","vuln-fix: Sanitize and encode user input in targeting names and lists

The application failed to sanitize special characters in targeting rule and group names, allowing injection of unsafe characters that could disrupt system behavior or enable XSS attacks.
This exposed users to cross-site scripting risks and potential data corruption by permitting malicious input to be stored and rendered without proper encoding or filtering.
The fix introduces character replacement to sanitize names and applies HTML escaping when rendering names in lists, preventing injection and ensuring safe output.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.23529411764705882,"[('escape', 'secword', ''), ('validate', 'secword', ''), ('#11205', 'ISSUE', ''), ('escape', 'SECWORD', ''), ('validate', 'secword', ''), ('update', 'ACTION', ''), ('adminbundle', 'SECWORD', ''), ('admin', 'SECWORD', ''), ('targetingcontroller.php', 'URL', ''), ('j.dreesen@neusta.de', 'EMAIL', ''), ('j.dreesen@neusta.de', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('encode', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('injection', 'secword', ''), ('unsafe', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('cross-site scripting', 'secword', ''), ('malicious', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('escaping', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
110,CWE-79,GHSA-3q55-66g3-p8xq,"@@ -834,10 +834,262 @@ function get_dangerous_files_extentions()
             'xqt',        //    SuperCalc Macro File',
             'xys',        //    XYplorer Script File',
             'zl9',        //    ZoneAlarm Quarantined EXE File
-
-
             'swf',        //    Flash File
 
+            'key',
+            'asax',
+            'btapp',
+            'xd',
+            'fwtemplate',
+            'crdownload',
+            'whtt',
+            'ssp',
+            'fmp',
+            'jspa',
+            'obml16',
+            'a5w',
+            'crt',
+            'vrt',
+            'website',
+            'p7c',
+            'dll',
+            'php',
+            'mjs',
+            'dhtml',
+            'xul',
+            'bml',
+            'download',
+            'cshtml',
+            'vsdisco',
+            'codasite',
+            'webbookmark',
+            'rjs',
+            'wsdl',
+            'dml',
+            'aro',
+            'dcr',
+            'shtml',
+            'dochtml',
+            'dwt',
+            'spc',
+            'a4p',
+            'htaccess',
+            'ascx',
+            'pac',
+            'p7b',
+            'xhtm',
+            'oam',
+            'site',
+            'kit',
+            'aspx',
+            'zul',
+            'tpl',
+            'htm',
+            'seam',
+            'svr',
+            'pem',
+            'url',
+            'dap',
+            'appcache',
+            'chm',
+            'wbs',
+            'htc',
+            'ewp',
+            'gsp',
+            'asr',
+            'der',
+            'master',
+            'stc',
+            'ap',
+            'html',
+            'p12',
+            'xpd',
+            'fwp',
+            'epibrw',
+            'strm',
+            'xss',
+            'node',
+            'disco',
+            'gsp',
+            'pro',
+            'rss',
+            'gne',
+            'sdb',
+            'compressed',
+            'asp',
+            'browser',
+            'php2',
+            'sites2',
+            'dothtml',
+            'bok',
+            'axd',
+            'nzb',
+            'vdw',
+            'obml',
+            'mhtml',
+            'ashx',
+            'con',
+            'rhtml',
+            'alx',
+            'opml',
+            'web',
+            'chat',
+            'csr',
+            'do',
+            'sht',
+            'asa',
+            'cha',
+            'h5p',
+            'qf',
+            'olp',
+            'hyperesources',
+            'sparkle',
+            'razor',
+            'php4',
+            'cms',
+            'mml',
+            'jnlp',
+            'har',
+            'br',
+            'webloc',
+            'srf',
+            'cer',
+            'uhtml',
+            'pptmhtml',
+            'phtml',
+            'xbel',
+            'cfm',
+            'fwtemplateb',
+            'jspx',
+            'jsp',
+            'xfdl',
+            'zhtml',
+            'stml',
+            'jsonl',
+            'maff',
+            'dbm',
+            'aex',
+            'crl',
+            'mht',
+            'wml',
+            'sass',
+            'xht',
+            'awm',
+            'page',
+            'hdml',
+            'webmanifest',
+            'itms',
+            'sitemap',
+            'shtm',
+            'wpp',
+            'jss',
+            'oth',
+            'ucf',
+            'prf',
+            'freeway',
+            'edge',
+            'iqy',
+            'vrml',
+            'mvc',
+            'wdgt',
+            'discomap',
+            'psp',
+            'hxs',
+            'adr',
+            'hype',
+            'csp',
+            'xhtml',
+            'webarchive',
+            'qbo',
+            'jhtml',
+            'svc',
+            'phtm',
+            'rw3',
+            'tpl',
+            'stl',
+            'wbxml',
+            'p7',
+            'ndjson',
+            'ognc',
+            'fwtb',
+            'muse',
+            'vbd',
+            'sites',
+            'rt',
+            'esproj',
+            'private',
+            'srl',
+            'zhtml',
+            'vbhtml', 
+            'hypetemplate',
+            'obml15',
+            'hypesymbol',
+            'pub',
+            'ece',
+            'mspx',
+            'docmhtml',
+            'xws',
+            'wgp',
+            'tvpi',
+            'woa',
+            'asmx',
+            'xbl',
+            'webhistory',
+            'idc',
+            'jws',
+            'lbc',
+            'att',
+            'tvvi',
+            'zvz',
+            'php3',
+            'webarchivexml',
+            'widget',
+            'swz',
+            'qrm',
+            'bwp',
+            'atom',
+            'cdf',
+            'map',
+            'hdm',
+            'php5',
+            'rwsw',
+            'wgt',
+            'nod',
+            'rflw',
+            'htx',
+            'mvr',
+            'an',
+            'rwp',
+            'lasso',
+            'vlp',
+            'stp',
+            'nxg',
+            'faces',
+            'kcmsf',
+            'ptw',
+            'less',
+            'saveddeck',
+            'ccbjs',
+            'wn',
+            'ppthtml',
+            'jcz',
+            'jvs',
+            'rwtheme',
+            'jst',
+            'mapx',
+            'cpg',
+            'wpx',
+            'qbx',
+            'suck',
+            'iwdgt',
+            'public',
+            'cphd',
+            'moz',
+            'zfo',
+            'stm',
+            'fcgi',
+            'itpc',
+            'cfml'
         );",Update Files.php,"vuln-fix: Expand list of dangerous file extensions to block risky uploads

The application maintained an incomplete list of dangerous file extensions, allowing some potentially harmful files to bypass upload restrictions and be stored or executed.
This posed a security risk by enabling attackers to upload malicious scripts or executables, which could lead to remote code execution or unauthorized system access.
The fix extends the blocked extensions list with numerous additional high-risk file types to improve detection and prevent unsafe file uploads.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.11764705882352941,"[('update', 'ACTION', ''), ('files.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('remote code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('high', 'SEVERITY', ''), ('improve', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
111,CWE-79,GHSA-q73m-3q7r-fpf7,"@@ -325,7 +325,7 @@ public function isAllowedFilename($filename){
 		$allow_array = array(
 			'.jpg','.jpeg','.png','.bmp','.gif','.ico','.webp',
 			'.mp3','.wav','.m4a','.ogg','.webma','.mp4','.flv',
-			'.mov','.webmv','.m3u8a','.flac','.mkv',
+			'.mov','.webmv','.flac','.mkv',
 			'.zip','.tar','.gz','.tgz','.ipa','.apk','.rar','.iso','.bz2','.epub',
 			'.pdf','.ofd','.swf','.epub','.xps',
 			'.doc','.docx','.odt','.rtf','.docm','.dotm','.dot','.dotx','.wps','.wpt',","Merge pull request #1632 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Restrict allowed file extensions to prevent unsafe uploads

The file upload validation allowed the '.m3u8a' extension, which is not a standard media or document format and could be exploited to upload malicious files.
This posed a security risk by enabling attackers to bypass file type restrictions and potentially execute arbitrary code or deliver malware through crafted uploads.
The fix removes the unsupported '.m3u8a' extension from the allowed list, tightening validation to only permit recognized safe file types.

Weakness: CWE-434
Severity: High
CVSS: 7.5",0.23529411764705882,"[('#1632', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('malicious files', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('malware', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
112,"CWE-80', 'CWE-79', 'CWE-116",GHSA-vmhh-xh3g-j992,"@@ -287,7 +287,7 @@
       &lt;form action=""$doc.getURL()"" method=""post""&gt;
         &lt;input type=""hidden"" name=""form_token"" value=""$services.csrf.token"" /&gt;
         &lt;input type=""hidden"" name=""action"" value=""create""/&gt;
-        &lt;input type=""hidden"" name=""newThemeName"" id=""newThemeName"" value=""$request.newThemeName"" /&gt;
+        &lt;input type=""hidden"" name=""newThemeName"" id=""newThemeName"" value=""$escapetool.xml($request.newThemeName)"" /&gt;
         &lt;input type=""submit"" value=""$services.localization.render('platform.flamingo.themes.home.create.confirm')"" class=""button""/&gt;
       &lt;/form&gt;
     {{/html}}",XWIKI-19294: Fix bad escaping,"vuln-fix: Escape newThemeName input to prevent XML injection

The form included user input for newThemeName without escaping, allowing injection of malicious XML content into the rendered page.
This exposed the application to XML injection attacks that could manipulate page structure or execute unintended scripts in the client context.
The fix applies XML escaping to the newThemeName value before rendering it in the hidden input field, ensuring safe output encoding.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xml injection', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('xml injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('encoding', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
113,CWE-79,GHSA-c558-5gfm-p2r8,"@@ -196,7 +196,7 @@
                                 <input type=""text"" size=""50"" id=""query"" name=""query"" value=""<%= (query==null ? """" : Utils.addEntities(query)) %>""/>
                                 <input type=""submit"" id=""main-query-submit"" class=""btn btn-primary"" value=""<fmt:message key=""jsp.general.go""/>"" />
 <% if (StringUtils.isNotBlank(spellCheckQuery)) {%>
-	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%= spellCheckQuery %></a></fmt:param></fmt:message></p>
+	<p class=""lead""><fmt:message key=""jsp.search.didyoumean""><fmt:param><a id=""spellCheckQuery"" data-spell=""<%= Utils.addEntities(spellCheckQuery) %>"" href=""#""><%=Utils.addEntities(spellCheckQuery) %></a></fmt:param></fmt:message></p>
 <% } %>                  
                                 <input type=""hidden"" value=""<%= rpp %>"" name=""rpp"" />
                                 <input type=""hidden"" value=""<%= Utils.addEntities(sortedBy) %>"" name=""sort_by"" />","[DS-4453] Escape spellcheck, autocomplete HTML (JSPUI)","vuln-fix: Sanitize spell check query output to prevent XSS

The application rendered the spell check suggestion without properly escaping HTML entities, allowing injection of malicious scripts via crafted spellCheckQuery input.
This exposed users to cross-site scripting attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and potentially steal sensitive data or hijack sessions.
The fix applies HTML entity encoding to the displayed spell check query, ensuring any special characters are safely escaped before rendering in the page.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('steal', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('hijack', 'SECWORD', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('escaped', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
114,CWE-79,GHSA-gq77-3r6x-383w,"@@ -301,6 +301,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".svg"")
 			|| $isDangerStr($filename , "".htm"")
 			|| $isDangerStr($filename , ""%"")
+			|| $isDangerStr($filename , "".xml"")
 		) {
 			return true;
 		}",file upload bug,"vuln-fix: Block XML files in dangerous filename check

The filename validation function did not consider "".xml"" extensions as dangerous, allowing potentially harmful XML files to bypass security filters.
This omission exposed the system to risks such as XML External Entity (XXE) attacks or malicious XML payload processing.
The fix adds "".xml"" to the list of blocked extensions, preventing unsafe XML files from being accepted.

Weakness: CWE-611
Severity: High
CVSS: 7.5",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-611', 'CWEID', ''), ('high', 'SEVERITY', '')]"
115,CWE-79,GHSA-6346-5r4h-ff5x,"@@ -158,7 +158,7 @@ class=""btn btn-link btn-sm <?php if (isset($abandoned)): ?>font-weight-bold text
             $(document).ready(function () {
                 var searchOrdersByProduct = new mw.autoComplete({
                     element: ""#js-orders-search-by-products"",
-                    placeholder: ""<?php if ($productKeyword) { echo $productKeyword; } else { _e(""Search by products...""); }?>"",
+                    placeholder: ""<?php if ($productKeyword) { echo xss_clean($productKeyword); } else { _e(""Search by products...""); }?>"",
                     autoComplete:true,
                     ajaxConfig: {
                         method: 'get',",Update order_filtering.blade.php,"vuln-fix: Sanitize product keyword in autocomplete placeholder

The autocomplete input placeholder used unsanitized user-supplied product keywords directly in HTML, allowing injection of malicious scripts.
This exposed users to cross-site scripting (XSS) attacks where attackers could execute arbitrary JavaScript in the context of the affected page.
The fix applies xss_clean to sanitize the product keyword before rendering it in the placeholder attribute, preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', ''), ('order_filtering.blade.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('keyword', 'SECWORD', ''), ('unsanitized', 'SECWORD', ''), ('keywords', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('xss_clean', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('keyword', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
116,CWE-79,GHSA-6jp6-9rf9-gc66,"@@ -37,6 +37,7 @@
 from django.template.loader import render_to_string
 from django.urls import reverse
 from django.utils import timezone
+from django.utils.html import escape
 from django.utils.http import urlencode
 from django.utils.safestring import mark_safe
 from django.utils.translation import gettext
@@ -318,7 +319,7 @@ def render(self, name, value, attrs=None, renderer=None, **kwargs):
             # Render textare
             textarea = super().render(fieldname, val, attrs, renderer, **kwargs)
             # Label for plural
-            label = str(unit.translation.language)
+            label = escape(unit.translation.language)
             if len(values) != 1:
                 label = f""{label}, {plural.get_plural_label(idx)}""
             ret.append(","translate: Add missing escaping to language name

Fixes https://hackerone.com/reports/1486674","vuln-fix: Escape language label to prevent XSS in form rendering

The form rendering code inserted user-controllable language labels directly into HTML without escaping, allowing injection of malicious scripts.
This exposed the application to cross-site scripting (XSS) attacks where attackers could execute arbitrary JavaScript in users’ browsers.
The fix applies HTML escaping to the language label before rendering, ensuring unsafe characters are neutralized and scripts cannot run.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('add', 'ACTION', ''), ('escaping', 'secword', ''), ('fixes', 'ACTION', ''), ('https://hackerone.com/reports/1486674', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
117,CWE-79,GHSA-3x96-m42v-hvh5,"@@ -87,11 +87,13 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
+    $autoSize = xss_clean($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
         $type = $_GET['type'];
     }
+    $type = xss_clean($type);
 
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
@@ -403,7 +405,9 @@
                 if (mw.notification) {
                     mw.notification.success('<?php _ejs('Settings are saved') ?>');
                 }
+                <?php if (isset($params['id'])) : ?>
                 mw.reload_module_parent('#<?php print $params['id']  ?>')
+                <?php endif; ?>
 
             });
 
@@ -440,9 +444,11 @@
 <body class=""mw-external-loading loading"">
 <div id=""settings-main"">
     <div id=""settings-container"">
-        <div class=""mw-module-live-edit-settings <?php print $params['id'] ?>""
-             id=""module-id-<?php print $params['id'] ?>"">{content}
-        </div>
+        <?php if (isset($params['id'])) : ?>
+            <div class=""mw-module-live-edit-settings <?php print $params['id'] ?>""
+                 id=""module-id-<?php print $params['id'] ?>"">{content}
+            </div>
+        <?php endif; ?>
     </div>
 </div>",update,"vuln-fix: Sanitize GET parameters to prevent XSS in module settings

The code failed to sanitize user-supplied GET parameters before using them in the module settings interface, allowing injection of malicious scripts.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in users’ browsers and hijack sessions or steal data.
The fix applies xss_clean sanitization to critical GET inputs and conditionally renders HTML elements only when safe parameters are present, mitigating script injection risks.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('hijack', 'secword', ''), ('steal', 'secword', ''), ('fix', 'ACTION', ''), ('xss_clean', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('safe', 'secword', ''), ('mitigating', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
118,CWE-79,GHSA-cqhr-jqvc-qw9p,"@@ -365,7 +365,7 @@ void writeMessageIfNotNull(String message, String partToRedirectTo,
 		if (message != null) {
 			writeln(SCRIPT_BEGIN);
 			// writeDirectly pour ne pas gérer de traductions si le message contient '#'
-			writeDirectly(""alert(\"""" + javascriptEncode(message) + ""\"");"");
+			writeDirectly(""alert(\"""" + htmlEncodeButNotSpace(javascriptEncode(message)) + ""\"");"");
 			writeln("""");
 			// redirect vers une url évitant que F5 du navigateur ne refasse l'action au lieu de faire un refresh
 			if (partToRedirectTo == null) {",fix XSS,"vuln-fix: Encode alert message to prevent XSS injection

The code directly injected user-controlled messages into JavaScript alert calls without proper HTML encoding, allowing injection of malicious scripts.
This created a cross-site scripting (XSS) risk where attackers could execute arbitrary JavaScript in users’ browsers, compromising session integrity and data confidentiality.
The fix applies HTML encoding alongside JavaScript encoding to sanitize message content, preventing script injection via alert dialogs.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encode', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('sanitize', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
119,CWE-79,GHSA-3r95-23jp-mhvg,"@@ -513,10 +513,10 @@ function factory($, Helper, Icons) {
      */
     function setStageHeadline(title) {
       if (getUtility().isUndefinedOrNull(title)) {
-        title = buildTitleByFormElement();
+        title = buildTitleByFormElement().text();
       }
 
-      $(getHelper().getDomElementDataIdentifierSelector('stageHeadline')).html(title);
+      $(getHelper().getDomElementDataIdentifierSelector('stageHeadline')).text(title);
     };
 
     /**
@@ -981,10 +981,10 @@ function factory($, Helper, Icons) {
 
       getHelper()
         .getTemplatePropertyDomElement('_type', template)
-        .append(getFormElementDefinition(formElement, 'label'));
+        .append(document.createTextNode(getFormElementDefinition(formElement, 'label')));
       getHelper()
         .getTemplatePropertyDomElement('_identifier', template)
-        .append(formElement.get('identifier'));
+        .append(document.createTextNode(formElement.get('identifier')));
     };
 
     /**
@@ -1029,7 +1029,7 @@ function factory($, Helper, Icons) {
 
             getHelper()
               .getTemplatePropertyDomElement('_label', rowTemplate)
-              .append(collectionElementConfiguration['label']);
+              .append(document.createTextNode(collectionElementConfiguration['label']));
             $(getHelper().getDomElementDataIdentifierSelector('validatorsContainer'), $(template))
               .append(rowTemplate.html());
           }
@@ -1089,7 +1089,7 @@ function factory($, Helper, Icons) {
           }
         }
 
-        getHelper().getTemplatePropertyDomElement('_label', rowTemplate).append(label);
+        getHelper().getTemplatePropertyDomElement('_label', rowTemplate).append(document.createTextNode(label));
 
         if (isPreselected) {
           getHelper().getTemplatePropertyDomElement('_label', rowTemplate).addClass(","[SECURITY] Ensure text preview of multivalue items in form editor

Multivalue items in the form editor user interface were previewed
as HTML, but should be treated as scalar text only.

Resolves: #96743
Releases: main, 11.5, 10.4
Change-Id: I5e8dab26119490ecf19ac5d48c2bc7a5a00daaad
Security-Bulletin: TYPO3-CORE-SA-2022-003
Security-References: CVE-2022-31048
Reviewed-on: https://review.typo3.org/c/Packages/TYPO3.CMS/+/73297
Tested-by: Oliver Hader <oliver.hader@typo3.org>
Reviewed-by: Oliver Hader <oliver.hader@typo3.org>","vuln-fix: Prevent XSS by escaping dynamic HTML content

The code inserted user-controllable strings directly into the DOM using html() or append(), allowing injection of malicious HTML or scripts.
This exposed the application to cross-site scripting (XSS) attacks where attackers could execute arbitrary JavaScript in users’ browsers.
The fix replaces unsafe HTML insertion with text nodes and text() methods to properly escape content and prevent script execution.

Weakness: CWE-79  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('security', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('#96743', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('escape', 'secword', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
120,CWE-79,GHSA-jp6r-xcjj-5h7r,"@@ -79,7 +79,7 @@ class TextEncodingBruteForce extends Operation {
         let table = ""<table class='table table-hover table-sm table-bordered table-nonfluid'><tr><th>Encoding</th><th>Value</th></tr>"";
 
         for (const enc in encodings) {
-            const value = Utils.printable(encodings[enc], true);
+            const value = Utils.escapeHtml(Utils.printable(encodings[enc], true));
             table += `<tr><td>${enc}</td><td>${value}</td></tr>`;
         }",Fixed XSS in 'Text Encoding Brute Force. Closes #539,"vuln-fix: Escape HTML output in encoding brute force table

The encoding brute force operation rendered user-controllable encoding values without escaping, allowing injection of malicious HTML or scripts into the output table.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in the victim’s browser context.
The fix applies HTML escaping to all encoding values before insertion into the table, preventing injection of executable code.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('fixed', 'ACTION', ''), ('xss', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('#539', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'secword', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
121,CWE-79,GHSA-rxch-gp62-574w,"@@ -170,7 +170,7 @@ public function transformAssignedTo($asset)
         }
         return $asset->assigned ? [
             'id' => $asset->assigned->id,
-            'name' => $asset->assigned->display_name,
+            'name' => e($asset->assigned->display_name),
             'type' => $asset->assignedType()
         ] : null;
     }","Added escape to assigned_to API response

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Escape assigned display name to prevent XSS

The code returned user-controlled display names without escaping, allowing injection of malicious HTML or scripts in rendered output.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in victims’ browsers.
The fix applies proper escaping to the display name before output, ensuring unsafe characters are neutralized.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.17647058823529413,"[('added', 'ACTION', ''), ('escape', 'SECWORD', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
122,CWE-79,GHSA-6465-r752-2h8v,"@@ -24,6 +24,7 @@
 use FacturaScripts\Core\Base\DataBase\DataBaseWhere;
 use FacturaScripts\Core\Lib\Widget\VisualItemLoadEngine;
 use FacturaScripts\Dinamic\Model\CodeModel;
+use FacturaScripts\Dinamic\Model\Page;
 use FacturaScripts\Dinamic\Model\PageOption;
 use FacturaScripts\Dinamic\Model\User;
 use Symfony\Component\HttpFoundation\Response;
@@ -121,7 +122,7 @@ public function privateCore(&$response, $user, $permissions)
         parent::privateCore($response, $user, $permissions);
         $this->model = new PageOption();
         $this->loadSelectedViewName();
-        $this->backPage = $this->request->get('url') ?: $this->selectedViewName;
+        $this->setBackPage();
         $this->selectedUser = $this->user->admin ? $this->request->get('nick') : $this->user->nick;
         $this->loadPageOptions();
 
@@ -275,6 +276,22 @@ private function loadPageOptionsForUser(): bool
         return true;
     }
 
+    private function setBackPage()
+    {
+        // check if the url is a real controller name
+        $url = $this->request->get('url', '');
+        $pageModel = new Page();
+        foreach ($pageModel->all([], [], 0, 0) as $page) {
+            if (substr($url, 0, strlen($page->name)) === $page->name) {
+                $this->backPage = $url;
+                return;
+            }
+        }
+
+        // set the default back page
+        $this->backPage = $this->selectedViewName;
+    }
+
     /**
      * @param array $column
      * @param string $name","We check the url parameter of the link to ensure that it is a valid controller.
------
Comprobamos el parámetro url del enlace para asegurar que sea un controlador válido.","vuln-fix: Validate backPage parameter to prevent open redirect

The application assigned the backPage URL directly from user input without verifying it matched a valid controller name.
This allowed attackers to craft URLs that redirect users to arbitrary external sites, enabling phishing or other malicious redirections.
The fix adds validation against known page names and defaults to a safe internal page if the input is invalid, preventing open redirect attacks.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.11764705882352941,"[('ensure', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('open redirect', 'secword', ''), ('attackers', 'SECWORD', ''), ('phishing', 'secword', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('open redirect', 'secword', ''), ('attacks', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
123,CWE-79,GHSA-2gqg-2rg7-gh33,"@@ -118,8 +118,8 @@ private function formatMessage($message)
         return [
             'severity'  => $this->severityLabel($level),
             'timestamp' => $displayTime,
-            'source'    => $device ? Url::deviceLink($device) : $message['message']['source'],
-            'message'   => $message['message']['message'] ?? '',
+            'source'    => $device ? Url::deviceLink($device) : htmlspecialchars($message['message']['source']),
+            'message'   => htmlspecialchars($message['message']['message'] ?? ''),
             'facility'  => is_numeric($facility) ? ""($facility) "" . __(""syslog.facility.$facility"") : $facility,
             'level'     => (is_numeric($level) && $level >= 0) ? ""($level) "" . __(""syslog.severity.$level"") : $level,
         ];",fix graylog xss (#13931),"vuln-fix: Sanitize log message fields to prevent XSS

The log formatting function did not escape user-supplied message and source fields before rendering, allowing injection of malicious HTML or scripts.
This exposed users viewing logs to cross-site scripting attacks, potentially leading to session hijacking or unauthorized actions within the application.
The fix applies htmlspecialchars to these fields, ensuring special characters are safely encoded and preventing script execution in log views.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('xss', 'secword', ''), ('#13931', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
124,CWE-79,GHSA-8c76-mxv5-w4g8,"@@ -6,18 +6,30 @@
 
 class SaveOptionApiController
 {
-    public function saveOption(Request $request) {
+    public $whitelistedGroupKeys = [
+        'website' => [
+            'website_head',
+            'website_footer'
+        ]
+    ];
+
+    public function saveOption(Request $request)
+    {
 
         $cleanFromXss = true;
         $option = $request->all();
 
-        // Allow for this keys
+        // Allow for this keys and groups
         if (isset($option['option_key'])) {
-            if ($option['option_key'] == 'website_head') {
-                $cleanFromXss = false;
-            }
-            if ($option['option_key'] == 'website_footer') {
-                $cleanFromXss = false;
+            foreach ($this->whitelistedGroupKeys as $group => $keys) {
+                if ($option['option_group'] == $group) {
+                    foreach ($keys as $key) {
+                        if ($option['option_key'] == $key) {
+                            $cleanFromXss = false;
+                            break;
+                        }
+                    }
+                }
             }
         }",Update SaveOptionApiController.php,"vuln-fix: Restrict XSS cleaning exceptions to whitelisted option keys

The saveOption API previously disabled XSS cleaning for specific option keys without verifying their group context, allowing broader bypass of input sanitization.
This flaw risked injection of malicious scripts through unvalidated inputs in unintended option groups, increasing the attack surface for cross-site scripting.
The fix introduces a whitelist mapping option groups to allowed keys, ensuring XSS cleaning is only disabled for explicitly approved key-group pairs.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('update', 'ACTION', ''), ('saveoptionapicontroller.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('xss', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('xss', 'secword', ''), ('keys', 'SECWORD', ''), ('bypass', 'secword', ''), ('sanitization', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('unvalidated inputs', 'SECWORD', ''), ('attack surface', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('xss', 'secword', ''), ('key', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
125,CWE-79,GHSA-rp34-85x3-3764,"@@ -34,10 +34,10 @@
 $status = 'ok';
 $message = '';
 
-$transport_id = $vars['transport_id'];
-$name = $vars['name'];
+$transport_id = strip_tags($vars['transport_id']);
+$name = strip_tags($vars['name']);
 $is_default = (int) (isset($vars['is_default']) && $vars['is_default'] == 'on');
-$transport_type = $vars['transport-type'];
+$transport_type = strip_tags($vars['transport-type']);
 
 if (empty($name)) {
     $status = 'error';","security - XSS Fix 01

fixing https://huntr.dev/bounties/114ba055-a2f0-4db9-aafb-95df944ba177/ (#13775)","vuln-fix: Sanitize transport input fields to prevent XSS

The code accepted user input for transport fields without removing HTML tags, allowing injection of malicious scripts into the application.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary JavaScript in victims’ browsers and steal sensitive data.
The fix applies strip_tags to sanitize transport_id, name, and transport_type inputs, removing HTML tags before further processing.

Weakness: CWE-79  
Severity: Medium  
CVSS: 5.4",0.17647058823529413,"[('security', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixing', 'ACTION', ''), ('https://huntr.dev/bounties/114ba055-a2f0-4db9-aafb-95df944ba177/', 'URL', ''), ('#13775', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('transport', 'secword', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('transport', 'secword', ''), ('removing', 'ACTION', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('removing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
126,"CWE-79', 'CWE-116",GHSA-xjfw-5vv5-vjq2,"@@ -58,9 +58,9 @@
       &lt;dd&gt;
         ## TODO: design a real framework to generate form by type
         #if (($descriptor.defaultValue || ""$!descriptor.defaultValue"" != '') &amp;&amp; ($descriptor.type.getName() == 'boolean' || $descriptor.type.getName() == 'int' || $descriptor.type.getName() == 'java.lang.String'))
-          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId"" value=""#if($request.get($descriptorId))$request.get($descriptorId)#else$descriptor.defaultValue#end""/&gt;
+          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId"" value=""#if($request.get($descriptorId))$escapetool.xml($request.get($descriptorId))#else$descriptor.defaultValue#end""/&gt;
         #else
-          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId""#if($request.get($descriptorId))value=""$request.get($descriptorId)""#end/&gt;
+          &lt;input type=""text"" id=""$descriptorId"" name=""$descriptorId""#if($request.get($descriptorId))value=""$escapetool.xml($request.get($descriptorId))""#end/&gt;
         #end
       &lt;/dd&gt;
     #end",XWIKI-19293: Fix bad escaping,"vuln-fix: Escape user input in form fields to prevent XSS

User-supplied input was directly injected into HTML form input values without proper escaping, allowing injection of malicious HTML or script code.
This exposed the application to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in users’ browsers and steal sensitive data.
The fix applies XML escaping to all user inputs rendered in form fields, ensuring special characters are safely encoded and preventing script injection.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', ''), ('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'secword', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
127,CWE-79,GHSA-qq74-vgcf-54c3,"@@ -311,6 +311,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".asa"")
 			|| $isDangerStr($filename , "".cshtml"")
 			|| $isDangerStr($filename , "".axd"")
+			|| $isDangerStr($filename , ""htm"")
 		) {
 			return true;
 		}",bug,"vuln-fix: Block .htm extension in dangerous filename check

The filename validation function did not consider files with the "".htm"" extension as dangerous, allowing potentially harmful files to bypass security filters.
This omission could enable attackers to upload or execute malicious HTML files, leading to cross-site scripting or unauthorized content delivery.
The fix adds "".htm"" to the list of disallowed extensions, enhancing filename validation to prevent risky file handling.

Weakness: CWE-434
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('bug', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
128,CWE-79,GHSA-gx6h-936c-vrrr,"@@ -45,7 +45,7 @@
       <div>
         <input type=""hidden"" name=""form_token"" value=""$!services.csrf.token"" />
         <input type=""hidden"" name=""register"" value=""1"" />
-        <input type=""hidden"" name=""xredirect"" value=""$!request.xredirect"" />
+        <input type=""hidden"" name=""xredirect"" value=""$escapetool.xml($!request.xredirect)"" />
         #set ($class = $xwiki.getClass('XWiki.XWikiUsers'))
         #set ($obj = $class.newObject())
         #set ($serverobj = $class.newObject())","XWIKI-19291: redirect parameter is badly handled in register page

  * Fix the typo","vuln-fix: Escape xredirect parameter to prevent XML injection

The xredirect parameter was directly embedded into a hidden input field without escaping, allowing injection of malicious XML or HTML content.
This posed a security risk by enabling cross-site scripting (XSS) or markup injection attacks that could manipulate page structure or execute arbitrary scripts.
The fix applies XML escaping to the xredirect value before rendering it in the input field, ensuring special characters are safely encoded.

Weakness: CWE-79
Severity: Medium
CVSS: 5.4",0.17647058823529413,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xml injection', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
129,CWE-79,GHSA-ff28-f46g-r9g8,"@@ -314,6 +314,7 @@ func runWeb(c *cli.Context) error {
 				}
 				defer fr.Close()
 
+				c.Header().Set(""Content-Security-Policy"", ""default-src 'none'; style-src 'unsafe-inline'; sandbox"")
 				c.Header().Set(""Cache-Control"", ""public,max-age=86400"")
 				c.Header().Set(""Content-Disposition"", fmt.Sprintf(`inline; filename=""%s""`, attach.Name))",attachment: set CSP header in the serving endpoint (#6926),"vuln-fix: Add Content-Security-Policy header to web responses

The web server responses lacked a Content-Security-Policy header, allowing browsers to execute potentially unsafe scripts or styles from untrusted sources.
This exposed users to cross-site scripting (XSS) and other injection attacks by permitting malicious content to run in the context of the web application.
The patch adds a restrictive Content-Security-Policy header that disables all content by default, allows only inline styles, and enables sandboxing to mitigate script execution risks.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.058823529411764705,"[('csp header', 'SECWORD', ''), ('#6926', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('security', 'secword', ''), ('server', 'SECWORD', ''), ('security', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('untrusted sources', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('security', 'SECWORD', ''), ('mitigate', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
130,CWE-79,GHSA-74qp-233x-p5j8,"@@ -15,13 +15,17 @@
  * limitations under the License.
  */
 
+function escapeHtml(unescapedText) {
+  return $(""<div>"").text(unescapedText).html()
+}
+
 function loadSessionsTable(sessions) {
   $.each(sessions, function(index, session) {
     $(""#interactive-sessions .sessions-table-body"").append(
       ""<tr>"" +
         tdWrap(uiLink(""session/"" + session.id, session.id)) +
         tdWrap(appIdLink(session)) +
-        tdWrap(session.name) +
+        tdWrap(escapeHtml(session.name)) +
         tdWrap(session.owner) +
         tdWrap(session.proxyUser) +
         tdWrap(session.kind) +
@@ -38,7 +42,7 @@ function loadBatchesTable(sessions) {
       ""<tr>"" +
         tdWrap(session.id) +
         tdWrap(appIdLink(session)) +
-        tdWrap(session.name) +
+        tdWrap(escapeHtml(session.name)) +
         tdWrap(session.owner) +
         tdWrap(session.proxyUser) +
         tdWrap(session.state) +
@@ -79,4 +83,4 @@ $(document).ready(function () {
       $(""#all-sessions"").append('<h4>No Sessions or Batches have been created yet.</h4>');
     }
   });
-});
\ No newline at end of file
+});","Add html escape to session name

## What changes were proposed in this pull request?

The PR adds HTML escaping to session names.

## How was this patch tested?

Manual test.

Author: Marco Gaido <mgaido@apache.org>

Closes #302 from mgaido91/escape_html.","vuln-fix: Escape HTML in session and batch names to prevent XSS

The application rendered session and batch names directly into HTML without escaping, allowing injection of malicious HTML or scripts by attackers.
This exposed users to cross-site scripting (XSS) attacks, enabling execution of arbitrary JavaScript in their browsers and potential session hijacking or data theft.
The fix introduces proper HTML escaping of these fields before insertion into the DOM, neutralizing embedded scripts and preventing XSS.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.17647058823529413,"[('add', 'ACTION', ''), ('escape', 'secword', ''), ('changes', 'ACTION', ''), ('adds', 'ACTION', ''), ('escaping', 'secword', ''), ('patch', 'ACTION', ''), ('manual', 'DETECTION', ''), ('mgaido@apache.org', 'EMAIL', ''), ('#302', 'ISSUE', ''), ('escape_html', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('escaping', 'secword', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('cross-site scripting', 'secword', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('hijacking', 'SECWORD', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('xss', 'secword', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
131,CWE-79,GHSA-c7pp-g2v2-2766,"@@ -891,10 +891,8 @@ var Gmail_ = function(localJQuery) {
                 endIndex = (parseInt(dataLength, 10) - 2) + response.indexOf(""["");
                 data = response.substring(response.indexOf(""[""), endIndex);
 
-                var get_data = new Function(""\""use strict\""; return "" + data);
-                realData = get_data();
-
-                parsedResponse.push(realData);
+                var json = JSON.parse(data);
+                parsedResponse.push(json);
 
                 // prepare response for next loop
                 response = response.substring(response.indexOf(""[""), response.length);
@@ -1684,11 +1682,9 @@ var Gmail_ = function(localJQuery) {
             return emails;
         }
 
-        get_data = get_data.substring(get_data.indexOf(""[""), get_data.length);
-        get_data = ""\""use strict\""; return "" + get_data;
-        get_data = new Function(get_data);
-
-        api.tracker.view_data = get_data();
+        var data = get_data.substring(get_data.indexOf(""[""), get_data.length);
+        var json = JSON.parse(data);
+        api.tracker.view_data = json;
 
         for(var i in api.tracker.view_data) {
             if (typeof(api.tracker.view_data[i]) === ""function"") {
@@ -1934,13 +1930,10 @@ var Gmail_ = function(localJQuery) {
         if (!get_data) {
             return {};
         }
-        get_data = get_data.substring(get_data.indexOf(""[""), get_data.length);
-        get_data = ""\""use strict\""; return "" + get_data;
-        get_data = new Function(get_data);
-
-        var cdata = get_data();
+        var data = get_data.substring(get_data.indexOf(""[""), get_data.length);
+        var json = JSON.parse(data);
 
-        api.tracker.email_data = cdata[0];
+        api.tracker.email_data = json[0];
         return api.tools.parse_email_data(api.tracker.email_data);
     };",Replace new Function() with JSON.parse(),"vuln-fix: Replace unsafe dynamic code execution with JSON parsing

The code used dynamic Function constructors to evaluate string data as JavaScript, enabling execution of arbitrary code from untrusted input.
This posed a critical security risk by allowing attackers to inject and run malicious scripts, leading to remote code execution within the application context.
The fix replaces dynamic evaluation with safe JSON.parse calls, ensuring only valid JSON data is processed without executing arbitrary code.

Weakness: CWE-95
Severity: Critical
CVSS: 9.8",0.11764705882352941,"[('json.parse', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('untrusted', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('malicious', 'SECWORD', ''), ('remote code execution', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('json.parse', 'URL', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-95', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
132,CWE-79,GHSA-c558-5gfm-p2r8,"@@ -141,7 +141,7 @@
 									tmp_val = item.displayedValue;
 								}
 								return {
-									label: item.displayedValue + "" ("" + item.count + "")"",
+									label: escapeHtml(item.displayedValue) + "" ("" + item.count + "")"",
 									value: tmp_val
 								};
 							}))			
@@ -153,7 +153,12 @@
 	function validateFilters() {
 		return document.getElementById(""filterquery"").value.length > 0;
 	}
-</script>		
+	// Generic HTML escape utility
+	var escapeHtml = s => (s + '').replace(/[&<>""']/g, m => ({
+		'&': '&amp;', '<': '&lt;', '>': '&gt;',
+		'""': '&quot;', ""'"": '&#39;'
+	})[m]);
+</script>
 </c:set>
 
 <dspace:layout titlekey=""jsp.search.title"">",[DS-4453] Discovery autocomplete HTML escaping (JSPUI),"vuln-fix: Escape HTML in filter labels to prevent XSS

The filter label rendering code directly inserted user-controlled values into HTML without escaping, allowing injection of malicious scripts.
This exposed users to cross-site scripting attacks where attackers could execute arbitrary JavaScript in victims’ browsers, compromising session and data security.
The fix adds a generic HTML escape function to sanitize displayed values before insertion, preventing script injection via filter labels.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('escaping', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'secword', ''), ('escaping', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('escape', 'secword', ''), ('sanitize', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
133,CWE-79,GHSA-gj85-pvp5-mvf9,"@@ -19,7 +19,7 @@ function autoload_class($class) {
 require_once dirname(__FILE__) . '/../config.php';
 require_once dirname(__FILE__) . '/../src/Storage.php';
 
-$GLOBALS['server'] = !empty($_GET['server']) ? $_GET['server'] : '';
+$GLOBALS['server'] = !empty($_GET['server']) ? htmlspecialchars($_GET['server']) : '';
 $GLOBALS['action'] = !empty($_GET['action']) ? $_GET['action'] : '';
 $GLOBALS['state'] = !empty($_GET['state']) ? $_GET['state'] : '';
 $GLOBALS['count'] = !empty($_GET['count']) ? $_GET['count'] : '';",Sanitize input,"vuln-fix: Sanitize server parameter to prevent XSS attacks

The application directly assigned the 'server' GET parameter to a global variable without sanitization, allowing injection of malicious HTML or JavaScript code.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to execute arbitrary scripts in victims' browsers and steal sensitive data or hijack sessions.
The fix applies htmlspecialchars to the 'server' parameter, encoding special characters and preventing script injection through this input.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.11764705882352941,"[('sanitize', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('server', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('server', 'secword', ''), ('sanitization', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('sensitive data', 'secword', ''), ('hijack', 'secword', ''), ('fix', 'ACTION', ''), ('htmlspecialchars', 'SECWORD', ''), ('server', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
134,CWE-79,GHSA-3j9m-hcv9-rpj8,"@@ -40,5 +40,5 @@ export function escapeHtml(str: string): string {
 }
 
 export function sanitizeAngularInterpolation(url: string): string {
-  return url.replace('{{', '%7B%7B').replace('}}', '%7D%7D');
+  return url.replaceAll('{{', '%7B%7B').replaceAll('}}', '%7D%7D');
 }

From: Dan Cech <dcech@grafana.com>

 packages/grafana-data/src/text/sanitize.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -40,5 +40,5 @@ export function escapeHtml(str: string): string {
 }
 
 export function sanitizeAngularInterpolation(url: string): string {
-  return url.replaceAll('{{', '%7B%7B').replaceAll('}}', '%7D%7D');
+  return url.replace(/\{\{/g, '%7B%7B').replace(/\}\}/g, '%7D%7D');
 }","Merge pull request #151 from grafana/dcech/sanitize-replaceAll

use global replace when sanitizing urls in 8.2.3","vuln-fix: Correct Angular interpolation sanitization to prevent injection

The sanitization function used replaceAll without escaping special characters, causing incomplete replacement of Angular interpolation patterns in URLs.
This allowed attackers to inject unsanitized template expressions, potentially leading to client-side template injection or XSS attacks.
The fix replaces replaceAll with global regex replace calls to ensure all interpolation delimiters are properly encoded and neutralized.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.17647058823529413,"[('#151', 'ISSUE', ''), ('sanitize', 'SECWORD', ''), ('sanitizing', 'secword', ''), ('8.2.3', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitization', 'secword', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('escaping', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('unsanitized', 'SECWORD', ''), ('injection', 'secword', ''), ('xss', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
135,CWE-79,GHSA-hm45-mgqm-gjm4,"@@ -72,6 +72,7 @@ <h1>{{ _('Loading servers...') }}</h1>
                 } else {
                     var base_guild_url = ""{{ url_for('home_blueprint.guild', guild='123456789123456789') }}""
                     $(""#serverrow"").html("""")
+                    let counter = 0
                     for (let g of json.data) {
                         var current_guild_url = base_guild_url.replace(""123456789123456789"", g.id)
                         $(""#serverrow"").append(`
@@ -80,13 +81,16 @@ <h1>{{ _('Loading servers...') }}</h1>
                                     <div class=""card h-100"" onmouseover=""playGif(this)"" onmouseout=""stopGif(this)"">
                                         <img class=""card-img-top"" src=""${g.icon}png"" alt=""Card image cap"" data-src-url=""${g.icon}"" data-is-animated=${g.animated}>
                                         <div class=""card-body"">
-                                            <h5 class=""card-title"">${g.name}</h5>
-                                            <p class=""card-text"">Owner: ${g.owner}</p>
+                                            <h5 class=""card-title"" id=""guild-counter-${counter}"">Loading...</h5>
+                                            <p class=""card-text"" id=""owner-counter-${counter}"">Owner: Loading...</p>
                                         </div>
                                     </div>
                                 </a>
                             </div>
                         `)
+                        $(`#guild-counter-${counter}`).text(g.name)
+                        $(`#owner-counter-${counter}`).text(g.owner)
+                        counter += 1
                     }
                 }
             }",Fix unformatted HTML,"vuln-fix: Prevent XSS by avoiding direct HTML injection of unescaped data

The code directly injected unescaped user-controlled guild names and owner fields into HTML, allowing malicious scripts to execute in the client browser.
This exposed users to cross-site scripting (XSS) attacks, enabling attackers to steal session data or perform actions on behalf of victims.
The fix defers setting text content via safe DOM text methods instead of direct HTML interpolation, preventing script injection.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('unescaped', 'SECWORD', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('steal', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
136,CWE-79,GHSA-c53x-wwx2-pg96,"@@ -21,7 +21,7 @@ const liljs = (elem, data = {}) => {
      * @param {String} property Name of the property to render
      * @param {String} value (Optional) A value to use instead of a property (used in lil-list-text)
      */
-    const setText = (elem, property, value) => elem.innerHTML = value || state[property].value;
+    const setText = (elem, property, value) => elem.textContent = value || state[property].value;
 
     /** Set style helper function
      * @function setStyle
@@ -43,7 +43,7 @@ const liljs = (elem, data = {}) => {
      */
     const setList = (elem, property) => {
       //TODO: Find a way to update without clearing lists
-      elem.innerHTML = """";
+      elem.textContent = """";
       state[property].value.forEach(value => {
         let clone = document.importNode(state[property].template.content, true);
         clone.querySelectorAll(""[lil-list-text]"").forEach(node => {","Use textContent over innerHTML so you can bind untrusted text values
without the possibility of an XSS attack.","vuln-fix: Replace innerHTML with textContent to prevent XSS

The code used innerHTML to set text content from state or input, allowing injection of malicious HTML or scripts into the DOM.
This exposed the application to cross-site scripting (XSS) attacks where attackers could execute arbitrary JavaScript in users’ browsers.
The fix replaces innerHTML assignments with textContent to safely insert text without interpreting it as HTML.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.17647058823529413,"[('untrusted', 'secword', ''), ('xss', 'SECWORD', ''), ('attack', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
137,CWE-79,GHSA-vhm6-gw82-6f8j,"@@ -62,7 +62,7 @@
                             echo ""
                                 <tr>
                                     <td>{$rule['name']}</td>
-                                    <td><i>"" . htmlentities($rule_display) . ""</i></td>
+                                    <td><i>"" . htmlentities(strip_tags($rule_display)) . ""</i></td>
                                     <td>{$rule['severity']}</td>
                                     <td>{$rule['id']}</td>
                                 </tr>",Resolved XSS issue from alert rule list modal (#13805),"vuln-fix: Sanitize rule display output to prevent XSS

The application outputted rule display content without removing embedded HTML tags, allowing malicious scripts to be injected and executed in users' browsers.
This exposed users to cross-site scripting attacks, risking session hijacking, data theft, or unauthorized actions within the application context.
The fix applies strip_tags before htmlentities to remove HTML tags, ensuring that only safe text is encoded and rendered.

Weakness: CWE-79  
Severity: High  
CVSS: 7.4",0.058823529411764705,"[('xss', 'SECWORD', ''), ('issue', 'FLAW', ''), ('#13805', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sanitize', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('removing', 'ACTION', ''), ('malicious', 'SECWORD', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('hijacking', 'SECWORD', ''), ('theft', 'secword', ''), ('fix', 'ACTION', ''), ('htmlentities', 'SECWORD', ''), ('remove', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('encoded', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
138,CWE-79,GHSA-mw75-qvfr-hpmr,"@@ -303,6 +303,7 @@ public function isDangerFilename($filename){
 			|| $isDangerStr($filename , "".shtm"")
 			|| $isDangerStr($filename , ""%"")
 			|| $isDangerStr($filename , "".xml"")
+			|| $isDangerStr($filename , "".xxhtml"")
 		) {
 			return true;
 		}
@@ -312,4 +313,4 @@ public function isDangerFilename($filename){
 
 
 
-}
\ No newline at end of file
+}","Merge pull request #1628 from ajaysenr/master

Update AttachmentModel.class.php","vuln-fix: Extend dangerous filename checks to include .xxhtml extension

The filename validation function did not consider files with the .xxhtml extension as dangerous, allowing potentially unsafe files to bypass security filters.
This omission could enable attackers to upload or serve malicious files disguised with this extension, leading to unauthorized code execution or data exposure.
The fix adds .xxhtml to the list of dangerous filename patterns, improving input validation and preventing unsafe file handling.

Weakness: CWE-434
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('#1628', 'ISSUE', ''), ('update', 'ACTION', ''), ('attachmentmodel.class.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('bypass', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious files', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('data exposure', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('improving', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
139,CWE-79,GHSA-h3vq-wv8j-36gw,"@@ -50,8 +50,21 @@ module.exports = function (svgString) {
     // Empty script tags and javascript executing
     svgString = svgString.replace(/<script[\s\S]*>[\s\S]*<\/script>/, '<script></script>');
     
-    // Remove error handlers
-    svgString = svgString.replace(/onerror=[\s\S]*['""].*?['""]/i, '');
+    // Remove event handlers
+    const eventNames = [
+        'onbegin', 'onend', 'onrepeat', 'onabort', 'onerror', 'onresize', 'onscroll', 'onunload', 'oncopy',
+        'oncut', 'onpaste', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose',
+        'oncuechange', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragexit', 'ondragleave',
+        'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onloadeddata', 'onloadedmetadata',
+        'onloadstart', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove',
+        'onemptied', 'onended', 'onerror', 'onfocus', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress',
+        'onkeyup', 'onload', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpause', 'onplay',
+        'onplaying', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onseeked', 'onseeking',
+        'onselect', 'onshow', 'onstalled', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onvolumechange',
+        'onwaiting', 'onactivate', 'onfocusin', 'onfocusout'
+    ];
+    const eventsRegex = new RegExp(`(${eventNames.join('|')})\\s*=\\s*['""].*['""]`, 'i');
+    svgString = svgString.replace(eventsRegex, '');
 
     return svgString;
 };",Remove lots of event handlers,"vuln-fix: Remove all event handler attributes from SVG input

The SVG sanitizer only removed onerror attributes, leaving many other event handler attributes intact that could execute malicious JavaScript.
This allowed attackers to embed harmful scripts in SVGs via various event handlers, leading to cross-site scripting (XSS) vulnerabilities when rendered.
The fix expands removal to a comprehensive list of event handler attributes, stripping them all to prevent script execution from SVG content.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('remove', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('sanitizer', 'SECWORD', ''), ('removed', 'ACTION', ''), ('onerror', 'FLAW', ''), ('malicious', 'secword', ''), ('attackers', 'FLAW', ''), ('cross-site scripting', 'SECWORD', ''), ('xss', 'secword', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
140,CWE-79,GHSA-q6mp-562x-ggvv,"@@ -1154,11 +1154,11 @@ function get_allowed_files_extensions_for_upload($fileTypes = 'images', $returnA
                 break;
             case 'file':
             case 'files':
-                $are_allowed .= ',css,json,zip,gzip,csv,7z';
+                $are_allowed .= ',css,json,zip,gzip,psd,csv,7z';
                 break;
             case 'documents':
             case 'doc':
-                $are_allowed .= ',doc,docx,pdf,odt,pages,rtf,txt,pps,ppt,pptx,xls,xlsx';
+                $are_allowed .= ',doc,docx,pdf,odt,rtf,txt,pps,ppt,pptx,xls,xlsx';
                 break;
             case 'archives':
             case 'arc':",update,"vuln-fix: Restrict allowed file upload extensions to prevent unsafe types

The file upload handler included potentially unsafe file types like PSD in allowed extensions without proper validation, increasing risk of malicious file uploads.
This could enable attackers to upload harmful files that might be executed or exploited on the server, leading to remote code execution or data compromise.
The fix removes risky extensions from the allowed list, tightening upload restrictions to only safe, validated file types.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.11764705882352941,"[('update', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'secword', ''), ('unsafe', 'SECWORD', ''), ('malicious file', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('server', 'secword', ''), ('remote code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,CWE-400,GHSA-rhcw-wjcm-9h6g,"@@ -230,9 +230,15 @@ public Resource getResource(final String p) {
                 log.tracef(""Failed to get path resource %s from path resource manager with base %s, as the path did not exist"", p, base);
                 return null;
             }
-        } catch (Exception e) {
+        } catch (IOException e) {
             UndertowLogger.REQUEST_LOGGER.debugf(e, ""Invalid path %s"", p);
             return null;
+        } catch (SecurityException e) {
+            UndertowLogger.REQUEST_LOGGER.errorf(e, ""Missing JSM permissions for path %s"", p);
+            throw e;
+        } catch (Exception e) {
+            UndertowLogger.REQUEST_LOGGER.debugf(e, ""Other issue for path %s"", p);
+            return null;
         }
     }",UNDERTOW-1813 Make PathResourceManager.getResource rethrow a SecurityException,"vuln-fix: Handle security exceptions in resource path access

The resource retrieval method did not explicitly catch SecurityException, causing potential silent failures or improper handling of permission issues during path access.
This omission risked masking security permission errors, allowing unauthorized access attempts to go unnoticed or improperly logged, weakening audit and defense mechanisms.
The fix adds explicit SecurityException handling to log errors clearly and rethrow the exception, ensuring proper security enforcement and visibility.

Weakness: CWE-276
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('pathresourcemanager.getresource', 'URL', ''), ('securityexception', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('securityexception', 'SECWORD', ''), ('improper handling', 'SECWORD', ''), ('permission issues', 'SECWORD', ''), ('security', 'secword', ''), ('permission', 'SECWORD', ''), ('errors', 'FLAW', ''), ('audit', 'secword', ''), ('defense', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('securityexception', 'SECWORD', ''), ('errors', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('security', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-276', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
1,CWE-400,GHSA-57f3-gghm-9mhc,"@@ -630,7 +630,7 @@ import { atob, btoa } from ""../libs/AtobBtoa.js"";
     var result = null;
 
     if (dataUrlParts.length === 2) {
-      var extractedInfo = /^data:(\w*\/\w*);*(charset=[\w=-]*)*;*$/.exec(
+      var extractedInfo = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(
         dataUrlParts[0]
       );
       if (Array.isArray(extractedInfo)) {",fix ReDoS-vulnerable regexp in addImage (#3091),"vuln-fix: Prevent malformed charset parameter in data URL parsing

The data URL parser allowed multiple consecutive charset parameters, enabling crafted inputs to bypass charset validation and potentially cause incorrect decoding or injection.
This flaw could be exploited to manipulate content interpretation, leading to injection attacks or data corruption in downstream processing.
The fix adds a negative lookahead to the charset regex to disallow repeated charset declarations, ensuring proper and secure parsing of data URLs.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('#3091', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('decoding', 'SECWORD', ''), ('injection', 'secword', ''), ('flaw', 'FLAW', ''), ('exploited', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
2,CWE-400,GHSA-394c-5j6w-4xmx,"@@ -222,7 +222,7 @@
 
             // Presto based
             /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
-            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
+            /(opera\s[mobiletab]{3,6}).+version\/([\w\.-]+)/i,                  // Opera Mobi/Tablet
             /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
             /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
             ], [NAME, VERSION], [
@@ -252,7 +252,7 @@
             /(konqueror)\/([\w\.]+)/i                                           // Konqueror
             ], [[NAME, 'Konqueror'], VERSION], [
 
-            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
+            /(trident).+rv[:\s]([\w\.]{1,9}).+like\sgecko/i                     // IE11
             ], [[NAME, 'IE'], VERSION], [
 
             /(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i                          // Microsoft Edge
@@ -362,13 +362,13 @@
             /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
             ], [VERSION, [NAME, 'Firefox']], [
 
-            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
+            /version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i                      // Mobile Safari
             ], [VERSION, [NAME, 'Mobile Safari']], [
 
-            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
+            /version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i                   // Safari & Safari Mobile
             ], [VERSION, NAME], [
 
-            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
+            /webkit.+?(gsa)\/([\w\.]+)\s.*(mobile\s?safari|safari)(\/[\w\.]+)/i // Google Search Appliance on iOS
             ], [[NAME, 'GSA'], VERSION], [
 
             /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
@@ -387,7 +387,7 @@
 
                                                                                 // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
             /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,                       // Other Firefox-based
-            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla
+            /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,                        // Mozilla
 
             // Other
             /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
@@ -487,7 +487,7 @@
             /(sprint\s(\w+))/i                                                  // Sprint Phones
             ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [
 
-            /(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,                        // HTC
+            /(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,                    // HTC
             /(zte)-(\w*)/i,                                                     // ZTE
             /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                 // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
@@ -591,13 +591,13 @@
             ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [
 
             /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
-            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
-            /android.+(redmi[\s\-_]*(?:note|k)?(?:[\s_]?[\w\s]+))(?:\s+build|\))/i,      
+            /android.+(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,                // Xiaomi Hongmi
+            /android.+(redmi[\s\-_]?(?:note|k)?(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i,      
                                                                                 // Xiaomi Redmi
-            /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i    
+            /android.+(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i    
                                                                                 // Xiaomi Mi
             ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
-            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))(?:\s+build|\))/i     // Mi Pad tablets
+            /android.+(mi[\s\-_]?(?:pad)(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i     // Mi Pad tablets
             ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
             /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
             ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
@@ -611,7 +611,7 @@
             /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
             ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
 
-            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
+            /android.+[;\/\s](Venue[\d\s]{2,7})\s+build/i                       // Dell Venue Tablets
             ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
 
             /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
@@ -669,8 +669,8 @@
             /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
             ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
 
-            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
-            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
+            //android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
+            //], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
 
             /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
             ], [VENDOR, MODEL, [TYPE, TABLET]], [",Fix ReDoS vulnerabilities reported by Snyk,"vuln-fix: Restrict regex quantifiers to prevent catastrophic backtracking

The user agent parsing regexes contained overly permissive quantifiers that could cause catastrophic backtracking with crafted input strings.
This exposed the system to Regular Expression Denial of Service (ReDoS) attacks, allowing attackers to exhaust CPU resources and degrade service availability.
The patch tightens quantifiers by specifying exact or limited repetition counts, reducing regex complexity and preventing exponential matching time.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerabilities', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('availability', 'secword', ''), ('patch', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
3,CWE-400,GHSA-f8m6-h2c7-8h9x,"@@ -266,7 +266,6 @@ def word_tokenize(self, s):
         return self._word_tokenizer_re().findall(s)
 
     _period_context_fmt = r""""""
-        \S*                          # some word material
         %(SentEndChars)s             # a potential sentence ending
         (?=(?P<after_tok>
             %(NonWord)s              # either other punctuation
@@ -1284,8 +1283,7 @@ def debug_decisions(self, text):
         See format_debug_decision() to help make this output readable.
         """"""
 
-        for match in self._lang_vars.period_context_re().finditer(text):
-            decision_text = match.group() + match.group(""after_tok"")
+        for match, decision_text in self._match_potential_end_contexts(text):
             tokens = self._tokenize_words(decision_text)
             tokens = list(self._annotate_first_pass(tokens))
             while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars):
@@ -1333,10 +1331,68 @@ def sentences_from_text(self, text, realign_boundaries=True):
         """"""
         return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]
 
+    def _match_potential_end_contexts(self, text):
+        """"""
+        Given a text, find the matches of potential sentence breaks,
+        alongside the contexts surrounding these sentence breaks.
+
+        Since the fix for the ReDOS discovered in issue #2866, we no longer match
+        the word before a potential end of sentence token. Instead, we use a separate
+        regex for this. As a consequence, `finditer`'s desire to find non-overlapping
+        matches no longer aids us in finding the single longest match.
+        Where previously, we could use::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +SKIP
+            [<re.Match object; span=(9, 18), match='acting!!!'>]
+
+        Now we have to find the word before (i.e. 'acting') separately, and `finditer`
+        returns::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +NORMALIZE_WHITESPACE
+            [<re.Match object; span=(15, 16), match='!'>,
+            <re.Match object; span=(16, 17), match='!'>,
+            <re.Match object; span=(17, 18), match='!'>]
+
+        So, we need to find the word before the match from right to left, and then manually remove
+        the overlaps. That is what this method does::
+
+            >>> pst = PunktSentenceTokenizer()
+            >>> text = ""Very bad acting!!! I promise.""
+            >>> pst._match_potential_end_contexts(text)
+            [(<re.Match object; span=(17, 18), match='!'>, 'acting!!! I')]
+
+        :param text: String of one or more sentences
+        :type text: str
+        :return: List of match-context tuples.
+        :rtype: List[Tuple[re.Match, str]]
+        """"""
+        before_words = {}
+        matches = []
+        for match in reversed(list(self._lang_vars.period_context_re().finditer(text))):
+            # Ignore matches that have already been captured by matches to the right of this match
+            if matches and match.end() > before_start:
+                continue
+            # Find the word before the current match
+            split = text[: match.start()].rsplit(maxsplit=1)
+            before_start = len(split[0]) if len(split) == 2 else 0
+            before_words[match] = split[-1]
+            matches.append(match)
+
+        return [
+            (
+                match,
+                before_words[match] + match.group() + match.group(""after_tok""),
+            )
+            for match in matches[::-1]
+        ]
+
     def _slices_from_text(self, text):
         last_break = 0
-        for match in self._lang_vars.period_context_re().finditer(text):
-            context = match.group() + match.group(""after_tok"")
+        for match, context in self._match_potential_end_contexts(text):
             if self.text_contains_sentbreak(context):
                 yield slice(last_break, match.end())
                 if match.group(""next_tok""):","Resolved serious ReDoS in PunktSentenceTokenizer (#2869)

* Resolved serious ReDOS in PunktSentenceTokenizer

* Improve performance by relying on string split instead of re.search

* Solved issue if sentence contains just one token","vuln-fix: Prevent ReDoS by refactoring sentence break regex matching

The original sentence tokenizer used a complex regex that matched overlapping patterns, causing catastrophic backtracking and enabling Regular Expression Denial of Service (ReDoS) attacks on crafted input.
This vulnerability allowed attackers to exhaust CPU resources by submitting specially crafted text that triggered exponential regex evaluation time, potentially causing service outages.
The fix refactors the matching logic to separate word and punctuation matching, iterating matches in reverse and manually handling overlaps to avoid exponential backtracking and improve performance.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('redos', 'SECWORD', ''), ('#2869', 'ISSUE', ''), ('redos', 'SECWORD', ''), ('improve', 'ACTION', ''), ('re.search', 'URL', ''), ('issue', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,CWE-400,GHSA-hf44-3mx6-vhhw,"@@ -188,13 +188,11 @@ private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> request
      * The url looks like: "".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..""
      */
     private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {
-
         String url = httpServletRequest.getRequestURI();
-        url = url.replaceFirst(""/navigate/directions/v5/gh/"" + profile + ""/"", """");
-        url = url.replaceAll(""\\?[*]"", """");
-
+        String urlStart = ""/navigate/directions/v5/gh/"" + profile + ""/"";
+        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(""Incorrect URL "" + url);
+        url = url.substring(urlStart.length());
         String[] pointStrings = url.split("";"");
-
         List<GHPoint> points = new ArrayList<>(pointStrings.length);
         for (int i = 0; i < pointStrings.length; i++) {
             points.add(GHPoint.fromStringLonLat(pointStrings[i]));","avoid regex in navigate module (#2304)

* replace two regexs with one indexOf

* make check stricter

* use @easbar's suggestion","vuln-fix: Validate URL prefix before parsing route points

The route parsing method did not verify that the request URL started with the expected prefix before extracting coordinate data.
This allowed malformed URLs to bypass assumptions, potentially causing unexpected exceptions or processing of invalid input leading to denial of service.
The fix adds explicit URL prefix validation and throws an exception if the URL format is incorrect, preventing unsafe parsing of arbitrary strings.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('#2304', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('malformed urls', 'SECWORD', ''), ('bypass', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe parsing', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
5,CWE-400,GHSA-hp68-xhvj-x6j6,"@@ -1,6 +1,6 @@
 // An internal HTML tag and emoji shorthand should not escape
 const preventEscapeRegex =
-  /(<.*?>|:[-a-z0-9ÀÁÂÃÄÇÈÉÊËÍÎÏÑÓÔÕÖŒœÙÚÛÜŸßàáâãäçèéêëíîïñóôõöùúûüÿ_＿+＋'\u1100-\u11ff\u2e80-\u2fd5\u3005\u3041-\u3096\u30a0-\u30ff\u3130-\u318f\u3400-\u4db5\u4e00-\u9fcb\ua960-\ua97f\uac00-\ud7ff\uff10-\uff19\uff41-\uff5a\uff61-\uff9f]+:)/
+  /(<[^>]*>|:[-a-z0-9ÀÁÂÃÄÇÈÉÊËÍÎÏÑÓÔÕÖŒœÙÚÛÜŸßàáâãäçèéêëíîïñóôõöùúûüÿ_＿+＋'\u1100-\u11ff\u2e80-\u2fd5\u3005\u3041-\u3096\u30a0-\u30ff\u3130-\u318f\u3400-\u4db5\u4e00-\u9fcb\ua960-\ua97f\uac00-\ud7ff\uff10-\uff19\uff41-\uff5a\uff61-\uff9f]+:)/
 
 const generateReplacerForEscape = (fallback: string) => (matched: string) =>
   `<span data-escape=""${fallback.repeat(matched.length)}"">${matched}</span>`
@@ -8,13 +8,14 @@ const generateReplacerForEscape = (fallback: string) => (matched: string) =>
 export const escapeReplacers = {
   blockquote: (partial: string) =>
     partial
-      .replace(/^((?:<.*?>)*)(.{4})/gm, (matched, leading, character) =>
-        character === '&gt;' ? `${leading}\u00ad&gt;` : matched
+      .replace(
+        /^((?:<(?:[^>]|>(?=<))*>)?)(&gt;)/gm,
+        (_, leadingTags, character) => `${leadingTags}\u00ad${character}`
       )
       .replace(
-        /^((?:<.*?>)*)(＞)/gm,
-        (_, leading, character) =>
-          `${leading}${generateReplacerForEscape('\u00ad＞')(character)}`
+        /^((?:<(?:[^>]|>(?=<))*>)?)(＞)/gm,
+        (_, leadingTags, character) =>
+          `${leadingTags}${generateReplacerForEscape('\u00ad＞')(character)}`
       ),
   bold: (partial: string) =>
     partial",Prevent catastrophic backtracking in blockquote escape replacer,"vuln-fix: Fix improper regex causing HTML tag escape errors

The regular expression used to detect internal HTML tags and emoji shorthand was overly greedy, incorrectly matching across multiple tags and causing improper escaping.
This flaw could lead to malformed HTML output or injection of unintended characters, potentially enabling cross-site scripting or content spoofing attacks.
The fix refines the regex to non-greedily match tag contents, ensuring accurate detection and proper escaping of HTML and emoji sequences.

Weakness: CWE-79
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('prevent', 'ACTION', ''), ('escape', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('errors', 'FLAW', ''), ('escaping', 'secword', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('cross-site scripting', 'secword', ''), ('spoofing', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
6,CWE-400,GHSA-43f8-2h32-f4cj,"@@ -41,7 +41,7 @@ function fromUrl (giturl, opts) {
     isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
   )
   var parsed = parseGitUrl(url)
-  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))
+  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/)
   var matches = Object.keys(gitHosts).map(function (gitHostName) {
     try {
       var gitHostInfo = gitHosts[gitHostName]
@@ -55,7 +55,7 @@ function fromUrl (giturl, opts) {
       var defaultRepresentation = null
       if (shortcutMatch && shortcutMatch[1] === gitHostName) {
         user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])
-        project = decodeURIComponent(shortcutMatch[3])
+        project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ''))
         defaultRepresentation = 'shortcut'
       } else {
         if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return","fix: backport regex fix from #76

PR-URL: https://github.com/npm/hosted-git-info/pull/84
Credit: @nlf
Close: #84
Reviewed-by: @wraithgar","vuln-fix: Correct git URL parsing to prevent malformed input handling

The git URL parser used a flawed regular expression that incorrectly captured URL components, allowing malformed or crafted inputs to bypass expected parsing rules.
This parsing flaw could lead to incorrect repository resolution or injection of unexpected values, potentially causing security issues in downstream processing or access control.
The fix replaces the regex with a stricter pattern and sanitizes the project name by removing trailing "".git"", ensuring consistent and secure URL component extraction.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('#76', 'ISSUE', ''), ('https://github.com/npm/hosted-git-info/pull/84', 'URL', ''), ('#84', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('access control', 'secword', ''), ('fix', 'ACTION', ''), ('sanitizes', 'SECWORD', ''), ('removing', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
7,CWE-400,GHSA-247x-2f9f-5wp7,"@@ -25,6 +25,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/attr_value.pb.h""
 #include ""tensorflow/core/framework/function.pb.h""
 #include ""tensorflow/core/framework/node_def.pb.h""
+#include ""tensorflow/core/framework/op_def.pb.h""
 #include ""tensorflow/core/framework/tensor.pb.h""
 #include ""tensorflow/core/lib/io/path.h""
 #include ""tensorflow/core/lib/monitoring/counter.h""
@@ -99,6 +100,19 @@ static Status ValidateNode(const NodeDef& node) {
   return Status::OK();
 }
 
+static Status ValidateFunctionNotRecursive(const FunctionDef& function) {
+  const auto& function_name = function.signature().name();
+  for (const auto& node : function.node_def()) {
+    if (node.op() == function_name) {
+      return errors::FailedPrecondition(
+          ""Function "", function_name,
+          "" is self recursive and TensorFlow does not support this scenario."");
+    }
+  }
+
+  return Status::OK();
+}
+
 static Status ValidateSavedTensors(const GraphDef& graph_def) {
   for (const auto& node : graph_def.node()) {
     TF_RETURN_IF_ERROR(ValidateNode(node));
@@ -110,6 +124,10 @@ static Status ValidateSavedTensors(const GraphDef& graph_def) {
       for (const auto& node : function.node_def()) {
         TF_RETURN_IF_ERROR(ValidateNode(node));
       }
+
+      // Also check that there is no recursivity in the library
+      // TODO(mihaimaruseac): Do more than self-recursivity
+      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));
     }
   }","Prevent stack overflow when FunctionLib in GraphDef has a self-recursive function.

It is likely that no recursivity is supported, but we should handle this separately.

PiperOrigin-RevId: 414860329
Change-Id: I02a2270e86282b37362ddd485eeef16fb986a9e0","vuln-fix: Prevent self-recursive functions in TensorFlow graphs

TensorFlow did not validate function definitions for self-recursion, allowing functions to call themselves directly without detection.
This could lead to infinite recursion during graph execution, causing denial of service or resource exhaustion in machine learning workflows.
The fix adds a validation step that detects and rejects self-recursive functions before graph execution, preventing unsupported recursive scenarios.

Weakness: CWE-674
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('prevent', 'ACTION', ''), ('overflow', 'secword', ''), ('change', 'ACTION', ''), ('i02a2270e86282b37362ddd485eeef16fb986a9e0', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('validate', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-674', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
8,CWE-400,GHSA-566m-qj78-rww5,"@@ -48,11 +48,11 @@ class PreviousMap {
   }
 
   getAnnotationURL(sourceMapString) {
-    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\*\//)[1].trim()
+    return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim()
   }
 
   loadAnnotation(css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=.*\*\//gm)
+    let annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm)
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up","Merge pull request #1567 from yetingli/main

Fix ReDoS in previous-map","vuln-fix: Prevent ReDoS via improved sourceMappingURL regex

The sourceMappingURL extraction used a greedy regex that could be exploited to cause catastrophic backtracking with crafted input strings.
This vulnerability allowed attackers to trigger Regular Expression Denial of Service (ReDoS), potentially exhausting server resources during source map parsing.
The fix replaces the greedy pattern with a tempered greedy token that safely matches without overlapping sourceMappingURL entries, preventing exponential regex evaluation.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('#1567', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('improved', 'ACTION', ''), ('exploited', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('server', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
9,"CWE-74', 'CWE-400",GHSA-97gv-3p2c-xw7j,"@@ -49,7 +49,10 @@ var configure = function( app, configObject ) {
 
 	// Register routes
 	app.get( ""/i18n/:locale"", i18nRoutes.i18n );
-	app.get( ""/i18n/:locale/:phrase"", i18nRoutes.translate );
+
+	if( process.env.NODE_ENV === ""development"" ) {
+		app.get( ""/i18n/:locale/:phrase"", i18nRoutes.translate );
+	}
 };
 
 /**",[FIX] Only register translate route during development,"vuln-fix: Restrict translation route to development environment

The translation endpoint was exposed in all environments, allowing attackers to access internal phrase translations potentially revealing sensitive localization data.
This unrestricted access could aid attackers in information gathering or facilitate further attacks by exposing internal application details.
The fix limits the translation route availability exclusively to the development environment, preventing exposure in production.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('availability', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
10,CWE-400,GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","Update index.js

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Properly close client connections on end event

The server failed to explicitly close client connections when the 'end' event was emitted, leaving sockets potentially open and unmanaged.
This could lead to resource exhaustion or denial of service by accumulating stale or half-open connections that consume system resources.
The fix replaces the removal of clients with an explicit call to close the client socket, ensuring proper connection termination and resource cleanup.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('update', 'ACTION', ''), ('index.js', 'URL', ''), ('fixes', 'ACTION', ''), ('#1', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('server', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,"CWE-400', 'CWE-918",GHSA-7q4h-pj78-j7vg,"@@ -21,9 +21,11 @@
 import java.security.cert.X509Certificate;
 import java.util.List;
 import java.util.Map;
+import java.util.logging.Logger;
 
 import javax.ws.rs.core.MultivaluedMap;
 
+import org.apache.cxf.common.logging.LogUtils;
 import org.apache.cxf.helpers.CastUtils;
 import org.apache.cxf.jaxrs.client.WebClient;
 import org.apache.cxf.jaxrs.impl.MetadataMap;
@@ -42,23 +44,31 @@
 import org.apache.cxf.rt.security.crypto.CryptoUtils;
 
 public class JwtRequestCodeFilter extends OAuthJoseJwtConsumer implements AuthorizationRequestFilter {
+    protected static final Logger LOG = LogUtils.getL7dLogger(JwtRequestCodeFilter.class);
     private static final String REQUEST_URI_CONTENT_TYPE = ""application/oauth-authz-req+jwt"";
     private static final String REQUEST_PARAM = ""request"";
     private static final String REQUEST_URI_PARAM = ""request_uri"";
+
     private boolean verifyWithClientCertificates;
     private String issuer;
     private JsonMapObjectReaderWriter jsonHandler = new JsonMapObjectReaderWriter();
+
     @Override
     public MultivaluedMap<String, String> process(MultivaluedMap<String, String> params,
                                                   UserSubject endUser,
                                                   Client client) {
         String requestToken = params.getFirst(REQUEST_PARAM);
+        String requestUri = params.getFirst(REQUEST_URI_PARAM);
+
         if (requestToken == null) {
-            String requestUri = params.getFirst(REQUEST_URI_PARAM);
             if (isRequestUriValid(client, requestUri)) {
                 requestToken = WebClient.create(requestUri).accept(REQUEST_URI_CONTENT_TYPE).get(String.class);
             }
+        } else if (requestUri != null) {
+            LOG.warning(""It is not valid to specify both a request and request_uri value"");
+            throw new SecurityException();
         }
+
         if (requestToken != null) {
             JweDecryptionProvider theDecryptor = super.getInitializedDecryptionProvider(client.getClientSecret());
             JwsSignatureVerifier theSigVerifier = getInitializedSigVerifier(client);",Make sure both a request + request_uri can't be specified,"vuln-fix: Prevent misuse of request and request_uri parameters in JWT filter

The filter allowed simultaneous presence of both 'request' and 'request_uri' parameters without validation, enabling ambiguous or conflicting authorization requests.
This could lead to security bypass or unexpected behavior by processing multiple request sources, increasing risk of token confusion or injection attacks.
The fix adds explicit validation to reject requests specifying both parameters together, enforcing correct usage and preventing ambiguous input handling.

Weakness: CWE-300
Severity: Medium
CVSS: 5.0",0.058823529411764705,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('bypass', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-300', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
12,CWE-400,GHSA-6cf8-qhqj-vjqm,"@@ -6621,6 +6621,10 @@ exports.set = function(obj, path, value) {
 	var v = arr[arr.length - 1];
 	var ispush = v.lastIndexOf('[]') !== -1;
 	var a = builder.join(';') + ';var v=typeof(a)===\'function\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';
+
+	if ((/__proto__|constructor|prototype/).test(a))
+		throw new Error('Prototype pollution');
+
 	var fn = new Function('w', 'a', 'b', a);
 	F.temporary.other[cachekey] = fn;
 	fn(obj, value, path);",Fixed `U.set()` by adding check for `Prototype pollution`.,"vuln-fix: Prevent prototype pollution in object path setter

The set function allowed assignment to dangerous object keys like __proto__, constructor, or prototype, enabling prototype pollution attacks.
This vulnerability could let attackers manipulate object prototypes, leading to arbitrary code execution or denial of service through corrupted application state.
The fix adds a check that throws an error if the path contains any prototype-related keys, blocking prototype pollution attempts.

Weakness: CWE-471
Severity: High
CVSS: 7.8",0.058823529411764705,"[('fixed', 'ACTION', ''), ('u.set', 'URL', ''), ('adding', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('weakness', 'secword', ''), ('cwe-471', 'CWEID', ''), ('high', 'SEVERITY', '')]"
13,CWE-400,GHSA-jxwx-85vp-gvwm,"@@ -1412,7 +1412,7 @@ $.extend( $.validator, {
 			// https://gist.github.com/dperini/729294
 			// see also https://mathiasbynens.be/demo/url-regex
 			// modified to allow protocol-relative URLs
-			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
+			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
 		},
 
 		// https://jqueryvalidation.org/date-method/","Core: fixed Regular Expression Denial of Service vulnerability (#2371)

ReDoS, or Regular Expression Denial of Service, is a vulnerability affecting
poorly constructed and potentially inefficient regular expressions which can
make them perform extremely badly given a creatively constructed input string.

GHSL-2020-294

credits to @erik-krogh for reporting the issue and providing a fix","vuln-fix: Strengthen URL validation regex to prevent bypass

The URL validation regex allowed invalid domain names by accepting underscores and other disallowed characters, enabling attackers to submit malformed URLs.
This flaw could lead to security issues such as injection attacks, phishing, or bypassing domain-based access controls relying on URL validation.
The fix tightens the regex by restricting domain labels to valid characters and proper structure, preventing acceptance of malformed or malicious URLs.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fixed', 'ACTION', ''), ('denial of service', 'secword', ''), ('vulnerability', 'secword', ''), ('#2371', 'ISSUE', ''), ('redos', 'SECWORD', ''), ('denial of service', 'secword', ''), ('vulnerability', 'secword', ''), ('issue', 'FLAW', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('url validation', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('malformed urls', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('phishing', 'secword', ''), ('bypassing', 'SECWORD', ''), ('url validation', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('malicious', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
14,CWE-400,GHSA-9hx2-hgq2-2g4f,"@@ -580,8 +580,9 @@ def next_object_id(self, offset=None):
     whitespace_or_hex = br""[\000\011\012\014\015\0400-9a-fA-F]""
     whitespace_optional = whitespace + b""*""
     whitespace_mandatory = whitespace + b""+""
+    whitespace_optional_no_nl = br""[\000\011\014\015\040]*""  # no ""\012"" aka ""\n""
     newline_only = br""[\r\n]+""
-    newline = whitespace_optional + newline_only + whitespace_optional
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
         + br""trailer""","Use more specific regex chars to prevent ReDoS

* CVE-2021-25292","vuln-fix: Prevent improper newline matching in PDF trailer regex

The PDF trailer parsing regex allowed newline characters within whitespace matches, causing incorrect parsing of trailer sections in malformed or malicious PDFs.
This flaw could lead to incorrect object boundary detection, enabling attackers to craft PDFs that bypass security checks or cause parser confusion.
The fix restricts whitespace matching to exclude newline characters before and after newlines, ensuring accurate trailer boundary recognition.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('cve-2021-25292', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('malicious', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
15,CWE-400,GHSA-rc8h-3fv6-pxv8,"@@ -82,8 +82,8 @@ internals.marshal = function (request, next) {
 
                 // Weak verifier
 
-                const ifModifiedSince = Date.parse(ifModifiedSinceHeader);
-                const lastModified = Date.parse(lastModifiedHeader);
+                const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
+                const lastModified = internals.parseDate(lastModifiedHeader);
 
                 if (ifModifiedSince &&
                     lastModified &&
@@ -147,6 +147,15 @@ internals.marshal = function (request, next) {
 };
 
 
+internals.parseDate = function (string) {
+
+    try {
+        return Date.parse(string);
+    }
+    catch (errIgnore) { }
+};
+
+
 internals.fail = function (request, boom, callback) {
 
     const error = boom.output;
@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.1"",
+    ""version"": ""11.1.3"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""
@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.2"",
+  ""version"": ""11.1.3"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""

From: Eran Hammer <eran@hammer.io>

 npm-shrinkwrap.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.3"",
+    ""version"": ""11.1.1"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""

From: Eran Hammer <eran@hammer.io>

 package.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.3"",
+  ""version"": ""11.1.2"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""","Merge pull request #2988 from hapijs/v11.1.x

Handle invalid date exceptions","vuln-fix: Handle invalid date parsing to prevent exceptions

The code parsed HTTP date headers using Date.parse without handling invalid input, which could throw exceptions and disrupt request processing.
This posed a security risk by allowing malformed headers to cause server errors or crashes, potentially leading to denial of service.
The fix wraps date parsing in a try-catch block via a helper function to safely handle invalid dates without throwing exceptions.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('#2988', 'ISSUE', ''), ('v11.1.x', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('date.parse', 'URL', ''), ('security', 'secword', ''), ('server', 'secword', ''), ('errors', 'FLAW', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
16,CWE-400,GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","DOS fix

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Properly close client connections on end event

The server failed to explicitly close client connections when the 'end' event was emitted, potentially leaving sockets open and consuming resources indefinitely.
This could allow attackers to exhaust server resources by initiating connections that never fully close, leading to denial of service conditions.
The fix replaces the resource cleanup call with an explicit client.close() to ensure proper termination of connections and release of associated resources.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.23529411764705882,"[('dos', 'secword', ''), ('fix', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#1', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('server', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('server', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('client.close', 'URL', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,CWE-400,GHSA-p55x-7x9v-q8m4,"@@ -472,11 +472,14 @@ func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }","Fix for CVE-2017-15133 TCP DOS (#631)

serveTCP calls reader.ReadTCP in the accept loop rather than in
the per-connection goroutine. If an attacker opens a connection
and leaves it idle, this will block the accept loop until the
connection times out (2s by default). During this time no other
incoming connections will succeed, preventing legitimate queries
from being answered.

This commit moves the call to reader.ReadTCP into the per-connection
goroutine. It also adds a missing call to Close whose absence allowed
file-descirptors to leak in select cases.

This attack and fix have no impact on serving UDP queries.","vuln-fix: Close TCP connection on read error to prevent resource leaks

The TCP server did not close connections when a read error occurred, causing file descriptors to remain open indefinitely.
This allowed attackers to exhaust server resources by triggering repeated read failures, leading to denial of service through resource exhaustion.
The fix ensures the connection is explicitly closed upon read errors, preventing resource leaks and improving server stability.

Weakness: CWE-772
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('fix', 'ACTION', ''), ('cve-2017-15133', 'VULNID', 'CVE'), ('dos', 'SECWORD', ''), ('#631', 'ISSUE', ''), ('reader.readtcp', 'URL', ''), ('attacker', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('reader.readtcp', 'URL', ''), ('adds', 'ACTION', ''), ('leak', 'secword', ''), ('attack', 'FLAW', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('resource leaks', 'SECWORD', ''), ('server', 'SECWORD', ''), ('error', 'FLAW', ''), ('attackers', 'FLAW', ''), ('server', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('errors', 'FLAW', ''), ('preventing', 'ACTION', ''), ('resource leaks', 'SECWORD', ''), ('improving', 'ACTION', ''), ('server', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-772', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
18,CWE-400,GHSA-fq6p-x6j3-cmmq,"@@ -169,14 +169,14 @@ class Color {
 
 			let color;
 			const name = m[ 1 ];
-			const components = m[ 2 ].replace(/^\s*/, '');
+			const components = m[ 2 ];
 
 			switch ( name ) {
 
 				case 'rgb':
 				case 'rgba':
 
-					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(255,0,0) rgba(255,0,0,0.5)
 						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
@@ -189,7 +189,7 @@ class Color {
 
 					}
 
-					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
 						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
@@ -207,7 +207,7 @@ class Color {
 				case 'hsl':
 				case 'hsla':
 
-					if ( color = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
 						const h = parseFloat( color[ 1 ] ) / 360;",Fix ReDoS,"vuln-fix: Prevent incorrect parsing of color components with leading spaces

The color parsing logic failed to properly handle leading whitespace in component strings, causing potential misinterpretation of color values.
This could lead to incorrect color rendering or unexpected behavior in applications relying on precise color parsing, potentially affecting UI security or integrity.
The fix adds explicit allowance for leading whitespace in regex patterns to correctly parse and normalize color component inputs.

Weakness: CWE-20
Severity: Low
CVSS: 3.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('low', 'SEVERITY', '')]"
19,CWE-400,GHSA-7f53-fmmv-mfjv,"@@ -107,7 +107,7 @@ export class URLSearchParams {
 
 function validateBaseUrl(url: string) {
   // from this MIT-licensed gist: https://gist.github.com/dperini/729294
-  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
+  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)*(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/.test(
     url,
   );
 }","Update validateBaseUrl to use latest regex

Summary:
Updating the regex to avoid a potential regular expression denial-of-service vulnerability.

Changelog: Update validateBaseUrl to use a more robust regular expression. Fixes CVE-2020-1920, GHSL-2020-293

Reviewed By: lunaleaps

Differential Revision: D25507604

fbshipit-source-id: c36a03c456881bc655c861e1a2c5cd41a7127c9d","vuln-fix: Strengthen base URL validation regex to prevent bypass

The base URL validation regex allowed invalid hostnames by accepting underscores and malformed domain labels, enabling attackers to bypass URL checks.
This flaw could lead to security issues such as SSRF or injection attacks by permitting crafted URLs that evade proper validation.
The fix tightens the regex to disallow underscores and enforce stricter hostname label rules, ensuring only valid domain names pass validation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('update', 'ACTION', ''), ('updating', 'ACTION', ''), ('denial-of-service', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('update', 'ACTION', ''), ('fixes', 'ACTION', ''), ('cve-2020-1920', 'VULNID', 'CVE'), ('c36a03c456881bc655c861e1a2c5cd41a7127c9d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('url validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('url validation', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('security', 'SECWORD', ''), ('issues', 'FLAW', ''), ('ssrf', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('hostname', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
20,"CWE-400', 'CWE-20",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate ragged_rank against pylist nesting depth

The function failed to verify that the specified ragged_rank does not exceed the maximum nesting depth of the input pylist.
This could lead to inconsistent internal state or unexpected behavior, potentially causing crashes or memory corruption during tensor construction.
The fix adds a check to raise an error if ragged_rank is greater than the pylist’s maximum depth, ensuring input consistency and preventing invalid tensor shapes.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('tf.ragged.constant', 'URL', ''), ('fixes', 'ACTION', ''), ('#55199', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
21,CWE-400,GHSA-h6rj-8r3c-9gpj,"@@ -282,7 +282,7 @@ def from_time(time, options = {})
       #
       # @since 2.0.0
       def legal?(string)
-        string.to_s =~ /^[0-9a-f]{24}$/i ? true : false
+        string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false
       end
 
       # Executes the provided block only if the size of the provided object is",Use \A \z for checking regex on legal,"vuln-fix: Enforce strict validation of 24-char hex strings

The validation method for 24-character hexadecimal strings allowed partial matches due to use of a non-anchored regex, accepting invalid inputs.
This could lead to security issues where malformed or malicious identifiers bypass validation, potentially causing logic errors or injection vulnerabilities.
The fix anchors the regex to the start and end of the string, ensuring only exact 24-character hex strings are considered valid.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('malicious', 'secword', ''), ('bypass', 'SECWORD', ''), ('logic errors', 'secword', ''), ('injection', 'secword', ''), ('vulnerabilities', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,CWE-400,GHSA-hwj9-h5mp-3pm3,"@@ -73,12 +73,14 @@ class PreviousMap {
 
   getAnnotationURL (sourceMapString) {
     return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
+      .match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1]
       .trim()
   }
 
   loadAnnotation (css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg)
+    let annotations = css.match(
+      /\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm
+    )
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up",Backport ReDoS vulnerabilities from PostCSS 8,"vuln-fix: Prevent incorrect source map URL extraction via regex

The source map URL extraction regex greedily matched multiple sourceMappingURL annotations, causing incorrect parsing of source map URLs.
This allowed attackers to craft malicious CSS that could confuse tooling or cause unexpected behavior by injecting multiple or malformed sourceMappingURL comments.
The fix updates the regex to use a tempered greedy token that stops at the next sourceMappingURL, ensuring accurate and secure extraction of the intended URL.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('redos', 'SECWORD', ''), ('vulnerabilities', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('malformed sourcemappingurl', 'SECWORD', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
23,CWE-400,GHSA-v2p6-4mp7-3r9v,"@@ -2,7 +2,7 @@ var makeString = require('./helper/makeString');
 var htmlEntities = require('./helper/htmlEntities');
 
 module.exports = function unescapeHTML(str) {
-  return makeString(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
+  return makeString(str).replace(/\&([^;]{1,10});/g, function(entity, entityCode) {
     var match;
 
     if (entityCode in htmlEntities) {","Try to fix regexp redos

fixes  #510","vuln-fix: Limit HTML entity length in unescape function

The unescapeHTML function did not restrict the length of HTML entity codes, allowing excessively long inputs to be processed by the regex.
This exposed the system to Regular Expression Denial of Service (ReDoS) attacks by enabling crafted inputs that cause catastrophic backtracking.
The fix limits entity code length to a maximum of 10 characters, preventing excessive regex backtracking and improving input validation.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#510', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('unescape', 'SECWORD', ''), ('unescapehtml', 'SECWORD', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('input validation', 'secword', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
24,CWE-400,GHSA-r33q-22hv-j29q,"@@ -610,6 +610,7 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 		var (
 			lastBHash common.Hash
 			root      common.Hash
+			header    *types.Header
 		)
 		reqCnt := len(req.Reqs)
 		if accept(req.ReqID, uint64(reqCnt), MaxProofsFetch) {
@@ -624,10 +625,6 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						return
 					}
 					// Look up the root hash belonging to the request
-					var (
-						header *types.Header
-						trie   state.Trie
-					)
 					if request.BHash != lastBHash {
 						root, lastBHash = common.Hash{}, request.BHash
 
@@ -654,6 +651,7 @@ func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 					// Open the account or storage trie for the request
 					statedb := h.blockchain.StateCache()
 
+					var trie state.Trie
 					switch len(request.AccKey) {
 					case 0:
 						// No account key specified, open an account trie",les: fix GetProofsV2 bug (#21896),"vuln-fix: Remove variable shadowing to ensure correct trie initialization

The handleMsg function contained variable shadowing that caused the trie variable to be redeclared in nested scopes, leading to uninitialized or incorrect trie usage.
This could result in inconsistent state access or logic errors, potentially allowing attackers to exploit incorrect blockchain state proofs or cause denial of service.
The fix removes inner redeclarations of the trie variable, ensuring the correct trie instance is used throughout the function for reliable state handling.

Weakness: CWE-672
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('#21896', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('ensure', 'ACTION', ''), ('initialization', 'SECWORD', ''), ('uninitialized', 'SECWORD', ''), ('logic errors', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-672', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
25,CWE-400,GHSA-4gw3-8f77-f72c,"@@ -126,7 +126,7 @@ CodeMirror.defineMode(""javascript"", function(config, parserConfig) {
           var kw = keywords[word]
           return ret(kw.type, kw.style, word)
         }
-        if (word == ""async"" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
+        if (word == ""async"" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
           return ret(""async"", ""keyword"", word)
       }
       return ret(""variable"", ""variable"", word)",[javascript mode] Fix potentially-exponential regexp,"vuln-fix: Fix regex to prevent ReDoS in async keyword detection

The JavaScript mode regex for detecting ""async"" keyword allowed catastrophic backtracking due to an overly permissive pattern matching block comments.
This vulnerability exposed the editor to Regular Expression Denial of Service (ReDoS) attacks when parsing maliciously crafted input containing nested or complex comments.
The fix refines the regex to safely match block comments without backtracking, preventing exponential runtime and improving parser resilience.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('keyword', 'SECWORD', ''), ('keyword', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('maliciously', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,CWE-400,GHSA-43f8-2h32-f4cj,"@@ -41,7 +41,7 @@ function fromUrl (giturl, opts) {
     isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
   )
   var parsed = parseGitUrl(url)
-  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))
+  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/)
   var matches = Object.keys(gitHosts).map(function (gitHostName) {
     try {
       var gitHostInfo = gitHosts[gitHostName]
@@ -55,7 +55,7 @@ function fromUrl (giturl, opts) {
       var defaultRepresentation = null
       if (shortcutMatch && shortcutMatch[1] === gitHostName) {
         user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])
-        project = decodeURIComponent(shortcutMatch[3])
+        project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ''))
         defaultRepresentation = 'shortcut'
       } else {
         if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return","fix: simplify the regular expression for shortcut matching

PR-URL: https://github.com/npm/hosted-git-info/pull/76
Credit: @nlf
Close: #76
Reviewed-by: @isaacs","vuln-fix: Correct regex parsing to prevent URL parsing errors

The URL parsing regex allowed malformed or unexpected input to bypass proper extraction of user and project components, risking incorrect repository resolution.
This could lead to security issues such as repository spoofing or injection attacks by misinterpreting crafted Git URLs.
The fix replaces the regex with a stricter pattern that correctly captures user and project parts, and removes trailing "".git"" suffix safely to ensure accurate parsing.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('https://github.com/npm/hosted-git-info/pull/76', 'URL', ''), ('#76', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('security', 'SECWORD', ''), ('issues', 'FLAW', ''), ('spoofing', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
27,CWE-400,GHSA-662x-fhqg-9p8v,"@@ -585,9 +585,9 @@
             /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
             /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    
                                                                                 // Xiaomi Mi
-            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i       // Redmi Phones
+            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]?[\w\s]+))\s+build/i       // Redmi Phones
             ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
-            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i            // Mi Pad tablets
+            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))\s+build/i            // Mi Pad tablets
             ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
             /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
             ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [",Fix potential ReDoS vulnerability,"vuln-fix: Correct regex to prevent improper device model parsing

The device detection regex patterns allowed optional multiple underscores or spaces, causing inconsistent or incorrect parsing of device model names from user agent strings.
This could lead to inaccurate device identification, enabling attackers to spoof device types or bypass device-specific security controls relying on correct parsing.
The fix restricts the regex to allow only a single optional underscore or space, ensuring consistent and accurate extraction of device model information.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'FLAW', ''), ('spoof', 'secword', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
28,CWE-400,GHSA-vp56-6g26-6827,"@@ -119,7 +119,7 @@ export function isOriginPotentiallyTrustworthy(url) {
 	// 5. If origin's host component is ""localhost"" or falls within "".localhost"", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return ""Potentially Trustworthy"".
 	// We are returning FALSE here because we cannot ensure conformance to
 	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
-	if (/^(.+\.)*localhost$/.test(url.host)) {
+	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
 		return false;
 	}","fix: ReDoS referrer (#1611)

* fix ReDoS referrer

* Update src/utils/referrer.js

Eliminate regex and use string matcher

Co-authored-by: Linus Unnebäck <linus@folkdatorn.se>

Co-authored-by: Khang. Võ Vĩ <khangvv@vng.com.vn>
Co-authored-by: Linus Unnebäck <linus@folkdatorn.se>","vuln-fix: Correct localhost trust check to prevent spoofing

The origin trust check incorrectly used a regex that could match unintended hosts, allowing attackers to spoof localhost origins.
This flaw risked treating malicious domains as trustworthy, potentially enabling cross-origin attacks or privilege escalation.
The fix replaces the regex with explicit string checks to accurately identify localhost and its subdomains, preventing spoofing.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.4117647058823529,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('#1611', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('update', 'ACTION', ''), ('referrer.js', 'URL', ''), ('linus@folkdatorn.se', 'EMAIL', ''), ('khangvv@vng.com.vn', 'EMAIL', ''), ('linus@folkdatorn.se', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('trust', 'secword', ''), ('prevent', 'ACTION', ''), ('spoofing', 'SECWORD', ''), ('trust', 'secword', ''), ('incorrectly used', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('spoof', 'secword', ''), ('flaw', 'FLAW', ''), ('malicious', 'secword', ''), ('attacks', 'FLAW', ''), ('privilege escalation', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('spoofing', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
29,CWE-400,GHSA-xfhp-gmh8-r8v2,"@@ -41,7 +41,7 @@ var Formatter = function(/*String*/ format){
   this._tokens = tokenize(format, this._re, this._parseDelim, this);
 };
 
-Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)([\*1-9]0*)*(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
+Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
 Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
   if(mapping){
     this._mapped = true;",Fix ReDoS,"vuln-fix: Fix format string regex to prevent malformed specifiers

The format string parser used a flawed regular expression that allowed invalid or malformed width and precision specifiers, potentially leading to incorrect parsing or unexpected behavior.
This could be exploited to cause format string vulnerabilities, including memory corruption or denial of service, by crafting malicious format inputs that bypass validation.
The patch corrects the regex to properly match width and precision fields, ensuring only valid specifiers are accepted and preventing malformed input processing.

Weakness: CWE-134
Severity: High
CVSS: 7.8",0.11764705882352941,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('exploited', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('malicious', 'secword', ''), ('bypass', 'secword', ''), ('patch', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-134', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,CWE-400,GHSA-j4f2-536g-r55m,"@@ -26,7 +26,7 @@ class Server extends EventEmitter {
         pingTimeout: 5000,
         pingInterval: 25000,
         upgradeTimeout: 10000,
-        maxHttpBufferSize: 10e7,
+        maxHttpBufferSize: 1e6,
         transports: Object.keys(transports),
         allowUpgrades: true,
         perMessageDeflate: {","feat: decrease the default value of maxHttpBufferSize

This change reduces the default value from 100 mb to a more sane 1 mb.

This helps protect the server against denial of service attacks by
malicious clients sending huge amounts of data.","vuln-fix: Limit maximum HTTP buffer size to prevent DoS

The server allowed excessively large HTTP buffer sizes, enabling attackers to send huge payloads that exhaust memory and degrade service availability.
This exposed the system to denial-of-service attacks by overwhelming server resources with oversized requests.
The fix reduces the maxHttpBufferSize configuration to a safer limit, mitigating resource exhaustion risks from large HTTP payloads.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('change', 'ACTION', ''), ('protect', 'ACTION', ''), ('server', 'SECWORD', ''), ('denial of service', 'secword', ''), ('attacks', 'FLAW', ''), ('malicious', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'secword', ''), ('server', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('availability', 'secword', ''), ('denial-of-service', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('mitigating', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,CWE-400,GHSA-hwj9-h5mp-3pm3,"@@ -48,9 +48,7 @@ class PreviousMap {
   }
 
   getAnnotationURL(sourceMapString) {
-    return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
-      .trim()
+    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\*\//)[1].trim()
   }
 
   loadAnnotation(css) {",Fix unsafe regexp in getAnnotationURL() too,"vuln-fix: Fix source map URL extraction to prevent crashes

The source map URL extraction regex assumed a match always existed, causing unhandled exceptions if the input lacked a valid sourceMappingURL annotation.
This could lead to application crashes or denial of service when processing malformed or malicious source map strings.
The fix adjusts the regex to correctly match the annotation format and avoids unexpected failures by ensuring safer extraction.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,CWE-400,GHSA-hj5v-574p-mj7c,"@@ -396,7 +396,7 @@ def makecmdoptions(self):
     def __str__(self):
         return ""<SvnAuth username=%s ...>"" %(self.username,)
 
-rex_blame = re.compile(r'\s*(\d+)\s*(\S+) (.*)')
+rex_blame = re.compile(r'\s*(\d+)\s+(\S+) (.*)')
 
 class SvnWCCommandPath(common.PathBase):
     """""" path implementation offering access/modification to svn working copies.","svnwc: fix regular expression vulnerable to DoS in blame functionality

The subpattern `\d+\s*\S+` is ambiguous which makes the pattern subject
to catastrophic backtracing given a string like `""1"" * 5000`.

SVN blame output seems to always have at least one space between the
revision number and the user name, so the ambiguity can be fixed by
changing the `*` to `+`.

Fixes #256.","vuln-fix: Fix regex to prevent incorrect blame parsing

The blame parsing regex allowed variable whitespace between fields, causing potential misinterpretation of blame data in edge cases with multiple spaces.
This could lead to incorrect attribution of code lines, enabling attackers to manipulate blame output and obscure malicious changes.
The patch tightens the regex to require at least one whitespace character, ensuring consistent and accurate blame field separation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerable', 'SECWORD', ''), ('dos', 'secword', ''), ('user name', 'secword', ''), ('fixed', 'ACTION', ''), ('changing', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#256', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('malicious', 'secword', ''), ('changes', 'ACTION', ''), ('patch', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,"CWE-400', 'CWE-918",GHSA-7q4h-pj78-j7vg,"@@ -42,6 +42,7 @@
 import org.apache.cxf.rt.security.crypto.CryptoUtils;
 
 public class JwtRequestCodeFilter extends OAuthJoseJwtConsumer implements AuthorizationRequestFilter {
+    private static final String REQUEST_URI_CONTENT_TYPE = ""application/oauth-authz-req+jwt"";
     private static final String REQUEST_PARAM = ""request"";
     private static final String REQUEST_URI_PARAM = ""request_uri"";
     private boolean verifyWithClientCertificates;
@@ -55,7 +56,7 @@ public MultivaluedMap<String, String> process(MultivaluedMap<String, String> par
         if (requestToken == null) {
             String requestUri = params.getFirst(REQUEST_URI_PARAM);
             if (isRequestUriValid(client, requestUri)) {
-                requestToken = WebClient.create(requestUri).get(String.class);
+                requestToken = WebClient.create(requestUri).accept(REQUEST_URI_CONTENT_TYPE).get(String.class);
             }
         }
         if (requestToken != null) {
@@ -101,9 +102,17 @@ public MultivaluedMap<String, String> process(MultivaluedMap<String, String> par
         }
         return params;
     }
-    private boolean isRequestUriValid(Client client, String requestUri) {
-        //TODO: consider restricting to specific hosts
-        return requestUri != null && requestUri.startsWith(""https://"");
+
+    /**
+     * This method must be overridden to support request_uri. Take care to validate the request_uri properly,
+     * as otherwise it could lead to a security problem
+     * (https://tools.ietf.org/html/draft-ietf-oauth-jwsreq-30#section-10.4)
+     * @param client the Client object
+     * @param requestUri the request_uri parameter to validate
+     * @return whether the requestUri is permitted or not
+     */
+    protected boolean isRequestUriValid(Client client, String requestUri) {
+        return false;
     }
     protected JwsSignatureVerifier getInitializedSigVerifier(Client c) {
         if (verifyWithClientCertificates) {",Disallow OAuth2 request_uri by default,"vuln-fix: Enforce strict validation of request_uri parameter

The OAuth JWT request processing did not properly validate the request_uri parameter, allowing potential retrieval of untrusted JWTs from arbitrary URIs.
This could enable attackers to supply malicious authorization requests, leading to token injection or authorization bypass vulnerabilities.
The fix disables request_uri usage by default and requires subclasses to implement strict validation logic before accepting any request_uri values.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('oauth', 'SECWORD', ''), ('validate', 'secword', ''), ('untrusted', 'secword', ''), ('attackers', 'FLAW', ''), ('malicious', 'secword', ''), ('injection', 'secword', ''), ('authorization bypass', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
34,CWE-400,GHSA-35q2-47q7-3pc3,"@@ -127,7 +127,7 @@ module.exports = {
     reply_to_object: replyToObject,
     print: print,
     err_code: /^([A-Z]+)\s+(.+)$/,
-    monitor_regex: /^[0-9]{10,11}\.[0-9]+ \[[0-9]+ .+\]( "".+?"")+$/,
+    monitor_regex: /^[0-9]{10,11}\.[0-9]+ \[[0-9]+ .+\].*""$/,
     clone: convenienceClone,
     callback_or_emit: callbackOrEmit,
     reply_in_order: replyInOrder","fix #1569 - improve monitor_regex (#1595)

Co-authored-by: Guy Korland <gkorland@gmail.com>","vuln-fix: Fix regex to prevent excessive backtracking in monitor logs

The monitor_regex pattern allowed multiple repeated groups with lazy quantifiers, causing potential catastrophic backtracking on crafted input strings.
This exposed the system to Regular Expression Denial of Service (ReDoS) attacks by allowing attackers to trigger excessive CPU usage during log processing.
The fix simplifies the regex by removing repeated capturing groups and tightening the pattern to ensure linear-time matching.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('#1569', 'ISSUE', ''), ('improve', 'ACTION', ''), ('#1595', 'ISSUE', ''), ('gkorland@gmail.com', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('removing', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
35,"CWE-400', 'CWE-185",GHSA-8462-q7x7-g2x4,"@@ -235,6 +235,13 @@ Decimal128.fromString = function(string) {
   // Trim the string
   string = string.trim();
 
+  // Naively prevent against REDOS attacks.
+  // TODO: implementing a custom parsing for this, or refactoring the regex would yield
+  //       further gains.
+  if (string.length >= 7000) {
+    throw new Error('' + string + ' not a valid Decimal128 string');
+  }
+
   // Results
   var stringMatch = string.match(PARSE_STRING_REGEXP);
   var infMatch = string.match(PARSE_INF_REGEXP);","fix(decimal128): add basic guard against REDOS attacks

This is a naive approach to reducing the efficacy of a REDOS attack
against this module. A refactor of the regular expression or a
custom parser substitute would be ideal, however this solution
suffices as a stopgap until such work is completed.

Many thanks to James Davis who graciously alterted us to the
attack","vuln-fix: Mitigate ReDoS in Decimal128 string parsing

The Decimal128 parser used a complex regular expression on unbounded input strings, allowing crafted long inputs to cause excessive backtracking.
This exposed the system to Regular Expression Denial of Service (ReDoS) attacks, potentially exhausting CPU resources and causing service unavailability.
The fix adds a length check to reject overly long strings early, preventing the regex from processing inputs that could trigger exponential runtime.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix(decimal128', 'ACTION', ''), ('add', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('redos', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attack', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('redos', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
36,CWE-400,GHSA-3pcq-34w5-p4g2,"@@ -35,7 +35,7 @@ import mapLimit from './mapLimit.mjs'
  */
 async function forEachLimit (iterable, iteratee, concurrency) {
   await mapLimit(iterable, async (v, i, t) => {
-    iteratee(v, i, t)
+    await iteratee(v, i, t)
   }, concurrency)
 }",Fix #5,"vuln-fix: Await asynchronous iteratee in forEachLimit to prevent race conditions

The forEachLimit function did not await the asynchronous iteratee calls, causing concurrent operations to proceed without proper completion tracking.
This introduced race conditions and potential data corruption or inconsistent state when iteratee functions involved asynchronous side effects.
The fix adds an await before the iteratee call to ensure each asynchronous operation completes before continuing, preserving correct execution order.

Weakness: CWE-362
Severity: Medium
CVSS: 5.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('#5', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('race conditions', 'SECWORD', ''), ('race conditions', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-362', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
37,"CWE-400', 'CWE-1321",GHSA-74cr-77xc-8g6r,"@@ -4,7 +4,7 @@ export function deepMerge(target: any, source: any): any {
   if (source === undefined || source === null) return target;
 
   for (const key of Object.keys(source)) {
-    if (source[key] === undefined) continue;
+    if (source[key] === undefined || key === '__proto__') continue;
 
     if (target[key] && isObject(source[key])) {
       deepMerge(target[key], source[key]);",Ignore __proto__ fields in deepMerge,"vuln-fix: Prevent prototype pollution in deepMerge function

The deepMerge function allowed merging properties named __proto__ from source objects into target objects, enabling prototype pollution attacks.
This vulnerability could let attackers manipulate object prototypes, leading to arbitrary code execution or denial of service by altering application behavior.
The fix adds a check to skip merging any __proto__ property, preventing modification of the object's prototype chain during deep merges.

Weakness: CWE-1321
Severity: High
CVSS: 7.8",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
38,"CWE-400', 'CWE-345",GHSA-6fc8-4gx4-v693,"@@ -286,7 +286,7 @@ class WebSocketServer extends EventEmitter {
     let protocol = req.headers['sec-websocket-protocol'];
 
     if (protocol) {
-      protocol = protocol.trim().split(/ *, */);
+      protocol = protocol.split(',').map(trim);
 
       //
       // Optionally call external protocol selection handler.
@@ -404,3 +404,15 @@ function abortHandshake(socket, code, message, headers) {
   socket.removeListener('error', socketOnError);
   socket.destroy();
 }
+
+/**
+ * Remove whitespace characters from both ends of a string.
+ *
+ * @param {String} str The string
+ * @return {String} A new string representing `str` stripped of whitespace
+ *     characters from both its beginning and end
+ * @private
+ */
+function trim(str) {
+  return str.trim();
+}","[security] Fix ReDoS vulnerability

A specially crafted value of the `Sec-Websocket-Protocol` header could
be used to significantly slow down a ws server.

PoC and fix were sent privately by Robert McLaughlin from University of
California, Santa Barbara.","vuln-fix: Correct protocol header parsing to prevent injection

The WebSocket server improperly parsed the 'sec-websocket-protocol' header by using a regex split without trimming each protocol token, allowing malformed input to pass unchecked.
This could enable attackers to inject unexpected whitespace or control characters, potentially leading to protocol confusion or bypassing protocol-based access controls.
The fix replaces the regex split with a split on commas followed by explicit trimming of each token, ensuring clean and accurate protocol parsing.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('protocol', 'secword', ''), ('server', 'secword', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('protocol', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('server', 'SECWORD', ''), ('protocol', 'secword', ''), ('protocol', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('protocol', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('protocol', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('protocol', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,CWE-400,GHSA-h6ch-v84p-w6p9,"@@ -53,16 +53,16 @@ export function parsePatch(uniDiff, options = {}) {
   // Parses the --- and +++ headers, if none are found, no lines
   // are consumed.
   function parseFileHeader(index) {
-    const headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
-    const fileHeader = headerPattern.exec(diffstr[i]);
+    const fileHeader = (/^(---|\+\+\+)\s+(.*)$/).exec(diffstr[i]);
     if (fileHeader) {
       let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
-      let fileName = fileHeader[2].replace(/\\\\/g, '\\');
+      const data = fileHeader[2].split('\t', 2);
+      let fileName = data[0].replace(/\\\\/g, '\\');
       if (/^"".*""$/.test(fileName)) {
         fileName = fileName.substr(1, fileName.length - 2);
       }
       index[keyPrefix + 'FileName'] = fileName;
-      index[keyPrefix + 'Header'] = fileHeader[3];
+      index[keyPrefix + 'Header'] = (data[1] || '').trim();
 
       i++;
     }",Optimize parch header parser,"vuln-fix: Correct parsing of patch file headers to prevent injection

The patch parser incorrectly extracted file header fields, allowing crafted input to inject unexpected tab characters and manipulate header parsing.
This flaw could lead to improper file path handling or injection of malicious metadata, potentially causing security issues in downstream patch processing or file operations.
The fix revises the header parsing logic to safely split on tabs and properly sanitize file names and headers, preventing injection and ensuring robust parsing.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('optimize', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('patch', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('patch', 'ACTION', ''), ('inject', 'secword', ''), ('manipulate', 'ACTION', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('malicious', 'SECWORD', ''), ('security', 'SECWORD', ''), ('issues', 'FLAW', ''), ('patch', 'ACTION', ''), ('fix', 'ACTION', ''), ('sanitize', 'secword', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
40,CWE-400,GHSA-xfhh-g9f5-x4m4,"@@ -286,11 +286,9 @@ function decodeString(str) {
 
   // look up attachments if type binary
   if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
-    var buf = '';
-    while (str.charAt(++i) !== '-') {
-      buf += str.charAt(i);
-      if (i == str.length) break;
-    }
+    var start = i + 1;
+    while (str.charAt(++i) !== '-' && i != str.length) {}
+    var buf = str.substring(start, i);
     if (buf != Number(buf) || str.charAt(i) !== '-') {
       throw new Error('Illegal attachments');
     }
@@ -299,13 +297,13 @@ function decodeString(str) {
 
   // look up namespace (if any)
   if ('/' === str.charAt(i + 1)) {
-    p.nsp = '';
+    var start = i + 1;
     while (++i) {
       var c = str.charAt(i);
       if (',' === c) break;
-      p.nsp += c;
       if (i === str.length) break;
     }
+    p.nsp = str.substring(start, i);
   } else {
     p.nsp = '/';
   }
@@ -313,17 +311,16 @@ function decodeString(str) {
   // look up id
   var next = str.charAt(i + 1);
   if ('' !== next && Number(next) == next) {
-    p.id = '';
+    var start = i + 1;
     while (++i) {
       var c = str.charAt(i);
       if (null == c || Number(c) != c) {
         --i;
         break;
       }
-      p.id += str.charAt(i);
       if (i === str.length) break;
     }
-    p.id = Number(p.id);
+    p.id = Number(str.substring(start, i + 1));
   }
 
   // look up json data","fix: prevent DoS (OOM) via massive packets (#95)

When maxHttpBufferSize is large (1e8 bytes), a payload of length 100MB
can be sent like so:

99999991:422222222222222222222222222222222222222222222...

This massive packet can cause OOM via building up many many
`ConsOneByteString` objects due to concatenation:
99999989 `ConsOneByteString`s and then converting the massive integer to
a `Number`.

The performance can be improved to avoid this by using `substring`
rather than building the string via concatenation.

Below I tried one payload of length 7e7 as the 1e8 payload took so
long to process that it timed out before running out of memory.

```
==== JS stack trace =========================================

    0: ExitFrame [pc: 0x13c5b79]
Security context: 0x152fe7b808d1 <JSObject>
    1: decodeString [0x2dd385fb5d1] [/node_modules/socket.io-parser/index.js:~276] [pc=0xf59746881be](this=0x175d34c42b69 <JSGlobal Object>,0x14eccff10fe1 <Very long string[69999990]>)
    2: add [0x31fc2693da29] [/node_modules/socket.io-parser/index.js:242] [bytecode=0xa7ed6554889 offset=11](this=0x0a2881be5069 <Decoder map = 0x3ceaa8bf48c9>,0x14eccff10fe1 <Very...

FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
 1: 0xa09830 node::Abort() [node]
 2: 0xa09c55 node::OnFatalError(char const*, char const*) [node]
 3: 0xb7d71e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
 4: 0xb7da99 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
 5: 0xd2a1f5  [node]
 6: 0xd2a886 v8::internal::Heap::RecomputeLimits(v8::internal::GarbageCollector) [node]
 7: 0xd37105 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]
 8: 0xd37fb5 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
 9: 0xd3965f v8::internal::Heap::HandleGCRequest() [node]
10: 0xce8395 v8::internal::StackGuard::HandleInterrupts() [node]
11: 0x1042cb6 v8::internal::Runtime_StackGuard(int, unsigned long*, v8::internal::Isolate*) [node]
12: 0x13c5b79  [node]
```","vuln-fix: Prevent inefficient string parsing in packet decoder

The packet decoder used inefficient string concatenation in loops to extract substrings, causing excessive CPU usage on large or malicious inputs.
This exposed the system to potential Denial of Service attacks by allowing crafted packets to trigger high CPU consumption during decoding.
The fix replaces repeated character concatenation with substring extraction using index boundaries, improving performance and preventing resource exhaustion.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('dos', 'SECWORD', ''), ('#95', 'ISSUE', ''), ('99999991:422222222222222222222222222222222222222222222', 'SHA', ''), ('...', 'VERSION', ''), ('improved', 'ACTION', ''), ('out of memory', 'SECWORD', ''), ('security', 'SECWORD', ''), ('0x152fe7b808d1', 'SHA', ''), ('decodestring', 'SECWORD', ''), ('0x2dd385fb5d1', 'SHA', ''), ('socket.io', 'URL', ''), ('pc=0xf59746881be](this=0x175d34c42b69', 'SHA', ''), ('object>,0x14eccff10fe1', 'SHA', ''), ('add', 'ACTION', ''), ('0x31fc2693da29', 'SHA', ''), ('socket.io', 'URL', ''), ('index.js:242', 'URL', ''), ('bytecode=0xa7ed6554889', 'SHA', ''), ('offset=11](this=0x0a2881be5069', 'SHA', ''), ('decoder', 'SECWORD', ''), ('0x3ceaa8bf48c9>,0x14eccff10fe1', 'SHA', ''), ('...', 'VERSION', ''), ('error', 'FLAW', ''), ('out of memory', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('decoder', 'SECWORD', ''), ('decoder', 'SECWORD', ''), ('malicious', 'secword', ''), ('denial of service', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('high', 'SEVERITY', ''), ('decoding', 'SECWORD', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
41,"CWE-400', 'CWE-1333",GHSA-wc69-rhjr-hc9g,"@@ -151,7 +151,7 @@ function untruncateYear(yearStr) {
 function preprocessRFC2822(s) {
     // Remove comments and folding whitespace and replace multiple-spaces with a single space
     return s
-        .replace(/\([^)]*\)|[\n\t]/g, ' ')
+        .replace(/\([^()]*\)|[\n\t]/g, ' ')
         .replace(/(\s\s+)/g, ' ')
         .replace(/^\s\s*/, '')
         .replace(/\s\s*$/, '');","[bugfix] Fix redos in preprocessRFC2822 regex (#6015)

* fix ReDoS in preprocessRFC2822 regex

Fixes: [#2936](https://github.com/moment/moment/issues/6012)

Disallow nested rfc2822 comments to prevent quadratic regex execution time (i.e each open bracket is considered at most twice).","vuln-fix: Correct regex to prevent unbalanced comment parsing

The date preprocessing function used a regex that matched comments with unbalanced parentheses, causing incorrect removal of nested or malformed comments.
This flaw could allow attackers to craft input that bypasses comment stripping, potentially leading to incorrect date parsing or injection of malicious content.
The fix updates the regex to only match comments without nested parentheses, ensuring accurate and secure comment removal.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('preprocessrfc2822', 'SECWORD', ''), ('#6015', 'ISSUE', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('preprocessrfc2822', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('#2936](https://github.com', 'ISSUE', ''), ('issues/6012', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('flaw', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
42,CWE-400,GHSA-hq37-853p-g5cf,"@@ -187,8 +187,8 @@
     'transparent': (0, 0, 0, 0),
 }
 
-RGBA = re.compile(r'rgba\([ \n\r\t]*(.+?)[ \n\r\t]*\)')
-RGB = re.compile(r'rgb\([ \n\r\t]*(.+?)[ \n\r\t]*\)')
+RGBA = re.compile(r'rgba\((.+?)\)')
+RGB = re.compile(r'rgb\((.+?)\)')
 HEX_RRGGBB = re.compile('#[0-9a-f]{6}')
 HEX_RGB = re.compile('#[0-9a-f]{3}')
 
@@ -212,14 +212,14 @@ def color(string, opacity=1):
     if match:
         r, g, b, a = tuple(
             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255
-            for i in match.group(1).split(','))
+            for i in match.group(1).strip().split(','))
         return (r, g, b, a * 255 * opacity)
 
     match = RGB.search(string)
     if match:
         r, g, b = tuple(
             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255
-            for i in match.group(1).split(','))
+            for i in match.group(1).strip().split(','))
         return (r, g, b, opacity)
 
     match = HEX_RRGGBB.search(string)","Merge pull request from GHSA-hq37-853p-g5cf

Don’t use overlapping groups for regular expressions","vuln-fix: Tighten regex and parsing for color function inputs

The color parsing function used overly permissive regex patterns that allowed leading and trailing whitespace inside parentheses, risking incorrect or ambiguous matches.
This could enable attackers to craft malicious input that bypasses intended parsing logic, potentially leading to unexpected behavior or injection attacks in downstream processing.
The fix restricts regex patterns to exclude whitespace around color values and adds trimming before splitting, ensuring precise and secure extraction of color components.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('bypasses', 'SECWORD', ''), ('injection', 'secword', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
43,CWE-400,GHSA-cwfw-4gq5-mrqx,"@@ -127,7 +127,7 @@ module.exports = function(braces, options) {
     .set('multiplier', function() {
       var isInside = this.isInside('brace');
       var pos = this.position();
-      var m = this.match(/^\{(,+(?:(\{,+\})*),*|,*(?:(\{,+\})*),+)\}/);
+      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
       if (!m) return;
 
       this.multiplier = true;",optimize regex,"vuln-fix: Fix brace multiplier regex to prevent excessive backtracking

The brace parsing regex allowed complex nested comma patterns causing catastrophic backtracking on crafted input strings.
This exposed the parser to Regular Expression Denial of Service (ReDoS) attacks, potentially freezing applications processing malicious patterns.
The patch simplifies and restricts the regex pattern to only valid comma and brace sequences, eliminating exponential matching complexity.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('optimize', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('malicious', 'secword', ''), ('patch', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
44,CWE-400,GHSA-qhmp-h54x-38qr,"@@ -355,7 +355,7 @@ def parse_native_url(url):
         result = re.match(
             r'^https?://maker\.ifttt\.com/use/'
             r'(?P<webhook_id>[A-Z0-9_-]+)'
-            r'/?(?P<events>([A-Z0-9_-]+/?)+)?'
+            r'((?P<events>(/[A-Z0-9_-]+)+))?'
             r'/?(?P<params>\?.+)?$', url, re.I)
 
         if result:",Slight bulletproofing to IFTTT regex handling (#436),"vuln-fix: Correct URL parsing regex to prevent path confusion

The URL parsing regex allowed ambiguous matching of event paths, enabling crafted URLs to bypass intended path segment boundaries and cause incorrect event extraction.
This flaw could lead to unauthorized event triggering or injection by manipulating URL structure, potentially compromising webhook security.
The fix refines the regex to enforce leading slashes on event segments, ensuring precise and secure path parsing.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('#436', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'secword', ''), ('flaw', 'FLAW', ''), ('injection', 'secword', ''), ('manipulating', 'ACTION', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
45,CWE-400,GHSA-3q6g-vf58-7m4g,"@@ -48,7 +48,7 @@ def my_type(value):
 
 
 email_regex = re.compile(
-    r""^"" ""(?P<local>[^@]*[^@.])"" r""@"" r""(?P<server>[^@]+(?:\.[^@]+)*)"" r""$"",
+    r""^"" ""(?P<local>[^@]*[^@.])"" r""@"" r""(?P<server>[^@\.]+(?:\.[^@\.]+)*)"" r""$"",
     re.IGNORECASE,
 )","optimize email regex (credits: @kevinbackhouse, fix: #372)","vuln-fix: Restrict email regex to prevent invalid domain parts

The email validation regex allowed domain parts containing dots, enabling acceptance of malformed or potentially malicious email addresses.
This flaw could lead to security issues such as injection attacks or improper email handling by accepting invalid domain formats.
The fix tightens the regex by disallowing dots within individual domain labels, ensuring only valid domain segments are matched.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('optimize', 'ACTION', ''), ('fix', 'ACTION', ''), ('#372', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('malicious', 'secword', ''), ('flaw', 'FLAW', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
46,"CWE-400', 'CWE-125",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent injection risks

The code used the deprecated Buffer constructor with a string argument, which can lead to unexpected buffer content and potential injection vulnerabilities.
This posed a security risk because improper buffer creation might allow attackers to craft inputs that bypass encoding assumptions, leading to data corruption or injection attacks.
The fix replaces the deprecated constructor with Buffer.from, ensuring safe and predictable buffer creation from the authentication string.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('buffer.from', 'URL', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('authentication', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
47,CWE-400,GHSA-627q-g293-49q7,"@@ -14,6 +14,8 @@ limitations under the License.
 ==============================================================================*/
 #include ""tensorflow/core/framework/shape_inference.h""
 
+#include <cstdint>
+
 #include ""tensorflow/core/framework/bounds_check.h""
 #include ""tensorflow/core/framework/full_type_util.h""
 #include ""tensorflow/core/framework/node_def.pb.h""
@@ -789,6 +791,19 @@ Status InferenceContext::InternalMakeShapeFromTensor(
       return ReturnUnknownShape(out);
     }
     const auto num_dims = Value(shape_dim);
+    // TODO(mihaimaruseac): Should be `TensorShape::MaxDimensions()` as we are
+    // not able to materialize shapes with more than this number of dimensions
+    // but then shape inference would fail for operations such as
+    // `tf.range`/`tf.ones`, etc. where the shape is not really materialized,
+    // only used during the inference. Hence, just prevent doing a `reserve`
+    // with a very large argument.
+    const int64_t max_dimensions = 1 << 20;
+    if (num_dims >= max_dimensions) {
+      return errors::Internal(
+          ""Cannot create a tensor with "", num_dims,
+          "" dimensions, as these would be more than maximum of "",
+          max_dimensions);
+    }
     std::vector<DimensionHandle> dims;
     dims.reserve(num_dims);
     for (int i = 0; i < num_dims; i++) dims.push_back(UnknownDim());","Fix abort caused by allocating a too large vector.

We need to make sure that the number of dimensions in a shape is within limits.

PiperOrigin-RevId: 408997911
Change-Id: If59e1c23f2ec9c2d4ff4d8632fd62b2a7773a4eb","vuln-fix: Limit tensor shape dimensions to prevent excessive allocation

The shape inference code allowed creating tensors with an extremely large number of dimensions, leading to unbounded memory reservation during shape construction.
This posed a risk of denial of service or crashes due to excessive memory allocation when processing malformed or maliciously crafted tensor shapes.
The fix adds an upper bound check on the number of dimensions, returning an error if the requested shape exceeds a safe maximum threshold.

Weakness: CWE-789
Severity: High
CVSS: 7.5",0.23529411764705882,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('if59e1c23f2ec9c2d4ff4d8632fd62b2a7773a4eb', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('maliciously', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bound check', 'SECWORD', ''), ('error', 'FLAW', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-789', 'CWEID', ''), ('high', 'SEVERITY', '')]"
48,CWE-400,GHSA-fj7c-vg2v-ccrm,"@@ -152,6 +152,8 @@ public void run() {
                     }
                 }
             });
+        } else {
+            bufferedBinaryMessage.getData().free();
         }
     }",[UNDERTOW-1935] - buffer leak on incoming websocket PONG message,"vuln-fix: Free binary message buffer on unexpected code path

The code failed to release memory for buffered binary messages when an unexpected condition occurred, causing a resource leak.
This allowed attackers to exhaust server memory by triggering unhandled message states, potentially leading to denial of service.
The fix adds explicit freeing of the binary message buffer in the else branch to ensure proper memory management.

Weakness: CWE-401
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('leak', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('release memory', 'SECWORD', ''), ('resource leak', 'secword', ''), ('attackers', 'FLAW', ''), ('server', 'secword', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-401', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
49,CWE-400,GHSA-gx8x-g87m-h5q6,"@@ -2588,7 +2588,7 @@ protected void scanPI() throws IOException {
                     if (c == '?' || c == '/') {
                         char c0 = (char)c;
                         c = fCurrentEntity.read();
-                        if (c == '>') {
+                        if (c == '>' || c == -1) {
                             break;
                         }
                         fStringBuffer.append(c0);",fix: ensure ill-formed PIs are parsed correctly,"vuln-fix: Handle EOF in processing instruction scanning to prevent infinite loop

The XML parser failed to properly handle end-of-file (EOF) conditions when scanning processing instructions, causing it to loop indefinitely on malformed input.
This allowed attackers to trigger denial of service by feeding incomplete XML data that caused the parser to hang and consume resources indefinitely.
The fix adds EOF detection in the processing instruction scanner to break the loop safely when the end of input is reached.

Weakness: CWE-835
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('infinite loop', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-835', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
50,CWE-400,GHSA-23fp-fmrv-f5px,"@@ -7,6 +7,17 @@ const formatError = error => [
   { messages: [{ id: error.id, message: error.message, field: error.field }] },
 ];
 
+const PLUGIN_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-_]+$/;
+
+/**
+ * Validates a plugin name format
+ */
+const isValidPluginName = plugin => {
+  return (
+    _.isString(plugin) && !_.isEmpty(plugin) && PLUGIN_NAME_REGEX.test(plugin)
+  );
+};
+
 /**
  * A set of functions called ""actions"" for `Admin`
  */
@@ -67,7 +78,7 @@ module.exports = {
     try {
       const { plugin } = ctx.request.body;
 
-      if (!/^[A-Za-z0-9_-]+$/.test(plugin)) {
+      if (!isValidPluginName(plugin)) {
         return ctx.badRequest('Invalid plugin name');
       }
 
@@ -107,7 +118,7 @@ module.exports = {
     try {
       const { plugin } = ctx.params;
 
-      if (!/^[A-Za-z0-9_-]+$/.test(plugin)) {
+      if (!isValidPluginName(plugin)) {
         return ctx.badRequest('Invalid plugin name');
       }",chore(admin): Improve plugin name validator in install/uninstall plugin,"vuln-fix: Enforce stricter plugin name validation to prevent injection

Plugin names were validated with a permissive regex allowing names starting with digits or special characters, risking injection or unexpected behavior.
This weak validation could enable attackers to craft malicious plugin names that bypass filters, potentially leading to code injection or security bypasses.
The fix introduces a stricter regex requiring plugin names to start with a letter and only contain alphanumeric, dash, or underscore characters, improving input validation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('chore(admin', 'SECWORD', ''), ('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('injection', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('malicious', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('code injection', 'SECWORD', ''), ('security', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('input validation', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
51,CWE-400,GHSA-29mw-wpgm-hmr9,"@@ -152,10 +152,11 @@
   var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
       reHasRegExpChar = RegExp(reRegExpChar.source);
 
-  /** Used to match leading and trailing whitespace. */
-  var reTrim = /^\s+|\s+$/g,
-      reTrimStart = /^\s+/,
-      reTrimEnd = /\s+$/;
+  /** Used to match leading whitespace. */
+  var reTrimStart = /^\s+/;
+
+  /** Used to match a single whitespace character. */
+  var reWhitespace = /\s/;
 
   /** Used to match wrap detail comments. */
   var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
@@ -993,6 +994,19 @@
     });
   }
 
+  /**
+   * The base implementation of `_.trim`.
+   *
+   * @private
+   * @param {string} string The string to trim.
+   * @returns {string} Returns the trimmed string.
+   */
+  function baseTrim(string) {
+    return string
+      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
+      : string;
+  }
+
   /**
    * The base implementation of `_.unary` without support for storing metadata.
    *
@@ -1326,6 +1340,21 @@
       : asciiToArray(string);
   }
 
+  /**
+   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
+   * character of `string`.
+   *
+   * @private
+   * @param {string} string The string to inspect.
+   * @returns {number} Returns the index of the last non-whitespace character.
+   */
+  function trimmedEndIndex(string) {
+    var index = string.length;
+
+    while (index-- && reWhitespace.test(string.charAt(index))) {}
+    return index;
+  }
+
   /**
    * Used by `_.unescape` to convert HTML entities to characters.
    *
@@ -12494,7 +12523,7 @@
       if (typeof value != 'string') {
         return value === 0 ? value : +value;
       }
-      value = value.replace(reTrim, '');
+      value = baseTrim(value);
       var isBinary = reIsBinary.test(value);
       return (isBinary || reIsOctal.test(value))
         ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
@@ -14979,7 +15008,7 @@
     function trim(string, chars, guard) {
       string = toString(string);
       if (string && (guard || chars === undefined)) {
-        return string.replace(reTrim, '');
+        return baseTrim(string);
       }
       if (!string || !(chars = baseToString(chars))) {
         return string;
@@ -15014,7 +15043,7 @@
     function trimEnd(string, chars, guard) {
       string = toString(string);
       if (string && (guard || chars === undefined)) {
-        return string.replace(reTrimEnd, '');
+        return string.slice(0, trimmedEndIndex(string) + 1);
       }
       if (!string || !(chars = baseToString(chars))) {
         return string;","perf: improve performance of `toNumber`, `trim` and `trimEnd` on large input strings","vuln-fix: Fix trimming functions to handle Unicode whitespace correctly

The original trim functions used regexes that did not properly recognize all Unicode whitespace characters, causing incomplete trimming of user input strings.
This allowed attackers to bypass input validation or filtering by using non-ASCII whitespace characters, potentially leading to injection or logic errors.
The fix replaces regex-based trimming with explicit character checks and index calculations that correctly handle all whitespace, ensuring robust and secure string sanitization.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('improve', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('attackers', 'FLAW', ''), ('bypass', 'SECWORD', ''), ('input validation', 'secword', ''), ('injection', 'secword', ''), ('logic errors', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'SECWORD', ''), ('sanitization', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
52,CWE-400,GHSA-jgrx-mgxx-jf9v,"@@ -1,4 +1,4 @@
-var INTERPOLATE = /{([\s\S]+?)}/g
+var INTERPOLATE = /{([^{]+?)}/g
 
 module.exports = function(str, data) {
   var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +",fix potential dos in regex,"vuln-fix: Prevent ReDoS by restricting interpolation regex pattern

The interpolation regex used in the template engine was overly permissive, allowing nested braces that could cause catastrophic backtracking on crafted input.
This vulnerability exposed applications to Regular Expression Denial of Service (ReDoS) attacks, potentially exhausting server resources and causing service outages.
The fix restricts the regex to disallow nested braces, reducing complexity and preventing exponential backtracking during template parsing.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('dos', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'secword', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('server', 'secword', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
53,"CWE-400', 'CWE-770",GHSA-c582-c96p-r5cq,"@@ -39,6 +39,22 @@ namespace experimental {
     PrivateThreadPoolDatasetOp::kDatasetType;
 /* static */ constexpr const char* const PrivateThreadPoolDatasetOp::kDatasetOp;
 
+namespace {
+// To prevent integer overflow issues when allocating threadpool memory for an
+// unreasonable number of threads.
+constexpr int kThreadLimit = 65536;
+
+Status ValidateNumThreads(int32_t num_threads) {
+  if (num_threads < 0) {
+    return errors::InvalidArgument(""`num_threads` must be >= 0"");
+  }
+  if (num_threads >= kThreadLimit) {
+    return errors::InvalidArgument(""`num_threads` must be < "", kThreadLimit);
+  }
+  return Status::OK();
+}
+}  // namespace
+
 class ThreadPoolResource : public ResourceBase {
  public:
   ThreadPoolResource(Env* env, const ThreadOptions& thread_options,
@@ -83,9 +99,7 @@ class ThreadPoolHandleOp : public OpKernel {
     OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_threads"", &num_threads_));
     OP_REQUIRES_OK(ctx, ctx->GetAttr(""max_intra_op_parallelism"",
                                      &max_intra_op_parallelism_));
-    OP_REQUIRES(
-        ctx, num_threads_ > 0,
-        errors::InvalidArgument(""`num_threads` must be greater than zero.""));
+    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));
   }
 
   // The resource is deleted from the resource manager only when it is private
@@ -531,8 +545,7 @@ void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,
                                                         DatasetBase* input,
                                                         int32_t num_threads,
                                                         DatasetBase** output) {
-  OP_REQUIRES(ctx, num_threads >= 0,
-              errors::InvalidArgument(""`num_threads` must be >= 0""));
+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));
   *output = new Dataset(ctx,
                         DatasetContext(DatasetContext::Params(
                             {PrivateThreadPoolDatasetOp::kDatasetType,
@@ -546,8 +559,7 @@ void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,
   int64_t num_threads = 0;
   OP_REQUIRES_OK(
       ctx, ParseScalarArgument<int64_t>(ctx, ""num_threads"", &num_threads));
-  OP_REQUIRES(ctx, num_threads >= 0,
-              errors::InvalidArgument(""`num_threads` must be >= 0""));
+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));
   *output = new Dataset(ctx, input, num_threads);
 }","[tf.data] Set limit on number of threads used in threadpool_dataset.

PiperOrigin-RevId: 410922677
Change-Id: Ib25814a99043ab10805b5d2d7088ae0e0b7b04fd","vuln-fix: Validate thread count to prevent integer overflow

The code did not properly limit the number of threads requested, allowing excessively large values that could cause integer overflow during resource allocation.
This posed a security risk by enabling denial of service or memory corruption through uncontrolled resource consumption or invalid memory operations.
The fix adds explicit validation to ensure the thread count is non-negative and below a safe upper limit, preventing overflow and related vulnerabilities.

Weakness: CWE-190
Severity: High
CVSS: 7.5",0.11764705882352941,"[('tf.data', 'URL', ''), ('change', 'ACTION', ''), ('ib25814a99043ab10805b5d2d7088ae0e0b7b04fd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('integer overflow', 'secword', ''), ('integer overflow', 'SECWORD', ''), ('security', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('uncontrolled resource consumption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('vulnerabilities', 'secword', ''), ('weakness', 'secword', ''), ('cwe-190', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,CWE-787,GHSA-crch-j389-5f84,"@@ -48,6 +48,9 @@ TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,
     axis_value += NumDimensions(input);
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
+
   // Copy the input dimensions to output except the axis dimension.
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);
   int j = 0;","Prevent array write out-of-bounds.

If user passes an invalid axis, then we copy one too many dimensions to the output in the loop below these checks. Even if we didn't do that, there will be further issues with an invalid axis, so we check for that right now.

PiperOrigin-RevId: 371023299
Change-Id: I9eca37ffc2b29e8e48710f500701270ef0790224","vuln-fix: Validate axis parameter bounds in tensor resize

The tensor resize function did not verify that the axis parameter was within valid dimension bounds before use.
This allowed attackers to cause out-of-bounds access or undefined behavior by specifying invalid axis indices, risking memory corruption or crashes.
The fix adds explicit checks to ensure the axis value is non-negative and less than the number of input dimensions before proceeding.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('issues', 'FLAW', ''), ('change', 'ACTION', ''), ('i9eca37ffc2b29e8e48710f500701270ef0790224', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,"CWE-787', 'CWE-119",GHSA-v6r6-84gr-92rm,"@@ -383,6 +383,19 @@ struct LaunchAvgPooling3dGradOp<CPUDevice, T> {
                      const std::array<int64, 3>& output_shape,
                      const std::array<int64, 3>& padding,
                      TensorFormat data_format, Tensor* output) {
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(0) == out_backprop.dim_size(0),
+        errors::InvalidArgument(
+            ""Expected first dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(0), "" and "", out_backprop.dim_size(0)));
+    OP_REQUIRES(
+        context, tensor_in_shape.dim_size(4) == out_backprop.dim_size(4),
+        errors::InvalidArgument(
+            ""Expected last dimension of tensor_in_shape and ""
+            ""out_backprop to match, got "",
+            tensor_in_shape.dim_size(4), "" and "", out_backprop.dim_size(4)));
+
     output->flat<T>().setZero();
     std::array<int64, 3> input_size = {{tensor_in_shape.dim_size(3),
                                         tensor_in_shape.dim_size(2),","Fix assertion failure in pooling_ops_3d

PiperOrigin-RevId: 372364504
Change-Id: Iecde4fe26b47a8fa935d6e2611b5585ed5777781","vuln-fix: Validate tensor dimensions in LaunchAvgPooling3dGradOp

The gradient computation function lacked checks ensuring input tensor shapes matched expected dimensions, risking mismatched tensor operations.
This could lead to out-of-bounds memory access or corrupted computations when tensor dimensions were inconsistent, potentially causing crashes or data leaks.
The fix adds explicit dimension validation with error reporting to prevent invalid tensor shape usage before proceeding with gradient calculations.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('iecde4fe26b47a8fa935d6e2611b5585ed5777781', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('ensuring', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,CWE-787,GHSA-2wwc-w2gw-4329,"@@ -3603,7 +3603,7 @@ GlobOpt::OptSrc(IR::Opnd *opnd, IR::Instr * *pInstr, Value **indirIndexValRef, I
 
         opnd->SetValueType(valueType);
 
-        if(!IsLoopPrePass() && opnd->IsSymOpnd() && valueType.IsDefinite())
+        if(!IsLoopPrePass() && opnd->IsSymOpnd() && (valueType.IsDefinite() || valueType.IsNotTaggedValue()))
         {
             if (opnd->AsSymOpnd()->m_sym->IsPropertySym())
             {",CVE-2019-1366,"vuln-fix: Strengthen type checks to prevent unsafe property access

The optimizer incorrectly assumed only definitely typed operands were safe for property symbol operations, missing cases with untagged values.
This flaw could lead to type confusion and unsafe memory accesses during optimization, risking memory corruption or crashes.
The fix broadens the type check to include untagged values, ensuring only safe operand types proceed to property symbol handling.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('cve-2019-1366', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('safe', 'secword', ''), ('flaw', 'FLAW', ''), ('type confusion', 'secword', ''), ('unsafe', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
3,"CWE-787', 'CWE-120",GHSA-wcv5-qrj6-9pfm,"@@ -239,6 +239,20 @@ class Conv3DBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -346,6 +360,20 @@ class Conv3DCustomBackpropInputOp : public OpKernel {
       input_shape = context->input(0).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
                                 ""Conv3DBackpropInputOp"", /*num_spatial_dims=*/3,
@@ -696,6 +724,20 @@ class Conv3DBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(
@@ -808,6 +850,20 @@ class Conv3DCustomBackpropFilterOp : public OpKernel {
       filter_shape = context->input(1).shape();
     }
 
+    OP_REQUIRES(
+        context, input_shape.dim_size(4) == filter_shape.dim_size(3),
+        errors::InvalidArgument(""input and filter_sizes must have the same ""
+                                ""number of channels. Got "",
+                                input_shape.dim_size(4), "" for input and "",
+                                filter_shape.dim_size(3), "" for filter_sizes""));
+    OP_REQUIRES(
+        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),
+        errors::InvalidArgument(""out_backprop and filter_sizes must have the ""
+                                ""same number of channels. Got "",
+                                out_backprop_shape.dim_size(4),
+                                "" for out_backprop and "",
+                                filter_shape.dim_size(4), "" for filter_sizes""));
+
     ConvBackpropDimensions dims;
     OP_REQUIRES_OK(context,
                    ConvBackpropComputeDimensions(","Validate some shape requirements for `Conv3DBackpropFilter*` and `Conv3DBackpropInput*` ops.

Older versions of Eigen might otherwise crash / produce OOB read on specially crafted inputs.

PiperOrigin-RevId: 369293977
Change-Id: I58f51445a93936d7cf8e616f75de17677df36718","vuln-fix: Enforce channel dimension consistency in Conv3D backprop ops

The Conv3D backpropagation operations lacked validation ensuring input, output gradient, and filter tensors have matching channel dimensions.
This allowed malformed tensor shapes to proceed, risking out-of-bounds memory access or incorrect computations that could lead to crashes or data corruption.
The fix adds explicit dimension checks that reject inputs with mismatched channel sizes, preventing unsafe tensor operations and ensuring memory safety.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i58f51445a93936d7cf8e616f75de17677df36718', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'secword', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
4,"CWE-787', 'CWE-125",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Add bounds checks to prevent out-of-bounds memory access

The FormatConverter code lacked sufficient bounds checking on array indices and traversal order accesses, risking out-of-bounds reads during sparse-to-dense conversion.
This could lead to memory corruption or crashes if attackers supplied crafted inputs causing invalid indexing beyond allocated buffers.
The fix adds explicit boundary checks before indexing arrays and traversal vectors to ensure all accesses remain within valid ranges.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,"CWE-787', 'CWE-190",GHSA-q5wr-fvpq-p67g,"@@ -60,10 +60,20 @@ void PngImg::ReadInfo_(PngReadStruct& rs) {
 ///
 void PngImg::InitStorage_() {
     rowPtrs_.resize(info_.height, nullptr);
-    data_ = new png_byte[info_.height * info_.rowbytes];
+    // Extend height and rowbytes from uint32_t to size_t to avoid multiplication overflow when size_t is larger
+    size_t h = info_.height;
+    size_t rb = info_.rowbytes;
+    // We need to make sure that info_.height * info_.rowbytes will not overflow size_t
+    // Unfotunately, there's no simple and portable way to do this in C++
+    // For integer division of positive numbers a * b > c <==> a > c / b holds
+    if (h > std::numeric_limits<size_t>::max() / rb) {
+        // TODO Propagate this exception to JS, and test it
+        throw std::runtime_error(""Image is too large to allocate single buffer"");
+    }
+    data_ = new png_byte[h * rb];
 
     for(size_t i = 0; i < info_.height; ++i) {
-        rowPtrs_[i] = data_ + i * info_.rowbytes;
+        rowPtrs_[i] = data_ + i * rb;
     }
 }",Handle image size overflow,"vuln-fix: Prevent integer overflow in PNG image buffer allocation

The image buffer allocation did not check for integer overflow when multiplying height and row byte size, risking allocation of insufficient memory.
This allowed attackers to trigger buffer overflows by crafting images with large dimensions, potentially leading to memory corruption and arbitrary code execution.
The fix adds a size_t overflow check before allocation and throws an exception if the requested buffer size exceeds addressable memory limits.

Weakness: CWE-190
Severity: High
CVSS: 7.8",0.11764705882352941,"[('overflow', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('integer overflow', 'SECWORD', ''), ('integer overflow', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('buffer overflows', 'secword', ''), ('memory corruption', 'secword', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-190', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,"CWE-476', 'CWE-787', 'CWE-125",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Validate tensor channel dimensions in fused batch norm op

The fused batch normalization operation lacked strict validation ensuring scale, offset, mean, and variance tensors matched the input channel dimension.
This could lead to out-of-bounds memory access or corrupted computations when mismatched tensor sizes were used, risking crashes or incorrect model behavior.
The fix adds explicit checks that these parameter tensors have the same number of elements as the input channels, enforcing safe and consistent tensor shapes.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('ensuring', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,CWE-787,GHSA-pvrc-hg3f-58r6,"@@ -130,6 +130,7 @@ class DilationOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Output tensor is of the following dimensions:
     // [ batch, out_rows, out_cols, depth ]
@@ -229,6 +230,7 @@ class DilationBackpropInputOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Verify that the incoming gradient tensor has the expected size
     // [ batch, out_rows, out_cols, depth ]
@@ -318,8 +320,10 @@ struct DilationBackpropInput<CPUDevice, T> {
                 }
               }
             }
-            in_backprop(b, h_in_max, w_in_max, d) +=
-                out_backprop(b, h_out, w_out, d);
+            if (h_in_max < input_rows && w_in_max < input_cols) {
+              in_backprop(b, h_in_max, w_in_max, d) +=
+                  out_backprop(b, h_out, w_out, d);
+            }
           }
         }
       }
@@ -349,6 +353,7 @@ class DilationBackpropFilterOp : public OpKernel {
     ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
                &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
                &out_cols);
+    if (!context->status().ok()) return;
 
     // Verify that the incoming gradient tensor has the expected size
     // [ batch, out_rows, out_cols, depth ]
@@ -438,8 +443,10 @@ struct DilationBackpropFilter<CPUDevice, T> {
                 }
               }
             }
-            filter_backprop(h_max, w_max, d) +=
-                out_backprop(b, h_out, w_out, d);
+            if (h_max < filter_rows && w_max < filter_cols) {
+              filter_backprop(h_max, w_max, d) +=
+                  out_backprop(b, h_out, w_out, d);
+            }
           }
         }
       }","Add missing validations in dillation ops.

PiperOrigin-RevId: 372037158
Change-Id: I4ee304c84a02550c030288a6534000b934fc1599","vuln-fix: Prevent out-of-bounds writes in dilation backpropagation ops

The dilation backpropagation operations lacked proper boundary checks before writing to output tensors, allowing out-of-bounds memory writes during gradient computation.
This could lead to memory corruption, crashes, or potential arbitrary code execution by exploiting invalid memory accesses in tensor backpropagation.
The fix adds explicit bounds checks and early error returns to ensure all tensor accesses remain within valid dimensions, preventing unsafe memory writes.

Weakness: CWE-787  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('missing validations', 'SECWORD', ''), ('change', 'ACTION', ''), ('i4ee304c84a02550c030288a6534000b934fc1599', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds writes', 'SECWORD', ''), ('boundary checks', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('exploiting', 'SECWORD', ''), ('invalid memory accesses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('error', 'FLAW', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-787', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,"CWE-787', 'CWE-120",GHSA-44qp-9wwf-734r,"@@ -185,6 +185,27 @@ class SparseCount : public OpKernel {
                 errors::InvalidArgument(
                     ""Input indices must be a 2-dimensional tensor. Got: "",
                     indices.shape().DebugString()));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),
+                errors::InvalidArgument(""Input values must be a vector. Got: "",
+                                        values.shape().DebugString()));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),
+                errors::InvalidArgument(""Input shape must be a vector. Got: "",
+                                        shape.shape().DebugString()));
+    OP_REQUIRES(context,
+                values.shape().dim_size(0) == indices.shape().dim_size(0),
+                errors::InvalidArgument(
+                    ""Number of values must match first dimension of indices."",
+                    ""Got "", values.shape().dim_size(0),
+                    "" values, indices shape: "", indices.shape().DebugString()));
+    OP_REQUIRES(
+        context, shape.shape().dim_size(0) == indices.shape().dim_size(1),
+        errors::InvalidArgument(
+            ""Number of dimensions must match second dimension of indices."",
+            ""Got "", shape.shape().dim_size(0),
+            "" dimensions, indices shape: "", indices.shape().DebugString()));
+    OP_REQUIRES(context, shape.NumElements() > 0,
+                errors::InvalidArgument(
+                    ""The shape argument requires at least one element.""));
 
     if (use_weights) {
       OP_REQUIRES(
@@ -195,28 +216,11 @@ class SparseCount : public OpKernel {
               ""; values shape: "", values.shape().DebugString()));
     }
 
-    OP_REQUIRES(context, shape.NumElements() != 0,
-                errors::InvalidArgument(
-                    ""The shape argument requires at least one element.""));
-
     bool is_1d = shape.NumElements() == 1;
     auto shape_vector = shape.flat<int64_t>();
     int num_batches = is_1d ? 1 : shape_vector(0);
     int num_values = values.NumElements();
 
-    for (int b = 0; b < shape_vector.size(); b++) {
-      OP_REQUIRES(context, shape_vector(b) >= 0,
-                  errors::InvalidArgument(
-                      ""Elements in dense_shape must be >= 0. Instead got:"",
-                      shape.DebugString()));
-    }
-
-    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),
-                errors::InvalidArgument(
-                    ""Number of values must match first dimension of indices."",
-                    ""Got "", num_values,
-                    "" values, indices shape: "", indices.shape().DebugString()));
-
     const auto indices_values = indices.matrix<int64_t>();
     const auto values_values = values.flat<T>();
     const auto weight_values = weights.flat<W>();
@@ -225,16 +229,6 @@ class SparseCount : public OpKernel {
 
     T max_value = 0;
 
-    OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),
-                errors::InvalidArgument(
-                    ""The first dimension of indices must be equal to or ""
-                    ""greather than number of values. ( "",
-                    indices.shape().dim_size(0), "" vs. "", num_values, "" )""));
-    OP_REQUIRES(context, indices.shape().dim_size(1) > 0,
-                errors::InvalidArgument(""The second dimension of indices must ""
-                                        ""be greater than 0. Received: "",
-                                        indices.shape().dim_size(1)));
-
     for (int idx = 0; idx < num_values; ++idx) {
       int batch = is_1d ? 0 : indices_values(idx, 0);
       if (batch >= num_batches) {","Cleanup and remove duplicate validation in `SparseCount`.

We have valdiation that is duplicated, checking different conditions, in different formats and failing to capture all cases. This should fix all the previous bugs.

PiperOrigin-RevId: 414886981
Change-Id: Ibf0bba0beb057b76d505324bb9487565daf95f01","vuln-fix: Add strict input shape validation in SparseCount kernel

The SparseCount operator lacked comprehensive validation of input tensor shapes and dimension consistency, allowing malformed inputs to proceed unchecked.
This could lead to out-of-bounds memory access or logic errors during sparse tensor processing, potentially causing crashes or data corruption.
The fix enforces strict shape checks on indices, values, and shape tensors, ensuring dimension compatibility and non-empty inputs before computation.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('remove', 'ACTION', ''), ('duplicate validation', 'secword', ''), ('fix', 'ACTION', ''), ('bugs', 'FLAW', ''), ('change', 'ACTION', ''), ('ibf0bba0beb057b76d505324bb9487565daf95f01', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,CWE-787,GHSA-p23j-g745-8449,"@@ -2161,27 +2161,46 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
             return false;
         }
         break;
-    case Js::OpCode::Decr_A:
-        isIncr = false;
-    case Js::OpCode::Incr_A:
-        isChangedByOne = true;
-        goto MemOpCheckInductionVariable;
     case Js::OpCode::Sub_I4:
-    case Js::OpCode::Sub_A:
         isIncr = false;
-    case Js::OpCode::Add_A:
     case Js::OpCode::Add_I4:
     {
-MemOpCheckInductionVariable:
-        StackSym *sym = instr->GetSrc1()->GetStackSym();
-        if (!sym)
+        // The only case in which these OpCodes can contribute to an inductionVariableChangeInfo
+        // is when the induction variable is being modified and overwritten aswell (ex: j = j + 1)
+        // and not when the induction variable is modified but not overwritten (ex: k = j + 1).
+        // This can either be detected in IR as
+        // s1     = Add_I4 s1     1  // Case #1, can be seen with ""j++"".
+        // or as
+        // s4(s2) = Add_I4 s3(s1) 1  // Case #2, can be see with ""j = j + 1"".
+        // s1     = Ld_A   s2
+        bool isInductionVar = false;
+        IR::Instr* nextInstr = instr->m_next;
+        if (
+            // Checks for Case #1 and Case #2
+            instr->GetDst()->GetStackSym() != nullptr &&
+            instr->GetDst()->IsRegOpnd() &&
+            (
+                // Checks for Case #1
+                (instr->GetDst()->GetStackSym() == instr->GetSrc1()->GetStackSym()) ||
+
+                // Checks for Case #2
+                (nextInstr&& nextInstr->m_opcode == Js::OpCode::Ld_A &&
+                 nextInstr->GetSrc1()->IsRegOpnd() &&
+                 nextInstr->GetDst()->IsRegOpnd() &&
+                 GetVarSymID(instr->GetDst()->GetStackSym()) == nextInstr->GetSrc1()->GetStackSym()->m_id &&
+                 GetVarSymID(instr->GetSrc1()->GetStackSym()) == nextInstr->GetDst()->GetStackSym()->m_id)
+            )
+        )
         {
-            sym = instr->GetSrc2()->GetStackSym();
+            isInductionVar = true;
         }
+        
+        // Even if dstIsInductionVar then dst == src1 so it's safe to use src1 as the induction sym always.
+        StackSym* sym = instr->GetSrc1()->GetStackSym();
 
         SymID inductionSymID = GetVarSymID(sym);
 
-        if (IsSymIDInductionVariable(inductionSymID, this->currentBlock->loop))
+        if (isInductionVar && IsSymIDInductionVariable(inductionSymID, this->currentBlock->loop))
         {
             if (!isChangedByOne)
             {
@@ -2246,7 +2265,6 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
                     {
                         inductionVariableChangeInfo.unroll++;
                     }
-                    
                     inductionVariableChangeInfo.isIncremental = isIncr;
                     loop->memOpInfo->inductionVariableChangeInfoMap->Item(inductionSymID, inductionVariableChangeInfo);
                 }
@@ -2284,6 +2302,27 @@ GlobOpt::CollectMemOpInfo(IR::Instr *instrBegin, IR::Instr *instr, Value *src1Va
             }
         }
         NEXT_INSTR_IN_RANGE;
+        IR::Instr* prevInstr = instr->m_prev;
+
+        // If an instr where the dst is an induction variable (and thus is being written to) is not caught by a case in the above
+        // switch statement (which implies that this instr does not contributes to a inductionVariableChangeInfo) and in the default
+        // case does not set doMemOp to false (which implies that this instr does not invalidate this MemOp), then FailFast as we
+        // should not be performing a MemOp under these conditions. 
+        AssertOrFailFast(!instr->GetDst() || instr->m_opcode == Js::OpCode::IncrLoopBodyCount || !loop->memOpInfo ||
+
+            // Refer to ""Case #2"" described above in this function. For the following IR:
+            // Line #1: s4(s2) = Add_I4 s3(s1) 1
+            // Line #2: s3(s1) = Ld_A   s4(s2)
+            // do not consider line #2 as a violating instr
+            (instr->m_opcode == Js::OpCode::Ld_I4 &&
+                prevInstr && (prevInstr->m_opcode == Js::OpCode::Add_I4 || prevInstr->m_opcode == Js::OpCode::Sub_I4) &&
+                instr->GetSrc1()->IsRegOpnd() &&
+                instr->GetDst()->IsRegOpnd() &&
+                prevInstr->GetDst()->IsRegOpnd() &&
+                instr->GetDst()->GetStackSym() == prevInstr->GetSrc1()->GetStackSym() &&
+                instr->GetSrc1()->GetStackSym() == prevInstr->GetDst()->GetStackSym()) ||
+
+            !loop->memOpInfo->inductionVariableChangeInfoMap->ContainsKey(GetVarSymID(instr->GetDst()->GetStackSym())));
     }
 
     return true;",CVE-2019-1335,"vuln-fix: Enforce strict induction variable checks in loop optimization

The loop optimization logic failed to correctly identify and validate induction variable updates, allowing inconsistent or unsafe memory operations during JIT compilation.
This could lead to incorrect assumptions about variable states, causing memory corruption or undefined behavior exploitable by crafted JavaScript code.
The fix adds precise induction variable detection and asserts fail-fast on unexpected writes, ensuring only valid induction variable modifications affect memory operation info.

Weakness: CWE-704
Severity: High
CVSS: 7.2",0.17647058823529413,"[('cve-2019-1335', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('updates', 'ACTION', ''), ('unsafe', 'secword', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,"CWE-787', 'CWE-125",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct loop index to prevent out-of-bounds access in type specialization

The loop incorrectly used a fixed index instead of the loop variable, causing repeated access to the same element and potential out-of-bounds mutation of type arguments.
This could lead to memory corruption or undefined behavior by modifying unintended elements, risking program crashes or exploitable state inconsistencies.
The fix replaces the fixed index with the correct loop variable to ensure proper iteration and safe access within the argument list.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('incorrectly used', 'SECWORD', ''), ('fixed', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
11,CWE-787,GHSA-37pf-w9ff-gqvm,"@@ -394,6 +394,7 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
     case Js::OpCode::StRootFldStrict:
     case Js::OpCode::StSlot:
     case Js::OpCode::StSlotChkUndecl:
+    case Js::OpCode::StSuperFld:
         Assert(dstOpnd != nullptr);
         sym = dstOpnd->AsSymOpnd()->m_sym;
         if (inGlobOpt)",[CVE-2019-0927],"vuln-fix: Include StSuperFld in field kill processing

The global optimizer did not consider the StSuperFld opcode when processing field kills, causing incomplete tracking of field modifications during optimization.
This could lead to incorrect assumptions about object state, enabling subtle type confusion or stale data usage that attackers might exploit for memory corruption.
The fix adds StSuperFld to the set of opcodes that trigger field kill processing, ensuring accurate state tracking and preventing optimization-induced vulnerabilities.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('cve-2019-0927', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('type confusion', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('vulnerabilities', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
12,"CWE-787', 'CWE-120",GHSA-3ff2-r28g-w7h9,"@@ -168,7 +168,7 @@ Status TransposeShapeFn(InferenceContext* c) {
 
     for (int32_t i = 0; i < rank; ++i) {
       int64_t in_idx = data[i];
-      if (in_idx >= rank) {
+      if (in_idx >= rank || in_idx <= -rank) {
         return errors::InvalidArgument(""perm dim "", in_idx,
                                        "" is out of range of input rank "", rank);
       }","Make Transpose's shape inference function validate that negative `perm` values are within the tensor's rank.

PiperOrigin-RevId: 403252853
Change-Id: Ia6b31b45b237312668bb31c2c3b3c7bbce2d2610","vuln-fix: Validate negative indices in transpose permutation

The transpose shape function did not properly validate negative permutation indices, allowing out-of-range negative values to pass unchecked.
This could lead to invalid memory access or logic errors during shape inference, potentially causing crashes or incorrect tensor operations.
The fix adds boundary checks for negative indices to ensure all permutation dimensions are within valid range before processing.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ia6b31b45b237312668bb31c2c3b3c7bbce2d2610', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('validate', 'secword', ''), ('out-of-range', 'SECWORD', ''), ('invalid memory access', 'SECWORD', ''), ('logic errors', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,"CWE-787', 'CWE-119",GHSA-6f89-8j54-29xf,"@@ -250,6 +250,19 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64 out_cols = out_backprop.dim_size(2);
     const int64 out_depth = out_backprop.dim_size(3);
 
+    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,
+                errors::InvalidArgument(""Given out_backprop shape "",
+                                        out_backprop.shape().DebugString(),
+                                        "", row_seq_tensor must have at least "",
+                                        out_rows + 1, "" elements, but got "",
+                                        row_seq_tensor.NumElements()));
+    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,
+                errors::InvalidArgument(""Given out_backprop shape "",
+                                        out_backprop.shape().DebugString(),
+                                        "", col_seq_tensor must have at least "",
+                                        out_cols + 1, "" elements, but got "",
+                                        col_seq_tensor.NumElements()));
+
     auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();
     auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();
     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();","Validate inputs of `FractionalAvgPoolGrad`.

PiperOrigin-RevId: 372420640
Change-Id: Icc583928e6cdc3062e12498e4d2337a8fe3da016","vuln-fix: Validate sequence tensor sizes in FractionalAvgPoolGradOp

The gradient operation for fractional average pooling did not verify that sequence tensors had sufficient elements relative to output dimensions.
This allowed out-of-bounds access risks when sequence tensors were smaller than expected, potentially causing memory corruption or crashes.
The fix adds explicit checks to ensure sequence tensors exceed output sizes, preventing invalid memory reads during gradient computation.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('icc583928e6cdc3062e12498e4d2337a8fe3da016', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,"CWE-787', 'CWE-131",GHSA-m3f9-w3p3-p669,"@@ -284,10 +284,22 @@ class QuantizedMulOp : public OpKernel {
   void Compute(OpKernelContext* context) override {
     const Tensor& x = context->input(0);
     const Tensor& y = context->input(1);
-    const float min_x = context->input(2).flat<float>()(0);
-    const float max_x = context->input(3).flat<float>()(0);
-    const float min_y = context->input(4).flat<float>()(0);
-    const float max_y = context->input(5).flat<float>()(0);
+    auto& min_x_tensor = context->input(2);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_x_tensor.shape()),
+                errors::InvalidArgument(""min_x must be a scalar""));
+    const float min_x = min_x_tensor.flat<float>()(0);
+    auto& max_x_tensor = context->input(3);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_x_tensor.shape()),
+                errors::InvalidArgument(""max_x must be a scalar""));
+    const float max_x = max_x_tensor.flat<float>()(0);
+    auto& min_y_tensor = context->input(4);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_y_tensor.shape()),
+                errors::InvalidArgument(""min_y must be a scalar""));
+    const float min_y = min_y_tensor.flat<float>()(0);
+    auto& max_y_tensor = context->input(5);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_y_tensor.shape()),
+                errors::InvalidArgument(""max_y must be a scalar""));
+    const float max_y = max_y_tensor.flat<float>()(0);
 
     BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));
     if (!bcast.IsValid()) {","Validate inputs to `QuantizedMul`

PiperOrigin-RevId: 369756982
Change-Id: I00d960cc3b9316fd7a86bd37a44e341c96e17624","vuln-fix: Validate scalar inputs in quantized multiplication op

The QuantizedMulOp did not verify that min and max input tensors were scalars, allowing malformed tensor shapes to bypass assumptions in computation.
This could lead to out-of-bounds memory access or incorrect calculations, potentially causing crashes or data corruption during model execution.
The fix adds explicit checks to ensure all min and max inputs are scalar tensors, rejecting invalid shapes early with clear error messages.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i00d960cc3b9316fd7a86bd37a44e341c96e17624', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('incorrect calculations', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
15,CWE-787,GHSA-2rfj-2mwp-787v,"@@ -9655,6 +9655,10 @@ using namespace Js;
             Var result = CALL_ENTRYPOINT(threadContext, marshalledFunction->GetEntryPoint(), function, CallInfo(flags, 1), thisVar);
             result = CrossSite::MarshalVar(requestContext, result);
 
+            // Set implicit call flags so we bail out if we're trying to propagate the value forward, e.g., from a compare. Subsequent calls
+            // to the getter may produce different results.
+            threadContext->AddImplicitCallFlags(ImplicitCall_Accessor);
+
             return result;
         });
     }",CVE-2019-0993,"vuln-fix: Prevent inconsistent accessor side effects in cross-site calls

The code failed to set implicit call flags when invoking accessor getters during cross-site marshaling, allowing inconsistent side effects to propagate unexpectedly.
This could lead to unpredictable behavior or security issues if subsequent calls to the same accessor returned different results, breaking assumptions about state consistency.
The fix adds the appropriate implicit call flag to ensure the runtime bails out on side-effecting accessors, preserving consistent execution semantics.

Weakness: CWE-841
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('cve-2019-0993', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-841', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
16,CWE-787,GHSA-2gfx-95x2-5v3x,"@@ -17,6 +17,7 @@ limitations under the License.
 
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/register_types.h""
+#include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/tensor_types.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_op.h""
@@ -30,9 +31,29 @@ class QuantizedReshapeOp : public ReshapeOp {
   void Compute(OpKernelContext* ctx) override {
     // This call processes inputs 1 and 2 to write output 0.
     ReshapeOp::Compute(ctx);
+    if (!ctx->status().ok()) {
+      return;
+    }
+
+    const auto& input_min_float_tensor = ctx->input(2);
+    const auto& input_min_float_shape = input_min_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_min_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
+                     (input_min_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_min must be a scalar or a vector of 1 element""));
+    const float input_min_float = input_min_float_tensor.flat<float>()(0);
+    const auto& input_max_float_tensor = ctx->input(3);
+    const auto& input_max_float_shape = input_max_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_max_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
+                     (input_max_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_max must be a scalar or a vector of 1 element""));
+    const float input_max_float = input_max_float_tensor.flat<float>()(0);
 
-    const float input_min_float = ctx->input(2).flat<float>()(0);
-    const float input_max_float = ctx->input(3).flat<float>()(0);
     Tensor* output_min = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
     output_min->flat<float>()(0) = input_min_float;","Validate arguments to `QuantizedReshape`.

Ensure that validations from `Reshape` also terminate `QuantizedReshape` on failure.

PiperOrigin-RevId: 369775421
Change-Id: If8c5342267aceea65b7cb83a4b183304886f1ce8","vuln-fix: Validate tensor shapes in QuantizedReshapeOp inputs

The QuantizedReshapeOp did not verify that input_min and input_max tensors were scalars or single-element vectors before accessing their values.
This lack of validation could lead to out-of-bounds memory access or undefined behavior when malformed tensor shapes are provided by attackers.
The fix adds explicit shape checks to ensure inputs are either scalars or vectors of size one, preventing invalid memory reads and improving robustness.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('if8c5342267aceea65b7cb83a4b183304886f1ce8', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('improving', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,CWE-787,GHSA-5rcr-q3rx-j7vr,"@@ -410,6 +410,14 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
         if (inGlobOpt)
         {
             KillObjectHeaderInlinedTypeSyms(this->currentBlock, false);
+            if (this->objectTypeSyms)
+            {
+                if (this->currentBlock->globOptData.maybeWrittenTypeSyms == nullptr)
+                {
+                    this->currentBlock->globOptData.maybeWrittenTypeSyms = JitAnew(this->alloc, BVSparse<JitArenaAllocator>, this->alloc);
+                }
+                this->currentBlock->globOptData.maybeWrittenTypeSyms->Or(this->objectTypeSyms);
+            }
         }
 
         // fall through",[CVE-2019-1107] Chakra JIT Type Confusion FinishOptPropOp,"vuln-fix: Track potentially written object type symbols in optimization

The global optimizer failed to record object type symbols that might be written during optimization, leading to incomplete type state tracking.
This caused incorrect assumptions about object layouts, risking type confusion and memory corruption vulnerabilities during JIT code generation.
The fix adds logic to accumulate and store possibly modified type symbols in the current block’s optimization data to ensure accurate type state management.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('cve-2019-1107', 'VULNID', 'CVE'), ('type confusion', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('type confusion', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('vulnerabilities', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
18,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Add safe tensor access checks to prevent null dereference

The code accessed input and output tensors without verifying their presence, risking null pointer dereferences during tensor operations.
This could lead to crashes or undefined behavior when malformed or incomplete model data is processed, potentially causing denial of service.
The fix replaces direct tensor retrieval calls with safe variants that validate tensor availability and return errors on failure, ensuring robust input validation.

Weakness: CWE-476
Severity: High
CVSS: 7.5",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('null dereference', 'SECWORD', ''), ('null pointer dereferences', 'SECWORD', ''), ('incomplete model', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('validate', 'secword', ''), ('availability', 'secword', ''), ('errors', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-476', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,CWE-787,GHSA-q99r-j969-6jwr,"@@ -354,6 +354,12 @@ namespace Js
             Var varLength;
             if (targetFunction->GetProperty(targetFunction, PropertyIds::length, &varLength, nullptr, requestContext))
             {
+                if (!TaggedInt::Is(varLength))
+                {
+                    // ToInt32 conversion on non-primitive length can invalidate assumptions made by the JIT,
+                    // so add implicit call flag if length isn't a TaggedInt already
+                    requestContext->GetThreadContext()->AddImplicitCallFlags(ImplicitCall_Accessor);
+                }
                 len = JavascriptConversion::ToInt32(varLength, requestContext);
             }",[CVE-2019-1237],"vuln-fix: Prevent JIT assumptions break from non-integer length property

The code failed to handle cases where the function length property was not a tagged integer, risking invalid assumptions in JIT optimizations.
This could lead to incorrect code generation or memory corruption due to unexpected implicit calls triggered by ToInt32 conversion on non-primitive values.
The fix adds an implicit call flag when length is not a tagged integer, ensuring the JIT accounts for side effects and maintains safe execution.

Weakness: CWE-682
Severity: High
CVSS: 7.5",0.11764705882352941,"[('cve-2019-1237', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-682', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,CWE-787,GHSA-grvw-q343-58wh,"@@ -1167,6 +1167,10 @@ void GlobOpt::InsertValueCompensation(
     IR::Instr *insertBeforeInstr = predecessor->GetLastInstr();
     Func *const func = insertBeforeInstr->m_func;
     bool setLastInstrInPredecessor;
+    // If this is a loop back edge, and the successor has been completed, don't attempt to update its block data.
+    // The update is unnecessary, and the data has likely been freed.
+    bool updateSuccessorBlockData = !this->isPerformingLoopBackEdgeCompensation || successor->GetDataUseCount() > 0;
+
     if(insertBeforeInstr->IsBranchInstr() || insertBeforeInstr->m_opcode == Js::OpCode::BailTarget)
     {
         // Don't insert code between the branch and the corresponding ByteCodeUses instructions
@@ -1257,29 +1261,33 @@ void GlobOpt::InsertValueCompensation(
             // Merge the head segment length value
             Assert(predecessorBlockData.liveVarSyms->Test(predecessorHeadSegmentLengthSym->m_id));
             predecessorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
-            successorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
             Value *const predecessorHeadSegmentLengthValue =
                 predecessorBlockData.FindValue(predecessorHeadSegmentLengthSym);
             Assert(predecessorHeadSegmentLengthValue);
             predecessorBlockData.SetValue(predecessorHeadSegmentLengthValue, mergedHeadSegmentLengthSym);
-            Value *const mergedHeadSegmentLengthValue = successorBlockData.FindValue(mergedHeadSegmentLengthSym);
-            if(mergedHeadSegmentLengthValue)
+
+            if (updateSuccessorBlockData)
             {
-                Assert(mergedHeadSegmentLengthValue->GetValueNumber() != predecessorHeadSegmentLengthValue->GetValueNumber());
-                if(predecessorHeadSegmentLengthValue->GetValueInfo() != mergedHeadSegmentLengthValue->GetValueInfo())
+                successorBlockData.liveVarSyms->Set(mergedHeadSegmentLengthSym->m_id);
+                Value *const mergedHeadSegmentLengthValue = successorBlockData.FindValue(mergedHeadSegmentLengthSym);
+                if(mergedHeadSegmentLengthValue)
                 {
-                    mergedHeadSegmentLengthValue->SetValueInfo(
-                        ValueInfo::MergeLikelyIntValueInfo(
-                            this->alloc,
-                            mergedHeadSegmentLengthValue,
-                            predecessorHeadSegmentLengthValue,
-                            mergedHeadSegmentLengthValue->GetValueInfo()->Type()
-                                .Merge(predecessorHeadSegmentLengthValue->GetValueInfo()->Type())));
+                    Assert(mergedHeadSegmentLengthValue->GetValueNumber() != predecessorHeadSegmentLengthValue->GetValueNumber());
+                    if(predecessorHeadSegmentLengthValue->GetValueInfo() != mergedHeadSegmentLengthValue->GetValueInfo())
+                    {
+                        mergedHeadSegmentLengthValue->SetValueInfo(
+                            ValueInfo::MergeLikelyIntValueInfo(
+                                this->alloc,
+                                mergedHeadSegmentLengthValue,
+                                predecessorHeadSegmentLengthValue,
+                                mergedHeadSegmentLengthValue->GetValueInfo()->Type()
+                                    .Merge(predecessorHeadSegmentLengthValue->GetValueInfo()->Type())));
+                    }
+                }
+                else
+                {
+                    successorBlockData.SetValue(CopyValue(predecessorHeadSegmentLengthValue), mergedHeadSegmentLengthSym);
                 }
-            }
-            else
-            {
-                successorBlockData.SetValue(CopyValue(predecessorHeadSegmentLengthValue), mergedHeadSegmentLengthSym);
             }
         }
 
@@ -1300,27 +1308,31 @@ void GlobOpt::InsertValueCompensation(
             // Merge the length value
             Assert(predecessorBlockData.liveVarSyms->Test(predecessorLengthSym->m_id));
             predecessorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
-            successorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
             Value *const predecessorLengthValue = predecessorBlockData.FindValue(predecessorLengthSym);
             Assert(predecessorLengthValue);
             predecessorBlockData.SetValue(predecessorLengthValue, mergedLengthSym);
-            Value *const mergedLengthValue = successorBlockData.FindValue(mergedLengthSym);
-            if(mergedLengthValue)
+
+            if (updateSuccessorBlockData)
             {
-                Assert(mergedLengthValue->GetValueNumber() != predecessorLengthValue->GetValueNumber());
-                if(predecessorLengthValue->GetValueInfo() != mergedLengthValue->GetValueInfo())
+                successorBlockData.liveVarSyms->Set(mergedLengthSym->m_id);
+                Value *const mergedLengthValue = successorBlockData.FindValue(mergedLengthSym);
+                if(mergedLengthValue)
                 {
-                    mergedLengthValue->SetValueInfo(
-                        ValueInfo::MergeLikelyIntValueInfo(
-                            this->alloc,
-                            mergedLengthValue,
-                            predecessorLengthValue,
-                            mergedLengthValue->GetValueInfo()->Type().Merge(predecessorLengthValue->GetValueInfo()->Type())));
+                    Assert(mergedLengthValue->GetValueNumber() != predecessorLengthValue->GetValueNumber());
+                    if(predecessorLengthValue->GetValueInfo() != mergedLengthValue->GetValueInfo())
+                    {
+                        mergedLengthValue->SetValueInfo(
+                            ValueInfo::MergeLikelyIntValueInfo(
+                                this->alloc,
+                                mergedLengthValue,
+                                predecessorLengthValue,
+                                mergedLengthValue->GetValueInfo()->Type().Merge(predecessorLengthValue->GetValueInfo()->Type())));
+                    }
+                }
+                else
+                {
+                    successorBlockData.SetValue(CopyValue(predecessorLengthValue), mergedLengthSym);
                 }
-            }
-            else
-            {
-                successorBlockData.SetValue(CopyValue(predecessorLengthValue), mergedLengthSym);
             }
         }",[CVE-2019-1300],"vuln-fix: Avoid use-after-free by skipping updates on completed loop blocks

The optimization pass updated block data for loop back edges even after the successor block was completed and its data likely freed.
This caused use-after-free errors leading to memory corruption and potential arbitrary code execution during JIT compilation.
The fix adds a condition to skip updating successor block data when performing loop back edge compensation if the successor’s data use count is zero.

Weakness: CWE-416
Severity: High
CVSS: 7.8",0.11764705882352941,"[('cve-2019-1300', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('use-after-free', 'SECWORD', ''), ('updates', 'ACTION', ''), ('updated', 'ACTION', ''), ('use-after-free', 'SECWORD', ''), ('errors', 'FLAW', ''), ('memory corruption', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('updating', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-416', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,"CWE-787', 'CWE-120",GHSA-f8h4-7rgh-q2gm,"@@ -18,6 +18,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/function_handle_cache.h""
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/resource_mgr.h""
+#include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/ops_util.h""
 #include ""tensorflow/core/lib/core/threadpool.h""
 #include ""tensorflow/core/lib/io/record_writer.h""
@@ -91,8 +92,20 @@ class ToTFRecordOp : public AsyncOpKernel {
     TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(
         &iter_ctx, /*parent=*/nullptr, ""ToTFRecordOpIterator"", &iterator));
 
+    const int num_output_dtypes = finalized_dataset->output_dtypes().size();
+    if (num_output_dtypes != 1) {
+      return errors::InvalidArgument(
+          ""ToTFRecordOp currently only support datasets of 1 single column, "",
+          ""but got "", num_output_dtypes);
+    }
+    const DataType dt = finalized_dataset->output_dtypes()[0];
+    if (dt != DT_STRING) {
+      return errors::InvalidArgument(
+          ""ToTFRecordOp currently only supports DT_STRING dataypes, but got "",
+          DataTypeString(dt));
+    }
     std::vector<Tensor> components;
-    components.reserve(finalized_dataset->output_dtypes().size());
+    components.reserve(num_output_dtypes);
     bool end_of_sequence;
     do {
       TF_RETURN_IF_ERROR(","Fix segfault/heap buffer overflow in `{Experimental,}DatasetToTFRecord` where dataset is numeric.

Code assumes only strings inputs and then interprets numbers as valid `tstring`s. Then, when trying to compute the CRC of the record this results in heap buffer overflow.

PiperOrigin-RevId: 387675909
Change-Id: I7396b9b8afc1ac744112af7c0b1cd7bb41e0f556","vuln-fix: Restrict ToTFRecordOp to single string column datasets

The ToTFRecordOp did not validate the dataset schema, allowing datasets with multiple columns or non-string types to be processed incorrectly.
This could lead to unexpected behavior or data corruption when writing TFRecord files, potentially causing downstream errors or security issues from malformed data.
The fix adds explicit checks to ensure only single-column datasets of type DT_STRING are accepted, rejecting unsupported schemas early.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('segfault', 'SECWORD', ''), ('buffer overflow', 'secword', ''), ('crc', 'secword', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('i7396b9b8afc1ac744112af7c0b1cd7bb41e0f556', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('errors', 'FLAW', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,"CWE-787', 'CWE-120",GHSA-4278-2v5v-65r4,"@@ -420,6 +420,15 @@ class RaggedBincountOp : public OpKernel {
     int num_values = values.size();
     int batch_idx = 0;
 
+    OP_REQUIRES(ctx, splits(0) == 0,
+                errors::InvalidArgument(""Splits must start with 0, not with "",
+                                        splits(0)));
+
+    OP_REQUIRES(ctx, splits(num_rows) == num_values,
+                errors::InvalidArgument(
+                    ""Splits must end with the number of values, got "",
+                    splits(num_rows), "" instead of "", num_values));
+
     Tensor* out_t;
     OP_REQUIRES_OK(
         ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));","Fix an invalid address vulnerability in `tf.raw_ops.RaggedBincount`.

PiperOrigin-RevId: 368293153
Change-Id: I4b4e493d3fd05e7dc55a55de3a041a80a4f275c3","vuln-fix: Validate splits tensor boundaries in RaggedBincountOp

The RaggedBincountOp kernel did not verify that the splits tensor started at zero and ended at the total number of values, allowing malformed inputs to pass unchecked.
This could lead to out-of-bounds memory access or corrupted computations when splits indices are invalid, risking crashes or data integrity issues.
The fix adds explicit checks to ensure splits(0) is zero and splits(num_rows) equals the number of values, rejecting invalid inputs early.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('tf.raw_ops.raggedbincount', 'URL', ''), ('change', 'ACTION', ''), ('i4b4e493d3fd05e7dc55a55de3a041a80a4f275c3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,"CWE-787', 'CWE-119",GHSA-q4qf-3fc6-8x34,"@@ -70,6 +70,9 @@ inline bool ResolveAxis(const int num_dims, const int* axis,
     // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */
     int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];
     TFLITE_DCHECK(current >= 0 && current < num_dims);
+    if (current < 0 || current >= num_dims) {
+      return false;
+    }
     bool is_dup = false;
     for (int j = 0; j < *out_num_axis; ++j) {
       if (out_axis[j] == current) {","[tflite] Ensure `ResolveAxis` properly handles negative inputs.

In Python, a list `l` of length `n` allows indexing with negative indices, `l[i]`. The only constraint is that `n + i` becomes positive. Code in `ResolveAxis` assumes the constraints and only checks it using a `DCHECK`. But the macro is a no-op in non-debug builds and that can result in reading from negative offsets (buffer underflows).

PiperOrigin-RevId: 332530683
Change-Id: I464e073fee618054ae3719a3679739007bb3f3bc","vuln-fix: Validate axis indices to prevent out-of-bounds access

The function failed to properly validate axis indices, allowing negative or out-of-range values to pass unchecked during tensor dimension resolution.
This could lead to out-of-bounds memory access, causing crashes or potential exposure of sensitive data through invalid reads.
The fix adds explicit boundary checks to reject invalid axis values before further processing, ensuring safe memory access.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('ensure', 'ACTION', ''), ('buffer underflows', 'SECWORD', ''), ('change', 'ACTION', ''), ('i464e073fee618054ae3719a3679739007bb3f3bc', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('validate', 'secword', ''), ('out-of-range', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,CWE-787,GHSA-8gvg-8vhf-h26g,"@@ -4006,6 +4006,11 @@ void ByteCodeGenerator::StartEmitCatch(ParseNodeCatch *pnodeCatch)
                 sym->SetIsGlobalCatch(true);
             }
 
+            if (sym->NeedsScopeObject())
+            {
+                scope->SetIsObject();
+            }
+
             Assert(sym->GetScopeSlot() == Js::Constants::NoProperty);
             if (sym->NeedsSlotAlloc(this, funcInfo))
             {
@@ -4029,6 +4034,11 @@ void ByteCodeGenerator::StartEmitCatch(ParseNodeCatch *pnodeCatch)
             sym->SetIsGlobalCatch(true);
         }
 
+        if (sym->NeedsScopeObject())
+        {
+            scope->SetIsObject();
+        }
+
         if (scope->GetMustInstantiate())
         {
             if (sym->IsInSlot(this, funcInfo))",[CVE-2019-0937],"vuln-fix: Ensure scope object creation for catch block variables

The bytecode generator failed to mark the catch scope as an object when catch variables required a scope object, leading to incorrect scope handling.
This flaw could cause variable resolution errors or unexpected behavior, potentially allowing scope pollution or incorrect variable access in exception handling.
The fix adds checks to set the catch scope as an object whenever any catch variable needs a scope object, ensuring proper scope instantiation and variable binding.

Weakness: CWE-284
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('cve-2019-0937', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('incorrect scope', 'secword', ''), ('flaw', 'FLAW', ''), ('errors', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-284', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
25,CWE-787,GHSA-hrmm-f4j8-8vxc,"@@ -1736,7 +1736,14 @@ void GlobOpt::ArraySrcOpt::Optimize()
     {
         if (newBaseValueType != baseValueType)
         {
-            UpdateValue(nullptr, nullptr, nullptr);
+            if (globOpt->IsSafeToTransferInPrePass(baseOpnd, baseValue))
+            {
+                UpdateValue(nullptr, nullptr, nullptr);
+            }
+            else if (globOpt->IsOperationThatLikelyKillsJsArraysWithNoMissingValues(instr) && baseValueInfo->HasNoMissingValues())
+            {
+                globOpt->ChangeValueType(nullptr, baseValue, baseValueInfo->Type().SetHasNoMissingValues(false), true);
+            }
         }
 
         // For javascript arrays and objects with javascript arrays:",[CVE-2019-0922] Type confusion in Edge - Individual,"vuln-fix: Prevent unsafe value updates in array optimization pass

The array optimization routine updated values without verifying if it was safe to transfer them during the pre-pass, risking inconsistent or invalid state changes.
This could lead to incorrect assumptions about array contents, enabling attackers to exploit type confusion or corrupt internal optimization metadata.
The fix adds safety checks to ensure updates only occur when transferring values is safe or when array value types are adjusted to reflect possible missing elements.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('cve-2019-0922', 'VULNID', 'CVE'), ('type confusion', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe value', 'SECWORD', ''), ('updates', 'ACTION', ''), ('updated', 'ACTION', ''), ('safe', 'secword', ''), ('changes', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('type confusion', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('updates', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,"CWE-787', 'CWE-119",GHSA-79fv-9865-4qcv,"@@ -199,7 +199,9 @@ static void SpatialMaxPoolWithArgMaxHelper(
         // CHECK(input_backprop_index >= in_start && input_backprop_index <
         // in_end)
         FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);
-        input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
+        if (index < out_backprop.NumElements()) {
+          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
+        }
       }
     }
   };","Prevent heap OOB error in `MaxPoolGrad`

PiperOrigin-RevId: 372424854
Change-Id: Idac0f23867ad8b0601cafbaaa52d5e64269e63a7","vuln-fix: Add bounds check to prevent out-of-bounds tensor access

The SpatialMaxPoolWithArgMaxHelper function lacked proper bounds checking on the output backpropagation tensor index, risking out-of-bounds memory reads.
This vulnerability could lead to memory corruption or crashes by accessing invalid memory locations when processing malformed or adversarial input tensors.
The fix adds an explicit index bounds check before accessing the output backpropagation tensor to ensure safe memory access within valid ranges.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('idac0f23867ad8b0601cafbaaa52d5e64269e63a7', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('adversarial', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,"CWE-787', 'CWE-665",GHSA-cjc7-49v2-jp64,"@@ -14,6 +14,7 @@ limitations under the License.
 ==============================================================================*/
 
 #include ""tensorflow/core/framework/op_kernel.h""
+#include ""tensorflow/core/framework/op_requires.h""
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_util.h""
@@ -101,6 +102,10 @@ class SparseAddOp : public OpKernel {
     std::vector<T> out_values;
     const int num_dims = a_shape->dim_size(0);
 
+    OP_REQUIRES(ctx, num_dims > 0,
+                errors::InvalidArgument(""Invalid input_a shape. Received: "",
+                                        a_shape->DebugString()));
+
     // The input and output sparse tensors are assumed to be ordered along
     // increasing dimension number.
     int64 i = 0, j = 0;","Fix `tf.raw_ops.SparseAdd ` invalid memory access failure.

PiperOrigin-RevId: 370568774
Change-Id: I5f73b31c865f2948a1c8dfb7ebd22b3cfb6405bf","vuln-fix: Validate input tensor shape in SparseAdd operation

The SparseAdd operation did not verify that the input tensor shape had a positive number of dimensions before processing.
This allowed malformed or empty tensor inputs to cause undefined behavior or crashes due to invalid assumptions about tensor structure.
The fix adds a validation check that rejects inputs with zero dimensions, ensuring only valid tensor shapes are processed.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.sparseadd', 'URL', ''), ('invalid memory access', 'secword', ''), ('change', 'ACTION', ''), ('i5f73b31c865f2948a1c8dfb7ebd22b3cfb6405bf', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
28,CWE-787,GHSA-5qw5-89mw-wcg2,"@@ -1134,7 +1134,12 @@ class SymbolicShapeRefiner {
         GetUnknownOutputShape(node, output_port);
     InferenceContext* ctx = GetContext(node);
     if (ctx == nullptr) {
-      return errors::InvalidArgument(""Missing context"");
+      return errors::InvalidArgument(""SetUnknownShape: Missing context"");
+    }
+    if (output_port < 0 || output_port >= ctx->num_outputs()) {
+      return errors::InvalidArgument(
+          ""SetUnknownShape: output_port must be in [0, "", ctx->num_outputs(),
+          "") but was "", output_port);
     }
     ctx->set_output(output_port, shape);
     return Status::OK();","Prevent a crash due to heap OOB write in grappler.

PiperOrigin-RevId: 408318417
Change-Id: If095feb8c001e3a8ac4a85b7387b81e8309df47d","vuln-fix: Validate output port index in shape inference

The shape inference function did not verify that the output port index was within valid bounds before accessing output shapes.
This allowed attackers to trigger out-of-bounds access, potentially causing crashes or memory corruption by referencing invalid output indices.
The fix adds explicit checks to ensure the output port index is non-negative and less than the number of outputs before proceeding.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('if095feb8c001e3a8ac4a85b7387b81e8309df47d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
29,CWE-787,GHSA-w32p-76xr-88pc,"@@ -392,6 +392,8 @@ namespace Js
         }
         propertyDescriptor->SetValue(getGetResult);
 
+        threadContext->AddImplicitCallFlags(Js::ImplicitCall_External);
+
         return TRUE;
     }
 
@@ -1907,6 +1909,9 @@ namespace Js
                 }
             }
         }
+
+        threadContext->AddImplicitCallFlags(Js::ImplicitCall_External);
+
         return TRUE;
 
     }",CVE-2019-1003,"vuln-fix: Mark implicit external calls to prevent unsafe optimizations

The JavaScript engine failed to mark certain operations as implicit external calls, causing the runtime to overlook side effects during optimization.
This allowed attackers to exploit incorrect assumptions about code behavior, potentially leading to inconsistent state or security bypasses in JIT-compiled code.
The fix explicitly adds implicit call flags to signal external side effects, ensuring the engine properly accounts for them during execution and optimization.

Weakness: CWE-676
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('cve-2019-1003', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('security', 'SECWORD', ''), ('bypasses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-676', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
30,CWE-787,GHSA-6j89-jhpr-849f,"@@ -370,6 +370,7 @@ class JsArrayKills
             (valueType.IsArrayOrObjectWithArray() &&
              (
               (killsArraysWithNoMissingValues && valueType.HasNoMissingValues()) ||
+              (killsObjectArraysWithNoMissingValues && !valueType.IsArray() && valueType.HasNoMissingValues()) ||
               (killsNativeArrays && !valueType.HasVarElements())
              )
             );",CVE-2019-1307,"vuln-fix: Fix incorrect array type handling in optimization kills

The optimization logic failed to properly distinguish object arrays without missing values from other array types, causing incorrect assumptions during code generation.
This flaw could lead to type confusion and unexpected behavior, potentially allowing attackers to exploit memory corruption or logic errors in optimized JavaScript code.
The patch adds explicit checks for object arrays with no missing values to ensure accurate kill set computation and prevent unsafe optimizations.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('cve-2019-1307', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('flaw', 'FLAW', ''), ('type confusion', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('logic errors', 'secword', ''), ('optimized', 'ACTION', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,CWE-787,GHSA-mw7r-3g6w-85qg,"@@ -4664,10 +4664,7 @@ ParseNodePtr Parser::ParseMemberList(LPCOLESTR pNameHint, uint32* pNameHintLengt
                     }
                 }
 
-                if (buildAST)
-                {
-                    CheckArgumentsUse(pidHint, GetCurrentFunctionNode());
-                }
+                CheckArgumentsUse(pidHint, GetCurrentFunctionNode());
 
                 bool couldBeObjectPattern = !isObjectPattern && m_token.tk == tkAsg;
                 // Saving the current state as we may change the isObjectPattern down below.",[CVE-2019-1131] Chakra Type confusion,"vuln-fix: Always check argument usage to prevent skipped validations

The parser conditionally skipped argument usage checks when AST building was disabled, allowing malformed or unexpected arguments to bypass validation.
This created a risk where attackers could exploit unchecked arguments to inject invalid syntax or cause inconsistent parser state, potentially leading to security flaws.
The fix removes the conditional, ensuring argument usage is always verified regardless of AST build state, maintaining consistent validation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('cve-2019-1131', 'VULNID', 'CVE'), ('type confusion', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('inject', 'secword', ''), ('security', 'secword', ''), ('flaws', 'secword', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('verified', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,CWE-787,GHSA-9g8h-pjm4-q92p,"@@ -77,7 +77,8 @@ static JasperInitializer initialize_jasper;
 
 Jpeg2KDecoder::Jpeg2KDecoder()
 {
-    m_signature = '\0' + String() + '\0' + String() + '\0' + String(""\x0cjP  \r\n\x87\n"");
+    static const unsigned char signature_[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};
+    m_signature = String((const char*)signature_, (const char*)signature_ + sizeof(signature_));
     m_stream = 0;
     m_image = 0;
 }
@@ -121,6 +122,8 @@ bool  Jpeg2KDecoder::readHeader()
         jas_image_t* image = jas_image_decode( stream, -1, 0 );
         m_image = image;
         if( image ) {
+            CV_Assert(0 == (jas_image_tlx(image)) && ""not supported"");
+            CV_Assert(0 == (jas_image_tly(image)) && ""not supported"");
             m_width = jas_image_width( image );
             m_height = jas_image_height( image );
 
@@ -130,14 +133,31 @@ bool  Jpeg2KDecoder::readHeader()
             for( int i = 0; i < numcmpts; i++ )
             {
                 int depth_i = jas_image_cmptprec( image, i );
+                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch
                 depth = MAX(depth, depth_i);
                 if( jas_image_cmpttype( image, i ) > 2 )
                     continue;
+                int sgnd = jas_image_cmptsgnd(image, i);
+                int xstart = jas_image_cmpttlx(image, i);
+                int xend = jas_image_cmptbrx(image, i);
+                int xstep = jas_image_cmpthstep(image, i);
+                int ystart = jas_image_cmpttly(image, i);
+                int yend = jas_image_cmptbry(image, i);
+                int ystep = jas_image_cmptvstep(image, i);
+                CV_Assert(sgnd == 0 && ""not supported"");
+                CV_Assert(xstart == 0 && ""not supported"");
+                CV_Assert(ystart == 0 && ""not supported"");
+                CV_Assert(xstep == 1 && ""not supported"");
+                CV_Assert(ystep == 1 && ""not supported"");
+                CV_Assert(xend == m_width);
+                CV_Assert(yend == m_height);
                 cntcmpts++;
             }
 
             if( cntcmpts )
             {
+                CV_Assert(depth == 8 || depth == 16);
+                CV_Assert(cntcmpts == 1 || cntcmpts == 3);
                 m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);
                 result = true;
             }
@@ -150,9 +170,14 @@ bool  Jpeg2KDecoder::readHeader()
     return result;
 }
 
+static void Jpeg2KDecoder_close(Jpeg2KDecoder* ptr)
+{
+    ptr->close();
+}
 
 bool  Jpeg2KDecoder::readData( Mat& img )
 {
+    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);
     bool result = false;
     int color = img.channels() > 1;
     uchar* data = img.ptr();
@@ -204,11 +229,16 @@ bool  Jpeg2KDecoder::readData( Mat& img )
                     result = true;
                 }
                 else
-                    fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n"");
+                {
+                    jas_cmprof_destroy(clrprof);
+                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");
+                }
                 jas_cmprof_destroy( clrprof );
             }
             else
-                fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n"");
+            {
+                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");
+            }
         }
         else
             result = true;
@@ -257,8 +287,8 @@ bool  Jpeg2KDecoder::readData( Mat& img )
                                 result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );
                             if( !result )
                             {
-                                i = ncmpts;
-                                result = false;
+                                jas_matrix_destroy( buffer );
+                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");
                             }
                         }
                         jas_matrix_destroy( buffer );
@@ -267,10 +297,12 @@ bool  Jpeg2KDecoder::readData( Mat& img )
             }
         }
         else
-            fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" );
+        {
+            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");
+        }
     }
 
-    close();
+    CV_Assert(result == true);
 
 #ifndef _WIN32
     if (!clr.empty())",imgcodecs: add more Jasper checks for supported and tested cases,"vuln-fix: Add strict validation and error handling in JPEG 2000 decoder

The JPEG 2000 decoder lacked comprehensive validation of image component parameters and error handling, allowing malformed or crafted images to trigger undefined behavior or memory corruption.
This posed a security risk by enabling attackers to exploit unchecked assumptions about image layout, component sizes, and color space conversions, potentially leading to crashes or code execution.
The fix introduces rigorous assertions on image component properties, enforces supported formats, and replaces error prints with exceptions to safely abort on invalid or unsupported data.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.058823529411764705,"[('add', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('decoder', 'SECWORD', ''), ('decoder', 'SECWORD', ''), ('error handling', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
33,CWE-787,GHSA-88cw-3m6x-49f7,"@@ -27152,8 +27152,11 @@ void Lowerer::LowerLdFrameDisplay(IR::Instr *instr, bool doStackFrameDisplay)
         if (instr->m_func != this->m_func && this->m_func->DoStackFrameDisplay())
         {
             StackSym * inlineeFrameDisplaySym = instr->m_func->GetLocalFrameDisplaySym();
-            Assert(inlineeFrameDisplaySym->IsAllocated());
-            InsertMove(IR::SymOpnd::New(inlineeFrameDisplaySym, TyMachReg, m_func), dstOpnd, instr);
+            Assert((inlineeFrameDisplaySym && inlineeFrameDisplaySym->IsAllocated()) || this->m_func->IsLoopBody());
+            if (inlineeFrameDisplaySym && inlineeFrameDisplaySym->IsAllocated())
+            {
+                InsertMove(IR::SymOpnd::New(inlineeFrameDisplaySym, TyMachReg, m_func), dstOpnd, instr);
+            }
         }
     }",[CVE-2020-17054],"vuln-fix: Prevent null dereference in frame display lowering

The lowering function assumed a valid allocated frame display symbol without checking for null, risking dereferencing a null pointer in certain loop body scenarios.
This could lead to crashes or undefined behavior, potentially exploitable to cause denial of service or memory corruption.
The fix adds a null check and conditional logic to ensure the symbol is valid and allocated before use, preventing invalid memory access.

Weakness: CWE-476
Severity: Medium
CVSS: 5.5",0.11764705882352941,"[('cve-2020-17054', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('null dereference', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-476', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
34,CWE-787,GHSA-9c78-vcq7-7vxq,"@@ -928,6 +928,36 @@ TfLiteStatus EvalShuffledQuantized(TfLiteContext* context, TfLiteNode* node,
   return kTfLiteOk;
 }
 
+// Verifies that sparsity values are valid given input/weight/output.
+bool VerifySparsity(const RuntimeShape& weights_shape,
+                    const RuntimeShape& input_shape,
+                    const RuntimeShape& output_shape,
+                    const TfLiteSparsity* sparsity) {
+  const int weights_dims_count = weights_shape.DimensionsCount();
+  const int output_dims_count = output_shape.DimensionsCount();
+  const int w0_size = sparsity->dim_metadata[0].dense_size;
+  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);
+  const int output_elements = output_shape.FlatSize();
+  const int input_elements = input_shape.FlatSize();
+  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);
+  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,
+                                       output_shape, output_dims_count - 1);
+  const int max_batch_index = batches - 1;
+  const int max_output = max_batch_index * output_depth + w0_size;
+  const int max_batch_depth = accum_depth * max_batch_index;
+
+  // Verify output size is enough.
+  if (output_elements < max_output) return false;
+
+  // Verify index from sparse in input is valid.
+  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {
+    if (input_elements <=
+        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])
+      return false;
+  }
+  return true;
+}
+
 template <KernelType kernel_type>
 TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,
                        TfLiteFullyConnectedParams* params, OpData* data,
@@ -968,24 +998,32 @@ TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,
                            ""Unsupported sparse fully-connected weight format."");
         return kTfLiteError;
       }
+      const auto& input_shape = GetTensorShape(input);
+      const auto& filter_shape = GetTensorShape(filter);
+      const auto& output_shape = GetTensorShape(output);
+      const auto& bias_shape = GetTensorShape(bias);
+      if (!VerifySparsity(filter_shape, input_shape, output_shape, &sparsity)) {
+        TF_LITE_KERNEL_LOG(context, ""Invalid sparse fully-connected format."");
+        return kTfLiteError;
+      }
 
       if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {
         // Random sparse.
         optimized_ops::FullyConnectedSparseWeight(
-            sparsity, op_params, GetTensorShape(input),
-            GetTensorData<float>(input), GetTensorShape(filter),
-            GetTensorData<float>(filter), GetTensorShape(bias),
-            GetTensorData<float>(bias), GetTensorShape(output),
-            GetTensorData<float>(output));
+            sparsity, op_params,                         // Disable formatting
+            input_shape, GetTensorData<float>(input),    // Disable formatting
+            filter_shape, GetTensorData<float>(filter),  // Disable formatting
+            bias_shape, GetTensorData<float>(bias),      // Disable formatting
+            output_shape, GetTensorData<float>(output));
       } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&
                  sparsity.dim_metadata[2].dense_size == 4) {
         // Block sparse with block size of 1x4.
         optimized_ops::FullyConnectedSparseWeight1x4(
-            sparsity, op_params, GetTensorShape(input),
-            GetTensorData<float>(input), GetTensorShape(filter),
-            GetTensorData<float>(filter), GetTensorShape(bias),
-            GetTensorData<float>(bias), GetTensorShape(output),
-            GetTensorData<float>(output),
+            sparsity, op_params,                         // Disable formatting
+            input_shape, GetTensorData<float>(input),    // Disable formatting
+            filter_shape, GetTensorData<float>(filter),  // Disable formatting
+            bias_shape, GetTensorData<float>(bias),      // Disable formatting
+            output_shape, GetTensorData<float>(output),
             CpuBackendContext::GetFromContext(context));
       } else {
         TF_LITE_KERNEL_LOG(context,","[lite] add validation check for sparse fully connected

PiperOrigin-RevId: 417629354
Change-Id: If96171c4bd4f5fdb01d6368d6deab19d1c9beca7","vuln-fix: Validate sparsity metadata to prevent out-of-bounds access

The sparse fully-connected operator lacked validation of sparsity metadata against input, weight, and output tensor shapes, risking invalid memory indexing.
This could lead to out-of-bounds reads or writes during sparse matrix operations, potentially causing crashes or exposing sensitive memory contents.
The fix adds comprehensive checks to ensure sparsity indices and dimensions are consistent and within valid tensor bounds before computation proceeds.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('if96171c4bd4f5fdb01d6368d6deab19d1c9beca7', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
35,"CWE-787', 'CWE-665",GHSA-cjc7-49v2-jp64,"@@ -44,6 +44,11 @@ class SparseAddOp : public OpKernel {
                     b_indices->shape().DebugString()));
     const int64 a_nnz = a_indices->dim_size(0);
     const int64 b_nnz = b_indices->dim_size(0);
+    const int num_dims = a_indices->dim_size(1);
+    OP_REQUIRES(ctx, b_indices->dim_size(1) == num_dims,
+                errors::InvalidArgument(
+                    ""Input indices must have the same dimension, got "",
+                    num_dims, "" and "", b_indices->dim_size(1)));
 
     OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
     OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
@@ -72,6 +77,13 @@ class SparseAddOp : public OpKernel {
                     ""Input shapes should be a vector but received shapes "",
                     a_shape->shape().DebugString(), "" and "",
                     b_shape->shape().DebugString()));
+    OP_REQUIRES(
+        ctx, a_shape->NumElements() == num_dims,
+        errors::InvalidArgument(""Second dimension of a_indices and length of ""
+                                ""a_shape must match, got "",
+                                num_dims, "" and "", a_shape->NumElements()));
+    OP_REQUIRES(ctx, num_dims > 0,
+                errors::InvalidArgument(""Tesors must not be empty""));
     OP_REQUIRES(
         ctx, a_shape->IsSameSize(*b_shape),
         errors::InvalidArgument(
@@ -100,11 +112,6 @@ class SparseAddOp : public OpKernel {
     std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx
     entries_to_copy.reserve(a_nnz + b_nnz);
     std::vector<T> out_values;
-    const int num_dims = a_shape->dim_size(0);
-
-    OP_REQUIRES(ctx, num_dims > 0,
-                errors::InvalidArgument(""Invalid input_a shape. Received: "",
-                                        a_shape->DebugString()));
 
     // The input and output sparse tensors are assumed to be ordered along
     // increasing dimension number.","Validate that a and b are proper sparse tensors

PiperOrigin-RevId: 373248068
Change-Id: I0a2041a0747901b3f00387a6a3bce9bca6b0b3b1","vuln-fix: Validate sparse tensor input dimensions in SparseAddOp

The SparseAddOp kernel lacked comprehensive validation of input tensor dimensions, allowing mismatched or empty sparse tensor inputs to proceed unchecked.
This could lead to undefined behavior, including out-of-bounds memory access or crashes, when operations assume consistent and non-empty tensor shapes.
The fix adds explicit checks ensuring input indices have matching dimensions, shapes align properly, and tensors are non-empty before computation proceeds.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i0a2041a0747901b3f00387a6a3bce9bca6b0b3b1', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
36,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Correct optional tensor input retrieval to prevent invalid access

The function incorrectly checked for optional tensor inputs, potentially returning mutable tensors when inputs were absent or optional.
This could lead to invalid memory access or use-after-free errors if code assumed the presence of valid tensors without proper validation.
The fix replaces the conditional logic with a direct call to GetInput, ensuring consistent and safe retrieval of input tensors.

Weakness: CWE-119
Severity: High
CVSS: 7.5",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('incorrectly checked', 'SECWORD', ''), ('invalid memory access', 'SECWORD', ''), ('use-after-free', 'SECWORD', ''), ('errors', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
37,"CWE-787', 'CWE-125",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Validate row partition size to prevent out-of-bounds access

The code did not verify that the row partition tensor size was consistent with the parent output index size before processing.
This could lead to out-of-bounds memory access or logic errors when the row partition size exceeded the output size, risking crashes or data corruption.
The fix adds a validation check that returns an error if the row partition size is greater than the output size, preventing invalid memory operations.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('logic errors', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
38,"CWE-787', 'CWE-125",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate input tensor dimensions to prevent zero-size tensors

The gradient operation did not verify that input tensor dimensions were non-zero, allowing zero-sized tensors to be processed without error.
This could lead to undefined behavior or crashes due to invalid memory access when downstream code assumes positive tensor dimensions.
The fix adds explicit checks to reject tensors with any zero dimension, ensuring only valid input shapes are accepted.

Weakness: CWE-119
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('verify', 'ACTION', ''), ('error', 'FLAW', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,"CWE-787', 'CWE-119",GHSA-7cqx-92hp-x6wh,"@@ -693,6 +693,7 @@ class MaxPooling3dGradGradOp : public OpKernel {
 
     Pool3dParameters params{context,  ksize_,       stride_,
                             padding_, data_format_, tensor_in.shape()};
+    if (!context->status().ok()) return;  // params is invalid
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(
@@ -710,6 +711,17 @@ class MaxPooling3dGradGradOp : public OpKernel {
         context, out_grad_backprop.NumElements() > 0,
         errors::InvalidArgument(""received empty tensor out_grad_backprop: "",
                                 out_grad_backprop.DebugString()));
+    OP_REQUIRES(context,
+                tensor_in.NumElements() == out_grad_backprop.NumElements(),
+                errors::InvalidArgument(""tensor_in and out_grad_backprop must ""
+                                        ""have same number of elements, got <"",
+                                        tensor_in.DebugString(), ""> and <"",
+                                        out_grad_backprop.DebugString(), "">""));
+    OP_REQUIRES(
+        context, tensor_out.NumElements() == output->NumElements(),
+        errors::InvalidArgument(
+            ""tensor_out and output must have same number of elements, got <"",
+            tensor_out.DebugString(), ""> and <"", output->DebugString(), "">""));
 
     LaunchMaxPooling3dGradGradOp<Device, T>::launch(
         context, params, tensor_in, tensor_out, out_grad_backprop, output);","Add missing validation, prevent heap OOB

PiperOrigin-RevId: 372246723
Change-Id: I1a454a643810e77d7d14821b342098c56a09fbbf","vuln-fix: Validate tensor dimensions in MaxPooling3dGradGradOp

The MaxPooling3dGradGradOp kernel lacked checks ensuring input and output tensors have matching element counts before computation.
This allowed malformed or crafted inputs to cause out-of-bounds memory access or undefined behavior during gradient calculations, risking memory corruption or crashes.
The fix adds explicit validation of tensor element counts and early exit on invalid pooling parameters to prevent unsafe operations.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i1a454a643810e77d7d14821b342098c56a09fbbf', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('ensuring', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
40,CWE-787,GHSA-w89r-qch4-8jv5,"@@ -415,11 +415,19 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
 
     case Js::OpCode::InlineArrayPush:
     case Js::OpCode::InlineArrayPop:
-        KillLiveFields(this->lengthEquivBv, bv);
-        if (inGlobOpt)
+        if(instr->m_func->GetThisOrParentInlinerHasArguments())
         {
-            // Deleting an item, or pushing a property to a non-array, may change object layout
-            KillAllObjectTypes(bv);
+            this->KillAllFields(bv);
+            this->SetAnyPropertyMayBeWrittenTo();
+        }
+        else
+        {
+            KillLiveFields(this->lengthEquivBv, bv);
+            if (inGlobOpt)
+            {
+                // Deleting an item, or pushing a property to a non-array, may change object layout
+                KillAllObjectTypes(bv);
+            }
         }
         break;
 
@@ -444,14 +452,23 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
                 // Kill length field for built-ins that can update it.
                 if (nullptr != this->lengthEquivBv)
                 {
-                    KillLiveFields(this->lengthEquivBv, bv);
+                    // If has arguments, all fields are killed in fall through
+                    if (!instr->m_func->GetThisOrParentInlinerHasArguments())
+                    {
+                        KillLiveFields(this->lengthEquivBv, bv);
+                    }
                 }
                 // fall through
 
             case IR::JnHelperMethod::HelperArray_Reverse:
-                // Deleting an item may change object layout
-                if (inGlobOpt)
+                if (instr->m_func->GetThisOrParentInlinerHasArguments())
+                {
+                    this->KillAllFields(bv);
+                    this->SetAnyPropertyMayBeWrittenTo();
+                }
+                else if (inGlobOpt)
                 {
+                    // Deleting an item may change object layout
                     KillAllObjectTypes(bv);
                 }
                 break;",[CVE-2019-0912],"vuln-fix: Fix incorrect field kill logic causing type confusion

The JIT optimizer mishandled field kill sets when functions had arguments, leading to inconsistent object layout assumptions during array mutations.
This flaw could cause type confusion and unsafe memory accesses by allowing stale or incorrect type information to persist across optimization boundaries.
The fix adjusts field kill logic to properly clear all relevant fields and mark properties as written when arguments are present, ensuring accurate type tracking.

Weakness: CWE-704
Severity: High
CVSS: 7.2",0.11764705882352941,"[('cve-2019-0912', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('type confusion', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('type confusion', 'secword', ''), ('unsafe', 'secword', ''), ('incorrect type', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('high', 'SEVERITY', '')]"
41,"CWE-787', 'CWE-131",GHSA-8c89-2vwr-chcq,"@@ -702,8 +702,14 @@ class QuantizedResizeBilinearOp : public OpKernel {
   }
 
   void Compute(OpKernelContext* context) override {
-    const float in_min = context->input(2).flat<float>()(0);
-    const float in_max = context->input(3).flat<float>()(0);
+    const auto& in_min_tensor = context->input(2);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_min_tensor.shape()),
+                errors::InvalidArgument(""min must be a scalar""));
+    const float in_min = in_min_tensor.flat<float>()(0);
+    const auto& in_max_tensor = context->input(3);
+    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_max_tensor.shape()),
+                errors::InvalidArgument(""max must be a scalar""));
+    const float in_max = in_max_tensor.flat<float>()(0);
 
     ImageResizerState st(align_corners_, false);
     st.ValidateAndCreateOutput(context);","Validate min and max arguments to `QuantizedResizeBilinear`.

PiperOrigin-RevId: 369765091
Change-Id: I33be8b78273ab7d08b97541692fe05cb7f94963a","vuln-fix: Validate scalar inputs in quantized resize operation

The quantized resize operation did not verify that min and max inputs were scalar tensors before accessing their values.
This allowed malformed inputs with incorrect shapes to cause out-of-bounds memory access or undefined behavior, risking crashes or data corruption.
The fix adds explicit shape checks to ensure min and max inputs are scalars, returning errors for invalid input shapes before use.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i33be8b78273ab7d08b97541692fe05cb7f94963a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
42,"CWE-787', 'CWE-120",GHSA-44qp-9wwf-734r,"@@ -206,6 +206,23 @@ class SparseCount : public OpKernel {
     OP_REQUIRES(context, shape.NumElements() > 0,
                 errors::InvalidArgument(
                     ""The shape argument requires at least one element.""));
+    // Validate indices: each index must be valid for the corresponding
+    // dimension. This could be possibly done better.
+    const auto indices_values = indices.matrix<int64_t>();
+    const auto shape_vector = shape.vec<int64_t>();
+    int num_values = values.NumElements();  // same as first dim of indices
+    int rank = indices.shape().dim_size(1);
+    for (int i = 0; i < num_values; ++i) {
+      for (int j = 0; j < rank; ++j) {
+        OP_REQUIRES(
+            context,
+            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),
+            errors::InvalidArgument(
+                ""Invalid index value at "", i, "": dimension "", j, "" has value "",
+                indices_values(i, j), "" which is not in [0, "", shape_vector(j),
+                "") (as given by dense shape "", shape.DebugString()));
+      }
+    }
 
     if (use_weights) {
       OP_REQUIRES(
@@ -217,11 +234,8 @@ class SparseCount : public OpKernel {
     }
 
     bool is_1d = shape.NumElements() == 1;
-    auto shape_vector = shape.flat<int64_t>();
     int num_batches = is_1d ? 1 : shape_vector(0);
-    int num_values = values.NumElements();
 
-    const auto indices_values = indices.matrix<int64_t>();
     const auto values_values = values.flat<T>();
     const auto weight_values = weights.flat<W>();","Further validate sparse tensor for `SparseCount`: indices must be valid within dense shape.

PiperOrigin-RevId: 414888122
Change-Id: I4552bd74c135ecd4bcb5448acc0a3ce9402d8286","vuln-fix: Validate sparse tensor indices to prevent out-of-bounds access

The SparseCount operator lacked validation of sparse indices against the tensor shape, allowing out-of-bounds indices to be processed.
This could lead to invalid memory access or corruption, causing crashes or potential data leakage during sparse tensor operations.
The fix adds explicit checks ensuring each index is within the valid range for its corresponding dimension, rejecting invalid inputs early.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('i4552bd74c135ecd4bcb5448acc0a3ce9402d8286', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
43,CWE-787,GHSA-mqh2-9wrp-vx84,"@@ -527,6 +527,10 @@ inline Status SparseTensor::Split(const SparseTensor& input_tensor,
   for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {
     const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);
     int slice_index = GetSliceIndex(dim, split_size, residual);
+    if (slice_index >= num_values.size()) {
+      return errors::InvalidArgument(""Slice index "", slice_index,
+                                     "" is larger than num_split."");
+    }
     num_values[slice_index]++;
   }","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseSplit`.

PiperOrigin-RevId: 371242872
Change-Id: I482bb3d12602c7c3cc9446f97fb9f584bb98e9a4","vuln-fix: Validate slice index bounds in sparse tensor split

The sparse tensor split function lacked validation for computed slice indices, allowing out-of-bounds access when indices exceeded the number of splits.
This could lead to memory corruption or crashes by writing beyond the allocated vector size, enabling potential denial of service or data integrity issues.
The fix adds explicit bounds checking on slice indices to ensure they do not exceed the number of splits before incrementing counters.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.sparsesplit', 'URL', ''), ('change', 'ACTION', ''), ('i482bb3d12602c7c3cc9446f97fb9f584bb98e9a4', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('denial of service', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checking', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,"CWE-665', 'CWE-20",GHSA-9rpc-5v9q-5r7f,"@@ -26,6 +26,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_util.h""
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,6 +39,17 @@ class SparseReshapeOp : public OpKernel {
   explicit SparseReshapeOp(OpKernelConstruction* context) : OpKernel(context) {}
 
   void Compute(OpKernelContext* context) override {
+    const Tensor& input_indices_in = context->input(0);
+    const Tensor& input_shape_in = context->input(1);
+
+    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),
+                errors::InvalidArgument(""Input must be a matrix.""));
+    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),
+                errors::InvalidArgument(""Input shape must be a vector.""));
+    OP_REQUIRES(context,
+                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),
+                errors::InvalidArgument(
+                    ""Input tensor rank must match input shape length.""));
     ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),
                                 context->input(2), 0 /* output indices index */,
                                 1 /* output shape index */);","Fix heap-buffer-overflow issue with `tf.raw_ops.SparseReshape`.

PiperOrigin-RevId: 371218558
Change-Id: I6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45","vuln-fix: Validate input tensor shapes in SparseReshapeOp

The SparseReshape operation lacked validation of input tensor shapes and dimensions before processing, allowing malformed inputs to proceed unchecked.
This could lead to out-of-bounds memory access or crashes when tensor ranks and shapes did not align, potentially causing denial of service or data corruption.
The fix adds explicit checks to ensure input indices are matrices, input shapes are vectors, and their dimensions match expected ranks, preventing invalid tensor operations.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.sparsereshape', 'URL', ''), ('change', 'ACTION', ''), ('i6a6dc5bf15b50a1d05bdd95e9ba347cb39f40f45', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,"CWE-908', 'CWE-200",GHSA-3wcq-x3mq-6r9p,"@@ -74,7 +74,8 @@ name.decode = function (buf, offset) {
 name.decode.bytes = 0
 
 name.encodingLength = function (n) {
-  return Buffer.byteLength(n) + 2
+  if (n === '.') return 1
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 var string = {}",backport encodingLength fix to v1,"vuln-fix: Correct encoding length calculation to prevent buffer overflow

The encodingLength function did not properly handle input strings with leading or trailing dots, causing incorrect length calculation for buffer allocation.
This flaw could lead to buffer overflows or memory corruption when encoding such strings, posing a risk of arbitrary code execution or crashes.
The fix trims leading and trailing dots before measuring byte length, ensuring accurate buffer size calculation and preventing overflow.

Weakness: CWE-120
Severity: High
CVSS: 7.8",0.11764705882352941,"[('encodinglength', 'SECWORD', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('encoding', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('encodinglength', 'SECWORD', ''), ('incorrect length', 'secword', ''), ('flaw', 'FLAW', ''), ('buffer overflows', 'secword', ''), ('memory corruption', 'secword', ''), ('encoding', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('overflow', 'secword', ''), ('weakness', 'secword', ''), ('cwe-120', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,"CWE-200', 'CWE-287",GHSA-cchx-mfrc-fwqr,"@@ -120,6 +120,6 @@ protected function generateCookieValue($class, $username, $expires, $password)
      */
     protected function generateCookieHash($class, $username, $expires, $password)
     {
-        return hash_hmac('sha256', $class.$username.$expires.$password, $this->getSecret());
+        return hash_hmac('sha256', $class.self::COOKIE_DELIMITER.$username.self::COOKIE_DELIMITER.$expires.self::COOKIE_DELIMITER.$password, $this->getSecret());
     }
 }",[Security] Add a separator in the remember me cookie hash,"vuln-fix: Add delimiters to cookie hash input to prevent ambiguity

The cookie hash generation concatenated multiple fields without delimiters, causing potential ambiguity in the input string used for HMAC computation.
This ambiguity could allow attackers to craft different input combinations producing the same hash, enabling authentication bypass or session hijacking.
The fix inserts explicit delimiters between fields before hashing, ensuring unique and unambiguous input to the HMAC function.

Weakness: CWE-347
Severity: High
CVSS: 7.5",0.058823529411764705,"[('security', 'SECWORD', ''), ('add', 'ACTION', ''), ('cookie', 'SECWORD', ''), ('hash', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('cookie', 'secword', ''), ('hash', 'secword', ''), ('prevent', 'ACTION', ''), ('cookie', 'SECWORD', ''), ('hash', 'secword', ''), ('hmac', 'secword', ''), ('attackers', 'FLAW', ''), ('hash', 'secword', ''), ('authentication bypass', 'secword', ''), ('hijacking', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('hmac', 'secword', ''), ('weakness', 'secword', ''), ('cwe-347', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,CWE-200,GHSA-xc7v-wxcw-j472,"@@ -128,7 +128,7 @@ TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
   if (connectOptions.proxyAuth) {
     connectOptions.headers = connectOptions.headers || {}
     connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
-        new Buffer(connectOptions.proxyAuth).toString('base64')
+        Buffer.from(connectOptions.proxyAuth).toString('base64')
   }
 
   debug('making CONNECT request')",Use .from,"vuln-fix: Replace deprecated Buffer constructor to prevent injection risks

The code used the deprecated Buffer constructor with a string argument, which can lead to unexpected behavior or security issues due to implicit encoding assumptions.
This posed a risk of malformed or malicious proxy authorization headers being generated, potentially allowing attackers to bypass authentication or cause injection attacks.
The fix replaces the deprecated constructor with Buffer.from, ensuring safe and explicit encoding of proxy credentials.

Weakness: CWE-117
Severity: Medium
CVSS: 5.0",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('encoding', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('authentication', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('buffer.from', 'URL', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('encoding', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-117', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,CWE-200,GHSA-hxf9-7h4c-f5jv,"@@ -2,6 +2,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -40,8 +41,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -77,8 +83,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.","vuln-fix: Use constant-time comparison for basic auth validation

The webhook basic authentication compared credentials using standard string comparison, exposing it to timing attacks that could reveal valid credentials by measuring response times.
This vulnerability allowed attackers to perform side-channel attacks to guess authentication tokens, potentially bypassing security controls and gaining unauthorized access.
The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure uniform comparison time and prevent timing-based credential disclosure.

Weakness: CWE-208
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('security', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attack', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attacker', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('upgrade', 'ACTION', ''), ('docs](http://anymail.readthedocs.io', 'URL', ''), ('exploit', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('auth', 'secword', ''), ('authentication', 'SECWORD', ''), ('string comparison', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('attacks', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('bypassing', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('string comparisons', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('credential', 'secword', ''), ('disclosure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-208', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
5,CWE-203,GHSA-434h-p4gx-jm89,"@@ -833,6 +833,12 @@ def auth_user_db(self, username, password):
         if user is None:
             user = self.find_user(email=username)
         if user is None or (not user.is_active):
+            # Balance failure and success
+            check_password_hash(
+                ""pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118""
+                ""c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c"",
+                ""password"",
+            )
             log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))
             return None
         elif check_password_hash(user.password, password):",fix: auth balance (#1634),"vuln-fix: Mitigate timing attacks in user authentication

The authentication function returned faster on invalid usernames, allowing attackers to distinguish valid users by measuring response times.
This timing discrepancy enabled user enumeration attacks, compromising account privacy and facilitating targeted credential attacks.
The fix adds a dummy password hash check on failure to equalize response times and prevent timing-based user enumeration.

Weakness: CWE-204
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('auth', 'secword', ''), ('#1634', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('attacks', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('authentication', 'secword', ''), ('attackers', 'FLAW', ''), ('timing discrepancy', 'secword', ''), ('user enumeration', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('privacy', 'secword', ''), ('credential', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('password', 'SECWORD', ''), ('hash', 'secword', ''), ('prevent', 'ACTION', ''), ('user enumeration', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-204', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
6,CWE-200,GHSA-23cm-x6j7-6hq3,"@@ -101,6 +101,13 @@ interface IPayload extends Partial<IMessage> {
 }
 /* eslint-enable camelcase */
 
+interface SharedWithData {
+    // The identity key of the device we shared with
+    deviceKey: string;
+    // The message index of the ratchet we shared with that device
+    messageIndex: number;
+}
+
 /**
  * @private
  * @constructor
@@ -115,12 +122,12 @@ interface IPayload extends Partial<IMessage> {
  *
  * @property {object} sharedWithDevices
  *    devices with which we have shared the session key
- *        userId -> {deviceId -> msgindex}
+ *        userId -> {deviceId -> SharedWithData}
  */
 class OutboundSessionInfo {
     public useCount = 0;
     public creationTime: number;
-    public sharedWithDevices: Record<string, Record<string, number>> = {};
+    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};
     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};
 
     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {
@@ -150,11 +157,11 @@ class OutboundSessionInfo {
         return false;
     }
 
-    public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {
+    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {
         if (!this.sharedWithDevices[userId]) {
             this.sharedWithDevices[userId] = {};
         }
-        this.sharedWithDevices[userId][deviceId] = chainIndex;
+        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };
     }
 
     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {
@@ -572,6 +579,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
         payload: IPayload,
     ): Promise<void> {
         const contentMap = {};
+        const deviceInfoByDeviceId = new Map<string, DeviceInfo>();
 
         const promises = [];
         for (let i = 0; i < userDeviceMap.length; i++) {
@@ -584,6 +592,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const userId = val.userId;
             const deviceInfo = val.deviceInfo;
             const deviceId = deviceInfo.deviceId;
+            deviceInfoByDeviceId.set(deviceId, deviceInfo);
 
             if (!contentMap[userId]) {
                 contentMap[userId] = {};
@@ -636,7 +645,10 @@ class MegolmEncryption extends EncryptionAlgorithm {
                 for (const userId of Object.keys(contentMap)) {
                     for (const deviceId of Object.keys(contentMap[userId])) {
                         session.markSharedWithDevice(
-                            userId, deviceId, chainIndex,
+                            userId,
+                            deviceId,
+                            deviceInfoByDeviceId.get(deviceId).getIdentityKey(),
+                            chainIndex,
                         );
                     }
                 }
@@ -719,8 +731,8 @@ class MegolmEncryption extends EncryptionAlgorithm {
             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);
             return;
         }
-        const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];
-        if (sentChainIndex === undefined) {
+        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];
+        if (sessionSharedData === undefined) {
             logger.debug(
                 ""megolm session ID "" + sessionId + "" never shared with device "" +
                 userId + "":"" + device.deviceId,
@@ -728,10 +740,18 @@ class MegolmEncryption extends EncryptionAlgorithm {
             return;
         }
 
+        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {
+            logger.warn(
+                `Session has been shared with device ${device.deviceId} but with identity ` +
+                `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,
+            );
+            return;
+        }
+
         // get the key from the inbound session: the outbound one will already
         // have been ratcheted to the next chain index.
         const key = await this.olmDevice.getInboundGroupSessionKey(
-            this.roomId, senderKey, sessionId, sentChainIndex,
+            this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,
         );
 
         if (!key) {
@@ -882,7 +902,7 @@ class MegolmEncryption extends EncryptionAlgorithm {
             const deviceId = deviceInfo.deviceId;
 
             session.markSharedWithDevice(
-                userId, deviceId, key.chain_index,
+                userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,
             );
         }",Verify target device key on reshare,"vuln-fix: Verify device identity key when using shared session keys

The code did not verify that the device identity key matched the one used when sharing the session key, allowing potential replay or impersonation attacks with stale keys.
This posed a security risk by enabling attackers to reuse or hijack session keys for devices whose identity keys have changed, undermining message confidentiality and integrity.
The fix stores and checks the device identity key alongside the message index, rejecting session keys if the current device key differs from the originally shared one.

Weakness: CWE-284
Severity: High
CVSS: 7.8",0.11764705882352941,"[('verify', 'ACTION', ''), ('key', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('key', 'secword', ''), ('keys', 'SECWORD', ''), ('verify', 'ACTION', ''), ('key', 'secword', ''), ('key', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('keys', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('hijack', 'secword', ''), ('keys', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('changed', 'ACTION', ''), ('integrity', 'secword', ''), ('fix', 'ACTION', ''), ('key', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('key', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-284', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,CWE-209,GHSA-pwwm-pwx2-2hw7,"@@ -87,6 +87,8 @@ public function sendResetLinkEmail(Request $request)
             \Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );
         }
 
+        // Prevent timing attack to enumerate users.
+        usleep(500000 + random_int(0, 1500000));
 
         if ($response === \Password::RESET_LINK_SENT) {
             \Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');","Added usleep :(

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Mitigate user enumeration via timing side channel in password reset

The password reset endpoint leaked information about user existence through response timing differences, enabling attackers to enumerate valid usernames.
This timing discrepancy allowed attackers to distinguish valid from invalid users, facilitating targeted attacks such as credential stuffing or phishing.
The fix adds randomized sleep delays to normalize response times, preventing attackers from inferring user validity based on timing variations.

Weakness: CWE-204
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('added', 'ACTION', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('user enumeration', 'SECWORD', ''), ('password', 'SECWORD', ''), ('password', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('timing discrepancy', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('attacks', 'FLAW', ''), ('credential', 'secword', ''), ('phishing', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('attackers', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-204', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
8,CWE-200,GHSA-7wv8-g97r-432h,"@@ -63,9 +63,9 @@
 
 });
 
-api_expose('users/search_authors', function ($params = false) {
+api_expose_admin('users/search_authors', function ($params = false) {
 
-    $return = array();
+    $return = array(); 
 
     $kw = false;
     if (isset($params['kw'])) {",search_authors only admins,"vuln-fix: Restrict user search API to admin users only

The users search_authors API endpoint was accessible to all authenticated users without proper authorization checks.
This allowed unauthorized users to enumerate or search user data, potentially exposing sensitive information or enabling user enumeration attacks.
The fix restricts access to this API by requiring administrative privileges, preventing unauthorized access to user search functionality.

Weakness: CWE-285
Severity: High
CVSS: 7.5",0.11764705882352941,"[('admins', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('admin users', 'SECWORD', ''), ('sensitive information', 'secword', ''), ('user enumeration', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('administrative', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-285', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,CWE-203,GHSA-mr6r-82x4-f4jj,"@@ -136,7 +136,17 @@ public function sign($msg, $key, $enc = null, $options = null)
             if( $k->cmpn(1) <= 0 || $k->cmp($ns1) >= 0 )
                 continue;
 
-            $kp = $this->g->mul($k);
+            // Fix the bit-length of the random nonce,
+            // so that it doesn't leak via timing.
+            // This does not change that ks = k mod k
+            $ks = $k->add($this->n);
+            $kt = $ks->add($this->n);
+            if ($ks->bitLength() === $this->n->bitLength()) {
+                $kp = $this->g->mul($kt);
+            } else {
+                $kp = $this->g->mul($ks);
+            }
+
             if( $kp->isInfinity() )
                 continue;","ecdsa: Apply nonce bit-length mitigation to stop timing leakage.

Ported from elliptic-js: https://github.com/indutny/elliptic/pull/203","vuln-fix: Mitigate timing leak in nonce bit-length during signature

The signature function leaked information about the random nonce’s bit-length through timing variations in elliptic curve multiplication.
This timing side channel could allow attackers to infer secret nonce properties, potentially leading to private key recovery in cryptographic operations.
The fix normalizes nonce bit-length by adjusting values before multiplication, ensuring constant-time behavior and preventing timing-based information leaks.

Weakness: CWE-208
Severity: High
CVSS: 7.8",0.17647058823529413,"[('ecdsa', 'secword', ''), ('nonce', 'secword', ''), ('timing leakage', 'SECWORD', ''), ('https://github.com/indutny/elliptic/pull/203', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('mitigate', 'ACTION', ''), ('timing leak', 'SECWORD', ''), ('nonce', 'secword', ''), ('signature', 'secword', ''), ('signature', 'secword', ''), ('nonce', 'secword', ''), ('attackers', 'SECWORD', ''), ('nonce', 'secword', ''), ('private key', 'secword', ''), ('cryptographic', 'SECWORD', ''), ('fix', 'ACTION', ''), ('nonce', 'secword', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('information leaks', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-208', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,CWE-209,GHSA-hhrj-wp42-32v3,"@@ -5,10 +5,12 @@
 use EloquentFilter\Filterable;
 use Illuminate\Database\Eloquent\Model;
 use MicroweberPackages\Content\Models\ModelFilters\ContentFilter;
+use MicroweberPackages\Core\Models\HasSearchableTrait;
 
 class Comment extends Model
 {
     use Filterable;
+    use HasSearchableTrait;
 
     public $table = 'comments';
 
@@ -21,6 +23,13 @@ class Comment extends Model
         'comment_body',
     ];
 
+    protected $searchable = [
+        'comment_name',
+        'comment_email',
+        'comment_website',
+        'comment_body',
+    ];
+
     public function modelFilter()
     {
         return $this->provideFilter(ContentFilter::class);",Update Comment.php,"vuln-fix: Add searchable trait to comment model for controlled search fields

The Comment model lacked explicit declaration of searchable fields, potentially allowing unrestricted or unsafe search queries on all attributes.
This could lead to information disclosure or injection attacks if unfiltered user input was used in search operations without proper constraints.
The fix introduces a searchable trait with a defined whitelist of safe fields, ensuring only intended attributes are searchable and reducing attack surface.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('update', 'ACTION', ''), ('comment.php', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('unsafe', 'secword', ''), ('disclosure', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('ensuring', 'ACTION', ''), ('attack surface', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,CWE-201,GHSA-3p92-886g-qxpq,"@@ -28,7 +28,7 @@ module.exports = function(options){
 
     if(writes.length > windowSize) writes.shift();
 
-    data = data instanceof Buffer ? data : new Buffer(data);
+    data = data instanceof Buffer ? data : new Buffer(data+'');
     bufLen += data.length;
 
     buf.push(data);",adding fix for exposing uninitalized memory found by @chalker,"vuln-fix: Prevent buffer overflow from non-buffer data input

The code converted non-Buffer inputs to Buffer without ensuring string conversion, allowing objects with custom toString methods to cause unexpected buffer sizes.
This could lead to buffer overflow or memory corruption if crafted inputs produce excessively large or malformed buffers.
The fix forces non-Buffer data to a string before Buffer creation, ensuring predictable and safe buffer allocation.

Weakness: CWE-120
Severity: High
CVSS: 7.5",0.058823529411764705,"[('adding', 'ACTION', ''), ('fix', 'ACTION', ''), ('uninitalized memory', 'secword', ''), ('found', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('buffer overflow', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('buffer overflow', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe buffer', 'secword', ''), ('weakness', 'secword', ''), ('cwe-120', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,CWE-20,GHSA-f7f4-hqp2-7prc,"@@ -3,6 +3,7 @@
  */
 
 var util = require('util');
+var url = require('url');
 var _ = require('@sailshq/lodash');
 var semver = require('semver');
 var parseSdkMetadata = require('./parse-sdk-metadata');
@@ -105,6 +106,8 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+
       method  : options.eventName,
 
       // Attached data becomes simulated HTTP body (`req.body`)",Define req.path for socket requests.,"vuln-fix: Extract and validate URL path from incoming messages

The code previously used the full URL string from incoming messages without parsing the path component, risking improper request handling or injection attacks.
This allowed attackers to craft URLs with malicious payloads in query or fragment parts that could bypass routing or security checks.
The fix parses the URL to explicitly extract and use only the pathname, ensuring safer and more accurate request processing.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('req.path', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('attackers', 'SECWORD', ''), ('malicious', 'secword', ''), ('bypass', 'secword', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,CWE-20,GHSA-hrg5-737c-2p56,"@@ -92,6 +92,9 @@ class UnsortedSegmentJoinOp : public OpKernel {
     const Tensor& num_segments_tensor = context->input(2);
     OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
+    OP_REQUIRES(context,
+                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),
+                errors::InvalidArgument(""Number of segments must be a scalar""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(","Fix tf.raw_ops.UnsortedSegmentJoin vulnerability with invalid num_segments.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445206880","vuln-fix: Enforce scalar shape for num_segments input in UnsortedSegmentJoinOp

The UnsortedSegmentJoinOp kernel did not verify that the num_segments input tensor was a scalar, allowing malformed tensor shapes to be processed.
This could lead to unexpected behavior or memory corruption by misinterpreting tensor data, potentially causing crashes or exploitable conditions.
The fix adds a check to ensure num_segments is a scalar tensor before use, preventing invalid input shapes from triggering unsafe operations.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.unsortedsegmentjoin', 'URL', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
14,CWE-20,GHSA-h5g4-ppwx-48q2,"@@ -134,6 +134,8 @@ class DeleteSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""`handle` must be scalar""));
     const string& name = handle.scalar<tstring>()();
     auto session_state = ctx->session_state();
     OP_REQUIRES(ctx, session_state != nullptr,","Fix tf.raw_ops.DeleteSessionTensor vulnerability with invalid `handle`.

Check that `handle` input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445228994","vuln-fix: Enforce scalar tensor shape for session handle input

The Compute method did not verify that the input tensor representing the session handle was a scalar, allowing malformed tensors to be processed.
This could lead to unexpected behavior or memory corruption if non-scalar tensors were used, potentially causing crashes or exploitable conditions.
The fix adds a check to ensure the handle tensor is scalar, rejecting invalid inputs early and preventing misuse of the session handle.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.deletesessiontensor', 'URL', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
15,CWE-20,GHSA-g25h-jr74-qp5j,"@@ -113,7 +113,50 @@ class QuantizeV2Op : public OpKernel {
 
     int num_slices = 1;
     if (axis_ > -1) {
+      OP_REQUIRES(
+          ctx, input.dims() > axis_,
+          errors::InvalidArgument(
+              ""Axis is on a zero-based index, so its value must always be less ""
+              ""than number of input's dims, but given axis value was "",
+              axis_, "" and input's dims was "", input.dims()));
       num_slices = input.dim_size(axis_);
+      OP_REQUIRES(ctx, input_min_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range dims are "",
+                      input_min_range.dims()));
+      OP_REQUIRES(ctx, input_min_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, min_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but min_range is a 1-D tensor of size "",
+                      input_min_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+      OP_REQUIRES(ctx, input_max_range.dims() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range dims are "",
+                      input_max_range.dims()));
+      OP_REQUIRES(ctx, input_max_range.dim_size(0) == num_slices,
+                  errors::InvalidArgument(
+                      ""If axis is specified, max_range must be a 1-D tensor ""
+                      ""whose size matches the axis dimension of the input and ""
+                      ""output tensors, but max_range is a 1-D tensor of size "",
+                      input_max_range.dim_size(0),
+                      "" and input's axis dimension is of size "", num_slices));
+    } else {
+      OP_REQUIRES(ctx, input_min_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, min_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_min_range.NumElements(), "" elements""));
+      OP_REQUIRES(ctx, input_max_range.NumElements() == 1,
+                  errors::InvalidArgument(
+                      ""If axis is not specified, max_range must contain a ""
+                      ""single float element, but it contains "",
+                      input_max_range.NumElements(), "" elements""));
     }
 
     const TensorShape& minmax_shape = ctx->input(1).shape();","Secure tf.raw_ops.QuantizeV2

Validate size and shape of min_range and max_range
Ensure axis is within input dims limits

PiperOrigin-RevId: 387232799
Change-Id: I36975281f7b5758e9e31a8dcc73fe610ef456318","vuln-fix: Add input dimension validation in QuantizeV2Op kernel

The QuantizeV2 operation lacked proper validation of input tensor dimensions and range tensor shapes when an axis parameter was specified or omitted.
This allowed malformed inputs to bypass checks, potentially causing out-of-bounds memory access or incorrect quantization results leading to undefined behavior or crashes.
The fix enforces strict dimension and size checks on input, min_range, and max_range tensors, ensuring they conform to expected shapes before proceeding with quantization.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('secure', 'secword', ''), ('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('i36975281f7b5758e9e31a8dcc73fe610ef456318', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('size checks', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
16,CWE-200,GHSA-f5fj-7265-jxhj,"@@ -1,4 +1,5 @@
 // Copyright 2016 The Gogs Authors. All rights reserved.
+// Copyright 2018 The Gitea Authors. All rights reserved.
 // Use of this source code is governed by a MIT-style
 // license that can be found in the LICENSE file.
 
@@ -87,7 +88,9 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 		names = append(names, participants[i].Name)
 	}
 
-	SendIssueCommentMail(issue, doer, content, comment, tos)
+	for _, to := range tos {
+		SendIssueCommentMail(issue, doer, content, comment, []string{to})
+	}
 
 	// Mail mentioned people and exclude watchers.
 	names = append(names, doer.Name)
@@ -99,7 +102,12 @@ func mailIssueCommentToParticipants(e Engine, issue *Issue, doer *User, content
 
 		tos = append(tos, mentions[i])
 	}
-	SendIssueMentionMail(issue, doer, content, comment, getUserEmailsByNames(e, tos))
+
+	emails := getUserEmailsByNames(e, tos)
+
+	for _, to := range emails {
+		SendIssueMentionMail(issue, doer, content, comment, []string{to})
+	}
 
 	return nil
 }",Don't disclose emails of all users when sending out emails (#4664),"vuln-fix: Prevent email header injection via bulk mailing functions

The mailing functions sent emails to multiple recipients by passing all addresses in a single slice, risking improper handling of recipient data.
This allowed attackers to exploit email header injection or recipient enumeration by manipulating bulk email parameters, potentially leaking user information or causing spam.
The fix changes the code to send individual emails per recipient, isolating addresses and preventing injection or unintended disclosure.

Weakness: CWE-93
Severity: High
CVSS: 7.5",0.058823529411764705,"[('disclose', 'secword', ''), ('#4664', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('improper handling', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('manipulating', 'ACTION', ''), ('spam', 'secword', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('preventing', 'ACTION', ''), ('injection', 'SECWORD', ''), ('disclosure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-93', 'CWEID', ''), ('high', 'SEVERITY', '')]"
17,"CWE-915', 'CWE-20",GHSA-66rh-8fw6-59q6,"@@ -37,7 +37,7 @@ function extend(target, obj) {
   assignSymbols(target, obj);
 
   for (var key in obj) {
-    if (key !== '__proto__' && hasOwn(obj, key)) {
+    if (isValidKey(key) && hasOwn(obj, key)) {
       var val = obj[key];
       if (isObject(val)) {
         if (typeOf(target[key]) === 'undefined' && typeOf(val) === 'function') {
@@ -68,6 +68,14 @@ function hasOwn(obj, key) {
   return Object.prototype.hasOwnProperty.call(obj, key);
 }
 
+/**
+ * Returns true if the given `key` is a valid key that can be used for assigning properties.
+ */
+
+function isValidKey(key) {
+  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
+}
+
 /**
  * Expose `assign`
  */",ensure keys are valid,"vuln-fix: Prevent prototype pollution by restricting property keys

The extend function allowed assignment of dangerous keys like 'constructor' and 'prototype', enabling prototype pollution attacks.
This vulnerability could let attackers manipulate object prototypes, leading to arbitrary code execution or denial of service through corrupted application state.
The fix adds a key validation function that blocks assignment of '__proto__', 'constructor', and 'prototype' properties to prevent prototype pollution.

Weakness: CWE-471
Severity: High
CVSS: 7.8",0.11764705882352941,"[('ensure', 'ACTION', ''), ('keys', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('key', 'secword', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'secword', ''), ('weakness', 'secword', ''), ('cwe-471', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,CWE-20,GHSA-9m95-8hx6-7p9v,"@@ -404,6 +404,11 @@ func (te *TarExtractor) UnpackEntry(root string, hdr *tar.Header, r io.Reader) (
 	if filepath.Join(""/"", hdr.Name) == ""/"" {
 		// If we got an entry for the root, then unsafeDir is the full path.
 		unsafeDir, file = hdr.Name, "".""
+		// If we're being asked to change the root type, bail because they may
+		// change it to a symlink which we could inadvertently follow.
+		if hdr.Typeflag != tar.TypeDir {
+			return errors.New(""malicious tar entry -- refusing to change type of root directory"")
+		}
 	}
 	dir, err := securejoin.SecureJoinVFS(root, unsafeDir, te.fsEval)
 	if err != nil {","layer: don't permit / type to be changed on extraction

If users can change the type of / to a symlink, they can cause umoci to
overwrite host files. This is obviously bad, and is not caught by the
rest of our directory escape detection code because the root itself has
been changed to a different directory.

Fixes: CVE-2021-29136
Reported-by: Robin Peraglie <robin@cure53.de>
Tested-by: Daniel Dao <dqminh89@gmail.com>
Reviewed-by: Tycho Andersen <tycho@tycho.pizza>
Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>","vuln-fix: Prevent root directory type change in tar extraction

The tar extraction code allowed changing the root directory entry to a non-directory type, such as a symlink, during unpacking.
This posed a security risk by enabling attackers to create or follow symlinks at the root, potentially leading to arbitrary file system access or traversal attacks.
The fix rejects tar entries that attempt to change the root directory’s type to anything other than a directory, preventing unsafe root modifications.

Weakness: CWE-59
Severity: High
CVSS: 7.8",0.23529411764705882,"[('changed', 'ACTION', ''), ('change', 'ACTION', ''), ('symlink', 'SECWORD', ''), ('escape', 'SECWORD', ''), ('changed', 'ACTION', ''), ('robin@cure53.de', 'EMAIL', ''), ('signed', 'secword', ''), ('cyphar@cyphar.com', 'EMAIL', ''), ('fixes', 'ACTION', ''), ('cve-2021-29136', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('change', 'ACTION', ''), ('changing', 'ACTION', ''), ('symlink', 'secword', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('symlinks', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-59', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,CWE-200,GHSA-5r2v-6gm6-vpvh,"@@ -112,6 +112,15 @@ func reqRepoWriter() macaron.Handler {
 	}
 }
 
+func reqRepoAdmin() macaron.Handler {
+	return func(c *context.Context) {
+		if !c.Repo.IsAdmin() {
+			c.Error(http.StatusForbidden)
+			return
+		}
+	}
+}
+
 func orgAssignment(args ...bool) macaron.Handler {
 	var (
 		assignOrg  bool
@@ -236,12 +245,12 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateHookOption{}), repo.CreateHook)
 					m.Combo(""/:id"").Patch(bind(api.EditHookOption{}), repo.EditHook).
 						Delete(repo.DeleteHook)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/collaborators"", func() {
 					m.Get("""", repo.ListCollaborators)
 					m.Combo(""/:collaborator"").Get(repo.IsCollaborator).Put(bind(api.AddCollaboratorOption{}), repo.AddCollaborator).
 						Delete(repo.DeleteCollaborator)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Get(""/raw/*"", context.RepoRef(), repo.GetRawFile)
 				m.Get(""/archive/*"", repo.GetArchive)
 				m.Get(""/forks"", repo.ListForks)
@@ -260,7 +269,7 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Post(bind(api.CreateKeyOption{}), repo.CreateDeployKey)
 					m.Combo(""/:id"").Get(repo.GetDeployKey).
 						Delete(repo.DeleteDeploykey)
-				}, reqAdmin())
+				}, reqRepoAdmin())
 				m.Group(""/issues"", func() {
 					m.Combo("""").Get(repo.ListIssues).Post(bind(api.CreateIssueOption{}), repo.CreateIssue)
 					m.Group(""/comments"", func() {
@@ -300,8 +309,8 @@ func RegisterRoutes(m *macaron.Macaron) {
 						Delete(reqRepoWriter(), repo.DeleteMilestone)
 				})
 
-				m.Patch(""/issue-tracker"", bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
-				m.Post(""/mirror-sync"", repo.MirrorSync)
+				m.Patch(""/issue-tracker"", reqRepoWriter(), bind(api.EditIssueTrackerOption{}), repo.IssueTracker)
+				m.Post(""/mirror-sync"", reqRepoWriter(), repo.MirrorSync)
 				m.Get(""/editorconfig/:filename"", context.RepoRef(), repo.GetEditorconfig)
 			}, repoAssignment())
 		}, reqToken())","routes/api: fix permission checks for routes

Reported by @ManassehZhou #5764","vuln-fix: Enforce repository admin check on sensitive routes

Certain repository routes previously used a generic admin check that did not verify repository-specific admin permissions, allowing unauthorized users to perform privileged actions.
This flaw risked unauthorized access and modification of repository settings, hooks, collaborators, and deploy keys, potentially compromising repository integrity and security.
The fix replaces the generic admin middleware with a repository-specific admin check that ensures only repository administrators can access these sensitive endpoints.

Weakness: CWE-285
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('permission', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('admin', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('admin', 'SECWORD', ''), ('verify', 'ACTION', ''), ('admin', 'SECWORD', ''), ('permissions', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('keys', 'SECWORD', ''), ('integrity', 'secword', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('admin', 'SECWORD', ''), ('admin', 'SECWORD', ''), ('ensures', 'ACTION', ''), ('administrators', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-285', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,CWE-20,GHSA-v82p-hv3v-p6qp,"@@ -49,35 +49,45 @@ class MklRequantizePerChannelOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     try {
       const Tensor& input = ctx->input(kInputTensorIndex);
+      OP_REQUIRES(
+          ctx, input.dims() == 4,
+          errors::InvalidArgument(""Current RequantizePerChannel operator""
+                                  ""supports 4D tensors only.""));
+
       const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);
+      size_t depth = input_min_vec.NumElements();
       float* input_min_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_min_vec.flat<float>().data()));
+
       const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);
+      OP_REQUIRES(
+          ctx, input_max_vec.NumElements() == depth,
+          errors::InvalidArgument(""input_max has incorrect size, expected "",
+                                  depth, "" was "", input_max_vec.NumElements()));
       float* input_max_vec_data = (float*)const_cast<void*>(
           static_cast<const void*>(input_max_vec.flat<float>().data()));
 
       const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_min must be a scalar""));
       const float input_requested_min_float =
           input_requested_min.flat<float>()(0);
+
       const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);
+      OP_REQUIRES(
+          ctx, input_requested_min.NumElements() == 1,
+          errors::InvalidArgument(""requested_output_max must be a scalar""));
       const float input_requested_max_float =
           input_requested_max.flat<float>()(0);
 
-      size_t depth = input_min_vec.NumElements();
-      OP_REQUIRES(
-          ctx, input.dims() == 4,
-          errors::InvalidArgument(""Current RequantizePerChannel operator""
-                                  ""supports 4D tensors only.""));
-      OP_REQUIRES(
-          ctx, input_min_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_min has incorrect size, expected "",
-                                  depth, "" was "", input_min_vec.dim_size(0)));
-      OP_REQUIRES(
-          ctx, input_max_vec.dim_size(0) == depth,
-          errors::InvalidArgument(""input_max has incorrect size, expected "",
-                                  depth, "" was "", input_max_vec.dim_size(0)));
-
-      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);
+      if (out_type_ == DT_QINT8) {
+        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,
+                    errors::InvalidArgument(
+                        ""If out_type is QINT8, requested_output_max must be ""
+                        ""non negative, got "",
+                        input_requested_min_float));
+      }
 
       const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;
       const float requested_min_max =","Reorganize and add more validation to MKL requantization

PiperOrigin-RevId: 387901341
Change-Id: I2515b9034c64e113db0bcec8337d30643ab0a0f1","vuln-fix: Add strict input validation in RequantizePerChannel operator

The RequantizePerChannel operator lacked comprehensive validation of input tensor dimensions and parameter sizes, allowing malformed inputs to proceed unchecked.
This could lead to out-of-bounds memory access or incorrect computations, potentially causing crashes or exploitable undefined behavior in downstream processing.
The fix enforces strict checks on tensor rank, vector sizes, and scalar parameters, rejecting invalid inputs early with clear error messages.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('i2515b9034c64e113db0bcec8337d30643ab0a0f1', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
21,CWE-20,GHSA-2p9q-h29j-3f5v,"@@ -36,6 +36,10 @@ class SummaryTensorOpV2 : public OpKernel {
                 errors::InvalidArgument(""tag must be scalar""));
     const Tensor& tensor = c->input(1);
     const Tensor& serialized_summary_metadata_tensor = c->input(2);
+    OP_REQUIRES(
+        c,
+        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),
+        errors::InvalidArgument(""serialized_summary_metadata must be scalar""));
 
     Summary s;
     Summary::Value* v = s.add_value();","Fix tf.raw_ops.TensorSummaryV2 vulnerability with invalid serialized_summary_metadata.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445197183","vuln-fix: Validate serialized summary metadata tensor shape

The code failed to verify that the serialized summary metadata tensor input was a scalar, allowing malformed tensor shapes to be processed.
This could lead to unexpected behavior or memory corruption when non-scalar tensors are used where scalars are required, risking application stability and security.
The fix adds a check to ensure the serialized summary metadata tensor is scalar, rejecting invalid inputs early to prevent downstream errors.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('serialized_summary_metadata', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('serialized', 'SECWORD', ''), ('verify', 'ACTION', ''), ('serialized', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('serialized', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,CWE-209,GHSA-hm37-9xh2-q499,"@@ -221,7 +221,9 @@ def from_bytes(
 
         Raises:
             ValueError: The provided byte string is not an ``openssh-key-v1``
-                key list or the declared key count is negative.
+                key list, when the declared key count is negative, or when an
+                EOF is found while parsing the key.
+
             UserWarning: The check numbers in the decrypted private byte string
                 do not match (likely due to an incorrect passphrase), the key
                 type or parameter values of a private key do not match that of
@@ -229,110 +231,117 @@ def from_bytes(
                 at the end of the decrypted private byte string are not as
                 expected.
         """"""
-        byte_stream = PascalStyleByteStream(byte_string)
+        try:
+            byte_stream = PascalStyleByteStream(byte_string)
 
-        header = byte_stream.read_from_format_instructions_dict(
-            cls.HEADER_FORMAT_INSTRUCTIONS_DICT
-        )
+            header = byte_stream.read_from_format_instructions_dict(
+                cls.HEADER_FORMAT_INSTRUCTIONS_DICT
+            )
+
+            if header['auth_magic'] != b'openssh-key-v1\x00':
+                raise ValueError('Not an openssh-key-v1 key')
 
-        if header['auth_magic'] != b'openssh-key-v1\x00':
-            raise ValueError('Not an openssh-key-v1 key')
+            num_keys = header['num_keys']
 
-        num_keys = header['num_keys']
+            if num_keys < 0:
+                raise ValueError('Cannot parse negative number of keys')
 
-        if num_keys < 0:
-            raise ValueError('Cannot parse negative number of keys')
+            public_key_list = []
+            for i in range(num_keys):
+                public_key_bytes = byte_stream.read_from_format_instruction(
+                    PascalStyleFormatInstruction.BYTES
+                )
+                public_key_list.append(
+                    PublicKey.from_bytes(public_key_bytes)
+                )
 
-        public_key_list = []
-        for i in range(num_keys):
-            public_key_bytes = byte_stream.read_from_format_instruction(
+            cipher_bytes = byte_stream.read_from_format_instruction(
                 PascalStyleFormatInstruction.BYTES
             )
-            public_key_list.append(
-                PublicKey.from_bytes(public_key_bytes)
-            )
 
-        cipher_bytes = byte_stream.read_from_format_instruction(
-            PascalStyleFormatInstruction.BYTES
-        )
-
-        kdf_class = get_kdf_options_class(header['kdf'])
-        kdf_options = kdf_class(
-            PascalStyleByteStream(
-                header['kdf_options']
-            ).read_from_format_instructions_dict(
-                kdf_class.FORMAT_INSTRUCTIONS_DICT
+            kdf_class = get_kdf_options_class(header['kdf'])
+            kdf_options = kdf_class(
+                PascalStyleByteStream(
+                    header['kdf_options']
+                ).read_from_format_instructions_dict(
+                    kdf_class.FORMAT_INSTRUCTIONS_DICT
+                )
             )
-        )
 
-        cipher_class = get_cipher_class(header['cipher'])
+            cipher_class = get_cipher_class(header['cipher'])
 
-        if kdf_class == NoneKDFOptions:
-            passphrase = ''
-        elif passphrase is None:
-            passphrase = getpass.getpass('Key passphrase: ')
+            if kdf_class == NoneKDFOptions:
+                passphrase = ''
+            elif passphrase is None:
+                passphrase = getpass.getpass('Key passphrase: ')
 
-        if issubclass(cipher_class, ConfidentialityIntegrityCipher):
-            cipher_bytes += byte_stream.read_fixed_bytes(
-                cipher_class.TAG_LENGTH
-            )
-
-        decipher_bytes = cipher_class.decrypt(
-            kdf_class(kdf_options),
-            passphrase,
-            cipher_bytes
-        )
-
-        decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
+            if issubclass(cipher_class, ConfidentialityIntegrityCipher):
+                cipher_bytes += byte_stream.read_fixed_bytes(
+                    cipher_class.TAG_LENGTH
+                )
 
-        decipher_bytes_header = \
-            decipher_byte_stream.read_from_format_instructions_dict(
-                cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
+            decipher_bytes = cipher_class.decrypt(
+                kdf_class(kdf_options),
+                passphrase,
+                cipher_bytes
             )
 
-        if decipher_bytes_header['check_int_1'] \
-                != decipher_bytes_header['check_int_2']:
-            warnings.warn('Cipher header check numbers do not match')
+            decipher_byte_stream = PascalStyleByteStream(decipher_bytes)
 
-        initlist = []
-        for i in range(num_keys):
-            initlist.append(
-                PublicPrivateKeyPair(
-                    public_key_list[i],
-                    PrivateKey.from_byte_stream(decipher_byte_stream)
-                )
-            )
-            if initlist[i].public.header['key_type'] \
-                    != initlist[i].private.header['key_type']:
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'key types for key {i}'
+            decipher_bytes_header = \
+                decipher_byte_stream.read_from_format_instructions_dict(
+                    cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT
                 )
-            if not all(
-                (
-                    initlist[i].public.params[k] ==
-                    initlist[i].private.params[k]
-                ) for k in (
-                    initlist[i].public.params.keys() &
-                    initlist[i].private.params.keys()
+
+            if decipher_bytes_header['check_int_1'] \
+                    != decipher_bytes_header['check_int_2']:
+                warnings.warn('Cipher header check numbers do not match')
+
+            initlist = []
+            for i in range(num_keys):
+                initlist.append(
+                    PublicPrivateKeyPair(
+                        public_key_list[i],
+                        PrivateKey.from_byte_stream(decipher_byte_stream)
+                    )
                 )
+                if initlist[i].public.header['key_type'] \
+                        != initlist[i].private.header['key_type']:
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'key types for key {i}'
+                    )
+                if not all(
+                    (
+                        initlist[i].public.params[k] ==
+                        initlist[i].private.params[k]
+                    ) for k in (
+                        initlist[i].public.params.keys() &
+                        initlist[i].private.params.keys()
+                    )
+                ):
+                    warnings.warn(
+                        f'Inconsistency between private and public '
+                        f'values for key {i}'
+                    )
+
+            decipher_padding = decipher_byte_stream.read()
+
+            if (
+                len(decipher_byte_stream.getvalue()) %
+                    cipher_class.BLOCK_SIZE != 0
+            ) or not (
+                bytes(
+                    range(1, 1 + cipher_class.BLOCK_SIZE)
+                ).startswith(decipher_padding)
             ):
-                warnings.warn(
-                    f'Inconsistency between private and public '
-                    f'values for key {i}'
-                )
-
-        decipher_padding = decipher_byte_stream.read()
-
-        if (
-            len(decipher_byte_stream.getvalue()) %
-                cipher_class.BLOCK_SIZE != 0
-        ) or not (
-            bytes(
-                range(1, 1 + cipher_class.BLOCK_SIZE)
-            ).startswith(decipher_padding)
-        ):
-            warnings.warn('Incorrect padding at end of ciphertext')
+                warnings.warn('Incorrect padding at end of ciphertext')
+        except ValueError as e:
+            raise e
+        except EOFError as e:
+            raise ValueError('Premature EOF detected while parsing key.')
+        except e:
+            raise ValueError('Unexpected error condition reached.')
 
         return cls(
             initlist,",Improved error handling to prevent unhandled exceptions in calling code.,"vuln-fix: Handle premature EOF and parsing errors in key deserialization

The key deserialization function did not properly handle unexpected end-of-file conditions, causing unhandled exceptions during parsing of malformed or truncated keys.
This could lead to application crashes or denial of service when processing crafted or corrupted key data, impacting availability and stability.
The fix adds explicit exception handling for EOFError and other unexpected errors, converting them into controlled ValueError exceptions with descriptive messages.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('improved', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('prevent', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('errors', 'FLAW', ''), ('key', 'secword', ''), ('deserialization', 'SECWORD', ''), ('key', 'SECWORD', ''), ('deserialization', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('key', 'secword', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('eoferror', 'FLAW', ''), ('errors', 'FLAW', ''), ('valueerror', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
23,CWE-200,GHSA-fcxw-hhxq-48wx,"@@ -42,6 +42,11 @@
 import java.net.URISyntaxException;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -1411,6 +1416,34 @@ public void addNote(String note, String namespace ) throws GitException, Interru
         createNote(note,namespace,""add"");
     }
 
+    private File createTempFileInSystemDir(String prefix, String suffix) throws IOException {
+        if (isWindows()) {
+            return Files.createTempFile(prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(prefix, suffix, fileAttribute).toFile();
+    }
+
+    private File createTempFile(String prefix, String suffix) throws IOException {
+        if (workspace == null) {
+            return createTempFileInSystemDir(prefix, suffix);
+        }
+        File workspaceTmp = new File(workspace.getAbsolutePath() + ""@tmp"");
+        if (!workspaceTmp.isDirectory() && !workspaceTmp.mkdirs()) {
+            if (!workspaceTmp.isDirectory()) {
+                return createTempFileInSystemDir(prefix, suffix);
+            }
+        }
+        Path tmpPath = Paths.get(workspaceTmp.getAbsolutePath());
+        if (isWindows()) {
+            return Files.createTempFile(tmpPath, prefix, suffix).toFile();
+        }
+        Set<PosixFilePermission> ownerOnly = PosixFilePermissions.fromString(""rw-------"");
+        FileAttribute fileAttribute = PosixFilePermissions.asFileAttribute(ownerOnly);
+        return Files.createTempFile(tmpPath, prefix, suffix, fileAttribute).toFile();
+    }
+
     private void deleteTempFile(File tempFile) {
         if (tempFile != null && !tempFile.delete() && tempFile.exists()) {
             listener.getLogger().println(""[WARNING] temp file "" + tempFile + "" not deleted"");
@@ -1420,7 +1453,7 @@ private void deleteTempFile(File tempFile) {
     private void createNote(String note, String namespace, String command ) throws GitException, InterruptedException {
         File msg = null;
         try {
-            msg = File.createTempFile(""git-note"", ""txt"", workspace);
+            msg = createTempFile(""git-note"", "".txt"");
             FileUtils.writeStringToFile(msg,note);
             launchCommand(""notes"", ""--ref="" + namespace, command, ""-F"", msg.getAbsolutePath());
         } catch (IOException | GitException e) {
@@ -1561,7 +1594,7 @@ private String launchCommandWithCredentials(ArgumentListBuilder args, File workD
     }
 
     private File createSshKeyFile(SSHUserPrivateKey sshUser) throws IOException, InterruptedException {
-        File key = File.createTempFile(""ssh"", ""key"");
+        File key = createTempFile(""ssh"", "".key"");
         try (PrintWriter w = new PrintWriter(key, Charset.defaultCharset().toString())) {
             List<String> privateKeys = sshUser.getPrivateKeys();
             for (String s : privateKeys) {
@@ -1597,7 +1630,7 @@ private String quoteUnixCredentials(String str) {
     }
 
     private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".bat"");
+        File ssh = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             // avoid echoing command as part of the password
             w.println(""@echo off"");
@@ -1610,7 +1643,7 @@ private File createWindowsSshAskpass(SSHUserPrivateKey sshUser) throws IOExcepti
     }
 
     private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException {
-        File ssh = File.createTempFile(""pass"", "".sh"");
+        File ssh = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""echo '"" + quoteUnixCredentials(Secret.toString(sshUser.getPassphrase())) + ""'"");
@@ -1621,7 +1654,7 @@ private File createUnixSshAskpass(SSHUserPrivateKey sshUser) throws IOException
 
     /* Package protected for testability */
     File createWindowsBatFile(String userName, String password) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".bat"");
+        File askpass = createTempFile(""pass"", "".bat"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""@set arg=%~1"");
             w.println(""@if (%arg:~0,8%)==(Username) echo "" + escapeWindowsCharsForUnquotedString(userName));
@@ -1636,7 +1669,7 @@ private File createWindowsStandardAskpass(StandardUsernamePasswordCredentials cr
     }
 
     private File createUnixStandardAskpass(StandardUsernamePasswordCredentials creds) throws IOException {
-        File askpass = File.createTempFile(""pass"", "".sh"");
+        File askpass = createTempFile(""pass"", "".sh"");
         try (PrintWriter w = new PrintWriter(askpass, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             w.println(""case \""$1\"" in"");
@@ -1766,7 +1799,7 @@ private File getSSHExeFromGitExeParentDir(String userGitExe) {
     }
 
     private File createWindowsGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".bat"");
+        File ssh = createTempFile(""ssh"", "".bat"");
 
         File sshexe = getSSHExecutable();
 
@@ -1779,7 +1812,7 @@ private File createWindowsGitSSH(File key, String user) throws IOException {
     }
 
     private File createUnixGitSSH(File key, String user) throws IOException {
-        File ssh = File.createTempFile(""ssh"", "".sh"");
+        File ssh = createTempFile(""ssh"", "".sh"");
         try (PrintWriter w = new PrintWriter(ssh, Charset.defaultCharset().toString())) {
             w.println(""#!/bin/sh"");
             // ${SSH_ASKPASS} might be ignored if ${DISPLAY} is not set
@@ -2383,7 +2416,7 @@ public void branch(String name) throws GitException, InterruptedException {
     public void commit(String message) throws GitException, InterruptedException {
         File f = null;
         try {
-            f = File.createTempFile(""gitcommit"", "".txt"");
+            f = createTempFile(""gitcommit"", "".txt"");
             try (OutputStream out = Files.newOutputStream(f.toPath())) {
                 out.write(message.getBytes(Charset.defaultCharset().toString()));
             }","[Fix SECURITY-445] better protect temporary files

Temporary files were previously written to the system temporary directory
with default permissions.  A malicious actor could have captured sensitive
information by reading files from the temporary directory.  The temporary
files typically are only on the file system for the duration of a single
command line git invocation, but cloning a large git repo could require
an extended time with those sensitive files in the temporary directory.

This change sets permissions on the temporary files to be readable only by
the file owner. If a workspace is available, a temporary directory adjacent
to the workspace is used instead of the system temporary directory.","vuln-fix: Restrict permissions on temporary files to prevent unauthorized access

Temporary files containing sensitive data were created without explicit permission restrictions, allowing other users on the system to potentially read or modify these files.
This posed a security risk by exposing private keys, credentials, or other confidential information to unauthorized local users, leading to information disclosure or privilege escalation.
The fix enforces owner-only read/write permissions on temporary files by setting POSIX file attributes when creating them on non-Windows systems.

Weakness: CWE-276
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('security-445', 'SECWORD', ''), ('protect', 'secword', ''), ('permissions', 'SECWORD', ''), ('malicious', 'secword', ''), ('sensitive', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('change', 'ACTION', ''), ('permissions', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('permissions', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('sensitive data', 'secword', ''), ('permission', 'SECWORD', ''), ('security', 'secword', ''), ('keys', 'SECWORD', ''), ('confidential', 'secword', ''), ('disclosure', 'secword', ''), ('privilege escalation', 'secword', ''), ('fix', 'ACTION', ''), ('permissions', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-276', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,"CWE-532', 'CWE-200",GHSA-25xj-89g5-fm6h,"@@ -445,9 +445,7 @@ func (c *ServerCommand) runRecoveryMode() int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// Initialize the storage backend
 	factory, exists := c.PhysicalBackends[config.Storage.Type]
@@ -684,6 +682,31 @@ func (c *ServerCommand) runRecoveryMode() int {
 	return 0
 }
 
+func logProxyEnvironmentVariables(logger hclog.Logger) {
+	proxyCfg := httpproxy.FromEnvironment()
+	cfgMap := map[string]string{
+		""http_proxy"":  proxyCfg.HTTPProxy,
+		""https_proxy"": proxyCfg.HTTPSProxy,
+		""no_proxy"":    proxyCfg.NoProxy,
+	}
+	for k, v := range cfgMap {
+		u, err := url.Parse(v)
+		if err != nil {
+			// Env vars may contain URLs or host:port values.  We only care
+			// about the former.
+			continue
+		}
+		if _, ok := u.User.Password(); ok {
+			u.User = url.UserPassword(""redacted-username"", ""redacted-password"")
+		} else if user := u.User.Username(); user != """" {
+			u.User = url.User(""redacted-username"")
+		}
+		cfgMap[k] = u.String()
+	}
+	logger.Info(""proxy environment"", ""http_proxy"", cfgMap[""http_proxy""],
+		""https_proxy"", cfgMap[""https_proxy""], ""no_proxy"", cfgMap[""no_proxy""])
+}
+
 func (c *ServerCommand) adjustLogLevel(config *server.Config, logLevelWasNotSet bool) (string, error) {
 	var logLevelString string
 	if config.LogLevel != """" && logLevelWasNotSet {
@@ -894,10 +917,7 @@ func (c *ServerCommand) Run(args []string) int {
 		vault.DefaultMaxRequestDuration = config.DefaultMaxRequestDuration
 	}
 
-	// log proxy settings
-	proxyCfg := httpproxy.FromEnvironment()
-	c.logger.Info(""proxy environment"", ""http_proxy"", proxyCfg.HTTPProxy,
-		""https_proxy"", proxyCfg.HTTPSProxy, ""no_proxy"", proxyCfg.NoProxy)
+	logProxyEnvironmentVariables(c.logger)
 
 	// If mlockall(2) isn't supported, show a warning. We disable this in dev
 	// because it is quite scary to see when first using Vault. We also disable",Don't include username or password of proxy env vars when logging them. (#9022),"vuln-fix: Redact credentials in proxy environment logging

The server logged proxy environment variables including URLs that could contain embedded usernames and passwords in plaintext.
This exposed sensitive credentials in logs, risking credential leakage to unauthorized users with log access.
The fix sanitizes proxy URLs by redacting any embedded usernames and passwords before logging them.

Weakness: CWE-532
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('password', 'SECWORD', ''), ('#9022', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('server', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('credential', 'secword', ''), ('fix', 'ACTION', ''), ('sanitizes', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-532', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
25,CWE-20,GHSA-w8rc-pgxq-x2cj,"@@ -108,7 +108,7 @@ public ShoppingCartData addItemsToShoppingCart( final ShoppingCartData shoppingC
     {
 
         ShoppingCart cartModel = null;
-        
+        if(item.getQuantity() < 1) item.setQuantity(1);
         /**
          * Sometimes a user logs in and a shopping cart is present in db (shoppingCartData
          * but ui has no cookie with shopping cart code so the cart code will have
@@ -216,7 +216,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -288,7 +288,7 @@ private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem
         }
         	
         for(ProductAvailability availability : availabilities) {
-        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() ==0) {
+        	if(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {
                 throw new Exception( ""Item with id "" + product.getId() + "" is not available"");
         	}
         }
@@ -554,8 +554,7 @@ public ShoppingCartData updateCartItem( final Long itemID, final String cartId,
         return null;
     }
     
-    @SuppressWarnings(""unchecked"")
-	@Override
+    @Override
     public ShoppingCartData updateCartItems( final List<ShoppingCartItem> shoppingCartItems, final MerchantStore store, final Language language )
             throws Exception
         {
@@ -720,7 +719,6 @@ public ReadableShoppingCart addToCart(PersistableShoppingCartItem item, Merchant
 	}
 	
 
-	@SuppressWarnings(""unchecked"")
 	@Override
 	public void removeShoppingCartItem(String cartCode, Long productId,
 	      MerchantStore merchant, Language language) throws Exception {

From: ""yannick.gosset"" <yannick.gosset@etu.univ-amu.fr>
 uses PersitableShoppingCartItem

 .../controller/shoppingCart/facade/ShoppingCartFacadeImpl.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -912,7 +912,7 @@ public ReadableShoppingCart addToCart(Customer customer, PersistableShoppingCart
 		
 		Validate.notNull(customer,""Customer cannot be null"");
 		Validate.notNull(customer.getId(),""Customer.id cannot be null or empty"");
-		
+		if(item.getQuantity() < 1) item.setQuantity(1);
 		//Check if customer has an existing shopping cart
 		ShoppingCart cartModel = shoppingCartService.getByCustomer(customer);","Merge pull request from GHSA-w8rc-pgxq-x2cj

Fixing negative charge vulnerability","vuln-fix: Enforce minimum quantity to prevent invalid cart item states

The shopping cart logic allowed items with zero or negative quantities to be added or updated, leading to inconsistent or invalid cart states.
This could be exploited to bypass inventory checks or cause unexpected behavior in order processing, potentially enabling fraudulent purchases or stock manipulation.
The fix enforces a minimum quantity of one by adjusting any item quantity less than one to one before further processing.

Weakness: CWE-841
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('ghsa', 'VULNID', 'GHSA'), ('fixing', 'ACTION', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('added', 'ACTION', ''), ('updated', 'ACTION', ''), ('exploited', 'SECWORD', ''), ('bypass', 'secword', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-841', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,CWE-200,GHSA-v6wr-fch2-vm5w,"@@ -1,141 +1,142 @@
 /*
-    *
-    *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
-    *  *
-    *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
-    *  *  you may not use this file except in compliance with the License.
-    *  *  You may obtain a copy of the License at
-    *  *
-    *  *       http://www.apache.org/licenses/LICENSE-2.0
-    *  *
-    *  *  Unless required by applicable law or agreed to in writing, software
-    *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
-    *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    *  *  See the License for the specific language governing permissions and
-    *  *  limitations under the License.
-    *  *
-    *  * For more information: http://www.orientechnologies.com
-    *
-    */
+ *
+ *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
+ *  *
+ *  *  Licensed under the Apache License, Version 2.0 (the ""License"");
+ *  *  you may not use this file except in compliance with the License.
+ *  *  You may obtain a copy of the License at
+ *  *
+ *  *       http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *  Unless required by applicable law or agreed to in writing, software
+ *  *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *  See the License for the specific language governing permissions and
+ *  *  limitations under the License.
+ *  *
+ *  * For more information: http://www.orientechnologies.com
+ *
+ */
 package com.orientechnologies.orient.server.network.protocol.http;
 
 import com.orientechnologies.common.concur.resource.OSharedResourceAbstract;
- import com.orientechnologies.common.log.OLogManager;
- import com.orientechnologies.orient.core.Orient;
- import com.orientechnologies.orient.core.config.OGlobalConfiguration;
-
- import java.util.HashMap;
- import java.util.Iterator;
- import java.util.Map;
- import java.util.Map.Entry;
- import java.util.Random;
- import java.util.TimerTask;
+import com.orientechnologies.common.log.OLogManager;
+import com.orientechnologies.orient.core.Orient;
+import com.orientechnologies.orient.core.config.OGlobalConfiguration;
+
+import java.security.SecureRandom;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.TimerTask;
 
 /**
-  * Handles the HTTP sessions such as a real HTTP Server.
-  *
-  * @author Luca Garulli
-  */
- public class OHttpSessionManager extends OSharedResourceAbstract {
-   private static final OHttpSessionManager instance = new OHttpSessionManager();
-   private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
-   private int                              expirationTime;
-   private Random                           random   = new Random();
-
-   protected OHttpSessionManager() {
-     expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
-
-     Orient.instance().scheduleTask(new TimerTask() {
-       @Override
-       public void run() {
-         final int expired = checkSessionsValidity();
-         if (expired > 0)
-           OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
-       }
-     }, expirationTime, expirationTime);
-   }
-
-   public int checkSessionsValidity() {
-     int expired = 0;
-
-     acquireExclusiveLock();
-     try {
-       final long now = System.currentTimeMillis();
-
-       Entry<String, OHttpSession> s;
-       for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
-         s = it.next();
-
-         if (now - s.getValue().getUpdatedOn() > expirationTime) {
-           // REMOVE THE SESSION
-           it.remove();
-           expired++;
-         }
-       }
-
-     } finally {
-       releaseExclusiveLock();
-     }
-
-     return expired;
-   }
-
-   public OHttpSession[] getSessions() {
-     acquireSharedLock();
-     try {
-
-       return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public OHttpSession getSession(final String iId) {
-     acquireSharedLock();
-     try {
-
-       final OHttpSession sess = sessions.get(iId);
-       if (sess != null)
-         sess.updateLastUpdatedOn();
-       return sess;
-
-     } finally {
-       releaseSharedLock();
-     }
-   }
-
-   public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
-     acquireExclusiveLock();
-     try {
-       final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
-       sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
-       return id;
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public OHttpSession removeSession(final String iSessionId) {
-     acquireExclusiveLock();
-     try {
-       return sessions.remove(iSessionId);
-
-     } finally {
-       releaseExclusiveLock();
-     }
-   }
-
-   public int getExpirationTime() {
-     return expirationTime;
-   }
-
-   public void setExpirationTime(int expirationTime) {
-     this.expirationTime = expirationTime;
-   }
-
-   public static OHttpSessionManager getInstance() {
-     return instance;
-   }
- }
+ * Handles the HTTP sessions such as a real HTTP Server.
+ *
+ * @author Luca Garulli
+ */
+public class OHttpSessionManager extends OSharedResourceAbstract {
+  private static final OHttpSessionManager instance = new OHttpSessionManager();
+  private Map<String, OHttpSession>        sessions = new HashMap<String, OHttpSession>();
+  private int                              expirationTime;
+  private Random                           random   = new SecureRandom();
+
+  protected OHttpSessionManager() {
+    expirationTime = OGlobalConfiguration.NETWORK_HTTP_SESSION_EXPIRE_TIMEOUT.getValueAsInteger() * 1000;
+
+    Orient.instance().scheduleTask(new TimerTask() {
+      @Override
+      public void run() {
+        final int expired = checkSessionsValidity();
+        if (expired > 0)
+          OLogManager.instance().debug(this, ""Removed %d session because expired"", expired);
+      }
+    }, expirationTime, expirationTime);
+  }
+
+  public int checkSessionsValidity() {
+    int expired = 0;
+
+    acquireExclusiveLock();
+    try {
+      final long now = System.currentTimeMillis();
+
+      Entry<String, OHttpSession> s;
+      for (Iterator<Map.Entry<String, OHttpSession>> it = sessions.entrySet().iterator(); it.hasNext();) {
+        s = it.next();
+
+        if (now - s.getValue().getUpdatedOn() > expirationTime) {
+          // REMOVE THE SESSION
+          it.remove();
+          expired++;
+        }
+      }
+
+    } finally {
+      releaseExclusiveLock();
+    }
+
+    return expired;
+  }
+
+  public OHttpSession[] getSessions() {
+    acquireSharedLock();
+    try {
+
+      return (OHttpSession[]) sessions.values().toArray(new OHttpSession[sessions.size()]);
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public OHttpSession getSession(final String iId) {
+    acquireSharedLock();
+    try {
+
+      final OHttpSession sess = sessions.get(iId);
+      if (sess != null)
+        sess.updateLastUpdatedOn();
+      return sess;
+
+    } finally {
+      releaseSharedLock();
+    }
+  }
+
+  public String createSession(final String iDatabaseName, final String iUserName, final String iUserPassword) {
+    acquireExclusiveLock();
+    try {
+      final String id = ""OS"" + System.currentTimeMillis() + random.nextLong();
+      sessions.put(id, new OHttpSession(id, iDatabaseName, iUserName, iUserPassword));
+      return id;
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public OHttpSession removeSession(final String iSessionId) {
+    acquireExclusiveLock();
+    try {
+      return sessions.remove(iSessionId);
+
+    } finally {
+      releaseExclusiveLock();
+    }
+  }
+
+  public int getExpirationTime() {
+    return expirationTime;
+  }
+
+  public void setExpirationTime(int expirationTime) {
+    this.expirationTime = expirationTime;
+  }
+
+  public static OHttpSessionManager getInstance() {
+    return instance;
+  }
+}",Adopted SecureRandom to avoid predicable random numbers in session,"vuln-fix: Use secure random for HTTP session ID generation

The HTTP session manager used a predictable pseudo-random number generator for session ID creation, making session identifiers guessable by attackers.
This weakness allowed attackers to potentially hijack user sessions by predicting or brute forcing valid session IDs, compromising user authentication and data.
The fix replaces the insecure Random instance with SecureRandom to generate cryptographically strong, unpredictable session identifiers.

Weakness: CWE-330
Severity: High
CVSS: 7.5",0.058823529411764705,"[('securerandom', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('secure', 'SECWORD', ''), ('session identifiers', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('weakness', 'FLAW', ''), ('attackers', 'FLAW', ''), ('hijack', 'SECWORD', ''), ('session ids', 'SECWORD', ''), ('authentication', 'secword', ''), ('fix', 'ACTION', ''), ('insecure', 'secword', ''), ('securerandom', 'SECWORD', ''), ('cryptographically', 'SECWORD', ''), ('session identifiers', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-330', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,CWE-20,GHSA-jjcx-999m-35hc,"@@ -60,6 +60,9 @@ public function configureJob(array $data): MessageBag
         $config['fints_password']  = (string)(Crypt::encrypt($data['fints_password']) ?? '');
         $config['apply-rules']     = 1 === (int)$data['apply_rules'];
 
+        // sanitize FinTS URL.
+        $config['fints_url'] = $this->validURI($config['fints_url']) ? $config['fints_url'] : '';
+
         $this->repository->setConfiguration($this->importJob, $config);
 
 
@@ -108,4 +111,21 @@ public function setImportJob(ImportJob $importJob): void
         $this->repository->setUser($importJob->user);
     }
 
+    /**
+     * @param string $fints_url
+     *
+     * @return bool
+     */
+    private function validURI(string $fintsUri): bool
+    {
+        $res = filter_var($fintsUri, FILTER_VALIDATE_URL);
+        if (false === $res) {
+            return false;
+        }
+        $scheme = parse_url($fintsUri, PHP_URL_SCHEME);
+
+        return 'https' === $scheme;
+    }
+
+
 }",Fix #2367,"vuln-fix: Enforce HTTPS validation on FinTS URL configuration

The application accepted arbitrary URLs for the FinTS service without validating their format or scheme, allowing insecure or malicious URLs to be stored.
This posed a security risk by enabling attackers to inject non-HTTPS URLs, potentially leading to man-in-the-middle attacks or data interception during financial transactions.
The fix adds strict validation to ensure only valid HTTPS URLs are accepted, sanitizing the configuration to reject insecure or malformed inputs.

Weakness: CWE-601
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('#2367', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('insecure', 'SECWORD', ''), ('malicious', 'secword', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('inject', 'secword', ''), ('man-in-the-middle', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('sanitizing', 'secword', ''), ('insecure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-601', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,CWE-20,GHSA-8687-vv9j-hgph,"@@ -27,6 +27,12 @@ module.exports = function cast(schema, obj, options, context) {
     throw new Error('Query filter must be an object, got an array ', util.inspect(obj));
   }
 
+  // bson 1.x has the unfortunate tendency to remove filters that have a top-level
+  // `_bsontype` property. Should remove this when we upgrade to bson 4.x. See gh-8222
+  if (obj.hasOwnProperty('_bsontype')) {
+    delete obj._bsontype;
+  }
+
   const paths = Object.keys(obj);
   let i = paths.length;
   let _keys;","fix(query): delete top-level `_bsontype` property in queries to prevent silent empty queries

Fix #8222","vuln-fix: Remove _bsontype property to prevent query filter tampering

The query filter processing did not remove the top-level _bsontype property, which bson 1.x treats specially and can cause unintended filter manipulation.
This allowed attackers to craft queries that bypass intended filtering logic, potentially leading to unauthorized data access or injection attacks.
The fix deletes the _bsontype property from query filters before processing, preventing bson from altering or ignoring critical filter criteria.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix(query', 'ACTION', ''), ('prevent', 'ACTION', ''), ('fix', 'ACTION', ''), ('#8222', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('prevent', 'ACTION', ''), ('tampering', 'secword', ''), ('remove', 'ACTION', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('critical', 'SEVERITY', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,CWE-20,GHSA-xrp2-fhq4-4q3w,"@@ -50,6 +50,15 @@ struct HistogramFixedWidthFunctor<CPUDevice, T, Tout> {
                         static_cast<double>(nbins);
     const double nbins_minus_1 = static_cast<double>(nbins - 1);
 
+    // We cannot handle NANs in the algorithm below (due to the case to int32)
+    const Eigen::Tensor<int32, 1, 1> nans_tensor =
+        values.isnan().template cast<int32>();
+    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();
+    const int num_nans = reduced_tensor(0);
+    if (num_nans > 0) {
+      return errors::InvalidArgument(""Histogram values must not contain NaN"");
+    }
+
     // The calculation is done by finding the slot of each value in `values`.
     // With [a, b]:
     //   step = (b - a) / nbins
@@ -98,12 +107,12 @@ class HistogramFixedWidthOp : public OpKernel {
     const auto nbins = nbins_tensor.scalar<int32>()();
 
     OP_REQUIRES(
-        ctx, (value_range(0) < value_range(1)),
+        ctx, value_range(0) < value_range(1),
         errors::InvalidArgument(""value_range should satisfy value_range[0] < ""
                                 ""value_range[1], but got '["",
                                 value_range(0), "", "", value_range(1), ""]'""));
     OP_REQUIRES(
-        ctx, (nbins > 0),
+        ctx, nbins > 0,
         errors::InvalidArgument(""nbins should be a positive number, but got '"",
                                 nbins, ""'""));","Prevent crash when histogram is called with NaN values.

Fixes #45770

PiperOrigin-RevId: 443149951","vuln-fix: Reject NaN values in histogram input to prevent invalid computation

The histogram operation did not check for NaN values in input tensors, causing undefined behavior during bin assignment and potential downstream errors.
This allowed attackers to supply NaNs that could lead to incorrect results or trigger crashes due to invalid numeric conversions in the algorithm.
The fix adds explicit detection and rejection of NaN inputs with a clear error message before any computation proceeds.

Weakness: CWE-682
Severity: Medium
CVSS: 4.3",0.17647058823529413,"[('prevent', 'ACTION', ''), ('fixes', 'ACTION', ''), ('#45770', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-682', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
30,"CWE-918', 'CWE-20",GHSA-2h63-qp69-fwvw,"@@ -847,8 +847,10 @@ private Element parseXml(String xmlString) {
         Document doc = null;
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         try {
-            javax.xml.parsers.DocumentBuilder parser = factory
-                    .newDocumentBuilder();
+            factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
+            factory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
+            factory.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+            javax.xml.parsers.DocumentBuilder parser = factory.newDocumentBuilder();
             parser.setErrorHandler(new ErrorHandler() {
                 public void error(SAXParseException exception)
                         throws SAXException {","BATIK-1284: Dont load DTDs in NodePickerPanel

git-svn-id: https://svn.apache.org/repos/asf/xmlgraphics/batik/trunk@1878396 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Disable external entity processing in XML parser

The XML parser allowed processing of external entities and DTDs, enabling XML External Entity (XXE) attacks through crafted XML input.
This exposed the application to risks such as sensitive file disclosure, server-side request forgery, and denial of service by loading malicious external resources.
The fix disables external-general-entities, external-parameter-entities, and external DTD loading features to prevent external entity resolution during XML parsing.

Weakness: CWE-611
Severity: High
CVSS: 7.5",0.17647058823529413,"[('https://svn.apache.org/repos/asf/xmlgraphics/batik/trunk@1878396', 'URL', ''), ('ffa450edef68', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('external entity', 'SECWORD', ''), ('xml external entity', 'SECWORD', ''), ('xxe', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('sensitive', 'SECWORD', ''), ('disclosure', 'secword', ''), ('server-side request forgery', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('external entity', 'secword', ''), ('weakness', 'secword', ''), ('cwe-611', 'CWEID', ''), ('high', 'SEVERITY', '')]"
31,CWE-20,GHSA-h8pj-cxx2-jfg2,"@@ -484,7 +484,11 @@ def copy_with(self, **kwargs: typing.Any) -> ""URL"":
         #  \_/   \______________/\_________/ \_________/ \__/
         #   |           |            |            |        |
         # scheme     authority       path        query   fragment
-        return URL(self._uri_reference.copy_with(**kwargs).unsplit())
+        new_url = URL(self)
+        new_url._uri_reference = self._uri_reference.copy_with(**kwargs)
+        if new_url.is_absolute_url:
+            new_url._uri_reference = new_url._uri_reference.normalize()
+        return URL(new_url)
 
     def copy_set_param(self, key: str, value: typing.Any = None) -> ""URL"":
         return self.copy_with(params=self.params.set(key, value))",Patch `copy_with`,"vuln-fix: Normalize absolute URLs to prevent path traversal

The URL copy method did not normalize absolute URLs after modifications, allowing crafted inputs to retain unsafe path segments like "".."" that could lead to directory traversal.
This posed a security risk by enabling attackers to bypass access controls or access unintended resources through manipulated URL paths.
The fix normalizes the internal URI reference for absolute URLs after copying, ensuring path components are sanitized and traversal sequences are resolved.

Weakness: CWE-22
Severity: High
CVSS: 7.5",0.11764705882352941,"[('patch', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('path traversal', 'secword', ''), ('unsafe', 'secword', ''), ('..', 'VERSION', ''), ('directory traversal', 'secword', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('manipulated', 'ACTION', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('sanitized', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-22', 'CWEID', ''), ('high', 'SEVERITY', '')]"
32,CWE-200,GHSA-qpv2-jxc7-3638,"@@ -1,6 +1,6 @@
 <?php
 
 return [
-    'sent'	        => 'Your password link has been sent!',
+    'sent'	        => 'Success: If that email address exists in our system, a password recovery email has been sent.',
     'user'			=> 'No matching active user found with that email.',
 ];","Updated language string

Signed-off-by: snipe <snipe@snipe.net>","vuln-fix: Prevent user enumeration via password reset messages

The password reset response revealed whether an email address was registered, allowing attackers to enumerate valid users by analyzing message differences.
This information disclosure risk enabled targeted attacks such as phishing or brute force by confirming active accounts in the system.
The fix standardizes the success message to avoid revealing user existence, providing a generic response regardless of email validity.

Weakness: CWE-200  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('updated', 'ACTION', ''), ('signed', 'secword', ''), ('snipe@snipe.net', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('user enumeration', 'SECWORD', ''), ('password', 'secword', ''), ('password', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('disclosure', 'secword', ''), ('attacks', 'FLAW', ''), ('phishing', 'secword', ''), ('fix', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,CWE-20,GHSA-xm9f-vxmx-4m58,"@@ -49,7 +49,7 @@ public function getResource($forWrite = false)
             $isError = false;
 
             $ioConfig = $this->getVars();
-            switch ($this->getVar('type', 'file')) {
+            switch (strtolower($this->getVar('type', 'file'))) {
                 case 'file':
                     //validate export/import path
                     $path = rtrim($ioConfig['path'], '\\/')","Merge pull request from GHSA-xm9f-vxmx-4m58

Co-authored-by: Mark Lewis <markwlewis@Marks-MacBook-Pro.local>","vuln-fix: Normalize type parameter to prevent case-sensitive bypass

The resource handler did not normalize the 'type' parameter before switch evaluation, allowing attackers to bypass intended case-sensitive checks.
This could lead to improper handling of resource types, potentially enabling unauthorized file operations or injection of unexpected input.
The fix converts the 'type' parameter to lowercase before the switch statement, ensuring consistent and secure type validation.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('ghsa', 'VULNID', 'GHSA'), ('markwlewis@marks-macbook-pro.local', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('bypass', 'secword', ''), ('sensitive', 'SECWORD', ''), ('improper handling', 'secword', ''), ('injection', 'secword', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
34,"CWE-325', 'CWE-200', 'CWE-502', 'CWE-20",GHSA-4h44-w6fm-548g,"@@ -14,10 +14,15 @@
 
 call_user_func(function() {
     $value = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('value');
-    $addition = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('addition');
     $scope = \TYPO3\CMS\Core\Utility\GeneralUtility::_GET('scope');
 
-    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, $addition);
+    if (!is_string($value) || empty($value)) {
+        \TYPO3\CMS\Core\Utility\HttpUtility::setResponseCodeAndExit(
+            \TYPO3\CMS\Core\Utility\HttpUtility::HTTP_STATUS_400
+        );
+    }
+
+    $content = \TYPO3\CMS\Core\Utility\GeneralUtility::hmac($value, 'flashvars');
 
     if ($scope === 'flashvars') {
         header('Content-type: application/x-www-form-urlencoded');","[SECURITY] Restrict file validation hash generation

Security-References: CVE-2020-15086","vuln-fix: Validate input and fix HMAC key usage in request handler

The code failed to validate the 'value' parameter from user input and incorrectly used a user-supplied 'addition' as the HMAC key, risking insecure hash generation.
This allowed attackers to cause errors or manipulate HMAC computations, potentially bypassing integrity checks or causing denial of service through invalid inputs.
The fix enforces that 'value' is a non-empty string and replaces the dynamic HMAC key with a fixed, constant string to ensure consistent and secure hashing.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('security', 'SECWORD', ''), ('hash', 'secword', ''), ('security', 'secword', ''), ('cve-2020-15086', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('fix', 'ACTION', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('validate', 'secword', ''), ('incorrectly used', 'SECWORD', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('insecure', 'secword', ''), ('hash', 'secword', ''), ('attackers', 'SECWORD', ''), ('errors', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('hmac', 'secword', ''), ('bypassing', 'SECWORD', ''), ('integrity', 'secword', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('hmac', 'secword', ''), ('key', 'SECWORD', ''), ('fixed', 'ACTION', ''), ('ensure', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
35,CWE-20,GHSA-832h-xg76-4gv6,"@@ -106,7 +106,7 @@ function expand(str, isTop) {
   var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
   var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
   var isSequence = isNumericSequence || isAlphaSequence;
-  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
+  var isOptions = m.body.indexOf(',') >= 0;
   if (!isSequence && !isOptions) {
     // {a},b}
     if (m.post.match(/,.*\}/)) {",fix bug in https://github.com/juliangruber/brace-expansion/issues/33,"vuln-fix: Fix inefficient options detection causing ReDoS risk

The original regex used to detect options in brace expansions was overly complex and could cause catastrophic backtracking on crafted input strings.
This vulnerability allowed attackers to trigger Regular Expression Denial of Service (ReDoS) by supplying inputs that cause exponential regex evaluation time.
The fix replaces the regex with a simple indexOf check for commas, eliminating backtracking and improving performance and security.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', ''), ('bug', 'FLAW', ''), ('https://github.com/juliangruber/brace-expansion/issues/33', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('denial of service', 'secword', ''), ('redos', 'SECWORD', ''), ('fix', 'ACTION', ''), ('improving', 'ACTION', ''), ('security', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
36,CWE-20,GHSA-qr2j-wrhx-4829,"@@ -119,6 +119,9 @@ func (api *PrivateDebugAPI) TraceChain(ctx context.Context, start, end rpc.Block
 	if to == nil {
 		return nil, fmt.Errorf(""end block #%d not found"", end)
 	}
+	if from.Number().Cmp(to.Number()) >= 0 {
+		return nil, fmt.Errorf(""end block (#%d) needs to come after start block (#%d)"", end, start)
+	}
 	return api.traceChain(ctx, from, to, config)
 }",eth: ensure from<to when tracing chain (credits Chen Nan via bugbounty),"vuln-fix: Validate block range order in TraceChain API

The TraceChain function did not verify that the end block number is greater than the start block number, allowing invalid or reversed block ranges.
This could lead to unexpected behavior or logic errors in blockchain tracing, potentially causing incorrect data processing or denial of service.
The fix adds a check to ensure the end block number is strictly greater than the start block number, returning an error if the order is invalid.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('ensure', 'ACTION', ''), ('bugbounty', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('logic errors', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
37,CWE-200,GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Method;
 import java.util.Set;
 import javax.el.BeanELResolver;
 import javax.el.ELContext;
@@ -111,7 +112,12 @@ private String transformPropertyName(Object property) {
   }
 
   private void checkRestrictedClass(Object o, Object method) {
-    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {
+    if (
+      o instanceof Class ||
+      o instanceof ClassLoader ||
+      o instanceof Thread ||
+      o instanceof Method
+    ) {
       throw new MethodNotFoundException(
         ""Cannot find method '"" + method + ""' in "" + o.getClass()
       );",add method to blacklist,"vuln-fix: Restrict reflective access to Method objects in EL resolver

The expression language resolver allowed reflective access to java.lang.reflect.Method instances, enabling attackers to invoke arbitrary methods via EL expressions.
This posed a critical security risk by permitting unauthorized code execution and potential privilege escalation through method invocation on sensitive classes.
The fix extends the restricted class check to include Method objects, blocking reflective method access and preventing exploitation.

Weakness: CWE-95
Severity: Critical
CVSS: 9.8",0.11764705882352941,"[('add', 'ACTION', ''), ('blacklist', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('java.lang.reflect.method', 'URL', ''), ('attackers', 'FLAW', ''), ('critical', 'SEVERITY', ''), ('security', 'secword', ''), ('code execution', 'SECWORD', ''), ('privilege escalation', 'secword', ''), ('sensitive', 'SECWORD', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('exploitation', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-95', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
38,"CWE-178', 'CWE-200",GHSA-24m3-w8g9-jwpq,"@@ -259,7 +259,7 @@ function ($val) {
             throw new Error\NotFound('The URL wasn\'t found in the module.');
         }
 
-        if (substr($path, -4) === '.php') {
+        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {
             // PHP file - attempt to run it
 
             /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that","Fix source code disclosure on case-insensitive file systems

If the file system containing the PHP code is case-insensitive, a
request containing an uppercase file extension will return the
contents of the PHP file to the browser instead of executing it.

E.g. a request for this URL will return the source code:

  https:/sp.example.org/simplesaml/module.php/core/frontpage_welcome.PHP

Fix that by converting the path to lowercase before checking the file
extension.

See the following page for details:

  https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq","vuln-fix: Normalize file extension check to prevent bypass

The code checked file extensions using a case-sensitive substring comparison, allowing attackers to bypass PHP file detection with uppercase or mixed-case extensions.
This could lead to execution of unintended files, increasing the risk of remote code execution or unauthorized script execution.
The fix applies a UTF-8 aware lowercase conversion before comparison, ensuring consistent and secure detection of "".php"" extensions regardless of case.

Weakness: CWE-179
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('disclosure', 'secword', ''), ('https:/sp.example.org', 'URL', ''), ('module.php', 'URL', ''), ('frontpage_welcome.php', 'URL', ''), ('fix', 'ACTION', ''), ('https://github.com/simplesamlphp/simplesamlphp/security/advisories/ghsa-24m3-w8g9-jwpq', 'VULNID', 'GHSA')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('bypass', 'secword', ''), ('remote code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('secure', 'secword', ''), ('weakness', 'secword', ''), ('cwe-179', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
39,CWE-200,GHSA-f2rp-4rv7-fc95,"@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 
-attributes :url, :user, :password, :ssl_verify_peer, :ssl_certs, :renew
+attributes :url, :user, :ssl_verify_peer, :ssl_certs, :renew",Fix clean API result,"vuln-fix: Remove password attribute to prevent accidental exposure

The code included a password attribute that could be inadvertently serialized or logged, risking exposure of sensitive credentials.
This posed a security risk by potentially leaking passwords through logs, API responses, or debugging output accessible to unauthorized users.
The fix removes the password attribute from the exposed attributes list, preventing accidental disclosure of sensitive authentication data.

Weakness: CWE-200
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('password', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('password', 'SECWORD', ''), ('serialized', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('security', 'secword', ''), ('passwords', 'SECWORD', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('password', 'secword', ''), ('preventing', 'ACTION', ''), ('disclosure', 'secword', ''), ('sensitive', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('high', 'SEVERITY', '')]"
40,CWE-20,GHSA-v82p-hv3v-p6qp,"@@ -57,6 +57,20 @@ class MklRequantizationRangePerChannelOp : public OpKernel {
         ctx, input_max.dim_size(0) == depth,
         errors::InvalidArgument(""input_max has incorrect size, expected "",
                                 depth, "" was "", input_max.dim_size(0)));
+    OP_REQUIRES(
+        ctx, input_min.NumElements() == depth,
+        errors::InvalidArgument(""input_min must have the same number of ""
+                                ""elements as input_max, got "",
+                                input_min.NumElements(), "" and "", depth));
+    OP_REQUIRES(ctx, input.NumElements() > 0,
+                errors::InvalidArgument(""input must not be empty""));
+    OP_REQUIRES(ctx, input.dims() == 4,
+                errors::InvalidArgument(""input must be in NHWC format""));
+    OP_REQUIRES(
+        ctx, input.dim_size(3) == depth,
+        errors::InvalidArgument(
+            ""input must have same number of channels as length of input_min: "",
+            input.dim_size(3), "" vs "", depth));
 
     const float* input_min_data = input_min.flat<float>().data();
     const float* input_max_data = input_max.flat<float>().data();","Add more validation to `RequantizationRangePerChannel`.

PiperOrigin-RevId: 387693946
Change-Id: Ife8dcbdb021bec4787eef6a4361dd08f17c14bd6","vuln-fix: Add input validation to prevent invalid tensor shapes

The operator lacked comprehensive validation of input tensor dimensions and element counts, allowing malformed tensors to be processed without error.
This could lead to out-of-bounds memory access or undefined behavior during computation, risking crashes or data corruption in the system.
The fix enforces strict checks on input tensor shape, element count, and channel dimensions to ensure consistency and prevent invalid memory operations.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ife8dcbdb021bec4787eef6a4361dd08f17c14bd6', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('input validation', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('error', 'FLAW', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
41,CWE-20,GHSA-pm9p-9926-w68m,"@@ -52,9 +52,21 @@ var ecstatic = module.exports = function (dir, options) {
   return function middleware (req, res, next) {
 
     // Strip any null bytes from the url
+    // This was at one point necessary because of an old bug in url.parse
+    //
+    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
+    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
+    //
+    // But this opens up a regex dos attack vector! D:
+    //
+    // Based on some research (ie asking #node-dev if this is still an issue),
+    // it's *probably* not an issue. :)
+    /*
     while(req.url.indexOf('%00') !== -1) {
       req.url = req.url.replace(/\%00/g, '');
     }
+    */
+
     // Figure out the path for the file from the given url
     var parsed = url.parse(req.url);
     try {","Remove stripping of null bytes

This was at one point necessary because of an old bug in url.parse

See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4

But this opens up a regex dos attack vector! D:

Based on some research (ie asking #node-dev if this is still an issue),
it's *probably* not an issue. :)","vuln-fix: Remove null byte stripping to prevent ReDoS attack

The middleware previously stripped null bytes from URLs using a loop with a global regex replace, which could be exploited to cause excessive CPU usage.
This introduced a Regular Expression Denial of Service (ReDoS) vulnerability by allowing attackers to craft URLs that trigger catastrophic backtracking in the regex engine.
The fix disables the null byte stripping code, as it is no longer necessary, thereby eliminating the ReDoS attack vector.

Weakness: CWE-400
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('remove', 'ACTION', ''), ('bug', 'FLAW', ''), ('url.parse', 'URL', ''), ('https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914', 'URL', ''), ('https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4', 'URL', ''), ('dos', 'SECWORD', ''), ('attack vector', 'secword', ''), ('issue', 'FLAW', ''), ('issue', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('prevent', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attack', 'secword', ''), ('exploited', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('redos', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('redos', 'SECWORD', ''), ('attack vector', 'secword', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
42,"CWE-400', 'CWE-20",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate ragged_rank against pylist nesting depth

The function failed to verify that the specified ragged_rank does not exceed the maximum nesting depth of the input pylist.
This could lead to inconsistent internal state or runtime errors when processing ragged tensors, potentially causing crashes or data corruption.
The fix adds a check to raise an error if ragged_rank is greater than the pylist’s maximum depth, ensuring input consistency and preventing invalid tensor construction.

Weakness: CWE-835
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('prevent', 'ACTION', ''), ('denial of service', 'secword', ''), ('tf.ragged.constant', 'URL', ''), ('fixes', 'ACTION', ''), ('#55199', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('errors', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-835', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
43,CWE-20,GHSA-j259-6c58-9m58,"@@ -545,10 +545,11 @@ PostgreSQL.prototype.buildExpression = function(columnName, operator,
       return new ParameterizedSQL(columnName + regexOperator,
         [operatorValue.source]);
     case 'contains':
-      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map((v) => `'${v}'`) + ']::'
-        + propertyDefinition.postgresql.dataType);
+      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map(() => '?') + ']::'
+        + propertyDefinition.postgresql.dataType,
+        operatorValue);
     case 'match':
-      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery('${operatorValue}')`);
+      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery(?)`, [operatorValue]);
     default:
       // invoke the base implementation of `buildExpression`
       return this.invokeSuper('buildExpression', columnName, operator,","fix: improve filter sanitisation

Add sanitisation of user-input for `contains` LoopBack filter which may allow for arbitrary SQL injection.

Signed-off-by: Rifa Achrinza <25147899+achrinza@users.noreply.github.com>","vuln-fix: Use parameterized queries to prevent SQL injection

The database query builder directly interpolated user input into SQL strings without proper escaping, enabling injection of malicious SQL code.
This allowed attackers to manipulate queries, potentially exposing or corrupting sensitive data through unauthorized database commands.
The fix replaces string interpolation with parameterized queries, safely binding user inputs as query parameters to prevent injection attacks.

Weakness: CWE-89
Severity: Critical
CVSS: 9.8",0.23529411764705882,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('sanitisation', 'SECWORD', ''), ('add', 'ACTION', ''), ('sanitisation', 'SECWORD', ''), ('sql injection', 'SECWORD', ''), ('signed', 'secword', ''), ('25147899+achrinza@users.noreply.github.com', 'EMAIL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('sql injection', 'secword', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('sensitive data', 'SECWORD', ''), ('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'secword', ''), ('attacks', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-89', 'CWEID', ''), ('critical', 'SEVERITY', '')]"
44,"CWE-200', 'CWE-668",GHSA-hm3x-jwwf-jpr9,"@@ -163,7 +163,7 @@ outputs:
             ironic::api::authtoken::user_domain_name: 'Default'
             ironic::api::authtoken::project_domain_name: 'Default'
             ironic::api::authtoken::username: 'ironic'
-            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
+            ironic::api::authtoken::www_authenticate_uri: {get_param: [EndpointMap, KeystonePublic, uri_no_suffix]}
             ironic::api::authtoken::auth_url: {get_param: [EndpointMap, KeystoneInternal, uri_no_suffix]}
             ironic::api::authtoken::region_name: {get_param: KeystoneRegion}
             ironic::api::authtoken::interface: 'internal'","Fix remaining usage of internal url for www_authenticate_uri

This is follow-up of 160936df134a471cfd245bd60964046027a571ea and fixes
remaining usage of internal endpoint url for [keystone_authtoken]
www_authenticate_uri.

Related-Bug: #1955397
Change-Id: Ib2ee7295c7fcda276e4fcf011a9e427e041f4848","vuln-fix: Use public Keystone URI for WWW-Authenticate header

The authentication configuration incorrectly used the internal Keystone URI for the WWW-Authenticate header, exposing internal endpoints to external clients.
This misconfiguration risked leaking sensitive internal service URLs, which could aid attackers in reconnaissance or unauthorized access attempts.
The fix changes the URI to the public Keystone endpoint, ensuring external clients receive only appropriate public authentication URLs.

Weakness: CWE-200
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('160936df134a471cfd245bd60964046027a571ea', 'SHA', ''), ('fixes', 'ACTION', ''), ('keystone_authtoken', 'SECWORD', ''), ('bug', 'FLAW', ''), ('#1955397', 'ISSUE', ''), ('change', 'ACTION', ''), ('ib2ee7295c7fcda276e4fcf011a9e427e041f4848', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('public keystone', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('incorrectly used', 'SECWORD', ''), ('keystone', 'SECWORD', ''), ('misconfiguration', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('public keystone', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
45,CWE-200,GHSA-wh98-p28r-vrc9,"@@ -58,7 +58,7 @@ def self.reload!
       prepare!
     end
 
-    def self.run! # :nodoc:
+    def self.run!(reset: false) # :nodoc:
       if check!
         super
       else","Fix reloader to work with new Executor signature

This is a follow up to [CVE-2022-23633].","vuln-fix: Add reset parameter to control run! method execution

The run! method lacked a parameter to control its execution flow, potentially causing unintended repeated operations without explicit reset control.
This could lead to inconsistent system states or resource exhaustion if the method was invoked multiple times without proper reset handling.
The patch introduces a reset parameter to the run! method, enabling callers to explicitly manage execution resets and prevent unintended repeated runs.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('cve-2022-23633', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('patch', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
46,CWE-200,GHSA-cv3f-px9r-54hm,"@@ -721,7 +721,6 @@ class Spawner {
 		prepareChroot(info, options);
 		info.userSwitching = prepareUserSwitching(options);
 		prepareSwitchingWorkingDirectory(info, options);
-		inferApplicationInfo(info);
 		return info;
 	}
 
@@ -775,6 +774,7 @@ class Spawner {
 		assert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);
 	}
 
+#ifdef false
 	void inferApplicationInfo(SpawnPreparationInfo &info) const {
 		info.codeRevision = readFromRevisionFile(info);
 		if (info.codeRevision.empty()) {
@@ -817,6 +817,7 @@ class Spawner {
 			return string();
 		}
 	}
+#endif
 
 	bool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {
 		if (options.loadShellEnvvars) {",Disable unused feature.,"vuln-fix: Disable insecure application info inference in spawner

The spawner component included a function that inferred application information from potentially untrusted files without proper validation.
This could allow attackers to manipulate application metadata, leading to incorrect execution contexts or privilege escalation risks.
The fix disables the insecure inference function by removing its invocation and enclosing its definition in a disabled preprocessor block.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('insecure', 'SECWORD', ''), ('untrusted', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('manipulate', 'ACTION', ''), ('privilege escalation', 'secword', ''), ('fix', 'ACTION', ''), ('insecure', 'secword', ''), ('removing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
47,"CWE-1321', 'CWE-20",GHSA-g6ww-v8xp-vmwg,"@@ -76,6 +76,9 @@ function parsePath(path) {
   var str = path.replace(/([^\\])\[/g, '$1.[');
   var parts = str.match(/(\\\.|[^.]+?)+/g);
   return parts.map(function mapMatches(value) {
+    if (value === ""constructor"" || value === ""__proto__"" || value === ""prototype"") {
+      return {}
+    }
     var regexp = /^\[(\d+)\]$/;
     var mArr = regexp.exec(value);
     var parsed = null;",fix: 🐛 fix prototype pollution,"vuln-fix: Prevent prototype pollution in path parsing function

The parsePath function allowed special keys like ""constructor"", ""__proto__"", and ""prototype"" to be processed, enabling prototype pollution attacks.
This vulnerability could let attackers manipulate object prototypes, leading to arbitrary code execution or denial of service through corrupted application state.
The fix blocks these dangerous keys by returning empty objects, preventing them from modifying the prototype chain during path parsing.

Weakness: CWE-471
Severity: High
CVSS: 7.8",0.11764705882352941,"[('fix', 'ACTION', ''), ('fix', 'ACTION', ''), ('prototype pollution', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('prototype pollution', 'secword', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'secword', ''), ('attackers', 'FLAW', ''), ('manipulate', 'ACTION', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-471', 'CWEID', ''), ('high', 'SEVERITY', '')]"
48,"CWE-191', 'CWE-20",GHSA-hx9q-2mx4-m4pg,"@@ -94,8 +94,10 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
-    OP_REQUIRES(context, num_segments > 0,
-                errors::InvalidArgument(""Number of segments must be positive""));
+    OP_REQUIRES(
+        context, num_segments >= 0,
+        errors::InvalidArgument(
+            ""Number of segments must be non-negative but got "", num_segments));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Allow 0 for number of segments in `unsorted_segment_join_op.cc`

Related to the fix for #55305

PiperOrigin-RevId: 443157549","vuln-fix: Allow zero segments in unsorted segment join operation

The operation incorrectly rejected zero as a valid number of segments, limiting input flexibility and causing unnecessary failures on legitimate edge cases.
This could lead to denial of service or application errors when users legitimately specify zero segments, disrupting workflows or data processing.
The fix relaxes the validation to accept zero or more segments, ensuring correct handling of empty segment scenarios without errors.

Weakness: CWE-703
Severity: Low
CVSS: 3.3",0.17647058823529413,"[('unsorted_segment_join_op.cc', 'URL', ''), ('fix', 'ACTION', ''), ('#55305', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('errors', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('low', 'SEVERITY', '')]"
49,CWE-200,GHSA-hxf9-7h4c-f5jv,"@@ -3,6 +3,7 @@
 
 import six
 from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic import View
@@ -41,8 +42,13 @@ def __init__(self, **kwargs):
     def validate_request(self, request):
         """"""If configured for webhook basic auth, validate request has correct auth.""""""
         if self.basic_auth:
-            basic_auth = get_request_basic_auth(request)
-            if basic_auth is None or basic_auth not in self.basic_auth:
+            request_auth = get_request_basic_auth(request)
+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()
+            # can terminate early: we're not trying to protect how many auth strings are allowed,
+            # just the contents of each individual auth string.)
+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)
+                          for allowed_auth in self.basic_auth)
+            if not auth_ok:
                 # noinspection PyUnresolvedReferences
                 raise AnymailWebhookValidationFailure(
                     ""Missing or invalid basic auth in Anymail %s webhook"" % self.esp_name)
@@ -78,8 +84,11 @@ def validate_request(self, request):
         *All* definitions of this method in the class chain (including mixins)
         will be called. There is no need to chain to the superclass.
         (See self.run_validators and collect_all_methods.)
+
+        Security note: use django.utils.crypto.constant_time_compare for string
+        comparisons, to avoid exposing your validation to a timing attack.
         """"""
-        # if request.POST['signature'] != expected_signature:
+        # if not constant_time_compare(request.POST['signature'], expected_signature):
         #     raise AnymailWebhookValidationFailure(""...message..."")
         # (else just do nothing)
         pass","Security: prevent timing attack on WEBHOOK_AUTHORIZATION secret

Anymail's webhook validation was vulnerable to a timing attack.
An attacker could have used this to recover your WEBHOOK_AUTHORIZATION
shared secret, potentially allowing them to post fabricated or malicious
email tracking events to your app.

There have not been any reports of attempted exploit in the wild. (The
vulnerability was discovered through code review.) Attempts would be
visible in http logs as a very large number of 400 responses on
Anymail's webhook urls, or in Python error monitoring as a very large
number of AnymailWebhookValidationFailure exceptions.

If you are using Anymail's webhooks, you should upgrade to this release.
In addition, you may want to rotate to a new WEBHOOK_AUTHORIZATION
secret ([docs](http://anymail.readthedocs.io/en/stable/tips/securing_webhooks/#use-a-shared-authorization-secret)),
particularly if your logs indicate attempted exploit.

(cherry picked from commit db586ede1fbb41dce21310ea28ae15a1cf1286c5)","vuln-fix: Use constant-time comparison for basic auth validation

The webhook handler compared basic authentication strings using standard equality, exposing it to timing attacks that could reveal valid credentials by measuring response times.
This vulnerability allowed attackers to incrementally guess authentication tokens, potentially bypassing security and gaining unauthorized webhook access.
The fix replaces direct string comparisons with Django’s constant_time_compare function to ensure uniform comparison time and prevent timing side-channel leaks.

Weakness: CWE-208
Severity: High
CVSS: 7.1",0.11764705882352941,"[('security', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('attack', 'SECWORD', ''), ('vulnerable', 'SECWORD', ''), ('attack', 'FLAW', ''), ('attacker', 'SECWORD', ''), ('malicious', 'secword', ''), ('exploit', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('error', 'FLAW', ''), ('upgrade', 'ACTION', ''), ('docs](http://anymail.readthedocs.io', 'URL', ''), ('exploit', 'SECWORD', ''), ('db586ede1fbb41dce21310ea28ae15a1cf1286c5', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('auth', 'secword', ''), ('authentication', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('vulnerability', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('authentication', 'secword', ''), ('bypassing', 'SECWORD', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('string comparisons', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-208', 'CWEID', ''), ('high', 'SEVERITY', '')]"
50,CWE-20,GHSA-8948-ffc6-jg52,"@@ -252,6 +252,11 @@ ReverseProxy.prototype.setupHttpsProxy = function (proxy, websocketsUpgrade, log
     key: getCertData(sslOpts.key),
     cert: getCertData(sslOpts.cert)
   };
+  
+  // Allows the option to disable older SSL/TLS versions
+  if(sslOpts.secureOptions) {
+    ssl.secureOptions = sslOpts.secureOptions;
+  }
 
   if (sslOpts.ca) {
     ssl.ca = getCertData(sslOpts.ca, true);","Adding option to disable older SSL/TLS versions

Simply pass in ""secureOptions"" as you normally would to an https config object, and redbird will pass it along into the https proxy server.","vuln-fix: Enable disabling of insecure SSL/TLS protocol versions

The HTTPS proxy setup did not allow disabling older, insecure SSL/TLS protocol versions, potentially permitting use of deprecated protocols.
This exposed connections to downgrade attacks and cryptographic weaknesses inherent in legacy SSL/TLS versions, risking data interception or tampering.
The patch adds support for passing secureOptions to explicitly disable insecure protocol versions, enhancing transport layer security.

Weakness: CWE-310
Severity: High
CVSS: 7.5",0.17647058823529413,"[('adding', 'ACTION', ''), ('ssl', 'secword', ''), ('tls', 'secword', ''), ('secureoptions', 'SECWORD', ''), ('https proxy', 'SECWORD', ''), ('server', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('insecure', 'secword', ''), ('ssl', 'secword', ''), ('tls', 'SECWORD', ''), ('protocol', 'secword', ''), ('https proxy', 'SECWORD', ''), ('insecure', 'secword', ''), ('ssl', 'secword', ''), ('tls', 'SECWORD', ''), ('protocol', 'secword', ''), ('protocols', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('cryptographic', 'SECWORD', ''), ('weaknesses', 'FLAW', ''), ('ssl', 'secword', ''), ('tls', 'SECWORD', ''), ('tampering', 'secword', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('secureoptions', 'SECWORD', ''), ('insecure', 'SECWORD', ''), ('protocol', 'secword', ''), ('transport', 'secword', ''), ('security', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-310', 'CWEID', ''), ('high', 'SEVERITY', '')]"
51,"CWE-475', 'CWE-20",GHSA-5wpj-c6f7-24x8,"@@ -304,6 +304,9 @@ Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,
     const Tensor* tensor;
     // TODO(fishx): Avoid blocking here.
     TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));
+    if (tensor->NumElements() == 0) {
+      return errors::InvalidArgument(""Empty resource handle"");
+    }
     const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);
     device_name = handle.device();","Fix empty resource handle vulnerability.

Some ops that attempt to extract a resource handle from user input
can lead to nullptr dereferences.  This returns an error in such
a case.

PiperOrigin-RevId: 445571938","vuln-fix: Reject empty tensors in resource handle retrieval

The function failed to check for empty tensors before accessing elements, allowing invalid dereferencing of tensor data with zero elements.
This could lead to out-of-bounds memory access or crashes when processing resource handles, potentially destabilizing the system or exposing memory.
The fix adds a check to detect empty tensors and returns an error early, preventing invalid memory access during resource handle extraction.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('vulnerability', 'secword', ''), ('nullptr', 'SECWORD', ''), ('error', 'FLAW', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
52,CWE-20,GHSA-qfpc-5pjr-mh26,"@@ -2990,6 +2990,10 @@ REGISTER_OP(""Dequantize"")
       if (!s.ok() && s.code() != error::NOT_FOUND) {
         return s;
       }
+      if (axis < -1) {
+        return errors::InvalidArgument(""axis should be at least -1, got "",
+                                       axis);
+      }
       const int minmax_rank = (axis == -1) ? 0 : 1;
       TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
       ShapeHandle minmax;","Fix a shape inference issue leading to nullptr deref.

PiperOrigin-RevId: 387712259
Change-Id: I7e670772b259c068a501a187cd89f18773bb95a1","vuln-fix: Validate axis parameter to prevent invalid input errors

The Dequantize operation lacked validation for the axis parameter, allowing values less than -1 to be processed without error.
This could lead to undefined behavior or crashes due to invalid tensor shape inference, potentially causing denial of service or memory corruption.
The fix adds a check to reject axis values below -1, ensuring only valid inputs proceed to shape inference.

Weakness: CWE-20
Severity: Medium
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i7e670772b259c068a501a187cd89f18773bb95a1', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('error', 'FLAW', ''), ('denial of service', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
53,CWE-200,GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import com.hubspot.jinjava.interpret.JinjavaInterpreter;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -136,7 +137,8 @@ protected boolean isRestrictedClass(Object o) {
       o instanceof Thread ||
       o instanceof Method ||
       o instanceof Field ||
-      o instanceof Constructor
+      o instanceof Constructor ||
+      o instanceof JinjavaInterpreter
     );
   }
 }",Add interpreter to blacklist,"vuln-fix: Restrict JinjavaInterpreter class access in security checks

The security check method failed to restrict access to the JinjavaInterpreter class, allowing potential unauthorized reflection or manipulation of template interpreter internals.
This omission could enable attackers to exploit the interpreter state or execute arbitrary code by bypassing class-based security restrictions.
The fix adds JinjavaInterpreter to the restricted classes list, preventing its exposure through reflection or unsafe object access.

Weakness: CWE-502
Severity: High
CVSS: 7.8",0.11764705882352941,"[('add', 'ACTION', ''), ('blacklist', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('exploit', 'secword', ''), ('bypassing', 'SECWORD', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-502', 'CWEID', ''), ('high', 'SEVERITY', '')]"
54,CWE-20,GHSA-gxg6-rc6c-v673,"@@ -118,6 +118,10 @@ interface from JDK1.2 VM...
 	*/
 	class Handler implements InvocationHandler
 	{
+		private Object readResolve() throws ObjectStreamException {
+			throw new NotSerializableException();
+		}
+
 		public Object invoke( Object proxy, Method method, Object[] args )
 			throws Throwable
 		{",Prevent deserialization of Handler,"vuln-fix: Prevent deserialization of dynamic proxy handler

The Handler class allowed Java deserialization to reconstruct proxy handler instances without restriction, enabling potential injection of malicious objects.
This posed a security risk by allowing attackers to exploit unsafe deserialization, leading to remote code execution or denial of service through crafted serialized data.
The fix adds a readResolve method that throws NotSerializableException, blocking deserialization of the handler and preventing unsafe object reconstruction.

Weakness: CWE-502
Severity: High
CVSS: 7.8",0.11764705882352941,"[('prevent', 'ACTION', ''), ('deserialization', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('deserialization', 'SECWORD', ''), ('deserialization', 'secword', ''), ('injection', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'FLAW', ''), ('exploit', 'SECWORD', ''), ('unsafe', 'SECWORD', ''), ('deserialization', 'secword', ''), ('remote code execution', 'secword', ''), ('denial of service', 'secword', ''), ('serialized', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('notserializableexception', 'SECWORD', ''), ('deserialization', 'secword', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-502', 'CWEID', ''), ('high', 'SEVERITY', '')]"
55,CWE-20,GHSA-m648-33qf-v3gp,"@@ -1468,7 +1468,9 @@ class CudnnRnnSequenceTensorDescriptor
   static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();
@@ -1486,7 +1488,9 @@ class CudnnRnnSequenceTensorDescriptor
       GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,
       const absl::Span<const int>& seq_lengths, bool time_major,
       cudnnDataType_t data_type) {
-    CHECK_GT(max_seq_length, 0);
+    if (max_seq_length <= 0) {
+      return port::Status(port::error::INVALID_ARGUMENT, ""max_seq_length <= 0"");
+    }
     int dims[] = {batch_size, data_size, 1};
     int strides[] = {dims[1] * dims[2], dims[2], 1};
     TensorDescriptor tensor_desc = CreateTensorDescriptor();","Prevent CHECK-fail in LSTM/GRU with zero-length input.

PiperOrigin-RevId: 346239181
Change-Id: I5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f","vuln-fix: Validate max_seq_length to prevent invalid tensor descriptor creation

The code did not validate that max_seq_length was greater than zero before creating tensor descriptors, allowing invalid or zero-length sequences.
This could lead to undefined behavior or memory corruption when downstream code assumes valid positive sequence lengths for GPU operations.
The fix adds explicit checks returning errors if max_seq_length is zero or negative, preventing creation of invalid tensor descriptors.

Weakness: CWE-704
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('prevent', 'ACTION', ''), ('change', 'ACTION', ''), ('i5f233dbc076aab7bb4e31ba24f5abd4eaf99ea4f', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('validate', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('errors', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
56,CWE-209,GHSA-hm37-9xh2-q499,"@@ -236,7 +236,8 @@ def read_fixed_bytes(self, num_bytes: int) -> bytes:
         """"""
         read_bytes = self.read(num_bytes)
         if len(read_bytes) < num_bytes:
-            raise EOFError(read_bytes)
+            raise EOFError(""Fewer than 'num_bytes' bytes remaining in the ""
+                    ""underlying bytestream"")
         return read_bytes
 
     def read_pascal_bytes(self, string_length_size: int) -> bytes:",Changed an exception message to prevent possible disclosures of keying material.,"vuln-fix: Improve error handling for incomplete byte reads

The byte stream reader raised EOFError with raw data when fewer bytes than requested were available, exposing internal data in error messages.
This risked leaking sensitive or partial data through exception outputs, potentially aiding attackers in information disclosure.
The fix replaces raw data in the exception with a generic error message that does not reveal underlying byte content.

Weakness: CWE-209
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('changed', 'ACTION', ''), ('prevent', 'ACTION', ''), ('keying', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('improve', 'ACTION', ''), ('error handling', 'SECWORD', ''), ('eoferror', 'FLAW', ''), ('error', 'FLAW', ''), ('sensitive', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-209', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
57,CWE-20,GHSA-f522-ffg8-j8r6,"@@ -11,4 +11,4 @@ exports['alpha'] = /^[a-zA-Z]+$/
 exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
 exports['style'] = /\s*(.+?):\s*([^;]+);?/g
 exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
-exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/
+exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/",fix utc-millisec regex to avoid a ddos attack,"vuln-fix: Restrict utc-millisec regex to prevent excessive input length

The utc-millisec regular expression allowed arbitrarily long digit sequences, enabling attackers to supply excessively large inputs that could degrade performance.
This exposed the system to potential denial-of-service attacks through resource exhaustion caused by processing overly long numeric strings.
The fix limits the integer and fractional parts to a maximum of 15 digits each, preventing excessive input length and reducing processing overhead.

Weakness: CWE-400  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('ddos', 'secword', ''), ('attack', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('attackers', 'SECWORD', ''), ('denial-of-service', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-400', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
58,"CWE-434', 'CWE-20",GHSA-5gjh-5j4f-cpwv,"@@ -16,6 +16,7 @@ import (
 	""strings""
 	""time""
 
+	""github.com/pkg/errors""
 	gouuid ""github.com/satori/go.uuid""
 	""github.com/unknwon/com""
 
@@ -23,9 +24,10 @@ import (
 
 	""gogs.io/gogs/internal/conf""
 	""gogs.io/gogs/internal/cryptoutil""
-	""gogs.io/gogs/internal/db/errors""
+	dberrors ""gogs.io/gogs/internal/db/errors""
 	""gogs.io/gogs/internal/gitutil""
 	""gogs.io/gogs/internal/osutil""
+	""gogs.io/gogs/internal/pathutil""
 	""gogs.io/gogs/internal/process""
 	""gogs.io/gogs/internal/tool""
 )
@@ -134,7 +136,7 @@ func (repo *Repository) UpdateRepoFile(doer *User, opts UpdateRepoFileOptions) (
 	if opts.OldBranch != opts.NewBranch {
 		// Directly return error if new branch already exists in the server
 		if git.RepoHasBranch(repoPath, opts.NewBranch) {
-			return errors.BranchAlreadyExists{Name: opts.NewBranch}
+			return dberrors.BranchAlreadyExists{Name: opts.NewBranch}
 		}
 
 		// Otherwise, delete branch from local copy in case out of sync
@@ -449,11 +451,16 @@ func isRepositoryGitPath(path string) bool {
 	return strings.HasSuffix(path, "".git"") || strings.Contains(path, "".git""+string(os.PathSeparator))
 }
 
-func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) (err error) {
+func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {
 	if len(opts.Files) == 0 {
 		return nil
 	}
 
+	// Prevent uploading files into the "".git"" directory
+	if isRepositoryGitPath(opts.TreePath) {
+		return errors.Errorf(""bad tree path %q"", opts.TreePath)
+	}
+
 	uploads, err := GetUploadsByUUIDs(opts.Files)
 	if err != nil {
 		return fmt.Errorf(""get uploads by UUIDs[%v]: %v"", opts.Files, err)
@@ -487,7 +494,9 @@ func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions)
 			continue
 		}
 
-		// Prevent copying files into .git directory, see https://gogs.io/gogs/issues/5558.
+		upload.Name = pathutil.Clean(upload.Name)
+
+		// Prevent uploading files into the "".git"" directory
 		if isRepositoryGitPath(upload.Name) {
 			continue
 		}",repo_editor: check upload `TreePath` and file name (#6838),"vuln-fix: Prevent uploading files into .git directory in repository

The file upload functionality allowed files to be placed inside the repository’s .git directory, bypassing intended path restrictions.
This posed a security risk by enabling attackers to overwrite or corrupt Git metadata, potentially leading to repository compromise or arbitrary code execution.
The fix adds explicit checks to reject uploads targeting paths within the .git directory, ensuring repository integrity is maintained.

Weakness: CWE-22
Severity: High
CVSS: 7.5",0.058823529411764705,"[('#6838', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('bypassing', 'SECWORD', ''), ('security', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('integrity', 'secword', ''), ('weakness', 'secword', ''), ('cwe-22', 'CWEID', ''), ('high', 'SEVERITY', '')]"
59,CWE-20,GHSA-f7f4-hqp2-7prc,"@@ -106,7 +106,10 @@ module.exports = function ToReceiveIncomingSailsIOMsg(app) {
 
       url     : options.incomingSailsIOMsg.url,
 
-      path    : url.parse(options.incomingSailsIOMsg.url).pathname,
+      path    : url.parse(options.incomingSailsIOMsg.url).pathname || '/',
+      // ^^ Uses || '/' because otherwise url.parse returns `null`,
+      // which is not a string and thus bad when you try to check
+      // .match() of it.
 
       method  : options.eventName,",Follow up to ff02114eaec090ee51db48435cc32d451662606e to ensure req.path is good and stringy.,"vuln-fix: Prevent null pathname causing runtime errors in URL parsing

The code failed to handle cases where url.parse returns a null pathname, leading to runtime errors when string methods like .match() were called on null values.
This caused potential application crashes or denial of service when processing malformed or unexpected URLs, impacting availability and stability.
The fix ensures a default '/' pathname is assigned when url.parse yields null, preventing invalid method calls on non-string values.

Weakness: CWE-682
Severity: Medium
CVSS: 5.0",0.058823529411764705,"[('ff02114eaec090ee51db48435cc32d451662606e', 'SHA', ''), ('ensure', 'ACTION', ''), ('req.path', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('errors', 'FLAW', ''), ('url.parse', 'URL', ''), ('errors', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('availability', 'secword', ''), ('fix', 'ACTION', ''), ('ensures', 'ACTION', ''), ('url.parse', 'URL', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-682', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
60,CWE-20,GHSA-x2mc-8fgj-3wmr,"@@ -261,7 +261,7 @@ exports.extract = function (cwd, opts) {
     var onlink = function () {
       if (win32) return next() // skip links on win for now before it can be tested
       xfs.unlink(name, function () {
-        var srcpath = path.resolve(cwd, header.linkname)
+        var srcpath = path.join(cwd, path.join('/', header.linkname))
 
         xfs.link(srcpath, name, function (err) {
           if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {",force hardlink targets to be in the tar,"vuln-fix: Prevent directory traversal in hardlink extraction

The extraction function resolved hardlink source paths using path.resolve, allowing crafted archive entries to escape the target directory via directory traversal.
This exposed the system to arbitrary file overwrite or link creation outside the intended extraction folder, risking privilege escalation or data corruption.
The fix replaces path resolution with a safe path join that anchors link targets within the extraction directory, preventing traversal outside the intended path.

Weakness: CWE-22
Severity: High
CVSS: 7.5",0.11764705882352941,[],0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('directory traversal', 'SECWORD', ''), ('path.resolve', 'URL', ''), ('escape', 'secword', ''), ('directory traversal', 'secword', ''), ('privilege escalation', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-22', 'CWEID', ''), ('high', 'SEVERITY', '')]"
61,"CWE-191', 'CWE-20",GHSA-hx9q-2mx4-m4pg,"@@ -94,6 +94,8 @@ class UnsortedSegmentJoinOp : public OpKernel {
                 errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
+    OP_REQUIRES(context, num_segments > 0,
+                errors::InvalidArgument(""Number of segments must be positive""));
     OP_REQUIRES(context, segment_dims != 0,
                 errors::InvalidArgument(""Segment_id cannot have rank 0""));","Validate `num_segments > 0` in `unsorted_segment_join`

Fixes #55305

PiperOrigin-RevId: 442047005","vuln-fix: Enforce positive number of segments in UnsortedSegmentJoinOp

The operation did not validate that the number of segments input was positive, allowing zero or negative values to proceed unchecked.
This could lead to undefined behavior or memory corruption during segment processing, potentially causing crashes or data integrity issues.
The fix adds a validation check that rejects non-positive segment counts with an appropriate error, preventing invalid inputs from causing downstream faults.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('validate', 'secword', ''), ('fixes', 'ACTION', ''), ('#55305', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('faults', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
62,CWE-209,GHSA-m884-279h-32v2,"@@ -20,15 +20,15 @@
                 <?php if ($exception['trace']) { ?>
                 <pre class=""stacktrace"">
 <?php
-                    echo $exception['class']."":\n"";
+                    echo $this->escape($exception['class'])."":\n"";
                     if ($exception['message']) {
-                        echo $exception['message'].""\n"";
+                        echo $this->escape($exception['message']).""\n"";
                     }
 
                     foreach ($exception['trace'] as $trace) {
                         echo ""\n  "";
                         if ($trace['function']) {
-                            echo 'at '.$trace['class'].$trace['type'].$trace['function'].'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
+                            echo $this->escape('at '.$trace['class'].$trace['type'].$trace['function']).'('.(isset($trace['args']) ? $this->formatArgsAsText($trace['args']) : '').')';
                         }
                         if ($trace['file'] && $trace['line']) {
                             echo($trace['function'] ? ""\n     ("" : 'at ').strtr(strip_tags($this->formatFile($trace['file'], $trace['line'])), [' at line '.$trace['line'] => '']).':'.$trace['line'].($trace['function'] ? ')' : '');",Escape variable in Exception Template,"vuln-fix: Escape exception output to prevent XSS in error pages

Exception class names, messages, and trace function details were output without escaping, allowing injection of malicious HTML or scripts in error pages.
This exposed users to cross-site scripting attacks where crafted exception data could execute arbitrary JavaScript in the browser context.
The fix applies proper escaping to all exception output fields before rendering, ensuring safe display of error information.

Weakness: CWE-79
Severity: High
CVSS: 7.4",0.11764705882352941,"[('escape', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('escape', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('xss', 'SECWORD', ''), ('error', 'FLAW', ''), ('escaping', 'SECWORD', ''), ('injection', 'secword', ''), ('malicious', 'secword', ''), ('error', 'FLAW', ''), ('cross-site scripting', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('escaping', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-79', 'CWEID', ''), ('high', 'SEVERITY', '')]"
63,"CWE-915', 'CWE-20",GHSA-f98m-q3hr-p5wq,"@@ -74,6 +74,10 @@ module.exports = function parse_str (str, array) { // eslint-disable-line camelc
     key = _fixStr(tmp[0])
     value = (tmp.length < 2) ? '' : _fixStr(tmp[1])
 
+    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
+      break;
+    }
+
     while (key.charAt(0) === ' ') {
       key = key.slice(1)
     }",fixed prototype pollution,"vuln-fix: Prevent prototype pollution in query string parsing

The parser did not block keys that could modify object prototypes, allowing attackers to inject properties like __proto__, constructor, or prototype.
This vulnerability enabled prototype pollution, which can lead to arbitrary code execution or denial of service by tampering with object behavior.
The fix adds a check to break parsing when dangerous prototype-related keys are detected, preventing prototype chain modification.

Weakness: CWE-1321
Severity: High
CVSS: 7.8",0.11764705882352941,"[('fixed', 'ACTION', ''), ('prototype pollution', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('prototype pollution', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('inject', 'secword', ''), ('vulnerability', 'secword', ''), ('prototype pollution', 'secword', ''), ('code execution', 'SECWORD', ''), ('denial of service', 'secword', ''), ('tampering', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('keys', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-1321', 'CWEID', ''), ('high', 'SEVERITY', '')]"
64,CWE-20,GHSA-278g-rq84-9hmg,"@@ -527,6 +527,8 @@ class MapStageOp : public OpKernel {
     OP_REQUIRES_OK(ctx, ctx->input(""key"", &key_tensor));
     OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices_tensor));
     OP_REQUIRES_OK(ctx, ctx->input_list(""values"", &values_tensor));
+    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,
+                errors::InvalidArgument(""key must not be empty""));
 
     // Create copy for insertion into Staging Area
     Tensor key(*key_tensor);","Prevent a CHECK-fail due to empty tensor input in `map_stage_op.cc`

PiperOrigin-RevId: 387737906
Change-Id: Idc52df0c71c7ed6e2dd633b651a581932f277c8a","vuln-fix: Reject empty keys in MapStageOp inputs

The MapStageOp kernel did not validate that the key tensor contained elements, allowing empty keys to be processed.
This could lead to undefined behavior or logic errors in downstream operations relying on non-empty keys, potentially causing crashes or data corruption.
The fix adds a check to ensure the key tensor is not empty, returning an error if this condition is violated.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('prevent', 'ACTION', ''), ('map_stage_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('idc52df0c71c7ed6e2dd633b651a581932f277c8a', 'SHA', '')]",0.47058823529411764,"[('fix', 'ACTION', ''), ('keys', 'SECWORD', ''), ('validate', 'secword', ''), ('key', 'secword', ''), ('keys', 'SECWORD', ''), ('logic errors', 'secword', ''), ('keys', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('key', 'secword', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
65,CWE-20,GHSA-j7c4-2xj8-wm7r,"@@ -61,6 +61,7 @@ def __str__(self):
 
 
 class Application:
+    MAX_LENGTH = 128 * 1024
     SOCKTYPES = {
         ""tcp"": socket.SOCK_STREAM,
         ""udp"": socket.SOCK_DGRAM,
@@ -180,7 +181,11 @@ def __call__(self, env, start_response):
             try:
                 length = int(env[""CONTENT_LENGTH""])
             except AttributeError:
-                length = -1
+                raise HTTPException(411, ""Length required."")
+            if length < 0:
+                raise HTTPException(411, ""Length required."")
+            if length > self.MAX_LENGTH:
+                raise HTTPException(413, ""Request entity too large."")
             try:
                 pr = codec.decode(env[""wsgi.input""].read(length))
             except codec.ParsingError as e:","Enforce a maximum packet length

Permanently fixes CVE-2015-5159 for all applications.","vuln-fix: Enforce content length limits to prevent oversized requests

The application did not properly validate the Content-Length header, allowing requests with missing or excessively large bodies to be processed.
This exposed the server to resource exhaustion and denial of service attacks by accepting arbitrarily large payloads that could overwhelm memory or processing capacity.
The fix enforces a required positive Content-Length and rejects requests exceeding a defined maximum size with appropriate HTTP error responses.

Weakness: CWE-770
Severity: High
CVSS: 7.5",0.23529411764705882,"[('fixes', 'ACTION', ''), ('cve-2015-5159', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('validate', 'secword', ''), ('server', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('fix', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-770', 'CWEID', ''), ('high', 'SEVERITY', '')]"
66,CWE-200,GHSA-37q6-576q-vgr7,"@@ -17,7 +17,17 @@ class HMRServer {
         this.server = https.createServer(await getCertificate(options.https));
       }
 
-      this.wss = new WebSocket.Server({server: this.server});
+      let websocketOptions = {
+        server: this.server
+      };
+
+      if (options.hmrHostname) {
+        websocketOptions.origin = `${options.https ? 'https' : 'http'}://${
+          options.hmrHostname
+        }`;
+      }
+
+      this.wss = new WebSocket.Server(websocketOptions);
       this.server.listen(options.hmrPort, resolve);
     });",fix security vuln (#1794),"vuln-fix: Restrict WebSocket origins to configured hostname

The WebSocket server accepted connections from any origin without restriction, allowing unauthorized cross-origin clients to establish WebSocket connections.
This exposed the server to cross-site WebSocket hijacking attacks, potentially leaking sensitive hot module replacement data to malicious origins.
The fix enforces origin checking by configuring the WebSocket server to accept connections only from the specified hostname, preventing unauthorized cross-origin access.

Weakness: CWE-942
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('security', 'SECWORD', ''), ('#1794', 'ISSUE', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('hostname', 'SECWORD', ''), ('server', 'SECWORD', ''), ('server', 'secword', ''), ('hijacking', 'SECWORD', ''), ('attacks', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('server', 'secword', ''), ('hostname', 'SECWORD', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-942', 'CWEID', ''), ('high', 'SEVERITY', '')]"
67,CWE-20,GHSA-c9g6-9335-x697,"@@ -45,9 +45,6 @@ fake_response = (req, res) ->
             try
                 res.write(r.join('\r\n'))
             catch x
-            try
-                res.end()
-            catch x
         res.setHeader = (k, v) -> headers[k] = v","Merge pull request #266 from cakoose/backport-writeHead-fix

writeHead: Don't end() response","vuln-fix: Remove unsafe nested error handling in response writing

The code contained nested try-catch blocks that attempted to call res.end() inside a catch, risking inconsistent response states on write failures.
This could lead to incomplete or corrupted HTTP responses, potentially exposing sensitive data or causing denial of service through improper error recovery.
The fix removes the inner try-catch and res.end() call to simplify error handling and avoid unsafe operations during response writes.

Weakness: CWE-703
Severity: Medium
CVSS: 5.0",0.17647058823529413,"[('#266', 'ISSUE', ''), ('fix', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('remove', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('error handling', 'SECWORD', ''), ('res.end', 'URL', ''), ('sensitive data', 'SECWORD', ''), ('denial of service', 'secword', ''), ('error', 'FLAW', ''), ('fix', 'ACTION', ''), ('removes', 'ACTION', ''), ('res.end', 'URL', ''), ('error handling', 'SECWORD', ''), ('unsafe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-703', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
68,CWE-20,GHSA-fv25-wrff-wf86,"@@ -98,6 +98,8 @@ class GetSessionTensorOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& handle = ctx->input(0);
+    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),
+                errors::InvalidArgument(""handle must be scalar""));
     const string& name = handle.scalar<tstring>()();
     Tensor val;
     auto session_state = ctx->session_state();","Fix tf.raw_ops.GetSessionTensor vulnerability with invalid handle.

Check that input is actually a scalar before treating it as such.

PiperOrigin-RevId: 445218701","vuln-fix: Enforce scalar tensor shape for session handle input

The Compute method did not verify that the input tensor handle was a scalar, allowing malformed tensors to be processed unexpectedly.
This could lead to out-of-bounds memory access or undefined behavior when non-scalar tensors are interpreted as scalar handles, risking memory corruption.
The fix adds a shape check that requires the handle tensor to be scalar, rejecting invalid inputs early to ensure safe tensor handling.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9",0.11764705882352941,"[('fix', 'ACTION', ''), ('tf.raw_ops.getsessiontensor', 'URL', ''), ('vulnerability', 'secword', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
69,CWE-20,GHSA-x9rg-q5fx-fx66,"@@ -124,7 +124,7 @@ public UnixUser authenticate(String username, String password) throws PAMExcepti
             check(libpam.pam_authenticate(pht,0),""pam_authenticate failed"");
             check(libpam.pam_setcred(pht,0),""pam_setcred failed"");
             // several different error code seem to be used to represent authentication failures
-//            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
+            check(libpam.pam_acct_mgmt(pht,0),""pam_acct_mgmt failed"");
 
             PointerByReference r = new PointerByReference();
             check(libpam.pam_get_item(pht,PAM_USER,r),""pam_get_item failed"");","call pam_acct_mgmt to verify whether the user account is valid.

This fixes issue #18 and thus CVE-2017-12197","vuln-fix: Enforce account management check in PAM authentication

The authentication flow previously skipped the pam_acct_mgmt call, omitting critical account status verification after password validation.
This allowed users with expired, disabled, or otherwise invalid accounts to authenticate successfully, bypassing intended access restrictions.
The fix reinstates the pam_acct_mgmt check to ensure account validity is confirmed before granting authentication.

Weakness: CWE-285
Severity: High
CVSS: 7.5",0.17647058823529413,"[('verify', 'ACTION', ''), ('user account', 'secword', ''), ('fixes', 'ACTION', ''), ('#18', 'ISSUE', ''), ('cve-2017-12197', 'VULNID', 'CVE')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('authentication', 'SECWORD', ''), ('critical', 'SEVERITY', ''), ('password', 'secword', ''), ('bypassing', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('authentication', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-285', 'CWEID', ''), ('high', 'SEVERITY', '')]"
70,CWE-20,GHSA-f7f6-xrwc-9c57,"@@ -588,7 +588,7 @@ THE SOFTWARE.
     <dependency>
       <groupId>commons-fileupload</groupId>
       <artifactId>commons-fileupload</artifactId>
-      <version>1.3.1-jenkins-1</version>
+      <version>1.3.1-jenkins-2</version> 
     </dependency>
 
     <!-- offline profiler API to put in the classpath if we need it -->",[SECURITY-490] Patch Commons File Upload 1.3.x.,"vuln-fix: Upgrade commons-fileupload to fix known vulnerabilities

The project used an outdated version of commons-fileupload with known security flaws that could be exploited via crafted file uploads.
This posed risks of arbitrary file write, remote code execution, or denial of service attacks through malicious multipart requests.
The fix updates the dependency to a patched version that addresses these vulnerabilities and improves overall file upload security.

Weakness: CWE-434
Severity: High
CVSS: 7.8",0.11764705882352941,"[('security-490', 'SECWORD', ''), ('patch', 'ACTION', ''), ('1.3.x', 'VERSION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('upgrade', 'ACTION', ''), ('fix', 'ACTION', ''), ('known vulnerabilities', 'secword', ''), ('security', 'SECWORD', ''), ('flaws', 'SECWORD', ''), ('exploited', 'SECWORD', ''), ('remote code execution', 'secword', ''), ('denial of service', 'secword', ''), ('attacks', 'SECWORD', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('updates', 'ACTION', ''), ('patched', 'ACTION', ''), ('vulnerabilities', 'SECWORD', ''), ('improves', 'ACTION', ''), ('security', 'secword', ''), ('weakness', 'secword', ''), ('cwe-434', 'CWEID', ''), ('high', 'SEVERITY', '')]"
71,"CWE-284', 'CWE-20",GHSA-23c7-6444-399m,"@@ -216,6 +216,10 @@ def kick(bot, trigger):
             return
         nick = Identifier(text[1])
         reason = ' '.join(text[2:])
+        if ',' in str(nick):
+            return bot.reply('Unable to kick. Kicking multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kick. Use of # when kicking is not expected.')
         if nick != bot.config.core.nick and trigger.account in chanops:
             bot.write(['KICK', trigger.sender, nick, ':' + reason])
             if dodeop:
@@ -263,6 +267,10 @@ def parse_host_mask(text):
 @example('.ban nick')
 def ban(bot, trigger):
     """"""Ban a user from the channel. The bot must be a channel operator for this command to work.""""""
+    if ',' in str(nick):
+        return bot.reply('Unable to ban. Banning multiple users is not allowed.') 
+    if '#' in str(nick):
+        return bot.reply('Unable to ban. Use of # when banning is not expected.')
     makemodechange(bot, trigger, '+b', isbqmode=True)
 
 
@@ -312,6 +320,10 @@ def kickban(bot, trigger):
                 deopbot(trigger.sender, bot)
             return
         nick = Identifier(text[1])
+        if ',' in str(nick):
+            return bot.reply('Unable to kickban. Kickbanning multiple users is not allowed.') 
+        if '#' in str(nick):
+            return bot.reply('Unable to kickban. Use of # when kickbanning is not expected.')
         mask = text[2] if any(s in text[2] for s in '!@*') else ''
         reasonidx = 3 if mask != '' else 2
         reason = ' '.join(text[reasonidx:])","Merge pull request from GHSA-23c7-6444-399m

* ban use of , & # when kicking

* Update __init__.py","vuln-fix: Restrict multi-user and channel symbol input in moderation commands

The kick, ban, and kickban commands allowed input containing commas or '#' symbols, enabling multiple user targeting or channel masks unexpectedly.
This posed a security risk by permitting abuse of moderation commands to affect multiple users or unintended targets, potentially disrupting channel operations.
The fix adds explicit checks rejecting inputs with commas or '#' symbols, ensuring only single user nicknames are accepted for these commands.

Weakness: CWE-285
Severity: Medium
CVSS: 5.0",0.23529411764705882,"[('ghsa-23c7', 'VULNID', 'GHSA'), ('update', 'ACTION', ''), ('init__.py', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('security', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-285', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
72,CWE-200,GHSA-rp7r-79rm-2758,"@@ -209,7 +209,7 @@ public int getMinorVersion() {
 	}
 
 	public boolean jdbcCompliant() {
-		return false;
+		return true;
 	}
 
 	/*","DERBY-561 - Embedded driver jdbcCompliant() method should return true
Test will be checked in as part of tess for DERBY-530



git-svn-id: https://svn.apache.org/repos/asf/db/derby/code/trunk@279860 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Declare JDBC compliance to prevent compatibility issues

The driver incorrectly reported non-compliance with JDBC standards by returning false in the jdbcCompliant method.
This misrepresentation could cause applications to disable important security features or fallback to less secure behaviors assuming the driver is non-compliant.
The fix changes the return value to true, accurately declaring JDBC compliance and ensuring proper security expectations and compatibility.

Weakness: CWE-693
Severity: Low
CVSS: 3.1",0.11764705882352941,"[('https://svn.apache.org/repos/asf/db/derby/code/trunk@279860', 'URL', ''), ('ffa450edef68', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('issues', 'FLAW', ''), ('misrepresentation', 'secword', ''), ('security', 'secword', ''), ('secure', 'SECWORD', ''), ('fix', 'ACTION', ''), ('changes', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('security', 'secword', ''), ('weakness', 'secword', ''), ('cwe-693', 'CWEID', ''), ('low', 'SEVERITY', '')]"
73,CWE-200,GHSA-wwgf-3xp7-cxj4,"new file mode 100644
@@ -0,0 +1,13 @@
+title:     Potentially sensitive data exposure
+link:      https://github.com/GeniusesOfSymfony/WebSocketBundle/security/advisories/GHSA-wwgf-3xp7-cxj4
+branches:
+    1.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['<1.10.4']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=2.0.0', '<2.6.1']
+    3.x:
+        time:       2020-07-06 14:08:35
+        versions:   ['>=3.0.0', '<3.3.0']
+reference: composer://gos/web-socket-bundle",Add gos/web-socket-bundle advisory,"vuln-fix: Add security advisory for sensitive data exposure

The WebSocketBundle contained a vulnerability that could lead to exposure of sensitive data through improperly secured WebSocket connections.
This posed a risk of unauthorized data disclosure, allowing attackers to intercept or access confidential information transmitted over the socket.
The fix documents the issue with a security advisory and specifies affected versions to inform users and prompt timely updates.

Weakness: CWE-200
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('security', 'SECWORD', ''), ('sensitive data exposure', 'SECWORD', ''), ('vulnerability', 'SECWORD', ''), ('sensitive data', 'secword', ''), ('secured', 'SECWORD', ''), ('disclosure', 'secword', ''), ('attackers', 'FLAW', ''), ('confidential', 'secword', ''), ('fix', 'ACTION', ''), ('issue', 'FLAW', ''), ('security', 'SECWORD', ''), ('updates', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-200', 'CWEID', ''), ('high', 'SEVERITY', '')]"
74,CWE-200,GHSA-m2q3-53fq-7h66,"@@ -176,6 +176,7 @@ def wiki_new
         fullname = params[:file][:filename]
         tempfile = params[:file][:tempfile]
       end
+      halt 500 unless tempfile.is_a? Tempfile
 
       # Remove page file dir prefix from upload path if necessary -- committer handles this itself
       dir      = wiki.per_page_uploads ? params[:upload_dest].match(/^(#{wiki.page_file_dir}\/+)?(.*)/)[2] : 'uploads'",Added security check.,"vuln-fix: Prevent file upload processing with invalid tempfile objects

The file upload handler did not verify that the uploaded file parameter was a valid Tempfile object before processing.
This allowed attackers to potentially cause server errors or unexpected behavior by submitting malformed or non-file inputs.
The fix adds a type check to halt processing with an error if the uploaded file is not a Tempfile instance, ensuring only valid uploads proceed.

Weakness: CWE-20
Severity: Medium
CVSS: 5.0",0.11764705882352941,"[('added', 'ACTION', ''), ('security', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('server', 'secword', ''), ('errors', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
75,"CWE-908', 'CWE-200",GHSA-3wcq-x3mq-6r9p,"@@ -78,7 +78,7 @@ name.decode.bytes = 0
 
 name.encodingLength = function (n) {
   if (n === '.') return 1
-  return Buffer.byteLength(n) + 2
+  return Buffer.byteLength(n.replace(/^\.|\.$/gm, '')) + 2
 }
 
 const string = {}",do trim on encodingLength as well,"vuln-fix: Prevent buffer length miscalculation from dot characters

The encodingLength function did not remove leading or trailing dots before calculating byte length, causing incorrect buffer size estimations.
This could lead to buffer overflows or memory corruption when encoding names with extraneous dots, risking application crashes or data corruption.
The fix strips leading and trailing dots from the input before measuring byte length, ensuring accurate buffer size calculation and safe memory allocation.

Weakness: CWE-119
Severity: High
CVSS: 7.8",0.11764705882352941,"[('encodinglength', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('encodinglength', 'SECWORD', ''), ('remove', 'ACTION', ''), ('buffer overflows', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('encoding', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
76,CWE-209,GHSA-4r65-35qq-ch8j,"@@ -38,10 +38,13 @@
 import uuid
 
 from functools import partial
+from ansible import constants as C
 from ansible.module_utils._text import to_bytes, to_text
 from ansible.module_utils.common.json import AnsibleJSONEncoder
+from ansible.module_utils.common.parameters import remove_values
 from ansible.module_utils.six import iteritems
 from ansible.module_utils.six.moves import cPickle
+from ansible.utils.helpers import deduplicate_list
 
 
 def write_to_file_descriptor(fd, obj):
@@ -163,12 +166,26 @@ def _exec_jsonrpc(self, name, *args, **kwargs):
         try:
             response = json.loads(out)
         except ValueError:
-            params = [repr(arg) for arg in args] + ['{0}={1!r}'.format(k, v) for k, v in iteritems(kwargs)]
+            sensitive_keys = list(
+                    C.MAGIC_VARIABLE_MAPPING[""password""]
+                    + C.MAGIC_VARIABLE_MAPPING[""private_key_file""]
+                    + C.MAGIC_VARIABLE_MAPPING[""become_pass""]
+            )
+            sensitive_values = [
+                v2 
+                for k, v in iteritems(kwargs) 
+                for k2, v2 in iteritems(v) 
+                if k2 in sensitive_keys
+            ]
+            params = [repr(remove_values(arg, sensitive_values)) for arg in args] + [
+                ""{0}={1!r}"".format(k, remove_values(v, sensitive_values)) 
+                for k, v in iteritems(kwargs)]
             params = ', '.join(params)
             raise ConnectionError(
                 ""Unable to decode JSON from response to {0}({1}). Received '{2}'."".format(name, params, out)
             )
 
+
         if response['id'] != reqid:
             raise ConnectionError('invalid json-rpc id received')
         if ""result_type"" in response:","Fixed exposed credentials in exception

Under certain conditions, sensitive connection parameters are shown in tracebacks when Ansible receives an unexpected response (in my case `None`) from `set_options` in ansible-connection. This patch creates a list of sensitive connection parameter names from `ansible.constants`, pulls a list of those values in the `params` that are about to be dumped to the screen and log file, and sends the `params` and list of `sensitive_values` to the `module_utils.common.parameters.remove_values` function for processing to hide them before being exposed.","vuln-fix: Mask sensitive data in JSON-RPC error logging

The JSON-RPC error handler logged full argument contents including sensitive credentials like passwords and private keys when JSON decoding failed.
This exposed confidential information in logs, risking credential leakage and unauthorized access if logs were accessed by attackers or insiders.
The fix filters out sensitive values from arguments before logging, ensuring that passwords and keys are redacted in error messages.

Weakness: CWE-532
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fixed', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('patch', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('ansible.constants', 'URL', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('sensitive data', 'SECWORD', ''), ('error', 'FLAW', ''), ('error handler', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('passwords', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('decoding', 'SECWORD', ''), ('confidential', 'secword', ''), ('credential', 'secword', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('sensitive', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('passwords', 'SECWORD', ''), ('keys', 'SECWORD', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-532', 'CWEID', ''), ('high', 'SEVERITY', '')]"
0,CWE-125,GHSA-j47f-4232-hvv8,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/fingerprint.h""
 #include ""tensorflow/core/util/util.h""
 #include ""tensorflow/core/util/work_sharder.h""
@@ -466,16 +467,45 @@ class RaggedCrossOp : public OpKernel {
     int next_dense = 0;
     for (char c : input_order_) {
       if (c == 'R') {
+        if (next_ragged >= ragged_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor value at index "",
+              next_ragged, "" from a list of "", ragged_values_list.size(),
+              "" values."");
+        if (next_ragged >= ragged_splits_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor split at index "",
+              next_ragged, "" from a list of "", ragged_splits_list.size(),
+              "" splits."");
         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
             features));
         next_ragged++;
       } else if (c == 'S') {
+        if (next_sparse >= sparse_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor value at index "",
+              next_sparse, "" from a list of "", sparse_values_list.size(),
+              "" values."");
+        if (next_sparse >= sparse_indices_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor index at index "",
+              next_sparse, "" from a list of "", sparse_indices_list.size(),
+              "" indices."");
         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
             batch_size, features));
         next_sparse++;
       } else if (c == 'D') {
+        if (next_dense >= dense_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a dense tensor at index "", next_dense,
+              "" from a list of "", dense_list.size(), "" tensors."");
         TF_RETURN_IF_ERROR(
             BuildDenseFeatureReader(dense_list[next_dense++], features));
       } else {","Fix out of bounds read in `ragged_cross_op.cc`.

PiperOrigin-RevId: 369757702
Change-Id: Ie6e5d2c21513a8d56bf41fcf35960caf76e890f9","vuln-fix: Add bounds checks for tensor input indices in RaggedCrossOp

The RaggedCrossOp kernel lacked validation for indices used to access ragged, sparse, and dense tensor input lists, risking out-of-bounds reads.
This could lead to crashes or memory corruption if malformed input caused the operator to read beyond allocated tensor arrays.
The fix adds explicit bounds checks with error returns before accessing input lists, preventing invalid memory access from out-of-range indices.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('out of bounds read', 'secword', ''), ('ragged_cross_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie6e5d2c21513a8d56bf41fcf35960caf76e890f9', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('out-of-range', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,CWE-125,GHSA-h9px-9vqg-222h,"@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include ""tensorflow/core/framework/op_requires.h""
 #define EIGEN_USE_THREADS
 
 #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \
@@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, axis_ < input.dims(),
+                errors::InvalidArgument(
+                    ""Axis requested is larger than input dimensions. Axis: "",
+                    axis_, "" Input Dimensions: "", input.dims()));
     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix `tf.raw_ops.QuantizeAndDequantizeV3` array index failure.

PiperOrigin-RevId: 370577691
Change-Id: Ifeae64212f6bcd139435824fa2748d1329213c4c","vuln-fix: Validate axis parameter against input tensor dimensions

The QuantizeAndDequantizeV3 operation did not verify that the axis parameter was within the bounds of the input tensor’s dimensions before use.
This allowed out-of-bounds access risks that could lead to crashes or undefined behavior when processing malformed inputs.
The fix adds a runtime check that rejects requests where the axis exceeds the input tensor’s dimensionality, preventing invalid memory access.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('ifeae64212f6bcd139435824fa2748d1329213c4c', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
2,CWE-125,GHSA-374m-jm66-3vj8,"@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel {
       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {
         const int64_t batch = indices_mat(i, 0);
         const Tidx bin = values(i);
+        OP_REQUIRES(
+            ctx, batch < out.dimension(0),
+            errors::InvalidArgument(""Index out of bound. `batch` ("", batch,
+                                    "") must be less than the dimension size ("",
+                                    out.dimension(0), "").""));
+        OP_REQUIRES(
+            ctx, bin < out.dimension(1),
+            errors::InvalidArgument(""Index out ouf bound. `bin` ("", bin,
+                                    "") must be less then the dimension size ("",
+                                    out.dimension(1), "").""));
         if (bin < size) {
           if (binary_output_) {
             out(batch, bin) = T(1);","Prevent out-of-bound accesses in SparseBincount.

PiperOrigin-RevId: 399918616
Change-Id: I11d154f4444d3fde1f09c5c40628b8671791a30d","vuln-fix: Add bounds checks to sparse bincount indices

The sparse bincount operation lacked validation of input indices against output tensor dimensions, allowing out-of-bounds indexing during accumulation.
This could lead to memory corruption or crashes by writing outside allocated buffers when processing malformed or malicious input data.
The fix adds explicit checks to ensure batch and bin indices are within valid output dimension ranges, preventing invalid memory access.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out-of-bound', 'SECWORD', ''), ('change', 'ACTION', ''), ('i11d154f4444d3fde1f09c5c40628b8671791a30d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('malicious', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,CWE-125,GHSA-9697-98pf-4rw7,"@@ -86,6 +86,10 @@ class UpperBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,
@@ -127,6 +131,10 @@ class LowerBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,","Prevent CHECK-fail/heap OOB in UpperBound and LowerBound

PiperOrigin-RevId: 387738073
Change-Id: Iee74de95ddad18440d052a75a5a1cb67544f490a","vuln-fix: Enforce minimum input rank in bound operations

The UpperBoundOp and LowerBoundOp kernels did not verify that input tensors had at least two dimensions before processing.
This allowed malformed inputs with insufficient rank to cause undefined behavior or crashes, potentially leading to denial of service or memory corruption.
The fix adds explicit checks to ensure input tensors are matrices or higher rank, rejecting invalid inputs early with clear error messages.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('iee74de95ddad18440d052a75a5a1cb67544f490a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
4,"CWE-787', 'CWE-125",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Add bounds checks to prevent out-of-bounds memory access

The FormatConverter code lacked sufficient bounds checking on array indices and traversal order accesses, risking out-of-bounds reads during sparse-to-dense conversion.
This could lead to memory corruption, crashes, or information disclosure by reading invalid memory locations when processing malformed or crafted input data.
The fix adds explicit boundary checks before indexing arrays and accessing traversal order elements to ensure all accesses remain within valid ranges.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,"CWE-476', 'CWE-787', 'CWE-125",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Enforce channel dimension consistency in batch norm inputs

The fused batch normalization operation lacked strict validation ensuring scale, offset, mean, and variance tensors matched the input channel dimension.
This allowed malformed inputs with mismatched tensor sizes to cause invalid memory access or corrupt computation results, risking crashes or incorrect model behavior.
The fix adds explicit checks that all parameter tensors have element counts equal to the input channels, rejecting invalid inputs early in execution.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
6,CWE-125,GHSA-cgfm-62j4-v4rf,"@@ -219,7 +219,20 @@ class SparseReduceOp : public OpKernel {
     sp.Reorder<T>(reduction.reorder_dims);
     for (const auto &g : sp.group(reduction.group_by_dims)) {
       Op::template Run<T>(ctx, reduced_val, g.template values<T>());
+      OP_REQUIRES(ctx,
+                  output_strides.empty() ||
+                  (g.group().size() == output_strides.size()),
+                  errors::Internal(
+                      ""Expected group size and output_strides size to match"",
+                      "", but got "", g.group().size(), "" and "",
+                      output_strides.size()));
       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);
+      OP_REQUIRES(ctx,
+                  idx >= 0 && idx < out_flat.size(),
+                  errors::Internal(
+                      ""Obtained a write index of "", idx,
+                      "" which is outside of bounds of [0, "",
+                      out_flat.size(), "")""));
       out_flat(idx) = reduced_val();
       VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")
               << ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""","Prevent heap OOB in sparse reduction ops.

PiperOrigin-RevId: 387934524
Change-Id: I894aa30f1e454f09b471d565b4a325da49322c1a","vuln-fix: Add bounds checks to prevent out-of-bounds writes in sparse reduce

The sparse reduce operation lacked validation of computed output indices, allowing out-of-bounds writes to the output tensor buffer.
This could lead to memory corruption, crashes, or potential arbitrary code execution if attackers control input shapes or indices.
The fix adds explicit checks ensuring group sizes match output strides and that computed indices are within valid output bounds before writing.

Weakness: CWE-787  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i894aa30f1e454f09b471d565b4a325da49322c1a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('out-of-bounds writes', 'SECWORD', ''), ('out-of-bounds writes', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('code execution', 'SECWORD', ''), ('attackers', 'FLAW', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-787', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,CWE-125,GHSA-q3g3-h9r4-prrc,"@@ -265,6 +265,11 @@ class SimpleBinaryOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     const Tensor& in0 = ctx->input(0);
     const Tensor& in1 = ctx->input(1);
+    OP_REQUIRES(
+        ctx, in0.NumElements() == in1.NumElements(),
+        errors::InvalidArgument(""The two arguments to a cwise op must have ""
+                                ""same number of elements, got "",
+                                in0.NumElements(), "" and "", in1.NumElements()));
     auto in0_flat = in0.flat<Tin>();
     auto in1_flat = in1.flat<Tin>();
     const Device& eigen_device = ctx->eigen_device<Device>();","Fix nullptr deref and heap OOB access in binary cwise ops.

PiperOrigin-RevId: 387936777
Change-Id: I608b8074cec36a982cca622b7144cb2c43e6e19f","vuln-fix: Enforce matching tensor sizes in element-wise operations

The element-wise binary operation did not verify that input tensors had the same number of elements before computation.
This allowed attackers to cause out-of-bounds memory access or undefined behavior by providing mismatched tensor sizes, risking crashes or data corruption.
The fix adds a runtime check that validates input tensor sizes are equal and returns an error if they differ, preventing unsafe operations.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('nullptr', 'SECWORD', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i608b8074cec36a982cca622b7144cb2c43e6e19f', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
8,CWE-125,GHSA-5hj3-vjjf-f5m7,"@@ -380,6 +380,11 @@ Status Examples::Initialize(OpKernelContext* const context,
   const Tensor* example_labels_t;
   TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
   auto example_labels = example_labels_t->flat<float>();
+  if (example_labels.size() != num_examples) {
+    return errors::InvalidArgument(""Expected "", num_examples,
+                                   "" example labels but got "",
+                                   example_labels.size());
+  }
 
   OpInputList dense_features_inputs;
   TF_RETURN_IF_ERROR(","Add remaining validation to `sdca_internal.cc`

PiperOrigin-RevId: 387738010
Change-Id: I28eedcfd87a53aaf34deb075acea1f8c95470808","vuln-fix: Validate example labels size to prevent out-of-bounds access

The code did not verify that the number of example labels matched the expected number of examples, risking out-of-bounds tensor access during processing.
This could lead to memory corruption or crashes if attackers supplied mismatched input sizes, potentially causing denial of service or data leakage.
The fix adds explicit size validation and returns an error if the example labels count does not match the expected number, preventing invalid memory access.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('add', 'ACTION', ''), ('sdca_internal.cc', 'URL', ''), ('change', 'ACTION', ''), ('i28eedcfd87a53aaf34deb075acea1f8c95470808', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('attackers', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
9,"CWE-787', 'CWE-125",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct loop index to prevent out-of-bounds access in type specialization

The code incorrectly used a fixed index instead of the loop variable when accessing elements, causing potential out-of-bounds memory access during type argument processing.
This flaw could lead to memory corruption or crashes if invalid indices are dereferenced, risking application stability and security.
The fix replaces the hardcoded index with the correct loop variable to ensure safe and accurate element access within bounds.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('incorrectly used', 'SECWORD', ''), ('fixed', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('memory corruption', 'secword', ''), ('security', 'SECWORD', ''), ('fix', 'ACTION', ''), ('hardcoded', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
10,CWE-125,GHSA-83rh-hx5x-q9p5,"@@ -101,10 +101,14 @@ bool HdrDecoder::readData(Mat& _img)
 
 bool HdrDecoder::checkSignature( const String& signature ) const
 {
-    if(signature.size() >= m_signature.size() &&
-       (!memcmp(signature.c_str(), m_signature.c_str(), m_signature.size()) ||
-       !memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())))
-       return true;
+    if (signature.size() >= m_signature.size() &&
+        0 == memcmp(signature.c_str(), m_signature.c_str(), m_signature.size())
+    )
+        return true;
+    if (signature.size() >= m_signature_alt.size() &&
+        0 == memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())
+    )
+        return true;
     return false;
 }",imgproc(hdr): fix bounds check in HdrDecoder::checkSignature(),"vuln-fix: Correct signature check to prevent buffer over-read

The signature verification logic combined two memcmp calls with an OR condition, causing potential out-of-bounds reads when signature length mismatched alternate signatures.
This could lead to reading memory beyond the buffer, risking crashes or information disclosure from invalid memory access.
The fix separates the checks to ensure each memcmp is only called if the signature length is sufficient for the compared signature, preventing buffer over-read.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3",0.058823529411764705,"[('fix', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('hdrdecoder::checksignature', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('prevent', 'ACTION', ''), ('buffer over-read', 'SECWORD', ''), ('signature', 'secword', ''), ('out-of-bounds reads', 'SECWORD', ''), ('signature', 'secword', ''), ('disclosure', 'secword', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('signature', 'secword', ''), ('signature', 'secword', ''), ('preventing', 'ACTION', ''), ('buffer over-read', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,CWE-125,GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stat_dim bounds in feature split calculation

The feature split calculation did not verify that stat_dim indices were within the valid range of stats dimensions, allowing out-of-bounds access.
This could lead to memory corruption or crashes by reading or writing beyond allocated tensor bounds during model training.
The fix adds explicit checks to ensure stat_dim is less than the total stats dimension size, preventing invalid memory access.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('tf.raw_ops.boostedtreessparsecalculatebestfeaturesplit', 'URL', ''), ('change', 'ACTION', ''), ('i83ca8a75b22aa78c037e8b98779da6cced16bfaa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,CWE-125,GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter against input tensor dimensions

The dequantization operation lacked validation to ensure the axis parameter was within the bounds of the input tensor’s dimensions.
This allowed attackers to trigger out-of-bounds access or crashes by specifying an invalid axis, potentially causing denial of service or memory corruption.
The fix adds a check that rejects requests where the axis is not less than the input tensor’s dimension count, preventing invalid memory indexing.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound access', 'secword', ''), ('adding', 'ACTION', ''), ('change', 'ACTION', ''), ('i3249d2a69ddc82f182c589a3a5bbfb71543f4b29', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('attackers', 'FLAW', ''), ('out-of-bounds', 'secword', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,CWE-125,GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate tensor element counts in dequantization op

The dequantization operation did not verify that input_min and input_max tensors matched the expected element count along the specified axis.
This allowed malformed inputs to cause out-of-bounds memory access or incorrect computations, risking crashes or data corruption during model execution.
The fix adds explicit checks to ensure these tensors have the correct number of elements, preventing invalid memory access and enforcing input consistency.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.23529411764705882,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('change', 'ACTION', ''), ('i135e94d360c2a1ce374c10f7e0fed1af603dbc02', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
14,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Add safe tensor access checks to prevent null pointer dereference

The code accessed input and output tensors without verifying their presence, risking null pointer dereferences if tensors were missing or invalid.
This could lead to crashes or undefined behavior, potentially exploitable to cause denial of service or memory corruption in the TensorFlow Lite runtime.
The fix replaces direct tensor retrieval calls with safe variants that return errors on failure, ensuring proper validation before use.

Weakness: CWE-476
Severity: High
CVSS: 7.5",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('null pointer dereference', 'SECWORD', ''), ('null pointer dereferences', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('safe', 'secword', ''), ('errors', 'FLAW', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-476', 'CWEID', ''), ('high', 'SEVERITY', '')]"
15,CWE-125,GHSA-545v-42p7-98fq,"@@ -1014,6 +1014,9 @@ struct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {
         const int input_start = start * input_size_per_batch;
         const int input_end = limit * input_size_per_batch;
         for (int64 index = input_start; index < input_end; index++) {
+          if (index >= argmax.NumElements()) {
+            break;
+          }
           int64 grad_out_index = argmax_flat(index);
           if (!include_batch_in_index) {
             const int64 cur_batch = index / input_size_per_batch;","Fix heap buffer overflow

PiperOrigin-RevId: 372132844
Change-Id: Idef9895efaf145f2b1c23d31983601ec980cd5e4","vuln-fix: Prevent out-of-bounds access in max pooling gradient

The gradient computation accessed the argmax tensor without verifying index bounds, risking out-of-bounds reads during backpropagation.
This could lead to memory corruption or crashes by reading invalid memory when input sizes or indices are inconsistent.
The fix adds a boundary check to ensure indices do not exceed the argmax tensor size, preventing invalid memory access.

Weakness: CWE-125
Severity: Medium
CVSS: 5.3",0.17647058823529413,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('idef9895efaf145f2b1c23d31983601ec980cd5e4', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
16,CWE-125,GHSA-4fg4-p75j-w5xj,"@@ -173,20 +173,50 @@ class QuantizedBatchNormOp : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
-    const float input_min = context->input(1).flat<float>()(0);
-    const float input_max = context->input(2).flat<float>()(0);
+    const auto& input_min_tensor = context->input(1);
+    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_min must have 1 element""));
+    const float input_min = input_min_tensor.flat<float>()(0);
+    const auto& input_max_tensor = context->input(2);
+    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_max must have 1 element""));
+    const float input_max = input_max_tensor.flat<float>()(0);
     const Tensor& mean = context->input(3);
-    const float mean_min = context->input(4).flat<float>()(0);
-    const float mean_max = context->input(5).flat<float>()(0);
+    const auto& mean_min_tensor = context->input(4);
+    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_min must have 1 element""));
+    const float mean_min = mean_min_tensor.flat<float>()(0);
+    const auto& mean_max_tensor = context->input(5);
+    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_max must have 1 element""));
+    const float mean_max = mean_max_tensor.flat<float>()(0);
     const Tensor& var = context->input(6);
-    const float var_min = context->input(7).flat<float>()(0);
-    const float var_max = context->input(8).flat<float>()(0);
+    const auto& var_min_tensor = context->input(7);
+    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_min must have 1 element""));
+    const float var_min = var_min_tensor.flat<float>()(0);
+    const auto& var_max_tensor = context->input(8);
+    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_max must have 1 element""));
+    const float var_max = var_max_tensor.flat<float>()(0);
     const Tensor& beta = context->input(9);
-    const float beta_min = context->input(10).flat<float>()(0);
-    const float beta_max = context->input(11).flat<float>()(0);
+    const auto& beta_min_tensor = context->input(10);
+    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_min must have 1 element""));
+    const float beta_min = beta_min_tensor.flat<float>()(0);
+    const auto& beta_max_tensor = context->input(11);
+    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_max must have 1 element""));
+    const float beta_max = beta_max_tensor.flat<float>()(0);
     const Tensor& gamma = context->input(12);
-    const float gamma_min = context->input(13).flat<float>()(0);
-    const float gamma_max = context->input(14).flat<float>()(0);
+    const auto& gamma_min_tensor = context->input(13);
+    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_min must have 1 element""));
+    const float gamma_min = gamma_min_tensor.flat<float>()(0);
+    const auto& gamma_max_tensor = context->input(14);
+    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_max must have 1 element""));
+    const float gamma_max = gamma_max_tensor.flat<float>()(0);
 
     OP_REQUIRES(context, input.dims() == 4,
                 errors::InvalidArgument(""input must be 4-dimensional"",
@@ -203,6 +233,33 @@ class QuantizedBatchNormOp : public OpKernel {
     OP_REQUIRES(context, gamma.dims() == 1,
                 errors::InvalidArgument(""gamma must be 1-dimensional"",
                                         gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value"",
+                                        gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value""));
+    const auto last_dim = input.shape().dims() - 1;
+    OP_REQUIRES(context,
+                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),
+                errors::InvalidArgument(""Must provide as many means as the ""
+                                        ""last dimension of the input tensor: "",
+                                        mean.shape().DebugString(), "" vs. "",
+                                        input.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == var.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and variance tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", var.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and beta tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", beta.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and gamma tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", gamma.shape().DebugString()));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Add missing validation in `QuantizedBatchNormWithGlobalNormalization`

PiperOrigin-RevId: 370123451
Change-Id: Id234d6dab1ec21230bb8e503dba30f899af87f33","vuln-fix: Validate tensor input sizes in quantized batch norm op

The QuantizedBatchNormOp did not verify that scalar inputs had exactly one element or that parameter tensors matched expected dimensions, risking invalid memory access.
This could lead to out-of-bounds reads or writes during computation, potentially causing crashes or exposing sensitive memory contents.
The fix adds explicit checks on tensor element counts and shape consistency, enforcing correct input sizes before proceeding with batch normalization.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('change', 'ACTION', ''), ('id234d6dab1ec21230bb8e503dba30f899af87f33', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('out-of-bounds reads', 'SECWORD', ''), ('sensitive', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
17,"CWE-908', 'CWE-125",GHSA-q263-fvxm-m5mw,"@@ -44,6 +44,7 @@ limitations under the License.
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
 #include ""tensorflow/core/lib/strings/scanner.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/logging.h""
 #include ""tensorflow/core/platform/macros.h""
 #include ""tensorflow/core/public/version.h""
@@ -1425,6 +1426,17 @@ void GraphConstructor::Undo() {
 
 Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,
                                   int input_index) {
+  if (output_index >= src->num_outputs()) {
+    return errors::InvalidArgument(
+        ""Output "", output_index, "" of node "", src->name(),
+        "" does not exist. Node only has "", src->num_outputs(), "" outputs."");
+  }
+  if (input_index >= dst->num_inputs()) {
+    return errors::InvalidArgument(
+        ""Input "", input_index, "" of node "", dst->name(),
+        "" does not exist. Node only has "", dst->num_inputs(), "" inputs."");
+  }
+
   DataType src_out = src->output_type(output_index);
   DataType dst_in = dst->input_type(input_index);
   if (!TypesCompatible(dst_in, src_out)) {","Prevent unitialized memory access in `GraphConstructor::MakeEdge`

The `MakeEdge` implementation assumes that there exists an output at `output_index` of `src` node and an input at `input_index` of `dst` node. However, if this is not the case this results in accessing data out of bounds. Because we are accessing an array that is a private member of a class and only in read only mode, this usually results only in unitialized memory access. However, it is reasonable to think that malicious users could manipulate these indexes to actually read data outside the class, thus resulting in information leakage and further exploits.

PiperOrigin-RevId: 346343288
Change-Id: I2127da27c2023d27f26efd39afa6c853385cab6f","vuln-fix: Validate node input and output indices in graph edges

The graph construction code did not verify that specified input and output indices were within valid ranges for nodes before creating edges.
This allowed attackers to trigger out-of-bounds accesses, potentially causing crashes or memory corruption by referencing non-existent node ports.
The fix adds explicit bounds checks on input and output indices, returning errors when indices exceed node capabilities to prevent invalid memory access.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out of bounds', 'SECWORD', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('information leakage', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('change', 'ACTION', ''), ('i2127da27c2023d27f26efd39afa6c853385cab6f', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('errors', 'FLAW', ''), ('prevent', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,CWE-125,GHSA-9c8h-vvrj-w2p8,"@@ -58,15 +58,21 @@ class RaggedGatherOpBase : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     // Get the input Tensors.
+
     OpInputList params_nested_splits_in;
     OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",
                                                 &params_nested_splits_in));
+    OP_REQUIRES(
+        context, params_nested_splits_in.size() > 0,
+        errors::InvalidArgument(""params_nested_splits must be non empty""));
+
     const Tensor& params_dense_values_in =
         context->input(params_nested_splits_in.size());
     const Tensor& indices_in =
         context->input(params_nested_splits_in.size() + 1);
 
-    DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, params_nested_splits_in[0].dims() > 0,
+                errors::InvalidArgument(""Split tensors must not be scalars""));
     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;
     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));","Fix heap OOB in `tf.raw_ops.RaggedGather`

PiperOrigin-RevId: 388355464
Change-Id: If14d96231d1cd7aad7c4d1c22c1bab1576b75717","vuln-fix: Validate input list and tensor dimensions in RaggedGatherOp

The operator failed to verify that the input list of nested splits was non-empty and that split tensors were not scalars before processing.
This allowed malformed inputs to cause invalid memory access or crashes due to unchecked assumptions about tensor shapes and sizes.
The fix adds explicit checks to ensure the input list is non-empty and that split tensors have valid dimensions, preventing unsafe operations on invalid inputs.

Weakness: CWE-20
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('tf.raw_ops.raggedgather', 'URL', ''), ('change', 'ACTION', ''), ('if14d96231d1cd7aad7c4d1c22c1bab1576b75717', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('high', 'SEVERITY', '')]"
19,CWE-125,GHSA-c545-c4f9-rf6v,"@@ -37,6 +37,7 @@ TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,
     axis = input_dims.size + 1 + axis;
   }
   TF_LITE_ENSURE(context, axis <= input_dims.size);
+  TF_LITE_ENSURE(context, axis >= 0);
 
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);
   for (int i = 0; i < output_dims->size; ++i) {","Prevent an OOB read in `expand_dims.cc`

The for loop that follows this check assumes that `axis` is between `0` and `input_dims.size`. If user supplied `axis` is negative, the if code before this check is supposed to bring it back to positive (similar to how in Python one can do `l[-3]` to mean `l[-3 + len(l)]`).

PiperOrigin-RevId: 387200206
Change-Id: I162f4feba12d547c3a4340833ae682016a2ebfab","vuln-fix: Validate axis parameter lower bound in tensor expansion

The tensor dimension expansion function lacked validation for negative axis values, allowing out-of-bounds access when axis was less than zero.
This could lead to memory corruption or crashes by indexing invalid tensor dimensions, potentially enabling denial of service or arbitrary code execution.
The fix adds a lower bound check to ensure the axis parameter is non-negative before proceeding with dimension expansion.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('expand_dims.cc', 'URL', ''), ('input_dims.size', 'URL', ''), ('change', 'ACTION', ''), ('i162f4feba12d547c3a4340833ae682016a2ebfab', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('code execution', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('bound check', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
20,CWE-125,GHSA-3h8m-483j-7xxm,"@@ -46,6 +46,10 @@ class RequantizationRangeOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,
+                errors::InvalidArgument(""Input min must not be empty.""));
+    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,
+                errors::InvalidArgument(""Input max must not be empty.""));
     const float input_min_float = ctx->input(1).flat<float>()(0);
     const float input_max_float = ctx->input(2).flat<float>()(0);
     Tensor* output_min = nullptr;","Fix out of bound read in requantization_range_op.cc

PiperOrigin-RevId: 372129031
Change-Id: Ie684ab98a3840c5186ead3eafffc0e0ed0e8030d","vuln-fix: Validate input tensors are non-empty before access

The computation did not verify that input tensors for min and max values contained elements before dereferencing, risking invalid memory access.
This allowed attackers to cause out-of-bounds reads or crashes by providing empty tensors, potentially leading to denial of service or memory corruption.
The fix adds explicit checks to ensure these input tensors have at least one element before accessing their contents.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.3",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound read', 'secword', ''), ('requantization_range_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie684ab98a3840c5186ead3eafffc0e0ed0e8030d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('attackers', 'FLAW', ''), ('out-of-bounds reads', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
21,CWE-125,GHSA-cvgx-3v3q-m36c,"@@ -2559,6 +2559,9 @@ Status QuantizeV2Shape(InferenceContext* c) {
   if (!s.ok() && s.code() != error::NOT_FOUND) {
     return s;
   }
+  if (axis < -1) {
+    return errors::InvalidArgument(""axis should be at least -1, got "", axis);
+  }
   const int minmax_rank = (axis == -1) ? 0 : 1;
   TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
   ShapeHandle minmax;","Prevent OOB access in QuantizeV2 shape inference

PiperOrigin-RevId: 400309614
Change-Id: I31412c71b05b4f21b677f7fa715a61499cbee39d","vuln-fix: Validate axis parameter to prevent invalid negative values

The QuantizeV2Shape function did not check if the axis parameter was less than -1, allowing invalid negative values to pass unchecked.
This could lead to unexpected behavior or crashes during shape inference, potentially causing denial of service or memory corruption.
The fix adds explicit validation to reject axis values below -1, ensuring only valid parameters proceed in computation.

Weakness: CWE-20  
Severity: Medium  
CVSS: 5.0",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i31412c71b05b4f21b677f7fa715a61499cbee39d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,CWE-125,GHSA-7fvx-3jfc-2cpc,"@@ -955,11 +955,12 @@ class ResourceScatterUpdateOp : public OpKernel {
                         params->dim_size(0), "")""));
       } else {
         int64_t num_updates = updates.NumElements();
-        OP_REQUIRES(c, num_updates % N == 0,
-                    errors::InvalidArgument(
-                        ""shape of indices ("", indices.shape().DebugString(),
-                        "") is not compatible with the shape of updates ("",
-                        updates.shape().DebugString(), "")""));
+        OP_REQUIRES(
+            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),
+            errors::InvalidArgument(
+                ""The shape of indices ("", indices.shape().DebugString(),
+                "") must be a prefix of the shape of updates ("",
+                updates.shape().DebugString(), "")""));
         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});
 
         functor::ScatterFunctor<Device, T, Index, op> functor;","Fix heap OOB due to dimension mismatch in `ResourceScatterUpdate`

PiperOrigin-RevId: 388292801
Change-Id: Id9bd7244d98d41b1517d4771850b32782c0cc949","vuln-fix: Enforce shape prefix constraint in scatter update op

The scatter update operation did not properly verify that the shape of indices is a prefix of the updates shape, allowing incompatible tensor shapes to proceed.
This could lead to out-of-bounds memory access or data corruption during tensor updates, risking crashes or incorrect computation results.
The fix replaces the modulo check with a strict prefix shape validation to ensure updates tensor shape correctly aligns with indices shape before processing.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('id9bd7244d98d41b1517d4771850b32782c0cc949', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('update', 'ACTION', ''), ('update', 'ACTION', ''), ('verify', 'ACTION', ''), ('updates', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('updates', 'ACTION', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('updates', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
23,CWE-125,GHSA-59q2-x2qc-4c97,"@@ -533,6 +533,17 @@ class UnicodeEncodeOp : public OpKernel {
     const Tensor& input_splits = context->input(1);
     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();
 
+    // Operation will treat first argument in input_splits as if it were zero
+    // regardless of its actual value since splits should begin with zero and
+    // end with the length of the input values vector.
+    OP_REQUIRES(
+        context, input_splits_flat(0) == 0,
+        errors::InvalidArgument(""First value in input_splits must be zero.""));
+    OP_REQUIRES(context,
+                input_splits_flat(input_splits_flat.size() - 1) ==
+                    input_tensor_flat.size(),
+                errors::InvalidArgument(""Last value in input_splits must be ""
+                                        ""equal to length of input_tensor.""));
     // Since we limit to a 2-D input (flat_values of rank 1 and a single splits
     // tensor), our output dimension will be 1 with it's size equal to the
     // number of splits (outer dimension or ragged tensor).
@@ -548,6 +559,14 @@ class UnicodeEncodeOp : public OpKernel {
     for (int i = 1; i < input_splits_flat.size(); ++i) {
       icu::UnicodeString unicode_string;
       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);
+      OP_REQUIRES(
+          context, input_splits_flat(i - 1) <= input_splits_flat(i),
+          errors::InvalidArgument(
+              ""Values in input_splits must be equal or in ascending order.""));
+      OP_REQUIRES(
+          context, input_splits_flat(i) <= input_tensor_flat.size(),
+          errors::InvalidArgument(""Values in input_splits must be less than or ""
+                                  ""equal to input_tensor length.""));
       for (; idx < input_splits_flat(i); ++idx) {
         int32 code_point = input_tensor_flat(idx);
         // Check for invalid code point","Fix heap buffer overflow in tf.raw_ops.UnicodeEncode.

PiperOrigin-RevId: 371717714
Change-Id: If33443b28f158e58078f1268f6b92f2728d219e0","vuln-fix: Validate input_splits boundaries and ordering in UnicodeEncodeOp

The UnicodeEncodeOp kernel lacked validation of the input_splits tensor, allowing malformed or out-of-order split indices to be processed without error.
This could lead to out-of-bounds memory access or corrupted string construction, potentially causing crashes or data leakage during Unicode encoding.
The fix adds explicit checks ensuring input_splits starts at zero, ends at the input length, and is non-decreasing with all values within valid bounds.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('tf.raw_ops.unicodeencode', 'URL', ''), ('change', 'ACTION', ''), ('if33443b28f158e58078f1268f6b92f2728d219e0', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('unicodeencodeop', 'SECWORD', ''), ('unicodeencodeop', 'SECWORD', ''), ('error', 'FLAW', ''), ('out-of-bounds', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,CWE-125,GHSA-jwf9-w5xm-f437,"@@ -123,6 +123,17 @@ TfLiteStatus GatherNdString(const TfLiteTensor* params,
 template <typename IndicesT>
 TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,
                           const TfLiteTensor* indices, TfLiteTensor* output) {
+  bool indices_has_only_positive_elements = true;
+  const auto* indices_values = GetTensorData<IndicesT>(indices);
+  const size_t num_indices = indices->bytes / sizeof(IndicesT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indices_values[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   switch (params->type) {
     case kTfLiteFloat32:
       return GatherNd<float, IndicesT>(params, indices, output);","Prevent heap OOB read in TFLite's `gather_nd.cc`.

Passing negative indices is illegal but there was a missing check so that resulted in OOB accesses.

PiperOrigin-RevId: 387208551
Change-Id: I6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd","vuln-fix: Validate indices to prevent negative indexing in GatherNd

The GatherNd operation did not verify that all indices were non-negative before accessing tensor elements, allowing out-of-bounds negative indexing.
This could lead to invalid memory reads or undefined behavior, potentially exposing sensitive data or causing crashes during model evaluation.
The fix adds a check to ensure all indices are positive, aborting evaluation early if negative values are detected to prevent unsafe memory access.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.23529411764705882,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('gather_nd.cc', 'URL', ''), ('missing check', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('sensitive data', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('prevent', 'ACTION', ''), ('unsafe', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Correct optional input tensor retrieval to prevent invalid access

The function incorrectly checked for optional tensors by comparing input indices against a sentinel, risking invalid tensor access or null dereference.
This flaw could lead to crashes or undefined behavior when processing nodes with optional inputs, potentially causing denial of service or memory corruption.
The fix replaces the conditional logic with a direct call to GetInput, ensuring consistent and safe retrieval of input tensors regardless of optional status.

Weakness: CWE-476
Severity: Medium
CVSS: 5.5",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('incorrectly checked', 'SECWORD', ''), ('null dereference', 'SECWORD', ''), ('flaw', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-476', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,"CWE-787', 'CWE-125",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Validate row partition size to prevent out-of-bounds access

The code did not verify that the row partition tensor size was consistent with the parent output index size before processing.
This could lead to out-of-bounds memory access or logic errors when the row partition size exceeded the output size, risking crashes or data corruption.
The fix adds a validation check that returns an error if the row partition size is greater than the output size, preventing invalid memory operations.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('logic errors', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
27,CWE-125,GHSA-2r8p-fg3c-wcj4,"@@ -660,6 +660,11 @@ class ResourceGatherOp : public OpKernel {
     OP_REQUIRES(
         c, TensorShapeUtils::IsVectorOrHigher(params.shape()),
         errors::InvalidArgument(""params must be at least 1 dimensional""));
+    OP_REQUIRES(
+        c, params.shape().dims() >= batch_dims_,
+        errors::InvalidArgument(""params must have at least "", batch_dims_,
+                                "" (batch_dims) dimensions but it has shape "",
+                                params.shape().DebugString()));
 
     // Check that we have enough index space
     const int64_t N = indices.NumElements();","Prevent heap oob access in `resource_variable_ops.cc`

PiperOrigin-RevId: 387936433
Change-Id: I9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6","vuln-fix: Enforce minimum batch_dims in ResourceGatherOp input validation

The ResourceGatherOp kernel lacked validation ensuring the input tensor has at least batch_dims dimensions, allowing malformed inputs to bypass shape checks.
This could lead to out-of-bounds memory access or undefined behavior during tensor indexing, potentially causing crashes or data corruption.
The fix adds a requirement that the input tensor’s rank is at least batch_dims, preventing invalid tensor shapes from proceeding.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('resource_variable_ops.cc', 'URL', ''), ('change', 'ACTION', ''), ('i9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('input validation', 'secword', ''), ('ensuring', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
28,CWE-125,GHSA-h4pc-gx2w-f2xv,"@@ -96,6 +96,8 @@ TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
     }
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
   const int input_size = SizeOfDimension(input, axis_value);
 
   if (minus_one_index != -1) {","Prevent array OOB read/write

PiperOrigin-RevId: 371026165
Change-Id: I26ac6372c87246e03c7eb8c94e84c84d86054b36","vuln-fix: Validate axis parameter bounds in tensor resizing

The tensor resizing function did not verify that the axis parameter was within valid dimension bounds before accessing tensor dimensions.
This allowed attackers to cause out-of-bounds reads or undefined behavior by supplying invalid axis values, risking memory corruption or crashes.
The fix adds explicit checks to ensure the axis is non-negative and less than the number of input dimensions before proceeding.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i26ac6372c87246e03c7eb8c94e84c84d86054b36', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('attackers', 'FLAW', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
29,CWE-125,GHSA-vqw6-72r7-fgw7,"@@ -162,6 +162,9 @@ class BaseMatrixTriangularSolveOp : public OpKernel {
     const Tensor& in1 = ctx->input(1);
 
     ValidateInputTensors(ctx, in0, in1);
+    if (!ctx->status().ok()) {
+      return;
+    }
 
     MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());
     OP_REQUIRES(
@@ -230,13 +233,22 @@ class MatrixTriangularSolveOp
  private:
   void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,
                             const Tensor& in1) override {
+    const auto in0_num_dims = in0.dims();
     OP_REQUIRES(
-        ctx, in0.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0.dims()));
+        ctx, in0_num_dims >= 2,
+        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0_num_dims));
 
+    const auto in1_num_dims = in1.dims();
     OP_REQUIRES(
-        ctx, in1.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in1.dims()));
+        ctx, in1_num_dims >= 2,
+        errors::InvalidArgument(""In[1] ndims must be >= 2: "", in1_num_dims));
+
+    const auto in0_last_dim = in0.dim_size(in0_num_dims - 1);
+    const auto in0_prev_dim = in0.dim_size(in0_num_dims - 2);
+    OP_REQUIRES(ctx, in0_last_dim == in0_prev_dim,
+                errors::InvalidArgument(
+                    ""In[0] matrices in the last dimensions must be square ("",
+                    in0_last_dim, "" =/= "", in0_prev_dim, "")""));
   }
 };","Validate (and ensure validation sticks) inputs for `MatrixTriangularSolve`.

PiperOrigin-RevId: 370282444
Change-Id: Iaed61a0b0727cc42c830658b72eb69f785f48dc5","vuln-fix: Validate input tensor dimensions to prevent invalid memory access

The matrix triangular solve operation lacked comprehensive validation of input tensor dimensions, allowing non-square or insufficiently dimensional tensors to proceed.
This could lead to out-of-bounds memory access or undefined behavior during matrix computations, potentially causing crashes or data corruption.
The fix adds explicit checks for minimum tensor rank and enforces square matrix shape on the last two dimensions, aborting early on invalid inputs.

Weakness: CWE-119  
Severity: High  
CVSS: 7.8",0.11764705882352941,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('iaed61a0b0727cc42c830658b72eb69f785f48dc5', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,"CWE-400', 'CWE-125",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent injection risks

The code used the deprecated Buffer constructor with a string argument, which can lead to unexpected buffer content and potential injection vulnerabilities.
This posed a security risk because improper buffer creation might allow attackers to craft inputs that bypass encoding assumptions, leading to data corruption or injection attacks.
The fix replaces the deprecated constructor with Buffer.from, ensuring safe and predictable buffer creation from string inputs.

Weakness: CWE-119
Severity: Medium
CVSS: 5.3",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('injection', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('vulnerabilities', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('bypass', 'SECWORD', ''), ('encoding', 'SECWORD', ''), ('injection', 'SECWORD', ''), ('attacks', 'FLAW', ''), ('fix', 'ACTION', ''), ('buffer.from', 'URL', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,"CWE-787', 'CWE-125",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate input tensor dimensions to prevent zero-size tensors

The gradient operation did not check for zero values in input tensor dimensions, allowing tensors with zero batch, rows, columns, or depth to proceed.
This could lead to invalid memory accesses or undefined behavior during tensor computations, potentially causing crashes or data corruption.
The fix adds explicit validation to reject input tensors with any zero dimension, ensuring safe and defined operation execution.

Weakness: CWE-119
Severity: High
CVSS: 7.5",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('invalid memory accesses', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-119', 'CWEID', ''), ('high', 'SEVERITY', '')]"
32,CWE-125,GHSA-qpw2-xchm-655q,"@@ -28,7 +28,7 @@ StringStream.prototype.write = function(data) {
     return false
   }
   if (this.fromEncoding) {
-    if (Buffer.isBuffer(data)) data = data.toString()
+    if (Buffer.isBuffer(data) || typeof data === 'number') data = data.toString()
     data = new Buffer(data, this.fromEncoding)
   }
   var string = this.decoder.write(data)","Merge pull request #9 from mhart/fix-buffer-constructor-vuln

Ensure data is not a number in Buffer constructor","vuln-fix: Prevent improper data conversion in StringStream write method

The write method did not handle numeric inputs correctly, causing unintended data conversion that could lead to corrupted output or unexpected behavior.
This flaw could be exploited to cause data integrity issues or application crashes when numeric values were passed, potentially disrupting service or enabling denial of service.
The fix adds a type check to convert numeric inputs to strings before processing, ensuring consistent and safe data handling.

Weakness: CWE-704
Severity: Low
CVSS: 3.3",0.17647058823529413,"[('#9', 'ISSUE', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('flaw', 'FLAW', ''), ('exploited', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('denial of service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-704', 'CWEID', ''), ('low', 'SEVERITY', '')]"
33,CWE-125,GHSA-6gmv-pjp9-p8w8,"@@ -1653,11 +1653,21 @@ REGISTER_OP(""ReverseSequence"")
         return errors::InvalidArgument(
             ""batch_dim must be < input rank: "", batch_dim, "" vs. "", input_rank);
       }
+
       if (seq_dim >= input_rank) {
         return errors::InvalidArgument(
             ""seq_dim must be < input rank: "", seq_dim, "" vs. "", input_rank);
       }
 
+      // To prevent out of bound access when calling c->Dim(input, batch_dim),
+      // batch_dim range [-1 * input rank, input rank) is allowed. However,
+      // the op implementation has a stricter bound for batch_dim requiring >= 0
+      // value. Thus, perform strict check here.
+      if (batch_dim < 0) {
+        return errors::InvalidArgument(""batch_dim must be >=0, got "",
+                                       batch_dim);
+      }
+
       DimensionHandle batch_dim_dim = c->Dim(input, batch_dim);
       TF_RETURN_IF_ERROR(
           c->Merge(batch_dim_dim, c->Dim(seq_lens_shape, 0), &batch_dim_dim));","Fix out of bound error in ReverseSequence Op shape function

PiperOrigin-RevId: 411896080
Change-Id: I7e59a38e2f960886edf2b6c54ed5a84e86a9b193","vuln-fix: Enforce non-negative batch_dim to prevent out-of-bounds access

The ReverseSequence operator allowed negative batch_dim values, which could lead to out-of-bounds tensor dimension access during execution.
This posed a security risk by enabling attackers to trigger invalid memory reads or crashes through crafted inputs with negative batch_dim.
The fix adds a strict check rejecting negative batch_dim values before any dimension access, ensuring safe and valid tensor indexing.

Weakness: CWE-125  
Severity: High  
CVSS: 7.5",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('i7e59a38e2f960886edf2b6c54ed5a84e86a9b193', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('security', 'secword', ''), ('attackers', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
