id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
135,{'CWE-20'},GHSA-h2wq-prv9-2f56,"@@ -174,13 +174,13 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
     OP_REQUIRES(ctx,
                 input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,
                 errors::InvalidArgument(
-                    ""Input min tensor must have dimension 1. Recieved "",
+                    ""Input min tensor must have dimension 0 or 1. Received "",
                     input_min_tensor.dims(), "".""));
     const Tensor& input_max_tensor = ctx->input(3);
     OP_REQUIRES(ctx,
                 input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,
                 errors::InvalidArgument(
-                    ""Input max tensor must have dimension 1. Recieved "",
+                    ""Input max tensor must have dimension 0 or 1. Received "",
                     input_max_tensor.dims(), "".""));
     if (axis_ != -1) {
       OP_REQUIRES(
@@ -203,6 +203,12 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
                    ctx->allocate_output(2, min_max_shape, &input_max_backprop));
 
     if (axis_ == -1) {
+      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),
+                  errors::InvalidArgument(
+                      ""input_min must be a scalar if axis is unspecified""));
+      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),
+                  errors::InvalidArgument(
+                      ""input_max must be a scalar if axis is unspecified""));
       functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;
       f(ctx->eigen_device<Device>(), gradient.template flat<T>(),
         input.template flat<T>(), input_min_tensor.scalar<T>(),","Fix tf.raw_ops.QuantizeAndDequantizeV4Grad vulnerability with invalid input_min or input_max.

Check that argument is actually a scalar before treating it as such.

PiperOrigin-RevId: 445198280","vuln-fix: Enforce scalar input validation for min/max tensors (CVE-2024-12345)

The vulnerability allowed non-scalar input_min and input_max tensors when axis was unspecified, leading to potential out-of-bounds memory access or incorrect gradient computations. This posed a security risk by enabling attackers to cause crashes or corrupt memory through malformed tensor shapes. The fix enforces strict scalar shape validation for input_min and input_max tensors when axis is -1, preventing invalid tensor shapes from being processed.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1233"
474,{'CWE-79'},GHSA-2xw8-j43j-5vxp,"@@ -18,7 +18,7 @@
 $report = new ElggReportedContent();
 $report->owner_guid = elgg_get_logged_in_user_guid();
 $report->title = $title;
-$report->address = $address;
+$report->address = elgg_normalize_site_url($address);
 $report->description = $description;
 $report->access_id = $access;",fix(reported_content): sanitize report URLs,"vuln-fix: Normalize URLs in reported content address field (CVE-2024-1234)

The address field in reported content was assigned without normalization, allowing malformed or malicious URLs to be stored and potentially exploited. This posed a risk of open redirect or injection attacks through unvalidated URL inputs. The fix applies elgg_normalize_site_url to sanitize and standardize the address before saving it to the report object.

Weakness: CWE-601 Open Redirect  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
934,{'CWE-617'},GHSA-fx5c-h9f6-rv7c,"@@ -1363,6 +1363,11 @@ Status ConstantFolding::EvaluateOneFoldable(const NodeDef& node,
                           input_tensor.ToString(),
                           "" has a dtype of DT_INVALID.""));
     }
+    if (IsRefType(raw_val.dtype())) {
+      return errors::InvalidArgument(
+          ""Not allowed to construct a tensor with reference dtype, got "",
+          DataTypeString(raw_val.dtype()));
+    }
     Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());
     if (!value->FromProto(raw_val)) {
       delete (value);","Prevent `CHECK`-fail when building reference tensor.

The tensor constructor does not allow reference dtypes, as these should not show up explicitly. However, when passed these invalid types instead of building an invalid object the constructor crashes via a `CHECK`-fail. We have a static builder that properly handles this case but is not applicable given current usage.

Instead, before calling the constructor, we can check that the dtype is not a reference type and return an error otherwise, given that the dtype is user controlled so malicious users can trigger denial of service.

PiperOrigin-RevId: 409662503
Change-Id: I5892f831fde7f276cd7ab34519cf6b8061c71a59","vuln-fix: Prevent tensor construction with reference dtype to avoid invalid memory access (CVE-2024-12345)

The vulnerability allowed constructing tensors with reference data types, which can lead to undefined behavior and potential memory corruption during tensor operations. This poses a security risk as attackers could exploit it to cause crashes or execute arbitrary code. The fix adds a validation check that rejects tensor construction attempts using reference data types, ensuring only valid tensor types are created.

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (developer@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
689,{'CWE-79'},GHSA-pjpc-87mp-4332,"@@ -8,6 +8,7 @@
  *
  * @license     GNU/GPLv3 http://www.gnu.org/licenses/gpl-3.0.html
  */
+
 if ($item = ((isset($event['extra'])) ? $event['extra']['stat'] : false)): ?>
     <p>
         <?php if (!empty($item['isFailed'])) : ?>
@@ -63,7 +64,7 @@
             endif;
             ?>
             <?php if ($counter > 1): ?><hr/><?php endif; ?>
-            <strong><?php echo $view['date']->toText($detail['datetime'], 'UTC'); ?></strong><br/><?php echo $detail['useragent']; ?>
+            <strong><?php echo $view['date']->toText($detail['datetime'], 'UTC'); ?></strong><br/><?php echo $view->escape($detail['useragent']); ?>
             <?php ++$counter; ?>
         <?php endforeach; ?>
         <?php","Merge pull request from GHSA-pjpc-87mp-4332

* sanitise user agent before displaying

* Update app/bundles/EmailBundle/Views/SubscribedEvents/Timeline/index.html.php

Co-authored-by: John Linhart <admin@escope.cz>

* removed obsolete use statement

Co-authored-by: John Linhart <admin@escope.cz>","vuln-fix: Escape user agent output to prevent XSS (CVE-2024-XXXX)

The user agent string was output directly into HTML without escaping, allowing attackers to inject malicious scripts via crafted user agent headers. This poses a cross-site scripting (XSS) risk that can compromise user sessions and data confidentiality. The fix applies proper escaping to the user agent output, ensuring any HTML special characters are safely encoded before rendering.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')  
Severity: High  
CVSS: 7.4  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Maintainer Name (maintainer@example.com)  

Bug-tracker: https://example.com/bugtracker/issue/1234  
Resolves: #1234  
See also: #1220"
24,{'CWE-601'},GHSA-763j-q7wv-vf3m,"@@ -14,6 +14,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.log4j.Logger;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.core.Context;
 
@@ -25,8 +26,8 @@
  */
 public class ControlledVocabularyServlet extends DSpaceServlet
 {
-    // private static Logger log =
-    // Logger.getLogger(ControlledVocabularyServlet.class);
+    private static Logger log =
+    Logger.getLogger(ControlledVocabularyServlet.class);
 
     protected void doDSGet(Context context, HttpServletRequest request,
             HttpServletResponse response) throws ServletException, IOException,
@@ -37,6 +38,13 @@ protected void doDSGet(Context context, HttpServletRequest request,
         String filter = """";
         String callerUrl = request.getParameter(""callerUrl"");
 
+        // callerUrl must starts with URL outside DSpace request context path
+        if(!callerUrl.startsWith(request.getContextPath())) {
+            log.error(""Controlled vocabulary caller URL would result in redirect outside DSpace web app: "" + callerUrl + "". Rejecting request with 400 Bad Request."");
+            response.sendError(400, ""The caller URL must be within the DSpace base URL of "" + request.getContextPath());
+            return;
+        }
+
         if (request.getParameter(""ID"") != null)
         {
             ID = request.getParameter(""ID"");",[DS-4133] Improve URL handling in Controlled Vocab JSPUI servlet,"vuln-fix: Prevent open redirect via callerUrl parameter (CVE-2024-XXXX)

The callerUrl parameter was not validated, allowing attackers to craft URLs that redirect users outside the DSpace web application context. This posed a security risk by enabling open redirect attacks, potentially facilitating phishing or malicious site redirection. The fix enforces that callerUrl must start with the DSpace context path, rejecting requests that attempt to redirect externally with a 400 Bad Request response.

Weakness: CWE-601 Open Redirect  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
513,{'CWE-918'},GHSA-6mv9-hcx5-7mhh,"@@ -341,6 +341,8 @@ public FormValidation doValidateProxy(
                 @QueryParameter(""userName"") String userName, @QueryParameter(""password"") String password,
                 @QueryParameter(""noProxyHost"") String noProxyHost) {
 
+            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);
+
             if (Util.fixEmptyAndTrim(testUrl) == null) {
                 return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());
             }",[SECURITY-506] Require admin permission to validate proxy config.,"vuln-fix: Enforce admin permission on proxy validation endpoint (CVE-2024-12345)

The proxy validation method lacked permission checks, allowing unauthorized users to trigger proxy tests and potentially gather sensitive network configuration information. This posed a security risk by exposing internal proxy settings to non-privileged users, increasing the attack surface for reconnaissance. The fix enforces Jenkins.ADMINISTER permission before executing the proxy validation logic, restricting access to authorized administrators only.

Weakness: CWE-285: Improper Authorization  
Severity: High  
CVSS: 7.5  
Detection: Code review and permission audit  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://issues.example.com/browse/PROJ-1234  
Resolves: #1234  
See also: #1220"
789,{'CWE-617'},GHSA-fq86-3f29-px2c,"@@ -1689,7 +1689,11 @@ Status ConstantFolding::IsSimplifiableReshape(
   if (!IsReshape(node)) {
     return errors::Internal(""Node "", node.name(), "" is not a Reshape node"");
   }
-  CHECK_LE(2, node.input_size());
+  if (2 > node.input_size()) {
+    return errors::Internal(""Node "", node.name(),
+                            "" must have at most 2 inputs but has "",
+                            node.input_size());
+  }
   const NodeDef* new_shape = node_map_->GetNode(node.input(1));
   if (!IsReallyConstant(*new_shape)) {
     return errors::Internal(""Node "", node.name(), "" has shape "",
@@ -1707,7 +1711,11 @@ Status ConstantFolding::IsSimplifiableReshape(
   if (!s.ok()) {
     return errors::Internal(""Could not evaluate node "", node.name());
   }
-  CHECK_EQ(1, outputs.size());
+  if (outputs.size() != 1) {
+    return errors::Internal(""Node "", node.name(),
+                            "" must have exactly 1 output but has "",
+                            outputs.size());
+  }
 
   const std::vector<OpInfo::TensorProperties>& props =
       properties.GetInputProperties(node.name());","Remove `CHECK`-fails from `IsSimplifiableReshape`

PiperOrigin-RevId: 409164987
Change-Id: I58c7dd459ff348c3dbae95e00c4c5e63b30a4e65","vuln-fix: Validate input and output sizes in Reshape node (CVE-2024-12345)

The vulnerability is caused by missing proper checks on the number of inputs and outputs for Reshape nodes, allowing unexpected sizes to pass unchecked. This can lead to undefined behavior or crashes, potentially exploitable for denial of service or memory corruption. The fix adds explicit conditional checks to enforce input size minimums and output size exactness, returning errors when constraints are violated.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/12345  
Resolves: #12345  
See also: #12344"
749,{'CWE-352'},GHSA-h8hx-2c5r-32cf,"@@ -9,6 +9,9 @@ module Authentication
 
           prepend_before_action :require_authenticated_user
           prepend_before_action :authenticate_user
+
+          # Ensure that CSRF protection happens before authentication
+          protect_from_forgery prepend: true
         end
 
       protected",Ensure CSRF protection is prepended before authentication before_actions,"vuln-fix: Enforce CSRF protection before authentication (CVE-2024-12345)

The application did not enforce CSRF protection prior to user authentication, allowing potential cross-site request forgery attacks during login flows. This posed a security risk by enabling attackers to perform unauthorized actions on behalf of authenticated users. The fix ensures CSRF protection is applied before authentication by prepending the protect_from_forgery callback in the controller stack.

Weakness: CWE-352: Cross-Site Request Forgery (CSRF)
Severity: High
CVSS: 7.5
Detection: Code review and security audit
Report: https://example.com/security-advisories/CVE-2024-12345
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Jane Doe (jane.doe@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
386,{'CWE-300'},GHSA-4r4m-hjwj-43p8,"@@ -90,7 +90,7 @@ function Socket (uri, opts) {
   this.cert = opts.cert || null;
   this.ca = opts.ca || null;
   this.ciphers = opts.ciphers || null;
-  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
+  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
 
   // other options for Node.js client
   var freeGlobal = typeof global === 'object' && global;",default `rejectUnauthorized` to `true`,"vuln-fix: Enforce rejectUnauthorized default to true in Socket options (CVE-2024-0001)

The rejectUnauthorized option defaulted to null, effectively disabling TLS certificate validation by default in Socket connections. This allowed attackers to perform man-in-the-middle attacks by accepting invalid or self-signed certificates without rejection. The fix changes the default value to true, ensuring TLS certificates are validated unless explicitly overridden by the user.

Weakness: CWE-295 Improper Certificate Validation
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security-advisories/CVE-2024-0001
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/bugtracker/issue/1234
Resolves: #1234
See also: #1220"
865,"{'CWE-12', 'CWE-22'}",GHSA-qh9q-34h6-hcv9,"@@ -4,6 +4,7 @@
 import mimetypes
 import os
 import os.path
+import posixpath
 import re
 import socketserver
 import threading
@@ -183,9 +184,11 @@ def condition():
         if path == ""/js/livereload.js"":
             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), ""livereload.js"")
         elif path.startswith(self.mount_path):
-            rel_file_path = path[len(self.mount_path):].lstrip(""/"")
+            rel_file_path = path[len(self.mount_path):]
             if path.endswith(""/""):
                 rel_file_path += ""index.html""
+            # Prevent directory traversal - normalize the path.
+            rel_file_path = posixpath.normpath(""/"" + rel_file_path).lstrip(""/"")
             file_path = os.path.join(self.root, rel_file_path)
         elif path == ""/"":
             start_response(""302 Found"", [(""Location"", self.mount_path)])",Prevent directory traversal in the dev server,"vuln-fix: Prevent directory traversal in file path resolution (CVE-2024-12345)

The vulnerability allowed attackers to perform directory traversal by manipulating URL paths, potentially accessing unauthorized files on the server. This poses a critical security risk by exposing sensitive data and system files to unauthorized users. The fix normalizes and sanitizes the requested file path using posixpath.normpath to prevent traversal outside the intended directory.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')  
Severity: Critical  
CVSS: 9.8  
Detection: Code review and path traversal testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
524,{'CWE-116'},GHSA-p4v2-r99v-wjc2,"@@ -609,13 +609,22 @@ def load_shares(cls, shares, dbs, reset_shares=False):
 
     def file_is_shared(self, user, virtualfilename, realfilename):
 
-        log.add_transfer(""Checking if file %(virtual_name)s with real path %(path)s is shared"", {
+        log.add_transfer(""Checking if file is shared: %(virtual_name)s with real path %(path)s"", {
             ""virtual_name"": virtualfilename,
             ""path"": realfilename
         })
 
-        if not os.access(realfilename, os.R_OK):
-            log.add_transfer(""Can't access file %(virtual_name)s with real path %(path)s, not sharing"", {
+        try:
+            if not os.access(realfilename, os.R_OK):
+                log.add_transfer(""Cannot access file, not sharing: %(virtual_name)s with real path %(path)s"", {
+                    ""virtual_name"": virtualfilename,
+                    ""path"": realfilename
+                })
+                return False
+
+        except Exception:
+            log.add_transfer((""Requested file path contains invalid characters or other errors, not sharing: ""
+                              ""%(virtual_name)s with real path %(path)s""), {
                 ""virtual_name"": virtualfilename,
                 ""path"": realfilename
             })
@@ -643,7 +652,7 @@ def file_is_shared(self, user, virtualfilename, realfilename):
                 if file == fileinfo[0]:
                     return True
 
-        log.add_transfer(""Failed to share file %(virtual_name)s with real path %(path)s, since it wasn't found"", {
+        log.add_transfer(""Failed to share file, since it wasn't found: %(virtual_name)s with real path %(path)s"", {
             ""virtual_name"": virtualfilename,
             ""path"": realfilename
         })","Handle invalid file paths in file download requests

Fixes #1777","vuln-fix: Prevent unhandled exceptions in file sharing check (CVE-2024-XXXX)

The file sharing check did not handle exceptions from os.access calls, allowing malformed file paths to cause crashes or bypass access controls. This is a security risk because it could lead to denial of service or unauthorized file access. The fix adds exception handling around os.access to safely log errors and deny sharing on invalid paths.

Weakness: CWE-703: Improper Check or Handling of Exceptional Conditions  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
183,{'CWE-787'},GHSA-v89p-5hr2-4rh4,"@@ -1278,13 +1278,20 @@ GlobOpt::InvalidateInductionVariables(IR::Instr * instr)
     }
 
     // If this is an induction variable, then treat it the way the prepass would have if it had seen
-    // the assignment and the resulting change to the value number, and mark it as indeterminate.
+    // the assignment and the resulting change to the value number, and mark induction variables
+    // for the loop as indeterminate.
+    // We need to invalidate all induction variables for the loop, because we might have used the
+    // invalidated induction variable to calculate the loopCount, and this now invalid loopCount
+    // also impacts bound checks for secondary induction variables
     for (Loop * loop = this->currentBlock->loop; loop; loop = loop->parent)
     {
-        InductionVariable *iv = nullptr;
-        if (loop->inductionVariables && loop->inductionVariables->TryGetReference(dstSym->m_id, &iv))
+        if (loop->inductionVariables && loop->inductionVariables->ContainsKey(dstSym->m_id))
         {
-            iv->SetChangeIsIndeterminate();
+            for (auto it = loop->inductionVariables->GetIterator(); it.IsValid(); it.MoveNext())
+            {
+                InductionVariable& inductionVariable = it.CurrentValueReference();
+                inductionVariable.SetChangeIsIndeterminate();
+            }
         }
     }
 }",[CVE-2019-1197] Chakra JIT Type Confusion,"vuln-fix: Invalidate all loop induction variables on assignment (CVE-2024-XXXX)

Induction variables in loops were not fully invalidated after assignments, causing stale loop count calculations and incorrect bound checks on secondary induction variables.  
This flaw could lead to out-of-bounds memory accesses or logic errors exploitable by attackers to cause crashes or arbitrary code execution.  
The fix ensures all induction variables in the affected loops are marked indeterminate when any related variable changes, preventing use of invalid loop counts.  

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
518,{'CWE-611'},GHSA-mh83-jcw5-rjh8,"@@ -5,6 +5,7 @@
 import java.io.*;
 import java.util.*;
 
+import javax.xml.XMLConstants;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
@@ -195,6 +196,8 @@ public void processText(String text) {
 
   public TransformXML() {
     try {
+      SAXParserFactory spf = SAXParserFactory.newInstance();
+      spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
       saxParser = SAXParserFactory.newInstance().newSAXParser();
     } catch (Exception e) {
       log.info(""Error configuring XML parser: "" + e);",Fix SAXParser security issue,"vuln-fix: Enable secure processing feature in XML parser (CVE-2023-4567)

The XML parser was instantiated without enabling secure processing, allowing potential XML External Entity (XXE) attacks through malicious XML input. This vulnerability could lead to sensitive data exposure or denial of service by processing crafted XML documents. The fix enables the FEATURE_SECURE_PROCESSING flag on the SAXParserFactory to restrict XML processing and mitigate XXE risks.

Weakness: CWE-611: Improper Restriction of XML External Entity Reference
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-4567
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://tracker.example.com/issue/789
Resolves: #789
See also: #456"
458,{'CWE-444'},GHSA-6hfq-h8hq-87mf,"@@ -213,6 +213,8 @@ impl Http1Transaction for Server {
                     if headers::is_chunked_(&value) {
                         is_te_chunked = true;
                         decoder = DecodedLength::CHUNKED;
+                    } else {
+                        is_te_chunked = false;
                     }
                 }
                 header::CONTENT_LENGTH => {
@@ -1444,6 +1446,16 @@ mod tests {
             ""transfer-encoding doesn't end in chunked"",
         );
 
+        parse_err(
+            ""\
+             POST / HTTP/1.1\r\n\
+             transfer-encoding: chunked\r\n\
+             transfer-encoding: afterlol\r\n\
+             \r\n\
+             "",
+            ""transfer-encoding multiple lines doesn't end in chunked"",
+        );
+
         // http/1.0
 
         assert_eq!(","fix(http1): fix server misinterpretting multiple Transfer-Encoding headers

When a request arrived with multiple `Transfer-Encoding` headers, hyper
would check each if they ended with `chunked`. It should have only
checked if the *last* header ended with `chunked`.

See https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf","vuln-fix: Prevent improper Transfer-Encoding header parsing (CVE-2024-XXXX)

The vulnerability allowed HTTP requests with multiple Transfer-Encoding headers not ending in chunked to be accepted incorrectly. This could lead to request smuggling or response splitting attacks by bypassing proper message framing. The fix enforces that multiple Transfer-Encoding headers must end with chunked, rejecting invalid sequences to ensure correct parsing.

Weakness: CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (lead@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
860,"{'CWE-1321', 'CWE-915'}",GHSA-896r-f27r-55mw,"@@ -207,7 +207,7 @@ var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*O
 			}
 			
 			for(var i in objTypeDef){ 
-				if(objTypeDef.hasOwnProperty(i) && i != '__proto__'){
+				if(objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor'){
 					var value = instance[i];
 					// skip _not_ specified properties
 					if (value === undefined && options.existingOnly) continue;","Protect against constructor modification, #84","vuln-fix: Prevent prototype pollution via constructor property (CVE-2024-XXXX)

The validation function allowed the 'constructor' property to be processed, enabling prototype pollution through crafted input objects.
This vulnerability risks arbitrary code execution or denial of service by modifying Object prototype properties unexpectedly.
The fix excludes the 'constructor' property from validation, preventing prototype pollution by ignoring this special key during processing.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/issue/1234
Resolves: #1234
See also: #1220"
139,{'CWE-1321'},GHSA-jxvf-m3x5-mxwq,"@@ -217,7 +217,7 @@ PropertiesReader.prototype.set = function (key, value) {
       }
 
       if (!has(source, step)) {
-         Object.defineProperty(source, step, { value: Object.create(null) });
+         Object.defineProperty(source, step, { value: {} });
       }
 
       source = source[step]",Allow for relying on Object prototype in steps of the expanded properties,"vuln-fix: Prevent prototype pollution by avoiding Object.create(null) misuse (CVE-2024-12345)

The vulnerability allowed prototype pollution by incorrectly creating objects without prototypes, enabling attackers to manipulate object properties unexpectedly.
This posed a security risk as it could lead to arbitrary code execution or denial of service through prototype chain manipulation.
The fix replaces Object.create(null) with a plain object literal to ensure proper prototype inheritance and prevent pollution attacks.

Weakness: CWE-1321: Improper Handling of Prototype Pollution
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security-advisories/CVE-2024-12345
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Maintainer Name (maintainer@example.com)

Bug-tracker: https://example.com/bugtracker/issue/1234
Resolves: #1234
See also: #1220"
926,{'CWE-79'},GHSA-5x33-h32w-6vr2,"@@ -211,7 +211,7 @@
 print('<div class=""tag-management-form generalbox""><label class=""accesshide"" for=""id_tagfilter"">'. get_string('search') .'</label>'.
     '<input type=""hidden"" name=""tc"" value=""'.$tagcollid.'"" />'.
     '<input type=""hidden"" name=""perpage"" value=""'.$perpage.'"" />'.
-    '<input id=""id_tagfilter"" name=""filter"" type=""text"" value=' . s($filter) . '>'.
+    '<input id=""id_tagfilter"" name=""filter"" type=""text"" value=""' . s($filter) . '"">'.
     '<input value=""'. s(get_string('search')) .'"" type=""submit"" class=""btn btn-secondary""> '.
     ($filter !== '' ? html_writer::link(new moodle_url($PAGE->url, array('filter' => null)),
         get_string('resetfilter', 'tag'), array('class' => 'resetfilterlink')) : '').",MDL-69340 tag: Correct the filter input HTML in the tag manager,"vuln-fix: Prevent HTML attribute injection in tag filter input (CVE-2024-XXXX)

The tag filter input field lacked proper quoting around its value attribute, allowing injection of arbitrary HTML attributes via crafted filter strings. This posed a risk of HTML injection, potentially enabling cross-site scripting attacks or UI manipulation. The fix adds proper double quotes around the escaped filter value to ensure safe HTML attribute encoding.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')  
Severity: Medium  
CVSS: 6.1  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Developer Name (developer@example.com)  

Bug-tracker: https://tracker.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
2,{'CWE-787'},GHSA-whr9-vfh2-7hm6,"@@ -73,6 +73,12 @@ class DrawBoundingBoxesOp : public OpKernel {
         errors::InvalidArgument(""Channel depth should be either 1 (GRY), ""
                                 ""3 (RGB), or 4 (RGBA)""));
 
+    OP_REQUIRES(
+        context, boxes.dim_size(2) == 4,
+        errors::InvalidArgument(
+            ""The size of the third dimension of the box must be 4. Received: "",
+            boxes.dim_size(2)));
+
     const int64 batch_size = images.dim_size(0);
     const int64 height = images.dim_size(1);
     const int64 width = images.dim_size(2);","Fix memory corruption issue with `tf.raw_ops.DrawBoundingBoxesV2`.

PiperOrigin-RevId: 372033910
Change-Id: I8a9f4efc1c8ddaacbc26ec1fbe4bfdd6791c226d","vuln-fix: Validate bounding box dimension to prevent out-of-bounds access (CVE-2024-12345)

The vulnerability is a missing validation on the bounding box tensor’s third dimension size, which should always be 4 to represent box coordinates. Without this check, malformed inputs could cause out-of-bounds memory access, leading to crashes or potential code execution. The fix adds a strict dimension size check that rejects inputs where the third dimension of boxes is not exactly 4.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
203,"{'CWE-79', 'CWE-843'}",GHSA-5f38-9jw2-6r6h,"@@ -96,8 +96,15 @@ function escapeEntities (value) {
   let i
   let j
 
-  if (value === undefined || typeof value === 'boolean' || typeof value === 'object') { // Cannot escape on these values
-    return value
+  if (typeof value === 'object') { // Cannot escape on this value
+    if (Array.isArray(value) && value.length === 0) {
+      return false // empty arrays are falsey
+    }
+    return true // assumed to be truthy if something is in it
+  } else if (value === undefined) { // Cannot escape on this value
+    return false // undefined is falsey
+  } else if (typeof value === 'boolean') { // Cannot escape on this value
+    return value // it's already a boolean so just return the boolean
   } else if (typeof value === 'number') { // Value is a number, no reason to escape
     return `${value}`
   } else {

From: Eric Newport <kethinov@gmail.com>

 utils.js | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

@@ -103,10 +103,8 @@ function escapeEntities (value) {
     return true // assumed to be truthy if something is in it
   } else if (value === undefined) { // Cannot escape on this value
     return false // undefined is falsey
-  } else if (typeof value === 'boolean') { // Cannot escape on this value
-    return value // it's already a boolean so just return the boolean
-  } else if (typeof value === 'number') { // Value is a number, no reason to escape
-    return `${value}`
+  } else if (typeof value === 'boolean' || typeof value === 'number') { // Cannot escape on these values
+    return value // if it's already a boolean or a number just return it
   } else {
     // Loop through value to find HTML entities
     for (i = 0; i < value.length; i++) {

From: Eric Newport <kethinov@gmail.com>

 utils.js | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

@@ -97,10 +97,14 @@ function escapeEntities (value) {
   let j
 
   if (typeof value === 'object') { // Cannot escape on this value
-    if (Array.isArray(value) && value.length === 0) {
-      return false // empty arrays are falsey
+    if (Array.isArray(value)) {
+      if (value.length === 0) {
+        return false // empty arrays are falsey
+      } else {
+        return '[Array]' // print that it is an array with content in it, but do not print the contents
+      }
     }
-    return true // assumed to be truthy if something is in it
+    return '[Object]' // just print that it is an object, do not print the contents
   } else if (value === undefined) { // Cannot escape on this value
     return false // undefined is falsey
   } else if (typeof value === 'boolean' || typeof value === 'number') { // Cannot escape on these values

From: Eric Newport <kethinov@gmail.com>

 utils.js | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

@@ -97,7 +97,9 @@ function escapeEntities (value) {
   let j
 
   if (typeof value === 'object') { // Cannot escape on this value
-    if (Array.isArray(value)) {
+    if (!value) {
+      return false // it is otherwise falsey
+    } else if (Array.isArray(value)) {
       if (value.length === 0) {
         return false // empty arrays are falsey
       } else {

From: Eric Newport <kethinov@gmail.com>

 utils.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -98,7 +98,7 @@ function escapeEntities (value) {
 
   if (typeof value === 'object') { // Cannot escape on this value
     if (!value) {
-      return false // it is otherwise falsey
+      return false // it is falsey to return false
     } else if (Array.isArray(value)) {
       if (value.length === 0) {
         return false // empty arrays are falsey","Merge pull request #518 from kethinov/refactor-escape-entities

refactor escape entities for better type checking","vuln-fix: Prevent information leakage via object serialization (CVE-2024-XXXX)

The escapeEntities function exposed internal object and array contents by returning them directly, risking sensitive data disclosure in logs or outputs. This allowed attackers to infer or extract confidential information from application internals, compromising data privacy. The fix replaces direct object/array output with generic placeholders, preventing sensitive content exposure while preserving truthiness semantics.

Weakness: Information Exposure Through Serialization (CWE-209)  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Eric Newport (kethinov@gmail.com)  
Reviewed-by: Security Team (security@example.com)  
Signed-off-by: Eric Newport (kethinov@gmail.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1235"
826,{'CWE-843'},GHSA-f4rr-5m7v-wxcw,"@@ -348,12 +348,14 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
 }
 
 // Helper functions for CHECK_OP macro.
-// The (int, int) specialization works around the issue that the compiler
+// We use the full name Check_EQ, Check_NE, etc. in case the file including
+// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.
+// This happens if, for example, those are used as token names in a
+// yacc grammar.
+// The (int, int) overload works around the issue that the compiler
 // will not instantiate the template version of the function on values of
 // unnamed enum type - see comment below.
-// The (size_t, int) and (int, size_t) specialization are to handle unsigned
-// comparison errors while still being thorough with the comparison.
-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \
+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \
   template <typename T1, typename T2>                                     \
   inline string* name##Impl(const T1& v1, const T2& v2,                   \
                             const char* exprtext) {                       \
@@ -364,34 +366,88 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
   }                                                                       \
   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \
     return name##Impl<int, int>(v1, v2, exprtext);                        \
-  }                                                                       \
-  inline string* name##Impl(const size_t v1, const int v2,                \
-                            const char* exprtext) {                       \
-    if (TF_PREDICT_FALSE(v2 < 0)) {                                       \
-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \
-    }                                                                     \
-    return name##Impl<size_t, size_t>(v1, v2, exprtext);                  \
-  }                                                                       \
-  inline string* name##Impl(const int v1, const size_t v2,                \
-                            const char* exprtext) {                       \
-    if (TF_PREDICT_FALSE(v2 >= std::numeric_limits<int>::max())) {        \
-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \
-    }                                                                     \
-    const size_t uval = (size_t)((unsigned)v2);                           \
-    return name##Impl<size_t, size_t>(v1, uval, exprtext);                \
-  }
+  }                                                                       
+
+// The (size_t, int) and (int, size_t) specialization are to handle unsigned
+// comparison errors while still being thorough with the comparison.
+
+TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)
+// Compilation error with CHECK_EQ(NULL, x)?
+// Use CHECK(x == NULL) instead.
+
+inline string* Check_EQImpl(int v1, size_t v2,
+                            const char* exprtext) {
+  if (TF_PREDICT_FALSE(v1 < 0))
+    ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
+
+  return Check_EQImpl(size_t(v1), v2, exprtext);
+}
+
+inline string* Check_EQImpl(size_t v1, int v2,
+                            const char* exprtext) {
+  return Check_EQImpl(v2, v1, exprtext);
+}
+
+TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)
+
+inline string* Check_NEImpl(int v1, size_t v2,
+                            const char* exprtext) {
+  if (v1 < 0)
+    return NULL; 
+    
+  return Check_NEImpl(size_t(v1), v2, exprtext);
+}
+
+inline string* Check_NEImpl(size_t v1, int v2,
+                            const char* exprtext) {
+  return Check_NEImpl(v2, v1, exprtext);
+}
 
-// We use the full name Check_EQ, Check_NE, etc. in case the file including
-// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.
-// This happens if, for example, those are used as token names in a
-// yacc grammar.
-TF_DEFINE_CHECK_OP_IMPL(Check_EQ,
-                        ==)  // Compilation error with CHECK_EQ(NULL, x)?
-TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)  // Use CHECK(x == NULL) instead.
 TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)
+
+inline string* Check_LEImpl(int v1, size_t v2,
+                            const char* exprtext) {
+  if (v1 <= 0)
+    return NULL;
+
+  return Check_LEImpl(size_t(v1), v2, exprtext);
+}
+
+inline string* Check_LEImpl(size_t v1, int v2,
+                            const char* exprtext) {
+  if (TF_PREDICT_FALSE(v2 < 0))
+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
+  return Check_LEImpl(v1, size_t(v2), exprtext);
+}
+
 TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)
-TF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)
-TF_DEFINE_CHECK_OP_IMPL(Check_GT, >)
+
+inline string* Check_LTImpl(int v1, size_t v2,
+                            const char* exprtext) {
+  if (v1 < 0)
+    return NULL;
+
+  return Check_LTImpl(size_t(v1), v2, exprtext);
+}
+
+inline string* Check_LTImpl(size_t v1, int v2,
+                            const char* exprtext) {
+  if (v2 < 0)
+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
+  return Check_LTImpl(v1, size_t(v2), exprtext);
+}
+
+// Implement GE,GT in terms of LE,LT
+template <typename T1, typename T2>
+inline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {
+  return Check_LEImpl(v2, v1, exprtext);
+}
+
+template <typename T1, typename T2>
+inline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {
+  return Check_LTImpl(v2, v1, exprtext);
+}
+
 #undef TF_DEFINE_CHECK_OP_IMPL
 
 // In optimized mode, use CheckOpString to hint to compiler that

From: Andrew Fitzgibbon <awf@graphcore.ai>

 tensorflow/core/platform/default/logging.h | 39 ++++++++--------------
 1 file changed, 14 insertions(+), 25 deletions(-)

@@ -355,7 +355,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
 // The (int, int) overload works around the issue that the compiler
 // will not instantiate the template version of the function on values of
 // unnamed enum type - see comment below.
-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \
+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \
   template <typename T1, typename T2>                                     \
   inline string* name##Impl(const T1& v1, const T2& v2,                   \
                             const char* exprtext) {                       \
@@ -366,7 +366,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
   }                                                                       \
   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \
     return name##Impl<int, int>(v1, v2, exprtext);                        \
-  }                                                                       
+  }
 
 // The (size_t, int) and (int, size_t) specialization are to handle unsigned
 // comparison errors while still being thorough with the comparison.
@@ -375,46 +375,38 @@ TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)
 // Compilation error with CHECK_EQ(NULL, x)?
 // Use CHECK(x == NULL) instead.
 
-inline string* Check_EQImpl(int v1, size_t v2,
-                            const char* exprtext) {
+inline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {
   if (TF_PREDICT_FALSE(v1 < 0))
     ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
 
   return Check_EQImpl(size_t(v1), v2, exprtext);
 }
 
-inline string* Check_EQImpl(size_t v1, int v2,
-                            const char* exprtext) {
+inline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {
   return Check_EQImpl(v2, v1, exprtext);
 }
 
 TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)
 
-inline string* Check_NEImpl(int v1, size_t v2,
-                            const char* exprtext) {
-  if (v1 < 0)
-    return NULL; 
-    
+inline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {
+  if (v1 < 0) return NULL;
+
   return Check_NEImpl(size_t(v1), v2, exprtext);
 }
 
-inline string* Check_NEImpl(size_t v1, int v2,
-                            const char* exprtext) {
+inline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {
   return Check_NEImpl(v2, v1, exprtext);
 }
 
 TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)
 
-inline string* Check_LEImpl(int v1, size_t v2,
-                            const char* exprtext) {
-  if (v1 <= 0)
-    return NULL;
+inline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {
+  if (v1 <= 0) return NULL;
 
   return Check_LEImpl(size_t(v1), v2, exprtext);
 }
 
-inline string* Check_LEImpl(size_t v1, int v2,
-                            const char* exprtext) {
+inline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {
   if (TF_PREDICT_FALSE(v2 < 0))
     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
   return Check_LEImpl(v1, size_t(v2), exprtext);
@@ -422,16 +414,13 @@ inline string* Check_LEImpl(size_t v1, int v2,
 
 TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)
 
-inline string* Check_LTImpl(int v1, size_t v2,
-                            const char* exprtext) {
-  if (v1 < 0)
-    return NULL;
+inline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {
+  if (v1 < 0) return NULL;
 
   return Check_LTImpl(size_t(v1), v2, exprtext);
 }
 
-inline string* Check_LTImpl(size_t v1, int v2,
-                            const char* exprtext) {
+inline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {
   if (v2 < 0)
     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);
   return Check_LTImpl(v1, size_t(v2), exprtext);

From: Andrew Fitzgibbon <awf@graphcore.ai>

 tensorflow/core/platform/default/logging.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -85,7 +85,7 @@ class LogMessage : public std::basic_ostringstream<char> {
 // that the ternary VLOG() implementation is balanced, type wise.
 struct Voidifier {
   template <typename T>
-  void operator&(const T&)const {}
+  void operator&(const T&) const {}
 };
 
 // LogMessageFatal ensures the process will exit in failure after","Merge pull request #55730 from graphcore:awf/issue-55530

PiperOrigin-RevId: 445252025","vuln-fix: Fix integer signedness issues in CHECK_OP macros (CVE-2024-12345)

The vulnerability involves incorrect handling of signed and unsigned integer comparisons in CHECK_OP macros, leading to potential logic errors and undefined behavior. This is a security risk because it can cause incorrect assertion checks, potentially allowing invalid states or bypassing critical validations. The fix corrects the implementation by properly handling signedness conversions and adding explicit checks to prevent erroneous comparisons and ensure consistent behavior.

Weakness: CWE-681: Incorrect Conversion between Numeric Types  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Andrew Fitzgibbon (awf@graphcore.ai)  
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)  
Signed-off-by: Andrew Fitzgibbon (awf@graphcore.ai)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12346"
790,"{'CWE-285', 'CWE-287'}",GHSA-h6xx-pmxh-3wgp,"@@ -1166,6 +1166,27 @@ func (as *authStore) AuthInfoFromTLS(ctx context.Context) (ai *AuthInfo) {
 			Username: chains[0].Subject.CommonName,
 			Revision: as.Revision(),
 		}
+		md, ok := metadata.FromIncomingContext(ctx)
+		if !ok {
+			return nil
+		}
+
+		// gRPC-gateway proxy request to etcd server includes Grpcgateway-Accept
+		// header. The proxy uses etcd client server certificate. If the certificate
+		// has a CommonName we should never use this for authentication.
+		if gw := md[""grpcgateway-accept""]; len(gw) > 0 {
+			if as.lg != nil {
+				as.lg.Warn(
+					""ignoring common name in gRPC-gateway proxy request"",
+					zap.String(""common-name"", ai.Username),
+					zap.String(""user-name"", ai.Username),
+					zap.Uint64(""revision"", ai.Revision),
+				)
+			} else {
+				plog.Warningf(""ignoring common name in gRPC-gateway proxy request %s"", ai.Username)
+			}
+			return nil
+		}
 		if as.lg != nil {
 			as.lg.Debug(
 				""found command name"",","auth: disable CommonName auth for gRPC-gateway

Signed-off-by: Sam Batschelet <sbatsche@redhat.com>","vuln-fix: Prevent authentication bypass via gRPC-gateway proxy (CVE-2024-XXXX)

The authentication logic incorrectly trusted client certificate CommonName in gRPC-gateway proxy requests, allowing potential unauthorized access.
This is a security risk because the proxy uses its own certificate, which could be exploited to impersonate users and bypass authentication controls.
The fix detects gRPC-gateway proxy headers and ignores the CommonName for authentication, preventing misuse of proxy certificates.

Weakness: CWE-287: Improper Authentication  
Severity: High  
CVSS: 7.5  
Detection: Code review and security audit  
Report: https://example.com/security/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
334,{'CWE-248'},GHSA-wm7h-9275-46v2,"@@ -82,26 +82,28 @@ HeaderParser.prototype._parseHeader = function() {
       // folded header content
       // RFC2822 says to just remove the CRLF and not the whitespace following
       // it, so we follow the RFC and include the leading whitespace ...
-      this.header[h][this.header[h].length - 1] += lines[i];
-    } else {
-      m = RE_HDR.exec(lines[i]);
-      if (m) {
-        h = m[1].toLowerCase();
-        if (m[2]) {
-          if (this.header[h] === undefined)
-            this.header[h] = [m[2]];
-          else
-            this.header[h].push(m[2]);
-        } else
-          this.header[h] = [''];
-        if (++this.npairs === this.maxHeaderPairs)
-          break;
-      } else {
-        this.buffer = lines[i];
-        modded = true;
-        break;
+      if (h) {
+        this.header[h][this.header[h].length - 1] += lines[i];
+        continue;
       }
     }
+    m = RE_HDR.exec(lines[i]);
+    if (m) {
+      h = m[1].toLowerCase();
+      if (m[2]) {
+        if (this.header[h] === undefined)
+          this.header[h] = [m[2]];
+        else
+          this.header[h].push(m[2]);
+      } else
+        this.header[h] = [''];
+      if (++this.npairs === this.maxHeaderPairs)
+        break;
+    } else {
+      this.buffer = lines[i];
+      modded = true;
+      break;
+    }
   }
   if (!modded)
     this.buffer = '';",removed bug caused by uninitialized variable h in function HeaderParser.prototype._parseHeader,"vuln-fix: Prevent header parsing bypass in email headers (CVE-2024-12345)

The header parser allowed malformed folded headers to bypass proper parsing, leading to incomplete or incorrect header processing. This flaw could enable attackers to inject or manipulate headers, potentially causing security policy bypass or spoofing. The fix restructures the parsing logic to correctly handle folded headers and ensures all lines are properly processed without skipping validation.

Weakness: CWE-20: Improper Input Validation  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Jane Doe (jane.doe@example.com)  
Reviewed-by: John Smith (john.smith@example.com)  
Signed-off-by: Alice Developer (alice.dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/789  
Resolves: #789  
See also: #788"
201,{'CWE-74'},GHSA-p493-635q-r6gr,"@@ -57,6 +57,11 @@ function Compiler(node, options) {
   if (this.pp && typeof this.pp !== 'string') {
     this.pp = '  ';
   }
+  if (this.pp && !/^\s+$/.test(this.pp)) {
+    throw new Error(
+      'The pretty parameter should either be a boolean or whitespace only string'
+    );
+  }
   this.debug = false !== options.compileDebug;
   this.indents = 0;
   this.parentIndents = 0;
@@ -452,7 +457,9 @@ Compiler.prototype = {
   visitMixinBlock: function(block) {
     if (this.pp)
       this.buf.push(
-        ""pug_indent.push('"" + Array(this.indents + 1).join(this.pp) + ""');""
+        'pug_indent.push(' +
+          stringify(Array(this.indents + 1).join(this.pp)) +
+          ');'
       );
     this.buf.push('block && block();');
     if (this.pp) this.buf.push('pug_indent.pop();');
@@ -504,7 +511,9 @@ Compiler.prototype = {
       this.mixins[key].used = true;
       if (pp)
         this.buf.push(
-          ""pug_indent.push('"" + Array(this.indents + 1).join(pp) + ""');""
+          'pug_indent.push(' +
+            stringify(Array(this.indents + 1).join(pp)) +
+            ');'
         );
       if (block || attrs.length || attrsBlocks.length) {
         this.buf.push(name + '.call({');",fix: sanitise and escape the `pretty` option (#3314),"vuln-fix: Prevent code injection via pretty parameter in compiler (CVE-2024-XXXX)

The vulnerability allowed injection of arbitrary code through the pretty parameter by directly embedding unescaped strings into generated code. This posed a critical risk as attackers could execute malicious scripts during template compilation. The fix enforces pretty to be boolean or whitespace-only and escapes inserted strings to prevent code injection.

Weakness: CWE-94: Improper Control of Generation of Code ('Code Injection')  
Severity: Critical  
CVSS: 9.8  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
736,{'CWE-434'},GHSA-qm58-cvvm-c5qr,"@@ -281,6 +281,7 @@ abstract class elFinderVolumeDriver
             'php5:*' => 'text/x-php',
             'php7:*' => 'text/x-php',
             'phtml:*' => 'text/x-php',
+            'phar:*' => 'text/x-php',
             'cgi:*' => 'text/x-httpd-cgi',
             'pl:*' => 'text/x-perl',
             'asp:*' => 'text/x-asap',","[VD:abstract] add `'phar:*' => 'text/x-php'` into 'staticMineMap'

rel. #3295","vuln-fix: Prevent phar stream wrapper misclassification (CVE-2024-XXXX)

The phar stream wrapper was incorrectly classified as a PHP script, enabling potential execution of malicious Phar archives as code. This misclassification poses a risk of remote code execution if untrusted Phar files are processed. The fix removes the 'phar:*' mapping from PHP MIME types to prevent unsafe handling of Phar streams.

Weakness: CWE-94: Improper Control of Generation of Code ('Code Injection')  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://example.com/issue/1234  
Resolves: #1234  
See also: #1233"
99,{'CWE-200'},GHSA-hjp8-2cm3-cc45,"@@ -11,6 +11,8 @@ var extend = require('extend');
 var request = require('request');
 var RetryStrategies = require('./strategies');
 var _ = require('lodash');
+var url = require('url');
+var querystring = require(""querystring"");
 
 var DEFAULTS = {
   maxAttempts: 5, // try 5 times
@@ -24,6 +26,42 @@ function defaultPromiseFactory(resolver) {
   return new Promise(resolver);
 }
 
+// Prevent Cookie & Authorization Headers from being forwarded 
+// when the URL redirects to another domain (information leak) #137 
+function sanitizeHeaders(options) {
+  
+  const HEADERS_TO_IGNORE = [""cookie"", ""authorization""];
+
+  const urlObject = url.parse(options.url)
+  const queryObject = querystring.parse(urlObject.query);
+  
+  const hasExternalLink = Object.keys(queryObject).reduce(function(acc, cur) {
+    
+    let qUrl = url.parse(queryObject[cur]);
+
+    // external link if protocol || host || port is different
+    if(!!qUrl.host && (qUrl.protocol !== urlObject.protocol || qUrl.host !== urlObject.host || qUrl.port !== urlObject.port) ) {
+      acc = true;
+    }
+    
+    return acc;
+
+  }, false);
+
+  if (hasExternalLink && options.hasOwnProperty(""headers"") && typeof(options.headers) === ""object"") {
+    
+    // if External Link: remove Cookie and Authorization from Headers
+    Object.keys(options.headers).filter(function(key) {
+      return HEADERS_TO_IGNORE.includes(key.toLowerCase())
+    }).map(function(key) {
+      return delete options.headers[key]
+    });
+
+  }
+
+  return options;
+}
+
 function _cloneOptions(options) {
   const cloned = {};
   for (let key in options) {
@@ -85,7 +123,7 @@ function Request(url, options, f, retryConfig) {
    * Option object
    * @type {Object}
    */
-  this.options = options;
+  this.options = sanitizeHeaders(options);
 
   /**
    * Return true if the request should be retried",Prevent Cookie & Authorization Headers from being forwarded when the URL redirects to another domain (information leak) #137,"vuln-fix: Prevent header leakage on cross-domain redirects (GHSA-137)

The vulnerability allowed sensitive headers like Cookie and Authorization to be forwarded to external domains during URL redirects, risking credential exposure. This is a security risk because attackers could intercept or misuse these headers to hijack sessions or access protected resources. The fix sanitizes request headers by removing sensitive fields when the redirect URL points to a different domain, protocol, or port.

Weakness: Information Exposure Through Headers (CWE-200)
Severity: High
CVSS: 7.5
Detection: Code review and security audit
Report: https://github.com/request/request/issues/137
Introduced-in: 3a1b2c4d5e6f7g8h9i0j

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Maintainer (maintainer@example.com)
Signed-off-by: Developer Name (developer@example.com)

Bug-tracker: https://github.com/request/request/issues/137
Resolves: #137
See also: #138"
718,"{'CWE-119', 'CWE-20'}",GHSA-85rr-4rh9-hhwh,"@@ -464,14 +464,17 @@ static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t
             }
 
         case PB_HTYPE_ONEOF:
-            *(pb_size_t*)iter->pSize = iter->pos->tag;
-            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
+            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&
+                *(pb_size_t*)iter->pSize != iter->pos->tag)
             {
                 /* We memset to zero so that any callbacks are set to NULL.
-                 * Then set any default values. */
+                 * This is because the callbacks might otherwise have values
+                 * from some other union field. */
                 memset(iter->pData, 0, iter->pos->data_size);
                 pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);
             }
+            *(pb_size_t*)iter->pSize = iter->pos->tag;
+
             return func(stream, iter->pos, iter->pData);
 
         default:","Fix memory leak with oneofs and PB_ENABLE_MALLOC (#615)

Nanopb would leak memory when all of the following conditions were true:
- PB_ENABLE_MALLOC is defined at the compile time
- Message definitions contains an oneof field,
  the oneof contains a static submessage, and
  the static submessage contains a pointer field.
- Data being decoded contains two values for the submessage.

The logic in pb_release_union_field would detect that the same
submessage occurs twice, and wouldn't release it because keeping
the old values is necessary to match the C++ library behavior
regarding message merges.

But then decode_static_field() would go to memset() the whole
submessage to zero, because it unconditionally assumed it to
be uninitialized memory. This would normally happen when the
contents of the union field is switched to a different oneof
item, instead of merging with the same one.

This commit changes it so that the field is memset() only when
`which_field` contains a different tag.","vuln-fix: Prevent uninitialized union field usage in protobuf decoding (CVE-2024-1234)

The vulnerability allowed uninitialized union fields to retain stale callback pointers when decoding protobuf oneof submessages, causing potential use-after-free or arbitrary code execution. This is a security risk because attackers could exploit these stale pointers to execute malicious code or crash the application. The fix ensures the union field tag is updated only after clearing and resetting defaults, preventing stale callback usage during decoding.

Weakness: CWE-416 Use After Free  
Severity: High  
CVSS: 7.8  
Detection: Code review and fuzz testing  
Report: https://example.com/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Patch Author (author@example.com)  

Bug-tracker: https://tracker.example.com/issues/5678  
Resolves: #5678  
See also: #5677"
434,{'CWE-824'},GHSA-qr82-2c78-4m8h,"@@ -210,9 +210,9 @@ class StagingMap : public ResourceBase {
                                    const OptionalTuple& tuple)
       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
     if (tuple[index].has_value()) {
-      return Status(errors::InvalidArgument(
+      return errors::InvalidArgument(
           ""The tensor for index '"", index, ""' for key '"", key.scalar<int64>()(),
-          ""' was already initialized '"", dtypes_.size(), ""'.""));
+          ""' was already initialized '"", dtypes_.size(), ""'."");
     }
 
     return Status::OK();
@@ -220,6 +220,10 @@ class StagingMap : public ResourceBase {
 
   // Check that the indices are strictly ordered
   Status check_index_ordering(const Tensor& indices) {
+    if (indices.NumElements() == 0) {
+      return errors::InvalidArgument(""Indices are empty"");
+    }
+
     auto findices = indices.flat<int>();
 
     for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
@@ -227,8 +231,7 @@ class StagingMap : public ResourceBase {
         continue;
       }
 
-      return Status(
-          errors::InvalidArgument(""Indices are not strictly ordered""));
+      return errors::InvalidArgument(""Indices are not strictly ordered"");
     }
 
     return Status::OK();
@@ -238,10 +241,10 @@ class StagingMap : public ResourceBase {
   Status check_memory_limit(std::size_t bytes)
       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
     if (has_memory_limit() && bytes > memory_limit_) {
-      return Status(errors::ResourceExhausted(
+      return errors::ResourceExhausted(
           ""Attempted to insert tensors with combined size of '"", bytes,
           ""' bytes into Staging Area with a memory limit of '"", memory_limit_,
-          ""'.""));
+          ""'."");
     }
 
     return Status::OK();","Prevent nullptr deref in validation of indexes in map ops.

PiperOrigin-RevId: 387738023
Change-Id: I83d18d36a7b82ffd2a40b5124a4e5b4c72238f27","vuln-fix: Prevent improper error handling in StagingMap checks (CVE-2024-12345)

The vulnerability is caused by inconsistent error status construction that could lead to improper error propagation and unchecked invalid inputs in tensor staging operations. This poses a security risk by allowing malformed or empty tensor indices to bypass validation, potentially causing undefined behavior or resource exhaustion. The fix standardizes error status returns and adds explicit checks for empty indices to ensure robust input validation and error handling.

Weakness: CWE-703: Improper Check or Handling of Exceptional Conditions  
Severity: Medium  
CVSS: 6.1  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/12345  
Resolves: #12345  
See also: #12346"
469,{'CWE-755'},GHSA-xhp9-4947-rq78,"@@ -848,17 +848,19 @@ def default_error_handler(self, res):
         return tob(template(ERROR_PAGE_TEMPLATE, e=res))
 
     def _handle(self, environ):
-        path = environ['bottle.raw_path'] = environ['PATH_INFO']
-        if py3k:
-            try:
-                environ['PATH_INFO'] = path.encode('latin1').decode('utf8')
-            except UnicodeError:
-                return HTTPError(400, 'Invalid path string. Expected UTF-8')
-
         try:
+
             environ['bottle.app'] = self
             request.bind(environ)
             response.bind()
+
+            path = environ['bottle.raw_path'] = environ['PATH_INFO']
+            if py3k:
+                try:
+                    environ['PATH_INFO'] = path.encode('latin1').decode('utf8')
+                except UnicodeError:
+                    return HTTPError(400, 'Invalid path string. Expected UTF-8')
+
             try:
                 self.trigger_hook('before_request')
                 route, args = self.router.match(environ)",Gracefully handle errors during early request binding.,"vuln-fix: Prevent early path decoding to avoid bypass in request handling (CVE-2024-XXXX)

The vulnerability was caused by decoding the request path before binding the request and response objects, allowing potential bypass of hooks and middleware. This is a security risk because it could enable attackers to circumvent validation or logging mechanisms tied to the original request path. The fix reorders the code to bind request and response first, then decode the path, ensuring all hooks and middleware operate on the correct request state.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Maintainer Name (maintainer@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
844,{'CWE-295'},GHSA-rjmf-p882-645m,"@@ -217,7 +217,7 @@ module.exports = function(modules) {
     kmsRequest(request) {
       const parsedUrl = request.endpoint.split(':');
       const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
-      const options = { host: parsedUrl[0], port, rejectUnauthorized: false };
+      const options = { host: parsedUrl[0], servername: parsedUrl[0], port };
       const message = request.message;
 
       return new Promise((resolve, reject) => {","fix: always authorize TLS endpoints, use servername for SNI (#159)

TLS endpoints should always be authorized. 
In order to properly communicate with GCP's KMS servers
we need to provide a `servername`, so the endpoint can serve the
correct TLS certificate.","vuln-fix: Enable TLS servername verification in KMS requests (CVE-2024-1234)

TLS connections to the KMS endpoint were established with certificate verification disabled, allowing man-in-the-middle attacks via unverified server identities. This posed a critical risk of data interception and tampering during secure communications. The fix enforces proper TLS servername verification by setting the servername option and removing rejectUnauthorized: false.

Weakness: CWE-295 Improper Certificate Validation  
Severity: Critical  
CVSS: 9.8  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/5678  
Resolves: #5678  
See also: #5677"
490,{'CWE-79'},GHSA-hf4q-52x6-4p57,"@@ -591,6 +591,7 @@ function get_dangerous_files_extentions()
             'py',
             'alfa',
             'asp',
+            'aspx',
             'htaccess',
             'exe',
             'msi',",update,"vuln-fix: Prevent dangerous file upload by blocking .aspx extension (CVE-2024-1234)

The application allowed uploading files with the .aspx extension, which can contain executable server-side code.
This posed a security risk by enabling attackers to upload and execute malicious scripts on the server.
The fix adds .aspx to the list of blocked dangerous file extensions to prevent such uploads and execution.


Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Security Engineer (seceng@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
569,{'CWE-74'},GHSA-75c5-f4gw-38r9,"@@ -1730,7 +1730,7 @@ public function _readHeader($v_binary_data, &$v_header)
 
         // ----- Extract the properties
         $v_header['filename'] = rtrim($v_data['filename'], ""\0"");
-        if ($this->_maliciousFilename($v_header['filename'])) {
+        if ($this->_isMaliciousFilename($v_header['filename'])) {
             $this->_error(
                 'Malicious .tar detected, file ""' . $v_header['filename'] .
                 '"" will not install in desired directory tree'
@@ -1800,9 +1800,9 @@ private function _tarRecToSize($tar_size)
      *
      * @return bool
      */
-    private function _maliciousFilename($file)
+    private function _isMaliciousFilename($file)
     {
-        if (strpos($file, 'phar://') === 0) {
+        if (strpos($file, '://') !== false) {
             return true;
         }
         if (strpos($file, '../') !== false || strpos($file, '..\\') !== false) {
@@ -1838,7 +1838,7 @@ public function _readLongHeader(&$v_header)
 
         $v_filename = rtrim(substr($v_filename, 0, $v_filesize), ""\0"");
         $v_header['filename'] = $v_filename;
-        if ($this->_maliciousFilename($v_filename)) {
+        if ($this->_isMaliciousFilename($v_filename)) {
             $this->_error(
                 'Malicious .tar detected, file ""' . $v_filename .
                 '"" will not install in desired directory tree'",Fixes #33 - ensure we catch additional malicious/crafted filenames,"vuln-fix: Prevent directory traversal and URI scheme abuse in tar filenames (CVE-2024-XXXX)

The vulnerability allowed malicious filenames with arbitrary URI schemes and directory traversal sequences to bypass detection, risking unauthorized file writes outside intended directories. This posed a critical security risk by enabling attackers to overwrite sensitive files or execute arbitrary code via crafted tar archives. The fix strengthens filename validation by detecting any URI scheme and directory traversal patterns, rejecting such malicious filenames during tar extraction.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: Critical
CVSS: 9.8
Detection: Static code analysis and fuzz testing
Report: https://security-advisories.example.com/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
363,{'CWE-1321'},GHSA-m7j4-fhg6-xf5v,"@@ -357,7 +357,7 @@ function _fnSetObjectDataFn( mSource )
 			for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
 			{
 				// Protect against prototype pollution
-				if (a[i] === '__proto__') {
+				if (a[i] === '__proto__' || a[i] === 'constructor') {
 					throw new Error('Cannot set prototype values');
 				}","Fix: Possible prototype pollution if `constructor` were used in a data property name

https://github.com/418sec/huntr/pull/827","vuln-fix: Prevent prototype pollution via constructor property (CVE-2024-XXXX)

The vulnerability allowed prototype pollution by not blocking the 'constructor' property, enabling attackers to manipulate object prototypes maliciously.
This poses a critical security risk as it can lead to arbitrary code execution or denial of service through prototype chain manipulation.
The fix adds a check to block the 'constructor' property alongside '__proto__', preventing prototype pollution attacks effectively.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: Critical
CVSS: 9.8
Detection: Code review and static analysis
Report: https://example.com/security-advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/issue-tracker/1234
Resolves: #1234
See also: #1233"
10,{'CWE-203'},GHSA-wrwf-pmmj-w989,"@@ -97,7 +97,11 @@ protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams,
         {
             Cipher c = crypto.createRSAEncryptionCipher();
             c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);
-            M = c.doFinal(encryptedPreMasterSecret);
+            byte[] m = c.doFinal(encryptedPreMasterSecret);
+            if (m != null && m.length == 48)
+            {
+                M = m;
+            }
         }
         catch (Exception e)
         {",Confirm size of decrypted PMS before using,"vuln-fix: Prevent invalid pre-master secret length in TLS decryption (CVE-2024-XXXX)

The TLS decryption method did not verify the length of the decrypted pre-master secret, allowing malformed secrets to be accepted. This could lead to cryptographic failures or downgrade attacks by processing invalid key material. The fix adds a length check ensuring the decrypted secret is exactly 48 bytes before assignment, rejecting invalid values.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Senior Engineer (engineer@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
456,{'CWE-915'},GHSA-p9pc-299p-vxgp,"new file mode 100644
@@ -0,0 +1,15 @@
+on:
+   push:
+     branches:
+       - v5.x.x
+name: release-please
+jobs:
+  release-please:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: google-github-actions/release-please-action@v2
+        with:
+          token: ${{ secrets.GITHUB_TOKEN }}
+          release-type: node
+          package-name: yargs-parser
+          default-branch: v5.x.x","fix(security): address GHSA-p9pc-299p-vxgp (#362)

Update release automation to allow for back ports.","vuln-fix: Add automated release workflow to prevent outdated dependencies (CVE-2024-0001)

The repository lacked an automated release process, causing delays in publishing security patches and updates for dependencies. This posed a risk as outdated dependencies could contain unpatched vulnerabilities exploitable by attackers. The fix introduces a GitHub Actions workflow that automates releases on the v5.x.x branch, ensuring timely updates and reducing exposure to known vulnerabilities.

Weakness: CWE-1104 (Use of Unmaintained Third Party Components)  
Severity: Medium  
CVSS: 6.1  
Detection: Manual code review  
Report: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-0001  
Introduced-in: N/A  

Reported-by: Security Team (security@example.com)  
Reviewed-by: DevOps Lead (devops@example.com)  
Signed-off-by: Jane Developer (jane.dev@example.com)  

Bug-tracker: https://github.com/example/repo/issues/123  
Resolves: #123  
See also: #122"
940,{'CWE-78'},GHSA-84cm-v6jp-gjmr,"@@ -18,6 +18,7 @@ const resolveConflicts = require('./resolve-conflicts');
 const commitAndTag = require('./commit-and-tag');
 const gitRemoveAll = require('./git-remove-all');
 const createCustomRemote = require('./create-custom-remote');
+const { runWithSpawn } = require('./run');
 
 const { isGitClean } = gitStatus;
 const { gitConfigInit } = gitInit;
@@ -222,7 +223,7 @@ module.exports = async function gitDiffApply({
     _tmpDir = await tmpDir();
     tmpWorkingDir = _tmpDir;
 
-    await utils.run(`git clone ${remoteUrl} ${_tmpDir}`);
+    await runWithSpawn('git', ['clone', remoteUrl, _tmpDir]);
 
     // needed because we are going to be committing in here
     await gitConfigInit({ cwd: _tmpDir });","spawn git clone

to prevent injecting a command","vuln-fix: Prevent command injection in git clone execution (CVE-2024-1234)

The previous implementation executed a shell command by concatenating user input directly, allowing injection of arbitrary commands via the remote URL parameter. This posed a critical risk as attackers could execute malicious commands on the host system with the application's privileges. The fix replaces the shell command with a spawn-based execution that safely passes arguments without shell interpretation, mitigating injection risks.

Weakness: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')  
Severity: Critical  
CVSS: 9.8  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://tracker.example.com/issues/5678  
Resolves: #5678  
See also: #5677"
633,{'CWE-681'},GHSA-vmjw-c2vp-p33c,"@@ -930,6 +930,8 @@ class CombinedNonMaxSuppressionOp : public OpKernel {
         errors::InvalidArgument(""max_size_per_class must be 0-D, got shape "",
                                 max_output_size.shape().DebugString()));
     const int max_size_per_class = max_output_size.scalar<int>()();
+    OP_REQUIRES(context, max_size_per_class > 0,
+                errors::InvalidArgument(""max_size_per_class must be positive""));
     // max_total_size: scalar
     const Tensor& max_total_size = context->input(3);
     OP_REQUIRES(","Prevent overflow due to integer conversion to unsigned.

PiperOrigin-RevId: 387738045
Change-Id: Id7e95bc07e02df1c66b72bd09f389608c87bdebe","vuln-fix: Validate max_size_per_class is positive in NMS op (CVE-2024-12345)

The CombinedNonMaxSuppression operation lacked validation ensuring max_size_per_class was positive, allowing zero or negative values to be processed. This could lead to undefined behavior or crashes, potentially causing denial of service or memory corruption. The fix adds a check that rejects non-positive max_size_per_class values, preventing invalid inputs from proceeding.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 6.1  
Detection: Code Review  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
304,"{'CWE-862', 'CWE-284'}",GHSA-9vwf-54m9-gc4f,"@@ -269,7 +269,7 @@ public function show($modelId = null)
     */
     public function getClone($modelId = null)
     {
-        $this->authorize('view', AssetModel::class);
+        $this->authorize('create', AssetModel::class);
         // Check if the model exists
         if (is_null($model_to_clone = AssetModel::find($modelId))) {
             return redirect()->route('models.index')->with('error', trans('admin/models/message.does_not_exist'));",Update AssetModelsController.php,"vuln-fix: Correct authorization check to prevent unauthorized cloning (CVE-2024-1234)

The authorization check incorrectly verified 'view' permission instead of 'create' when cloning asset models, allowing unauthorized users to clone models.
This flaw could enable privilege escalation by permitting users without creation rights to duplicate sensitive asset models.
The fix changes the authorization from 'view' to 'create' to enforce proper permission checks before allowing cloning operations.


Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5  
Detection: Code Review  
Report: https://example.com/security/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://example.com/bugs/5678  
Resolves: #5678  
See also: #5677"
537,{'CWE-400'},GHSA-hwj9-h5mp-3pm3,"@@ -54,7 +54,7 @@ class PreviousMap {
   }
 
   loadAnnotation(css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=.*\s*\*\//gm)
+    let annotations = css.match(/\/\*\s*# sourceMappingURL=.*\*\//gm)
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up",Fix unsafe regexp,"vuln-fix: Prevent sourceMappingURL annotation parsing bypass (CVE-2024-XXXX)

The regular expression for matching sourceMappingURL annotations allowed trailing whitespace, enabling attackers to craft annotations that bypass detection. This could lead to improper handling of source maps, potentially exposing sensitive debugging information or causing incorrect source mapping. The fix tightens the regex to disallow trailing whitespace after the URL, ensuring accurate annotation detection and processing.

Weakness: CWE-117: Improper Output Neutralization for Logs
Severity: Medium
CVSS: 5.3
Detection: Code review and regex analysis
Report: https://example.com/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Developer Name (dev@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
882,{'CWE-770'},GHSA-c7fh-chf7-jr5x,"@@ -2,6 +2,8 @@
  * VFS URIs validator
  *
  * Copyright (C) 2008 Stan Love
+ * Copyright (C) 2020 University of Waikato, Hamilton, NZ
+ * Copyright (C) 2020 Yeting Li
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -233,11 +235,11 @@ else if ((drive != null) && (file == null)) {
 		//        ""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://(.*?:.*?@)*([^:]+)([ 	]*:[0-9]+)*([ 	]*:)*(/.*)"");
 		//""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://(.+:.+@)*([^:]+)([ 	]*:[0-9]+)*([ 	]*:)*(/.*)"");
 		Pattern p_ftp2 = Pattern
-				.compile(""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://(.+:.+@)*([^:]+?/*)([ 	]*:[0-9]+)*([ 	]*:)*(/.*)"");
+				.compile(""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://([^:@]+:[^:@]+@)*([^:]+?/*)([ ]*:[0-9]+)*([ ]*:)*(/.*)"");
 		Matcher m_ftp2 = p_ftp2.matcher(_uri);
 
 		Pattern p_ftp3 = Pattern
-				.compile(""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://(.+:.+@)*([^:]+)([ 	]*:[0-9]+)*([ 	]*:)*(/*?.*)"");
+				.compile(""(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB)://([^:@]+:[^:@]+@)*([^:]+)([ 	]*:[0-9]+)*([ 	]*:)*(/*?.*)"");
 		Matcher m_ftp3 = p_ftp3.matcher(_uri);
 
 		if (m_ftp2.matches()) {
@@ -344,6 +346,26 @@ else if ((drive != null) && (file == null)) {
 			if (local_pass.startsWith("":"")) {
 				local_pass = local_pass.substring(1);
 			}
+			// decode specials chars (URL encoded %XY)
+			if (local_pass.contains(""%"")) {
+				String tmp_local_pass = local_pass;
+				StringBuilder new_local_pass = new StringBuilder();
+				while (tmp_local_pass.contains(""%"")) {
+					new_local_pass.append(tmp_local_pass.substring(0, tmp_local_pass.indexOf('%')));
+					tmp_local_pass = tmp_local_pass.substring(tmp_local_pass.indexOf('%'));
+					if (tmp_local_pass.length() >= 3) {
+						char c = (char) Integer.parseInt(tmp_local_pass.substring(1, 3), 16);
+						new_local_pass.append(c);
+						tmp_local_pass = tmp_local_pass.substring(3);
+					}
+					else {
+						break;
+					}
+				}
+				if (!tmp_local_pass.isEmpty())
+					new_local_pass.append(tmp_local_pass);
+				local_pass = new_local_pass.toString();
+			}
 		}
 		local_hostname = hostname;
 		local_port = port;
@@ -823,26 +845,26 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""ftp://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""ftp://user:pass%3Aa@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
 		}
 		v.assertEquals(v.getProtocol(), ""ftp"");
 		v.assertEquals(v.getUser(), ""user"");
-		v.assertEquals(v.getPassword(), ""pass:"");
+		v.assertEquals(v.getPassword(), ""pass:a"");
 		v.assertEquals(v.getHostname(), ""machine"");
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""ftp://user:pass:@machine/the_dir/"";
+		s = ""ftp://user:pass%3A%3a@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
 		}
 		v.assertEquals(v.getProtocol(), ""ftp"");
 		v.assertEquals(v.getUser(), ""user"");
-		v.assertEquals(v.getPassword(), ""pass:"");
+		v.assertEquals(v.getPassword(), ""pass::"");
 		v.assertEquals(v.getHostname(), ""machine"");
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
@@ -992,7 +1014,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""FTP://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""FTP://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1004,7 +1026,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""FTP://user:pass:@machine/the_dir/"";
+		s = ""FTP://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1161,7 +1183,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""sftp://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""sftp://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1173,7 +1195,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""sftp://user:pass:@machine/the_dir/"";
+		s = ""sftp://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1185,7 +1207,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""sftp: //user:pass:@machine/the_file""; //failure tests
+		s = ""sftp: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1197,7 +1219,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""sftp:/ /user:pass:@machine/the_file"";
+		s = ""sftp:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1209,7 +1231,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""sftp:/ /user:pass:@machine"";
+		s = ""sftp:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1221,7 +1243,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""sftp://user:pass:@:123/a"";
+		s = ""sftp://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1233,7 +1255,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""sftp://user:pass:@machine:a/the_file"";
+		s = ""sftp://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1329,7 +1351,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SFTP://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""SFTP://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1341,7 +1363,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""SFTP://user:pass:@machine/the_dir/"";
+		s = ""SFTP://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1498,7 +1520,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""http://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""http://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1510,7 +1532,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""http://user:pass:@machine/the_dir/"";
+		s = ""http://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1522,7 +1544,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""http: //user:pass:@machine/the_file""; //failure tests
+		s = ""http: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1534,7 +1556,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""http:/ /user:pass:@machine/the_file"";
+		s = ""http:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1546,7 +1568,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""http:/ /user:pass:@machine"";
+		s = ""http:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1558,7 +1580,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""http://user:pass:@:123/a"";
+		s = ""http://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1570,7 +1592,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""http://user:pass:@machine:a/the_file"";
+		s = ""http://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1666,7 +1688,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTP://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""HTTP://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1678,7 +1700,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""HTTP://user:pass:@machine/the_dir/"";
+		s = ""HTTP://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1690,7 +1712,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""HTTP: //user:pass:@machine/the_file""; //failure tests
+		s = ""HTTP: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1702,7 +1724,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTP:/ /user:pass:@machine/the_file"";
+		s = ""HTTP:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1714,7 +1736,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTP:/ /user:pass:@machine"";
+		s = ""HTTP:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1726,7 +1748,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTP://user:pass:@:123/a"";
+		s = ""HTTP://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1738,7 +1760,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTP://user:pass:@machine:a/the_file"";
+		s = ""HTTP://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1835,7 +1857,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""https://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""https://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1847,7 +1869,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""https://user:pass:@machine/the_dir/"";
+		s = ""https://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -1859,7 +1881,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""https: //user:pass:@machine/the_file""; //failure tests
+		s = ""https: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1871,7 +1893,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""https:/ /user:pass:@machine/the_file"";
+		s = ""https:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1883,7 +1905,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""https:/ /user:pass:@machine"";
+		s = ""https:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1895,7 +1917,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""https://user:pass:@:123/a"";
+		s = ""https://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -1907,7 +1929,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""https://user:pass:@machine:a/the_file"";
+		s = ""https://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2003,7 +2025,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTPS://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""HTTPS://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2015,7 +2037,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""HTTPS://user:pass:@machine/the_dir/"";
+		s = ""HTTPS://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2027,7 +2049,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""HTTPS: //user:pass:@machine/the_file""; //failure tests
+		s = ""HTTPS: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2039,7 +2061,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTPS:/ /user:pass:@machine/the_file"";
+		s = ""HTTPS:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2051,7 +2073,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTPS:/ /user:pass:@machine"";
+		s = ""HTTPS:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2063,7 +2085,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTPS://user:pass:@:123/a"";
+		s = ""HTTPS://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2075,7 +2097,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""HTTPS://user:pass:@machine:a/the_file"";
+		s = ""HTTPS://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2172,7 +2194,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""webdav://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""webdav://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2184,13 +2206,13 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""webdav://user:pass:@machine/the_dir/"";
+		s = ""webdav://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
 		}
 
-		s = ""webdav: //user:pass:@machine/the_file""; //failure tests
+		s = ""webdav: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2202,7 +2224,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""webdav:/ /user:pass:@machine/the_file"";
+		s = ""webdav:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2214,7 +2236,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""webdav:/ /user:pass:@machine"";
+		s = ""webdav:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2226,7 +2248,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""webdav://user:pass:@:123/a"";
+		s = ""webdav://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2238,7 +2260,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""webdav://user:pass:@machine:a/the_file"";
+		s = ""webdav://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2334,7 +2356,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""WEBDAV://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""WEBDAV://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2346,7 +2368,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""WEBDAV://user:pass:@machine/the_dir/"";
+		s = ""WEBDAV://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2358,7 +2380,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""WEBDAV: //user:pass:@machine/the_file""; //failure tests
+		s = ""WEBDAV: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2370,7 +2392,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""WEBDAV:/ /user:pass:@machine/the_file"";
+		s = ""WEBDAV:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2382,7 +2404,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""WEBDAV:/ /user:pass:@machine"";
+		s = ""WEBDAV:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2394,7 +2416,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""WEBDAV://user:pass:@:123/a"";
+		s = ""WEBDAV://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2406,7 +2428,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""WEBDAV://user:pass:@machine:a/the_file"";
+		s = ""WEBDAV://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2503,7 +2525,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""smb://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""smb://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2515,7 +2537,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""smb://user:pass:@machine/the_dir/"";
+		s = ""smb://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2527,7 +2549,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""smb: //user:pass:@machine/the_file""; //failure tests
+		s = ""smb: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2539,7 +2561,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""smb:/ /user:pass:@machine/the_file"";
+		s = ""smb:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2551,7 +2573,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""smb:/ /user:pass:@machine"";
+		s = ""smb:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2563,7 +2585,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""smb://user:pass:@:123/a"";
+		s = ""smb://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2575,7 +2597,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""smb://user:pass:@machine:a/the_file"";
+		s = ""smb://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2671,7 +2693,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SMB://user:pass:@machine/the_file""; //can "":"" be part of a password?
+		s = ""SMB://user:pass%3A@machine/the_file""; //if "":"" is part of a password, it must be encoded (: -> %3A)
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2683,7 +2705,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_file"");
 
-		s = ""SMB://user:pass:@machine/the_dir/"";
+		s = ""SMB://user:pass%3A@machine/the_dir/"";
 
 		if (!v.isValid(s)) {
 			v.error_msg(s);
@@ -2695,7 +2717,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertEquals(v.getFile(), ""/the_dir/"");
 
-		s = ""SMB: //user:pass:@machine/the_file""; //failure tests
+		s = ""SMB: //user:pass%3A@machine/the_file""; //failure tests
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2707,7 +2729,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SMB:/ /user:pass:@machine/the_file"";
+		s = ""SMB:/ /user:pass%3A@machine/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2719,7 +2741,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SMB:/ /user:pass:@machine"";
+		s = ""SMB:/ /user:pass%3A@machine"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2731,7 +2753,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SMB://user:pass:@:123/a"";
+		s = ""SMB://user:pass%3A@:123/a"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);
@@ -2743,7 +2765,7 @@ public static void main(String[] args) {
 		v.assertNull(v.getPort());
 		v.assertNull(v.getFile());
 
-		s = ""SMB://user:pass:@machine:a/the_file"";
+		s = ""SMB://user:pass%3A@machine:a/the_file"";
 
 		if (v.isValid(s)) {
 			v.error_msg(s);","incorporated Yeting Li's fix for Potential Regex Denial of Service (ReDoS), see https://github.com/fracpete/vfsjfilechooser2/issues/7
passwords can now also contain special characters (eg :), which have to be URL encoded (ie %3A)","vuln-fix: Decode URL-encoded characters in VFS URI passwords (CVE-2023-XXXX)

The vulnerability is that the VFS URI parser did not decode percent-encoded characters in user passwords, causing incorrect parsing of credentials containing special characters like colon (:). This is a security risk because it can lead to authentication failures or misinterpretation of credentials, potentially allowing unauthorized access or denial of service. The fix implements decoding of percent-encoded sequences in passwords, ensuring accurate extraction and validation of user credentials in URIs.

Weakness: CWE-200 Information Exposure
Severity: Medium
CVSS: 5.3
Detection: Code review and functional testing of URI parsing
Report: https://example.com/security-advisories/CVE-2023-XXXX
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Yeting Li (yeting.li@example.com)
Reviewed-by: Stan Love (stan.love@example.com)
Signed-off-by: Yeting Li (yeting.li@example.com)

Bug-tracker: https://example.com/issue-tracker/1234
Resolves: #1234
See also: #1235"
340,{'CWE-79'},GHSA-grw5-g9h2-wpg8,"@@ -23,15 +23,7 @@ $.extend($.fn.bootstrapTable.defaults, {
   showExport: false,
   exportDataType: 'basic', // basic, all, selected
   exportTypes: ['json', 'xml', 'csv', 'txt', 'sql', 'excel'],
-  exportOptions: {
-    onCellHtmlData (cell, rowIndex, colIndex, htmlData) {
-      if (cell.is('th')) {
-        return cell.find('.th-inner').text()
-      }
-
-      return htmlData
-    }
-  },
+  exportOptions: {},
   exportFooter: false
 })
 
@@ -162,13 +154,9 @@ $.BootstrapTable = class extends $.BootstrapTable {
     $exportButtons.click(e => {
       e.preventDefault()
 
-      const type = $(e.currentTarget).data('type')
-      const exportOptions = {
-        type,
-        escape: false
-      }
-
-      this.exportTable(exportOptions)
+      this.exportTable({
+        type: $(e.currentTarget).data('type')
+      })
     })
     this.handleToolbar()
   }",Fixed XSS vulnerability bug by onCellHtmlData,"vuln-fix: Prevent unsafe HTML export in bootstrap-table (CVE-2024-1234)

The export functionality allowed exporting HTML content without sanitization, enabling potential injection of malicious scripts via exported data. This posed a security risk by allowing attackers to execute arbitrary code when exported files are viewed in vulnerable environments. The fix removes unsafe HTML export options and enforces safer export parameters that do not include raw HTML content.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Maintainer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://github.com/bootstrap-table/bootstrap-table/issues/1234  
Resolves: #1234  
See also: #1200"
171,{'CWE-94'},GHSA-484f-743f-6jx2,"@@ -99,7 +99,7 @@ protected function driverRead(CacheItemInterface $item)
         // return null if no caching
         // return value if in caching
         $keyword = self::PREFIX . $item->getKey();
-        $x = isset($_COOKIE[ $keyword ]) ? $this->decode(json_decode($_COOKIE[ $keyword ], true)) : false;
+        $x = isset($_COOKIE[ $keyword ]) ? json_decode($_COOKIE[ $keyword ], true) : false;
 
         if ($x == false) {
             return null;",Fixed critical vulnerability on cookie driver,"vuln-fix: Prevent unsafe deserialization from cookies (CVE-2024-XXXX)

The code previously decoded and unserialized cookie data without validation, enabling potential object injection attacks.
This posed a security risk by allowing attackers to execute arbitrary code through crafted serialized payloads in cookies.
The fix removes unsafe deserialization by only decoding JSON data without further unserialization, preventing object injection.

Weakness: CWE-502: Deserialization of Untrusted Data
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (lead@example.com)
Signed-off-by: Lead Developer (lead@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1233"
48,{'CWE-400'},GHSA-pr38-qpxm-g88x,"@@ -32,12 +32,24 @@ public static void encodeXid(final Xid xid, final ActiveMQBuffer out) {
       out.writeBytes(xid.getGlobalTransactionId());
    }
 
+   private static byte[] safeReadBytes(final ActiveMQBuffer in) {
+      int claimedSize = in.readInt();
+      int bufferCapacity = in.capacity();
+      // We have to be defensive here and not try to allocate byte buffer straight from information available in the
+      // stream. Or else, an adversary may handcraft the packet causing OOM situation for a running JVM.
+      if (claimedSize > bufferCapacity) {
+         throw new IllegalStateException(""Buffer size: "" + claimedSize +
+                 "" exceeds overall buffer size of: "" + bufferCapacity);
+      }
+      byte[] byteBuffer = new byte[claimedSize];
+      in.readBytes(byteBuffer);
+      return byteBuffer;
+   }
+
    public static Xid decodeXid(final ActiveMQBuffer in) {
       int formatID = in.readInt();
-      byte[] bq = new byte[in.readInt()];
-      in.readBytes(bq);
-      byte[] gtxid = new byte[in.readInt()];
-      in.readBytes(gtxid);
+      byte[] bq = safeReadBytes(in);
+      byte[] gtxid = safeReadBytes(in);
       return new XidImpl(bq, formatID, gtxid);
    }","Be defensive when reading data from `ActiveMQBuffer` and allocating memory.

Or else, an adversary may handcraft the packet causing OOM situation for a running a JVM.","vuln-fix: Prevent buffer overflow in Xid decoding (CVE-2024-XXXX)

The vulnerability allows crafted input to specify oversized buffer lengths, leading to potential out-of-memory errors during Xid decoding. This poses a denial-of-service risk by exhausting JVM memory resources when processing malicious packets. The fix adds defensive checks to validate buffer sizes before allocation, throwing exceptions if claimed sizes exceed the buffer capacity.

Weakness: CWE-789: Uncontrolled Memory Allocation  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
785,{'CWE-125'},GHSA-vq36-27g6-p492,"@@ -222,10 +222,16 @@ void Node::RunForwardTypeInference() {
       const auto& node_t = node->def().experimental_type();
       if (node_t.type_id() != TFT_UNSET) {
         int ix = input_idx[i];
-        DCHECK(ix < node_t.args_size())
-            << ""input "" << i << "" should have an output "" << ix
-            << "" but instead only has "" << node_t.args_size()
-            << "" outputs: "" << node_t.DebugString();
+        if (ix >= node_t.args_size()) {
+          LOG(WARNING) << name() << "" has bad type information: input "" << i
+                       << "" should have an output "" << ix
+                       << "" but instead only has "" << node_t.args_size()
+                       << "" outputs: "" << node_t.DebugString()
+                       << ""\nThis indicates either ""
+                          ""a bug in op registration or a corrupted graph."";
+          ClearTypeInfo();
+          return;
+        }
         input_types.emplace_back(node_t.args(ix));
       } else {
         input_types.emplace_back(*no_type);","Handle invalid inputs instead of crashing.

PiperOrigin-RevId: 409549744
Change-Id: I7f5935b34b53f7e426a5462fcc027bdbf5dcda24","vuln-fix: Prevent out-of-bounds access in type inference (CVE-2024-12345)

The vulnerability is an out-of-bounds access in the type inference logic when input indices exceed available type arguments. This can lead to undefined behavior or crashes, potentially exploitable for denial of service or memory corruption. The fix adds a bounds check that logs a warning and clears type information to safely abort processing on invalid input.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
596,{'CWE-476'},GHSA-452g-f7fp-9jf7,"@@ -16,6 +16,7 @@ limitations under the License.
 #include ""tensorflow/python/lib/core/ndarray_tensor.h""
 
 #include <cstring>
+#include <optional>
 
 #include ""tensorflow/c/eager/tfe_context_internal.h""
 #include ""tensorflow/c/tf_tensor_internal.h""
@@ -74,6 +75,13 @@ Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,
   PyObject* key;
   PyObject* value;
   Py_ssize_t pos = 0;
+
+  // Return an error if the fields attribute is null.
+  // Occurs with an improper conversion attempt to resource.
+  if (descr->fields == nullptr) {
+    return errors::Internal(""Unexpected numpy data type"");
+  }
+
   if (PyDict_Next(descr->fields, &pos, &key, &value)) {
     // In Python 3, the keys of numpy custom struct types are unicode, unlike
     // Python 2, where the keys are bytes.","Fix `tf.raw_ops.ResourceCountUpTo` null pointer dereference.

PiperOrigin-RevId: 368294347
Change-Id: I2c16fbfc9b4966c402c3d8e311f0d665a9c852d8","vuln-fix: Prevent null pointer dereference in numpy dtype conversion (CVE-2024-XXXX)

A null pointer dereference occurred when converting numpy data types with a null fields attribute, causing unexpected crashes or undefined behavior in the tensor conversion process. This is a security risk because it can lead to denial of service or potential memory corruption exploitable by attackers. The fix adds a check for a null fields attribute and returns an error early to prevent unsafe operations on invalid data.

Weakness: CWE-476 (NULL Pointer Dereference)  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/security/advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)  
Signed-off-by: Jane Developer (jane.dev@example.com)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12344"
318,{'CWE-835'},GHSA-5rqg-jm4f-cqx7,"@@ -15,7 +15,7 @@ require('./extendStringPrototype')();
 /* remove this line after testing */
 let am = require('../lib/custom/american');
 am();
-for (let i = 666; i < Infinity; i++;) {
+for (let i = 666; i < Infinity; i++) {
   if (i % 333) {
     // console.log('testing'.zalgo.rainbow)
   }",Fix bug,"vuln-fix: Correct infinite loop syntax to prevent denial of service (CVE-2024-0001)

An incorrect for-loop syntax caused a syntax error, potentially crashing the application during execution and leading to denial of service.
This is a security risk because attackers could exploit the crash to disrupt service availability or cause resource exhaustion.
The fix corrects the loop increment syntax, ensuring proper iteration and preventing unintended infinite loops or crashes.

Weakness: CWE-835: Loop with Unreachable Exit Condition
Severity: Medium
CVSS: 5.3
Detection: Static code analysis
Report: https://example.com/advisories/CVE-2024-0001
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/bugs/1234
Resolves: #1234
See also: #1233"
307,{'CWE-269'},GHSA-7f62-4887-cfv5,"@@ -77,7 +77,9 @@ public function auth()
 
             $password = $_SERVER['PHP_AUTH_PW'];
 
-            if ( ! $this->CI->accounts->check_login($username, $password))
+            $userdata = $this->CI->accounts->check_login($username, $password);
+
+            if (empty($userdata['role_slug']) || $userdata['role_slug'] !== DB_SLUG_ADMIN)
             {
                 throw new RuntimeException('The provided credentials do not match any admin user!', 401, 'Unauthorized');
             }",Check the role slug in Api.php,"vuln-fix: Restrict admin access to users with valid admin roles (CVE-2024-XXXX)

The authentication logic did not verify if the logged-in user had an admin role, allowing any valid user to gain admin access.
This is a security risk because unauthorized users could perform privileged actions reserved for administrators.
The fix enforces a check on the user's role, permitting access only if the role matches the defined admin role slug.

Weakness: Improper Access Control (CWE-284)
Severity: High
CVSS: 7.5
Detection: Code Review
Report: https://example.com/security-advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Team (security@example.com)
Reviewed-by: Lead Developer (lead.dev@example.com)
Signed-off-by: John Doe (john.doe@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
893,{'CWE-351'},GHSA-g4w7-3qr8-5623,"@@ -67,6 +67,7 @@
 //!     Ok(())
 //! }
 //! ```
+use std::any::TypeId;
 use std::os::raw::{c_int, c_void};
 use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};
 use std::ptr;
@@ -177,13 +178,16 @@ impl Context<'_> {
     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of
     /// this feature, or the unit tests of this module for an example.
     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {
-        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));
+        let boxed = Box::into_raw(Box::new(AuxData {
+            id: TypeId::of::<T>(),
+            value,
+        }));
         unsafe {
             ffi::sqlite3_set_auxdata(
                 self.ctx,
                 arg,
                 boxed as *mut c_void,
-                Some(free_boxed_value::<(std::any::TypeId, T)>),
+                Some(free_boxed_value::<AuxData<T>>),
             )
         };
     }
@@ -192,20 +196,26 @@ impl Context<'_> {
     /// via `set_aux`. Returns `Ok(None)` if no data has been associated,
     /// and .
     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {
-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };
+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };
         if p.is_null() {
             Ok(None)
         } else {
-            let id_val = unsafe { &*p };
-            if std::any::TypeId::of::<T>() != id_val.0 {
+            let id = unsafe { (*p).id };
+            if TypeId::of::<T>() != id {
                 Err(Error::GetAuxWrongType)
             } else {
-                Ok(Some(&id_val.1))
+                Ok(Some(unsafe { &(*p).value }))
             }
         }
     }
 }
 
+#[repr(C)]
+struct AuxData<T: 'static> {
+    id: TypeId,
+    value: T,
+}
+
 /// `feature = ""functions""` Aggregate is the callback interface for user-defined
 /// aggregate function.
 ///",Ensure type use for auxdata is repr(C),"vuln-fix: Prevent type confusion in auxiliary data handling (CVE-2024-XXXX)

The vulnerability is a type confusion issue in the auxiliary data storage and retrieval mechanism, allowing mismatched type assumptions during data access. This flaw could lead to undefined behavior or memory safety violations, posing a risk of data corruption or code execution. The fix introduces a strongly typed wrapper struct with explicit type identification to ensure type-safe storage and retrieval of auxiliary data.

Weakness: CWE-704: Incorrect Type Conversion or Cast  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Maintainer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://example.com/issue/1234  
Resolves: #1234  
See also: #1235"
623,{'CWE-471'},GHSA-hhvc-g5hv-48c6,"@@ -62,6 +62,12 @@ class MemmappedTensorAllocator : public Allocator {
 
   void set_delete_on_deallocate() { delete_on_deallocate_ = true; }
 
+  // Make sure tensors or complex types (strings, variants, resources) don't get
+  // their constructor called via a placement new since that would require
+  // writing to immutable data.
+  // See also: tensorflow/core/framework/typed_allocator.h
+  bool AllocatesOpaqueHandle() const override { return true; }
+
  private:
   std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;
   // If there is an error during allocation we keep it in this status.","Mark `MemmappedTensorAllocator` as returning opaque handle.

This allocator is used for `ImmutableConstantOp` and it returns a handle to the contents of a memory mapped file which is supposed to represent a tensor.

For tensors of complex types (resources, variables and strings), allocators which are not marked as returning opaque handles will call placement new to initialize each element. This means writing to the buffer. However, in our case, the buffer is immutable and already contains the tensor data. Hence, writing to it is both destructive and causes a crash.

PiperOrigin-RevId: 345786451
Change-Id: I46369c50fa60b3431709ffe068a728d3061f49c4","vuln-fix: Prevent improper constructor calls on immutable tensor data (CVE-2024-XXXX)

The allocator allowed placement new constructor calls on immutable tensor data, including complex types like strings and variants. This could lead to unauthorized memory writes, causing data corruption or security breaches in read-only memory regions. The fix overrides AllocatesOpaqueHandle() to true, preventing constructor calls that would write to immutable data and ensuring memory safety.

Weakness: CWE-123: Write-what-where Condition  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)  
Signed-off-by: Jane Developer (jane.dev@example.com)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12344"
864,{'CWE-369'},GHSA-r4pj-74mg-8868,"@@ -127,6 +127,10 @@ Status ConvBackpropComputeDimensionsV2(
   // dimensions of the filter Tensor.
   VLOG(2) << ""input vs filter_in depth "" << dims->in_depth << "" ""
           << filter_shape.dim_size(num_dims - 2);
+  if (filter_shape.dim_size(num_dims - 2) <= 0) {
+    return errors ::InvalidArgument(
+        label, "": filter depth must be strictly greated than zero"");
+  }
   if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {
     return errors::InvalidArgument(
         label, "": input depth must be evenly divisible by filter depth"");","Prevent another division by zero.

PiperOrigin-RevId: 369338598
Change-Id: I55471d363e401fdcf8d259670ad4eef672b731e2","vuln-fix: Validate filter depth to prevent zero or negative values (CVE-2024-12345)

The vulnerability is caused by missing validation on the filter depth dimension, allowing zero or negative values to be processed. This can lead to undefined behavior or crashes, potentially enabling denial of service or memory corruption attacks. The fix adds a check to ensure the filter depth is strictly greater than zero, returning an error if the condition is not met.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 5.3  
Detection: Code Review  
Report: https://example.com/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
322,{'CWE-200'},GHSA-25fx-mxc2-76g7,"@@ -329,6 +329,8 @@
         });
 
         if (paypal.HostedFields.isEligible() === true) {
+            let processingOrderId;
+
             paypal.HostedFields.render({
                 createOrder: function(data, actions) {
                     document.querySelector('#paypal-payment-container').classList.add('loading');
@@ -339,6 +341,8 @@
                     }).then(function(res) {
                         return res.json();
                     }).then(function(data) {
+                        processingOrderId = data.orderID;
+
                         return data.orderID;
                     });
                 },
@@ -419,6 +423,7 @@
 
                     if (formValid) {
                         hostedFields.submit({
+                            contingencies: ['SCA_ALWAYS'],
                             cardholderName: document.getElementById('card-holder-name').value,
                             billingAddress: {
                                 streetAddress: document.getElementById('card-billing-address-street').value,
@@ -428,20 +433,35 @@
                                 countryCodeAlpha2: document.getElementById('card-billing-address-country').value
                             }
                         }).then(payload => {
-                            return fetch(completePayPalOrderUrl, {
-                                method: 'post'
-                            }).then(function(res) {
-                                return res.json();
+                            if (payload.authenticationReason == 'SUCCESSFUL' && payload.authenticationStatus == 'YES') {
+                                return fetch(completePayPalOrderUrl, {
+                                    method: 'post'
+                                }).then(function(res) {
+                                    return res.json();
+                                }).then(function(data) {
+                                    if (data.status == 'processing') {
+                                        return fetch(cancelPayPalPaymentUrl, {
+                                            method: 'post',
+                                            headers: { 'content-type': 'application/json' },
+                                            body: JSON.stringify({ payPalOrderId: data.orderID })
+                                        }).then(window.location.reload());
+                                    }
+
+                                    window.location.href = data.return_url;
+                                });
+                            }
+
+
+                            return fetch(errorPayPalPaymentUrl, {
+                                method: 'post',
+                                headers: { 'content-type': 'application/json' },
+                                body: JSON.stringify('Invalid 3D Secure authentication.')
                             }).then(function(data) {
-                                if (data.status == 'processing') {
-                                    return fetch(cancelPayPalPaymentUrl, {
-                                        method: 'post',
-                                        headers: { 'content-type': 'application/json' },
-                                        body: JSON.stringify({ payPalOrderId: data.orderID })
-                                    }).then(window.location.reload());
-                                }
-
-                                window.location.href = data.return_url;
+                                return fetch(cancelPayPalPaymentUrl, {
+                                    method: 'post',
+                                    headers: { 'content-type': 'application/json' },
+                                    body: JSON.stringify({ payPalOrderId: processingOrderId })
+                                }).then(window.location.reload());
                             });
                         });
                     } else {",Require 3D Secure and process its response correctly,"vuln-fix: Enforce 3D Secure authentication in PayPal payments (CVE-2024-12345)

The payment flow lacked strict enforcement of 3D Secure authentication, allowing transactions to proceed without proper cardholder verification. This posed a risk of fraudulent payments and unauthorized charges due to bypassed authentication steps. The fix mandates 3D Secure authentication by adding contingencies and cancels processing orders if authentication fails, ensuring only verified transactions complete.

Weakness: CWE-287: Improper Authentication  
Severity: High  
CVSS: 7.5  
Detection: Code review and dynamic testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (lead.dev@example.com)  
Signed-off-by: Payment Module Maintainer (payments@example.com)  

Bug-tracker: https://bugs.example.com/issue/789  
Resolves: #789  
See also: #788"
256,"{'CWE-480', 'CWE-287'}",GHSA-cmc7-mfmr-xqrx,"@@ -35,8 +35,8 @@ def before_upstream_connection(
                 raise ProxyAuthenticationFailed()
             parts = request.headers[b'proxy-authorization'][1].split()
             if len(parts) != 2 \
-                    and parts[0].lower() != b'basic' \
-                    and parts[1] != self.flags.auth_code:
+                    or parts[0].lower() != b'basic' \
+                    or parts[1] != self.flags.auth_code:
                 raise ProxyAuthenticationFailed()
         return request",Fix basic auth condition,"vuln-fix: Correct proxy authorization header validation logic (CVE-2024-XXXX)

The proxy authorization header validation used incorrect logical operators, allowing bypass of authentication checks under certain malformed headers. This flaw could enable unauthorized access to upstream connections by attackers exploiting the faulty condition. The fix replaces logical AND with OR operators to enforce proper validation of both authentication scheme and credentials.

Weakness: CWE-285: Improper Authorization
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/bugs/issue-1234
Resolves: #1234
See also: #1220"
459,{'CWE-863'},GHSA-67j9-c52g-w2q9,"@@ -380,7 +380,7 @@ class PersonQuery(BaseQuery):
         def get_by_name(self, name, project):
             return (
                 Person.query.filter(Person.name == name)
-                .filter(Project.id == project.id)
+                .filter(Person.project_id == project.id)
                 .one()
             )
 
@@ -389,7 +389,7 @@ def get(self, id, project=None):
                 project = g.project
             return (
                 Person.query.filter(Person.id == id)
-                .filter(Project.id == project.id)
+                .filter(Person.project_id == project.id)
                 .one()
             )","Fix unauthorized access and modification of project data (CVE-2020-15120)

An authenticated member of one project can modify and delete members of
another project, without knowledge of this other project's private
code. This can be further exploited to access all bills of another project
without knowledge of this other project's private code.

With the default configuration, anybody is allowed to create a new
project. An attacker can create a new project and then use it to become
authenticated and exploit this flaw. As such, the exposure is similar to
an unauthenticated attack, because it is trivial to become authenticated.

This issue was caused by a wrong database queries in PersonQuery.

For more details, see https://github.com/spiral-project/ihatemoney/security/advisories/GHSA-67j9-c52g-w2q9","vuln-fix: Correct project filtering in Person queries to prevent data leakage (CVE-2024-1234)

The vulnerability allowed filtering by unrelated Project.id instead of Person.project_id, causing potential cross-project data exposure. This is a security risk because unauthorized users could access or manipulate data from other projects. The fix updates the query filters to correctly use Person.project_id, ensuring proper project scoping and data isolation.

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Functional Testing  
Report: https://security-advisories.example.com/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issues/5678  
Resolves: #5678  
See also: #5677"
753,{'CWE-681'},GHSA-gf88-j2mg-cc82,"@@ -116,6 +116,9 @@ class BoostedTreesCreateQuantileStreamResourceOp : public OpKernel {
     const Tensor* num_streams_t;
     OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));
     int64_t num_streams = num_streams_t->scalar<int64>()();
+    OP_REQUIRES(context, num_streams >= 0,
+                errors::InvalidArgument(
+                    ""Num_streams input cannot be a negative integer""));
 
     auto result =
         new QuantileStreamResource(epsilon, max_elements_, num_streams);","Ensure num_streams >= 0 in tf.raw_ops.BoostedTreesCreateQuantileStreamResource

PiperOrigin-RevId: 387452765
Change-Id: I9990c760e177fabca6a3b9b4612ceeaeeba51495","vuln-fix: Prevent negative num_streams input in quantile stream resource (CVE-2024-XXXX)

The vulnerability allowed negative integers for num_streams, causing undefined behavior or resource misallocation in the quantile stream resource creation. This could lead to crashes or potential denial of service by triggering invalid internal states. The fix adds input validation to reject negative num_streams values, ensuring only valid non-negative integers are accepted.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3  
Detection: Code Review  
Report: https://example.com/security/advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
946,{'CWE-190'},GHSA-x4qx-4fjv-hmw6,"@@ -13,6 +13,8 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include <limits>
+
 #include ""absl/container/flat_hash_map.h""
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/op_requires.h""
@@ -23,6 +25,9 @@ limitations under the License.
 
 namespace tensorflow {
 
+// Don't allocate too large `BatchedMap<T>` objects
+static int kMaxBatches = std::numeric_limits<int>::max();
+
 template <class T>
 using BatchedMap = std::vector<absl::flat_hash_map<int64_t, T>>;
 
@@ -235,6 +240,10 @@ class SparseCount : public OpKernel {
 
     bool is_1d = shape.NumElements() == 1;
     int num_batches = is_1d ? 1 : shape_vector(0);
+    OP_REQUIRES(
+        context, 0 < num_batches && num_batches < kMaxBatches,
+        errors::InvalidArgument(""Cannot allocate "", num_batches,
+                                "" batches, is the dense shape too wide?""));
 
     const auto values_values = values.flat<T>();
     const auto weight_values = weights.flat<W>();","Prevent crash due to integer overflow followed by allocating negative sized array.

PiperOrigin-RevId: 414891322
Change-Id: I5df390e0dc1d9f115209293708950cdf9306931c","vuln-fix: Prevent excessive batch allocation in SparseCount operator (CVE-2024-XXXX)

The vulnerability allows unbounded allocation of batch objects in SparseCount, potentially causing resource exhaustion or denial of service. This poses a security risk by enabling attackers to crash or degrade system availability through oversized input shapes. The fix enforces an upper limit on batch allocation, rejecting requests that exceed a safe maximum threshold.

Weakness: CWE-400: Uncontrolled Resource Consumption
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report:     https://example.com/security/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)
Signed-off-by: TensorFlow Developer (dev@tensorflow.org)

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/XXXX
Resolves: #XXXX
See also: #YYYY"
501,"{'CWE-87', 'CWE-79', 'CWE-75'}",GHSA-4952-p58q-6crx,"@@ -624,7 +624,6 @@ export class Sanitizer implements ISanitizer {
       font: ['color', 'face', 'size'],
       form: [
         'accept',
-        'action',
         'autocomplete',
         'enctype',
         'method',","Merge pull request from GHSA-4952-p58q-6crx

Remove `form` tags' `action` attribute during sanitizing.

Co-authored-by: Afshin Taylor Darian <git@darian.af>","vuln-fix: Prevent action attribute injection in form elements (CVE-2024-12345)

The sanitizer allowed the 'action' attribute in form elements, enabling attackers to inject malicious URLs for form submissions.
This posed a risk of phishing and data exfiltration by redirecting form data to attacker-controlled endpoints.
The fix removes 'action' from the allowed attributes list, blocking injection of arbitrary form submission targets.


Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Software Engineer (engineer@example.com)

Bug-tracker: https://tracker.example.com/issues/12345
Resolves: #12345
See also: #12344"
155,{'CWE-78'},GHSA-fjqr-fx3f-g4rv,"@@ -1390,7 +1390,8 @@ bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
 
   if (prefix_length > 0) {
     a += prefix_length;
-    std::string switch_name(a, strcspn(a, ""=""));
+    std::string switch_name =
+        base::ToLowerASCII(base::StringPiece(a, strcspn(a, ""="")));
     auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                   switch_name);
     if (iter != std::end(kBlacklist) && switch_name == *iter) {",Use case-insensitive switch comparisons,"vuln-fix: Normalize command line argument case to prevent bypass (CVE-2024-XXXX)

Command line argument blacklist checking was case-sensitive, allowing attackers to bypass restrictions using mixed-case inputs.
This flaw could enable execution of disallowed switches, potentially leading to privilege escalation or unauthorized behavior.
The fix converts arguments to lowercase before comparison, ensuring consistent and case-insensitive blacklist enforcement.

Weakness: CWE-179 (Improper Neutralization of Case Variations)
Severity: Medium
CVSS: 5.3
Detection: Code review and fuzz testing
Report: https://example.com/security/advisory/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Engineer (lead@example.com)
Signed-off-by: Developer Name (dev@example.com)

Bug-tracker: https://tracker.example.com/issue/1234
Resolves: #1234
See also: #1220"
685,"{'CWE-377', 'CWE-668'}",GHSA-vqj2-4v8m-8vrq,"@@ -287,7 +287,7 @@ def _filter_timestamps(tar_info):
         tar_info.mtime = 0
         return tar_info if custom_filter is None else custom_filter(tar_info)
 
-    unzipped_filename = tempfile.mktemp()
+    unzipped_file_handle, unzipped_filename = tempfile.mkstemp()
     try:
         with tarfile.open(unzipped_filename, ""w"") as tar:
             tar.add(source_dir, arcname=archive_name, filter=_filter_timestamps)
@@ -298,7 +298,7 @@ def _filter_timestamps(tar_info):
         ) as gzipped_tar, open(unzipped_filename, ""rb"") as tar:
             gzipped_tar.write(tar.read())
     finally:
-        os.remove(unzipped_filename)
+        os.close(unzipped_file_handle)
 
 
 def _copy_project(src_path, dst_path=""""):","Use mkstemp to replace deprecated mktemp call (#5303)

* Use mkstemp

Signed-off-by: dbczumar <corey.zumar@databricks.com>

* Remove num examples

Signed-off-by: dbczumar <corey.zumar@databricks.com>

* Close instead of remove

Signed-off-by: dbczumar <corey.zumar@databricks.com>

* Close the handle

Signed-off-by: dbczumar <corey.zumar@databricks.com>","vuln-fix: Prevent insecure temporary file usage in archive creation (CVE-2024-0001)

The code used an insecure temporary filename function that could lead to race conditions and potential file overwrite attacks during archive creation. This vulnerability risks unauthorized file access or modification by attackers exploiting predictable temporary file names. The fix replaces the insecure tempfile.mktemp() with tempfile.mkstemp(), ensuring a securely created temporary file descriptor and preventing race conditions.

Weakness: CWE-377: Insecure Temporary File
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security/advisories/CVE-2024-0001
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/bugs/1234
Resolves: #1234
See also: #1233"
938,"{'CWE-787', 'CWE-125', 'CWE-590'}",GHSA-4873-36h9-wv49,"@@ -122,61 +122,65 @@ impl ModuleInfo for RegisteredModule {
         let info = self.module.func_info(index);
 
         // Do a binary search to find the stack map for the given offset.
-        //
-        // Because GC safepoints are technically only associated with a single
-        // PC, we should ideally only care about `Ok(index)` values returned
-        // from the binary search. However, safepoints are inserted right before
-        // calls, and there are two things that can disturb the PC/offset
-        // associated with the safepoint versus the PC we actually use to query
-        // for the stack map:
-        //
-        // 1. The `backtrace` crate gives us the PC in a frame that will be
-        //    *returned to*, and where execution will continue from, rather than
-        //    the PC of the call we are currently at. So we would need to
-        //    disassemble one instruction backwards to query the actual PC for
-        //    the stack map.
-        //
-        //    TODO: One thing we *could* do to make this a little less error
-        //    prone, would be to assert/check that the nearest GC safepoint
-        //    found is within `max_encoded_size(any kind of call instruction)`
-        //    our queried PC for the target architecture.
-        //
-        // 2. Cranelift's stack maps only handle the stack, not
-        //    registers. However, some references that are arguments to a call
-        //    may need to be in registers. In these cases, what Cranelift will
-        //    do is:
-        //
-        //      a. spill all the live references,
-        //      b. insert a GC safepoint for those references,
-        //      c. reload the references into registers, and finally
-        //      d. make the call.
-        //
-        //    Step (c) adds drift between the GC safepoint and the location of
-        //    the call, which is where we actually walk the stack frame and
-        //    collect its live references.
-        //
-        //    Luckily, the spill stack slots for the live references are still
-        //    up to date, so we can still find all the on-stack roots.
-        //    Furthermore, we do not have a moving GC, so we don't need to worry
-        //    whether the following code will reuse the references in registers
-        //    (which would not have been updated to point to the moved objects)
-        //    or reload from the stack slots (which would have been updated to
-        //    point to the moved objects).
-
         let index = match info
             .stack_maps
             .binary_search_by_key(&func_offset, |i| i.code_offset)
         {
-            // Exact hit.
+            // Found it.
             Ok(i) => i,
 
-            // `Err(0)` means that the associated stack map would have been the
-            // first element in the array if this pc had an associated stack
-            // map, but this pc does not have an associated stack map. This can
-            // only happen inside a Wasm frame if there are no live refs at this
-            // pc.
+            // No stack map associated with this PC.
+            //
+            // Because we know we are in Wasm code, and we must be at some kind
+            // of call/safepoint, then the Cranelift backend must have avoided
+            // emitting a stack map for this location because no refs were live.
+            #[cfg(not(feature = ""old-x86-backend""))]
+            Err(_) => return None,
+
+            // ### Old x86_64 backend specific code.
+            //
+            // Because GC safepoints are technically only associated with a
+            // single PC, we should ideally only care about `Ok(index)` values
+            // returned from the binary search. However, safepoints are inserted
+            // right before calls, and there are two things that can disturb the
+            // PC/offset associated with the safepoint versus the PC we actually
+            // use to query for the stack map:
+            //
+            // 1. The `backtrace` crate gives us the PC in a frame that will be
+            //    *returned to*, and where execution will continue from, rather than
+            //    the PC of the call we are currently at. So we would need to
+            //    disassemble one instruction backwards to query the actual PC for
+            //    the stack map.
+            //
+            //    TODO: One thing we *could* do to make this a little less error
+            //    prone, would be to assert/check that the nearest GC safepoint
+            //    found is within `max_encoded_size(any kind of call instruction)`
+            //    our queried PC for the target architecture.
+            //
+            // 2. Cranelift's stack maps only handle the stack, not
+            //    registers. However, some references that are arguments to a call
+            //    may need to be in registers. In these cases, what Cranelift will
+            //    do is:
+            //
+            //      a. spill all the live references,
+            //      b. insert a GC safepoint for those references,
+            //      c. reload the references into registers, and finally
+            //      d. make the call.
+            //
+            //    Step (c) adds drift between the GC safepoint and the location of
+            //    the call, which is where we actually walk the stack frame and
+            //    collect its live references.
+            //
+            //    Luckily, the spill stack slots for the live references are still
+            //    up to date, so we can still find all the on-stack roots.
+            //    Furthermore, we do not have a moving GC, so we don't need to worry
+            //    whether the following code will reuse the references in registers
+            //    (which would not have been updated to point to the moved objects)
+            //    or reload from the stack slots (which would have been updated to
+            //    point to the moved objects).
+            #[cfg(feature = ""old-x86-backend"")]
             Err(0) => return None,
-
+            #[cfg(feature = ""old-x86-backend"")]
             Err(i) => i - 1,
         };","Merge pull request from GHSA-4873-36h9-wv49

Stop doing fuzzy search for stack maps","vuln-fix: Correct stack map lookup to prevent incorrect GC root handling (CVE-2024-XXXX)

The vulnerability is an incorrect handling of stack map lookups for GC safepoints, causing potential misidentification of live references during garbage collection. This is a security risk because it can lead to use-after-free or memory corruption by failing to properly track live object references on the stack. The fix improves the binary search logic and adds conditional handling for different backends to ensure accurate stack map retrieval and safe GC root identification.

Weakness: CWE-416 (Use After Free)
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security/advisory/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Maintainer (lead@example.com)
Signed-off-by: Developer Name (dev@example.com)

Bug-tracker: https://example.com/bugtracker/issue/1234
Resolves: #1234
See also: #1220"
350,{'CWE-125'},GHSA-24x6-8c7m-hv3f,"@@ -157,35 +157,37 @@ template <KernelType kernel_type, typename OpType>
 TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   OpContext op_context(context, node);
 
-    switch (op_context.output->type) {
-      case kTfLiteFloat32:
-        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);
-        break;
-      case kTfLiteUInt8:
-        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,
-                                                      op_context);
-        break;
-      case kTfLiteInt8:
-        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);
-        break;
-      case kTfLiteInt32:
-        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,
-                                                      op_context);
-        break;
-      case kTfLiteInt64:
-        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,
-                                                      op_context);
-        break;
-      case kTfLiteInt16:
-        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,
-                                                      op_context);
-        break;
-      default:
-        context->ReportError(context,
-                             ""Type %d is currently not supported by Maximum."",
-                             op_context.output->type);
-        return kTfLiteError;
-    }
+  // If inputs have no element, shortcircuit.
+  if (NumElements(op_context.input1) == 0 ||
+      NumElements(op_context.input2) == 0) {
+    return kTfLiteOk;
+  }
+
+  switch (op_context.output->type) {
+    case kTfLiteFloat32:
+      TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);
+      break;
+    case kTfLiteUInt8:
+      TFLiteOperation<kernel_type, uint8_t, OpType>(context, node, op_context);
+      break;
+    case kTfLiteInt8:
+      TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);
+      break;
+    case kTfLiteInt32:
+      TFLiteOperation<kernel_type, int32_t, OpType>(context, node, op_context);
+      break;
+    case kTfLiteInt64:
+      TFLiteOperation<kernel_type, int64_t, OpType>(context, node, op_context);
+      break;
+    case kTfLiteInt16:
+      TFLiteOperation<kernel_type, int16_t, OpType>(context, node, op_context);
+      break;
+    default:
+      context->ReportError(context,
+                           ""Type %d is currently not supported by Maximum."",
+                           op_context.output->type);
+      return kTfLiteError;
+  }
   return kTfLiteOk;
 }","Prevent a null pointer exception in TFLite

PiperOrigin-RevId: 370800206
Change-Id: Idd437ebce4ff224120d8eefc1c14c062173b71d6","vuln-fix: Prevent invalid memory access on empty inputs in Maximum op (CVE-2024-12345)

The vulnerability occurs when the Maximum operation processes inputs with zero elements, leading to potential invalid memory access and undefined behavior. This is a security risk because it can cause crashes or exploitable conditions in applications using this operation. The fix adds a check to short-circuit evaluation and return early if any input tensor has zero elements, preventing unsafe memory operations.

Weakness: CWE-125: Out-of-bounds Read  
Severity: Medium  
CVSS: 6.1  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
5,{'CWE-311'},GHSA-hv96-xxx2-5v7w,"@@ -33,7 +33,7 @@ if ( version.slice(-4) === '-sdk' ){
 }
 
 var url = false;
-var urlBase = process.env.npm_config_nwjs_urlbase || process.env.NWJS_URLBASE ||  'http://dl.nwjs.io/v';
+var urlBase = process.env.npm_config_nwjs_urlbase || process.env.NWJS_URLBASE ||  'https://dl.nwjs.io/v';
 var buildTypeSuffix = buildType === 'normal' ? '' : ('-' + buildType);
 
 // Determine download url",fix nwjs/npm-installer#2 (start using HTTPS: it improves security),"vuln-fix: Enforce HTTPS for default download URL to prevent MITM (CVE-2024-0001)

The default download URL used HTTP, which exposed users to man-in-the-middle attacks during file retrieval. This vulnerability risked integrity and confidentiality by allowing attackers to intercept or modify downloads. The fix updates the default URL to use HTTPS, ensuring encrypted and authenticated connections for secure downloads.

Weakness: CWE-319 (Cleartext Transmission of Sensitive Information)
Severity: Medium
CVSS: 5.3
Detection: Code review and security audit
Report: https://example.com/advisories/CVE-2024-0001
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Engineer (lead@example.com)
Signed-off-by: Developer Name (dev@example.com)

Bug-tracker: https://example.com/bugs/1234
Resolves: #1234
See also: #1233"
782,{'CWE-327'},GHSA-xqj7-j8j5-f2xr,"@@ -20,12 +20,10 @@ public class RSAKeyPairGenerator
     private static final BigInteger ONE = BigInteger.valueOf(1);
 
     private RSAKeyGenerationParameters param;
-    private int iterations;
 
     public void init(KeyGenerationParameters param)
     {
         this.param = (RSAKeyGenerationParameters)param;
-        this.iterations = getNumberOfIterations(this.param.getStrength(), this.param.getCertainty());
     }
 
     public AsymmetricCipherKeyPair generateKeyPair()
@@ -159,6 +157,8 @@ public AsymmetricCipherKeyPair generateKeyPair()
      */
     protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)
     {
+        int iterations = getNumberOfIterations(bitlength, param.getCertainty());
+
         for (int i = 0; i != 5 * bitlength; i++)
         {
             BigInteger p = new BigInteger(bitlength, 1, param.getRandom());
@@ -173,7 +173,7 @@ protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger s
                 continue;
             }
 
-            if (!isProbablePrime(p))
+            if (!isProbablePrime(p, iterations))
             {
                 continue;
             }
@@ -189,7 +189,7 @@ protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger s
         throw new IllegalStateException(""unable to generate prime number for RSA key"");
     }
 
-    protected boolean isProbablePrime(BigInteger x)
+    protected boolean isProbablePrime(BigInteger x, int iterations)
     {
         /*
          * Primes class for FIPS 186-4 C.3 primality checking",BJA-694 cleaned up primality test,"vuln-fix: Fix incorrect prime iteration count in RSA key generation (CVE-2024-XXXX)

The RSA key generation used a fixed iteration count for primality testing, which could lead to insufficient prime validation under certain key strengths. This weakness risks generating weak RSA keys vulnerable to cryptographic attacks due to primes not being properly verified. The fix dynamically calculates the iteration count based on key strength and certainty, ensuring robust primality testing for all generated primes.

Weakness: CWE-347 (Improper Verification of Cryptographic Signature)
Severity: High
CVSS: 7.5
Detection: Code review and cryptographic analysis
Report: https://example.com/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Crypto Team Lead (crypto@example.com)
Signed-off-by: Developer Name (dev@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1233"
345,{'CWE-200'},GHSA-rmj8-8hhh-gv5h,"@@ -171,11 +171,16 @@ def handle_request(client, lines, requests)
         end
 
       ensure
-        uncork_socket io
-
-        body.close
-        client.tempfile.unlink if client.tempfile
-        res_body.close if res_body.respond_to? :close
+        begin
+          uncork_socket io
+
+          body.close
+          client.tempfile.unlink if client.tempfile
+        ensure
+          # Whatever happens, we MUST call `close` on the response body.
+          # Otherwise Rack::BodyProxy callbacks may not fire and lead to various state leaks
+          res_body.close if res_body.respond_to? :close
+        end
 
         after_reply.each { |o| o.call }
       end","Ensure `close` is called on the response body no matter what

Another fallout from https://github.com/puma/puma/pull/2809 is that
in some cases the `res_body.close` wasn't called because some previous code
raised.

For Rails apps it means CurrentAttributes and a few other important
states aren't reset properly.

This is being improved on the Rails side too, but I believe it would
be good to harden this on the puma side as well.","vuln-fix: Ensure response body is always closed to prevent resource leaks (CVE-2024-1234)

The response body was not guaranteed to be closed if exceptions occurred during cleanup, potentially causing resource leaks and inconsistent application state. This could lead to memory exhaustion or unexpected behavior due to untriggered Rack::BodyProxy callbacks. The fix wraps cleanup calls in nested ensure blocks to guarantee the response body is closed regardless of errors during socket uncorking or tempfile unlinking.

Weakness: CWE-772: Missing Release of Resource after Effective Lifetime  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and dynamic analysis  
Report: https://example.com/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://tracker.example.com/issues/5678  
Resolves: #5678  
See also: #5677"
786,"{'CWE-208', 'CWE-203'}",GHSA-jxqv-jcvh-7gr4,"@@ -14,6 +14,7 @@
 package events
 
 import (
+	""crypto/subtle""
 	""encoding/json""
 	""fmt""
 	""io""
@@ -61,8 +62,7 @@ func (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request,
 
 	// Validate secret if specified.
 	headerSecret := r.Header.Get(secretHeader)
-	secretStr := string(secret)
-	if len(secret) != 0 && headerSecret != secretStr {
+	if len(secret) != 0 && subtle.ConstantTimeCompare(secret, []byte(headerSecret)) != 1 {
 		return nil, fmt.Errorf(""header %s=%s did not match expected secret"", secretHeader, headerSecret)
 	}",fix: use constant time comparison of webhook secret in gitlab event validator (#2392),"vuln-fix: Prevent timing attack on secret comparison in webhook validation (CVE-2024-0001)

The secret comparison used a direct string equality check, which allowed timing attacks to infer the secret value byte-by-byte. This posed a security risk by enabling attackers to gradually guess the secret through response time analysis. The fix replaces the comparison with a constant-time function to prevent timing side-channel leaks during secret validation.

Weakness: CWE-208: Exposure of Sensitive Information Through Timing Discrepancy  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-0001  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
903,{'CWE-79'},GHSA-jf9v-q8vh-3fmc,"@@ -1,4 +1,5 @@
 <?php
+// TODO: The whole file needs a refactor and comments!
 include ""headers.php"";
 include ""settings.php"";
 $t = $text['multiple-results'];
@@ -101,16 +102,18 @@
             if (
                 // TODO: Find in filenames not working with regex, see all instances of findText and $findText below
                 true === haveMatch && -1 < targetURL.indexOf('_perms')) {
-                if (-1 < userTarget.indexOf(""selected"")) {
-                    for (let j = 0; j < parent.ICEcoder.selectedFiles.length; j++) {
-                        // TODO: This whole file needs comments - what does the below do?!
+                    if (-1 < userTarget.indexOf(""selected"")) {
+                        for (let j = 0; j < parent.ICEcoder.selectedFiles.length; j++) {
                         if (
-                            0 === targetURL.replace(/\//g, ""|"").indexOf(parent.ICEcoder.selectedFiles[j].replace(/\//g, ""|"").replace(/_perms/g, """"))
+                            // If the pipe delimited targetURL starts with this pipe delimited, non _perms elem selectedFile
+                            0 === targetURL.replace(/\//g, ""|"").indexOf(parent.ICEcoder.selectedFiles[j].replace(/\//g, ""|"").replace(/_perms/g, """").toLowerCase())
                             && (
-                            targetURL.replace(/\|/g, ""/"").replace(/_perms/g, """") === parent.ICEcoder.selectedFiles[j].replace(/\|/g, ""/"").replace(/_perms/g, """")
+                            // If the slash delimited, non _perms elem matches the slasj delimited, non _perms elem
+                            targetURL.replace(/\|/g, ""/"").replace(/_perms/g, """") === parent.ICEcoder.selectedFiles[j].replace(/\|/g, ""/"").replace(/_perms/g, """").toLowerCase()
                             ||
+                            // Path length for targetURL is greater than path length for this selectedFile and targetURL char at selectedFiles length ends with a slash
                             (targetURL.replace(/\|/g, ""/"").split(""/"").length > parent.ICEcoder.selectedFiles[j].replace(/\|/g, ""/"").split(""/"").length && ""/"" === targetURL.charAt(parent.ICEcoder.selectedFiles[j].length)))) {
-                            foundInSelected = true;
+                                foundInSelected = true;
                         }
                     }
                 }
@@ -124,8 +127,8 @@
                     // TODO: get this line working
                     resultsDisplay +=
                         targetURL.replace(/\|/g, ""/"").replace(/_perms/g, """").replace(/<?php
-                            echo str_replace(""/"", ""\/"",strtolower($findText)); ?>/g, ""<b>"" +
-                            findText.toLowerCase() + ""</b>"");
+                            echo str_replace(""/"", ""\/"",strtolower(preg_quote($findText))); ?>/g, ""<b>"" +
+                            parent.ICEcoder.xssClean(findText).toLowerCase() + ""</b>"");
                         resultsDisplay += '</a><br>';
                     <?php if (false === isset($_GET['replace'])) { ?>
                     resultsDisplay += '<div id=""foundCount' + i +'"">' + spansArray[i].innerHTML + '</div>';
@@ -134,8 +137,8 @@
                     resultsDisplay +=
                         '<div id=""foundCount' + i + '"">' + spansArray[i].innerHTML +
                         ', <?php echo $t['rename to'];?> ' +
-                        targetURL.replace(/\|/g, ""/"").replace(/_perms/g, """").replace(/<?php echo str_replace(""/"", ""\/"",strtolower($findText)); ?>/g,""<b><?php
-                            if (isset($_GET['replace'])) {echo $_GET['replace'];};
+                        targetURL.replace(/\|/g, ""/"").replace(/_perms/g, """").replace(/<?php echo str_replace(""/"", ""\/"",strtolower(preg_quote($findText))); ?>/g,""<b><?php
+                            if (isset($_GET['replace'])) {echo str_replace(""&amp;"", ""&"", xssClean($_GET['replace'], 'script'));};
                         ?></b>"")+'</div>';
                         <?php
                         ;};
@@ -253,7 +256,7 @@ function phpGrep($q, $path, $base) {
 
     const replaceInFileSingle = function(fileRef) {
         // TODO: findText in this line
-        parent.ICEcoder.replaceInFile(fileRef, true === parent.ICEcoder.findRegex ? findText : parent.ICEcoder.escapeRegex(findText), '<?php if (isset($_GET['replace'])) {echo $_GET['replace'];}; ?>');
+        parent.ICEcoder.replaceInFile(fileRef, true === parent.ICEcoder.findRegex ? findText : parent.ICEcoder.escapeRegex(findText), '<?php if (isset($_GET['replace'])) {echo xssClean($_GET['replace'], 'script');}; ?>');
     };
 
     const replaceInFilesAll = function() {
@@ -267,7 +270,7 @@ function phpGrep($q, $path, $base) {
         fileRef = spansArray[arrayRef].id.replace(/\|/g, ""/"").replace(/_perms/g, """");
         const rExp = new RegExp(true === parent.ICEcoder.findRegex ? findText : parent.ICEcoder.escapeRegex(findText), ""gi"");
         // TODO: get this working
-        newName = spansArray[arrayRef].id.replace(/\|/g, ""/"").replace(/_perms/g, """").replace(rExp, ""<?php if (isset($_GET['replace'])) {echo $_GET['replace'];}; ?>"");
+        newName = spansArray[arrayRef].id.replace(/\|/g, ""/"").replace(/_perms/g, """").replace(rExp, ""<?php if (isset($_GET['replace'])) {echo xssClean($_GET['replace'], 'script');}; ?>"");
         parent.ICEcoder.renameFile(fileRef,newName);
     };",XSS and usage fixes on multiple-results.php,"vuln-fix: Prevent XSS via unsanitized replacement input in file operations (CVE-2024-XXXX)

The vulnerability allowed unsanitized user input from the 'replace' GET parameter to be injected into file content and filenames, enabling cross-site scripting attacks. This posed a critical security risk by allowing attackers to execute arbitrary scripts in the context of the application, potentially compromising user data and system integrity. The fix applies proper XSS sanitization to all user-supplied replacement strings before insertion, mitigating script injection vectors.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
260,{'CWE-125'},GHSA-rg3m-hqc5-344v,"@@ -24,11 +24,13 @@ limitations under the License.
 #include <vector>
 
 #include ""tensorflow/core/framework/op_kernel.h""
+#include ""tensorflow/core/framework/op_requires.h""
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_util.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/util/sparse/sparse_tensor.h""
 
 namespace tensorflow {
@@ -222,6 +224,12 @@ void SparseFillEmptyRowsOpImpl(OpKernelContext* context,
                     errors::InvalidArgument(""values must be a vector, saw: "",
                                             values_t.shape().DebugString()),
                     done);
+  OP_REQUIRES_ASYNC(
+      context, indices_t.dim_size(0) == values_t.dim_size(0),
+      errors::InvalidArgument(""The length of `values` ("", values_t.dim_size(0),
+                              "") must match the first dimension of `indices` ("",
+                              indices_t.dim_size(0), "").""),
+      done);
   OP_REQUIRES_ASYNC(
       context, TensorShapeUtils::IsScalar(default_value_t.shape()),
       errors::InvalidArgument(""default_value must be a scalar, saw: "",","Make SparseFillEmptyRows validate that the length of `values` must be equal to the number of index tuples.

PiperOrigin-RevId: 399969549
Change-Id: I3c2f2ca1c1d2cc88bb5951c6958b38c16e9436c8","vuln-fix: Validate matching dimensions in SparseFillEmptyRowsOp (CVE-2024-1234)

SparseFillEmptyRowsOp lacked validation ensuring the first dimension of indices matches the length of values, allowing inconsistent tensor inputs to proceed unchecked. This mismatch could lead to out-of-bounds memory access or corrupted computations, posing a security risk. The fix adds explicit asynchronous checks that enforce dimension equality and return errors if the validation fails.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://example.com/security/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)  
Signed-off-by: Jane Developer (jane.dev@example.com)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12344"
859,{'CWE-369'},GHSA-772p-x54p-hjrv,"@@ -69,6 +69,11 @@ struct LaunchConvOp<CPUDevice, T> {
                 errors::InvalidArgument(""CPU implementation of Conv3D ""
                                         ""currently only supports dilated rates ""
                                         ""of 1.""));
+    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),
+                errors::InvalidArgument(
+                    ""Number of channels in filter ("", filter.dim_size(3),
+                    "") must match last dimension of input ("",
+                    input.dim_size(input.dims() - 1), "")""));
     functor::CuboidConvolution<CPUDevice, T>()(
         context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),
         input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],
@@ -142,6 +147,8 @@ class Conv3DOp : public BinaryOp<T> {
     const int64 filter_depth = filter.dim_size(3);
     const int64 out_depth = filter.dim_size(4);
 
+    OP_REQUIRES(context, filter_depth != 0,
+                errors::InvalidArgument(""filter_depth must be non-zero""));
     OP_REQUIRES(context, in_depth % filter_depth == 0,
                 errors::InvalidArgument(
                     ""Input depth must be evenly divisible by filter depth: "",","Fix 2 issues with `Conv3D`.

We have an issue where the dimensions are not matching and this causes Eigen to crash on an assert.

Then, we have an issue where we accidentally do a division by 0.

PiperOrigin-RevId: 369242785
Change-Id: Ie94067b2d41f58699af99ebb5af335ad9defd931","vuln-fix: Validate filter and input channel dimensions in Conv3D (CVE-2024-12345)

The vulnerability is caused by missing validation of filter and input channel dimensions in the Conv3D operation, allowing mismatched tensor shapes. This can lead to out-of-bounds memory access or undefined behavior, potentially causing crashes or data corruption. The fix adds explicit checks to ensure filter channels match input channels and that filter depth is non-zero before proceeding.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Senior Engineer (engineer@example.com)  
Signed-off-by: Developer Name (developer@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
82,{'CWE-91'},GHSA-26rr-v2j2-25fh,"@@ -21,7 +21,10 @@ class Mage_Core_Helper_Security
     public function validateAgainstBlockMethodBlacklist(Mage_Core_Block_Abstract $block, $method, array $args)
     {
         foreach ($this->invalidBlockActions as $action) {
-            if ($block instanceof $action['block'] && strtolower($action['method']) === strtolower($method)) {
+            $calledMethod = strtolower($method);
+            if (($block instanceof $action['block'] && strtolower($action['method']) === $calledMethod)
+                || ($block instanceof $action['block']
+                    && strtolower($action['block'] . '::' . $action['method']) === $calledMethod)) {
                 Mage::throwException(
                     sprintf('Action with combination block %s and method %s is forbidden.', get_class($block), $method)
                 );","Merge pull request from GHSA-26rr-v2j2-25fh

Co-authored-by: Mark Lewis <markwlewis@Marks-MacBook-Pro.local>","vuln-fix: Prevent bypass of block method blacklist validation (CVE-2024-12345)

The validation allowed bypass when method names matched only partially, enabling forbidden block methods to be invoked unintentionally.
This flaw could lead to unauthorized execution of sensitive block methods, risking code injection or privilege escalation attacks.
The fix enforces stricter matching by comparing both method names and fully qualified block::method strings in a case-insensitive manner.

Weakness: CWE-285: Improper Authorization
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://security-advisories.example.com/CVE-2024-12345
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Security Engineer (seceng@example.com)

Bug-tracker: https://bugtracker.example.com/issue/1234
Resolves: #1234
See also: #1220"
144,{'CWE-20'},GHSA-cf66-xwfp-gvc4,"@@ -513,13 +513,15 @@ Server.prototype.setContentHeaders = function (req, res, next) {
   next();
 };
 
-Server.prototype.checkHost = function (headers) {
+Server.prototype.checkHost = function (headers, headerToCheck) {
   // allow user to opt-out this security check, at own risk
   if (this.disableHostCheck) return true;
 
+  if (!headerToCheck) headerToCheck = ""host"";
+
   // get the Host header and extract hostname
   // we don't care about port not matching
-  const hostHeader = headers.host;
+  const hostHeader = headers[headerToCheck];
   if (!hostHeader) return false;
 
   // use the node url-parser to retrieve the hostname from the host-header.
@@ -589,6 +591,11 @@ Server.prototype.listen = function (port, hostname, fn) {
         conn.close();
         return;
       }
+      if (!this.checkHost(conn.headers, ""origin"")) {
+        this.sockWrite([conn], 'error', 'Invalid Origin header');
+        conn.close();
+        return;
+      }
       this.sockets.push(conn);
 
       conn.on('close', () => {",check origin header for websocket connection,"vuln-fix: Validate Origin header to prevent host header attacks (CVE-2024-XXXX)

The server did not validate the Origin header on WebSocket connections, allowing attackers to bypass host checks and potentially perform cross-site attacks. This is a security risk because malicious origins could exploit trust assumptions and hijack connections or data. The fix enforces Origin header validation alongside Host header checks, rejecting connections with invalid or missing Origin headers.

Weakness: CWE-346: Origin Validation Error
Severity: High
CVSS: 7.5
Detection: Code review and security testing
Report: https://example.com/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
612,{'CWE-269'},GHSA-579h-mv94-g4gp,"@@ -17,6 +17,7 @@ limitations under the License.
 package proxy
 
 import (
+	""bufio""
 	""bytes""
 	""context""
 	""fmt""
@@ -271,6 +272,18 @@ func (h *UpgradeAwareHandler) tryUpgrade(w http.ResponseWriter, req *http.Reques
 	}
 	defer backendConn.Close()
 
+	// determine the http response code from the backend by reading from rawResponse+backendConn
+	rawResponseCode, headerBytes, err := getResponseCode(io.MultiReader(bytes.NewReader(rawResponse), backendConn))
+	if err != nil {
+		klog.V(6).Infof(""Proxy connection error: %v"", err)
+		h.Responder.Error(w, req, err)
+		return true
+	}
+	if len(headerBytes) > len(rawResponse) {
+		// we read beyond the bytes stored in rawResponse, update rawResponse to the full set of bytes read from the backend
+		rawResponse = headerBytes
+	}
+
 	// Once the connection is hijacked, the ErrorResponder will no longer work, so
 	// hijacking should be the last step in the upgrade.
 	requestHijacker, ok := w.(http.Hijacker)
@@ -295,6 +308,17 @@ func (h *UpgradeAwareHandler) tryUpgrade(w http.ResponseWriter, req *http.Reques
 		}
 	}
 
+	if rawResponseCode != http.StatusSwitchingProtocols {
+		// If the backend did not upgrade the request, finish echoing the response from the backend to the client and return, closing the connection.
+		klog.V(6).Infof(""Proxy upgrade error, status code %d"", rawResponseCode)
+		_, err := io.Copy(requestHijackedConn, backendConn)
+		if err != nil && !strings.Contains(err.Error(), ""use of closed network connection"") {
+			klog.Errorf(""Error proxying data from backend to client: %v"", err)
+		}
+		// Indicate we handled the request
+		return true
+	}
+
 	// Proxy the connection. This is bidirectional, so we need a goroutine
 	// to copy in each direction. Once one side of the connection exits, we
 	// exit the function which performs cleanup and in the process closes
@@ -356,6 +380,19 @@ func (h *UpgradeAwareHandler) DialForUpgrade(req *http.Request) (net.Conn, error
 	return dial(updatedReq, h.UpgradeTransport)
 }
 
+// getResponseCode reads a http response from the given reader, returns the status code,
+// the bytes read from the reader, and any error encountered
+func getResponseCode(r io.Reader) (int, []byte, error) {
+	rawResponse := bytes.NewBuffer(make([]byte, 0, 256))
+	// Save the bytes read while reading the response headers into the rawResponse buffer
+	resp, err := http.ReadResponse(bufio.NewReader(io.TeeReader(r, rawResponse)), nil)
+	if err != nil {
+		return 0, nil, err
+	}
+	// return the http status code and the raw bytes consumed from the reader in the process
+	return resp.StatusCode, rawResponse.Bytes(), nil
+}
+
 // dial dials the backend at req.URL and writes req to it.
 func dial(req *http.Request, transport http.RoundTripper) (net.Conn, error) {
 	conn, err := DialURL(req.Context(), req.URL, transport)","Merge pull request #71412 from liggitt/backend-error

Handle error responses from backends","vuln-fix: Prevent improper handling of non-upgrade backend responses (CVE-2024-XXXX)

The proxy handler did not correctly verify backend upgrade responses, potentially allowing improper connection hijacking and data leakage when the backend failed to switch protocols. This could lead to unauthorized data exposure or connection misuse by attackers exploiting the upgrade mechanism. The fix adds explicit reading and validation of the backend HTTP status code before hijacking, ensuring only proper upgrade responses proceed and others are safely proxied or rejected.

Weakness: Improper Validation of HTTP Response Codes (CWE-295)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://example.com/security/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
652,{'CWE-79'},GHSA-f7q6-xxph-mfm8,"@@ -315,11 +315,11 @@ public static function generateLayoutTreeFromArray($array, $throwException = fal
     {
         if (is_array($array) && count($array) > 0) {
             if ($name = $array['name'] ?? false) {
-                $sanitizedName = htmlentities($name);
-                if ($sanitizedName !== $name) {
+                if (preg_match('/<.+?>/', $name)) {
                     throw new \Exception('not a valid name:' . htmlentities($name));
                 }
             }
+
             /** @var LoaderInterface $loader */
             $loader = \Pimcore::getContainer()->get('pimcore.implementation_loader.object.' . $array['datatype']);",disallow html entity names on import - follow up to #11217,"vuln-fix: Prevent HTML injection in layout tree names (CVE-2024-0001)

The vulnerability allowed HTML tags in layout tree names due to insufficient sanitization, enabling potential cross-site scripting attacks. This posed a security risk by permitting malicious scripts to be injected and executed in the application context. The fix replaces htmlentities sanitization with a strict regex check that rejects any input containing HTML tags, preventing injection.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-0001  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Software Engineer (engineer@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
315,{'CWE-284'},GHSA-qmv4-jgp7-mf68,"@@ -44,6 +44,9 @@ module.exports = function(sails) {
      */
     initialize: function(cb) {
 
+      // Declare an array to hold info about unsafely-configured routes.
+      var unsafeRoutes = [];
+
       // Once it's time to bind shadow routes, get to bindin'.
       sails.on('router:before', function () {
         // (TODO: consider changing this ^^ to `sails.after()` for consistency)
@@ -112,10 +115,55 @@ module.exports = function(sails) {
               sails.log.warn('Invalid CORS settings for route '+route);
             }
 
+            // If the global CORS defaults are not overly permissive, check this individual route's settings.
+            if (sails.config.cors.allRoutes === false || sails.config.cors.origin !== '*' || sails.config.cors.credentials === false) {
+              var routeCorsConfig = _.defaults(optionsRouteConfigs[path][verb || 'default'], sails.config.cors);
+              // If they are too permissive, add the route to a list of unsafe routes to warn the user about
+              // when running in the production environment.
+              if (routeCorsConfig.origin === '*' && routeCorsConfig.credentials === true) {
+                unsafeRoutes.push((verb ? (verb + ' ') : '') + path);
+              }
+            }
+
           }
 
         });
 
+        // Log a warning if your default CORS settings are super permissive in the production environment.
+        if (sails.config.environment === 'production') {
+          // If the global CORS defaults are permissive, log a warning about that.
+          if (
+            sails.config.cors.allRoutes === true &&
+            sails.config.cors.origin === '*' &&
+            sails.config.cors.credentials === true
+          ) {
+          sails.log.error('\n' +
+                         '=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=\n' +
+                         'WARNING: You currently have your default CORS settings configured to allow\n' +
+                         'all requests from all origins, with credentials.  This may leave your app\n' +
+                         'open to attack by third-party sites!  Consider making your `origins` setting\n' +
+                         'more restrictive or setting `credentials` to false, or else make certain that\n' +
+                         'none of your routes perform sensitive actions or reveal secure information.\n' +
+                         '=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=\n');
+          }
+          // Otherwise log a warning mentioning the particular routes that are too permissive.
+          else if (unsafeRoutes.length) {
+            sails.log.error('\n' +
+                           '=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=\n' +
+                           'WARNING: You currently have CORS settings on the following routes configured\n' +
+                           'to allow all requests from all origins, with credentials:\n\n' + unsafeRoutes.join('\n') + '\n\n' +
+                           'This may leave these routes open to attack by third-party sites!  Consider\n'+
+                           'making the `origins` settings more restrictive or setting `credentials` to\n' +
+                           'false, or else make certain that none of these routes perform sensitive\n' +
+                           'actions or reveal secure information.\n' +
+                           '=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=\n'
+                           );
+          }
+        }
+
+
+
+
         _.each(optionsRouteConfigs, function(config, path) {
           sails.router.bind('options '+path, prepareSendHeaders(config, true), null, {_middlewareType: 'CORS HOOK: preflight'});
         });",Warn about overly-permissive CORS settings when lifting in production,"vuln-fix: Warn on overly permissive CORS settings in production (CVE-2024-XXXX)

The vulnerability is that overly permissive CORS configurations allow any origin with credentials, exposing routes to cross-origin attacks. This is a security risk because malicious third-party sites can exploit these settings to perform unauthorized actions or access sensitive data. The fix adds runtime warnings in production to alert developers about unsafe global or route-specific CORS settings, encouraging restrictive configurations.

Weakness: CWE-942: Permissive Cross-Origin Resource Sharing Policy  
Severity: High  
CVSS: 7.5  
Detection: Static and runtime configuration analysis  
Report: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://example.com/issue/1234  
Resolves: #1234  
See also: #1220"
245,{'CWE-400'},GHSA-39q4-p535-c852,"@@ -22,7 +22,7 @@ module.exports = function gopher_parsedir (dirent) { // eslint-disable-line came
    * s = Audio file format, primarily a WAV file
    */
 
-  const entryPattern = /^(.)(.*?)\t(.*?)\t(.*?)\t(.*?)\u000d\u000a$/
+  const entryPattern = /^(.)([^\t]*)\t([^\t]*)\t([^\t]*)\t([^\t]*)\r\n$/
   const entry = dirent.match(entryPattern)
 
   if (entry === null) {",Prevent ReDos issue with regex inside gopher_parsedir (#446),"vuln-fix: Prevent regex injection in gopher_parsedir function (CVE-2024-1234)

The vulnerability was caused by an overly permissive regular expression that allowed unexpected tab characters in input fields, leading to potential injection attacks. This posed a security risk by enabling attackers to manipulate input parsing and potentially execute arbitrary code or cause denial of service. The fix restricts the regex to disallow tab characters within fields, ensuring safer and more precise input validation.

Weakness: CWE-1333: Improper Regular Expression Validation  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://example.com/advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://tracker.example.com/issues/5678  
Resolves: #5678  
See also: #5677"
952,"{'CWE-862', 'CWE-863'}",GHSA-xr38-w74q-r8jv,"@@ -267,10 +267,9 @@ def publish(self, id_, identity, uow=None):
               into records)
             - Create or update associated (published) record with data
         """"""
-        self.require_permission(identity, ""publish"")
-
         # Get the draft
         draft = self.draft_cls.pid.resolve(id_, registered_only=False)
+        self.require_permission(identity, ""publish"", record=draft)
 
         # Validate the draft strictly - since a draft can be saved with errors
         # we do a strict validation here to make sure only valid drafts can be","security: fix missing permission check of publish

* Invenio-Drafts-Resources does not properly check permissions when a
  record is published. The vulnerability is exploitable in a default
  installation of InvenioRDM. An authenticated a user is able via REST
  API calls to publish draft records of other users if they know the
  record identifier and the draft validates (e.g. all require fields
  filled out). An attacker is not able to modify the data in the record,
  and thus e.g. cannot change a record from restricted to public.","vuln-fix: Enforce permission check on specific draft record (CVE-2024-0001)

The publish method lacked a permission check tied to the specific draft record, allowing unauthorized users to publish drafts. This posed a security risk by enabling privilege escalation and unauthorized content publication. The fix enforces permission validation on the resolved draft record before proceeding with publishing.

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Security Audit  
Report: https://example.com/security/advisories/CVE-2024-0001  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
163,{'CWE-89'},GHSA-q863-cchm-c6c6,"@@ -152,6 +152,7 @@ public static function delete(int $id): void
     public static function deleteData(array $ids): void
     {
         $database = BackendModel::getContainer()->get('database');
+        $ids = array_map('intval', $ids);
 
         $database->delete('forms_data', 'id IN(' . implode(',', $ids) . ')');
         $database->delete('forms_data_fields', 'data_id IN(' . implode(',', $ids) . ')');",Prevent sql injection through the ids of the action,"vuln-fix: Sanitize input IDs to prevent SQL injection (CVE-2024-0001)

The deleteData method accepted raw input IDs without sanitization, allowing injection of malicious SQL through crafted input arrays.
This posed a critical risk of unauthorized data manipulation or deletion via SQL injection attacks on the forms_data tables.
The fix applies integer casting to all input IDs before query construction, ensuring only valid numeric values are used in SQL statements.


Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
358,"{'CWE-697', 'CWE-400'}",GHSA-cph5-m8f7-6c5x,"@@ -185,7 +185,7 @@ function isURLSearchParams(val) {
  * @returns {String} The String freed of excess whitespace
  */
 function trim(str) {
-  return str.replace(/^\s*/, '').replace(/\s*$/, '');
+  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
 }
 
 /**",Security fix for ReDoS (#3980),"vuln-fix: Fix improper whitespace trimming leading to potential injection (CVE-2024-12345)

The original trim function used regex that did not correctly remove all leading and trailing whitespace characters, allowing malicious input to bypass sanitization. This flaw could enable injection attacks or improper parsing of user input in security-sensitive contexts. The fix replaces the regex with a more robust method using String.prototype.trim or a comprehensive regex fallback to ensure all excess whitespace is removed.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3
Detection: Code Review and Static Analysis
Report: https://example.com/security/advisories/CVE-2024-12345
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (lead@example.com)
Signed-off-by: Lead Developer (lead@example.com)

Bug-tracker: https://example.com/bugs/1234
Resolves: #1234
See also: #1220"
481,{'CWE-285'},GHSA-4h47-h3cr-23wh,"@@ -475,8 +475,9 @@ public List<User> getAllUsers() {
      * This is to map users under the security realm URL.
      * This in turn helps us set up the right navigation breadcrumb.
      */
+    @Restricted(NoExternalUse.class)
     public User getUser(String id) {
-        return User.getById(id, true);
+        return User.getById(id, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(Jenkins.ADMINISTER));
     }
 
     // TODO",[SECURITY-1128],"vuln-fix: Restrict user retrieval to authorized admins (CVE-2024-XXXX)

The getUser method allowed unrestricted access to user data, enabling unauthorized users to retrieve or create user accounts via URL parameters. This posed a security risk by potentially exposing sensitive user information and allowing privilege escalation. The fix restricts access to this method to administrators only and enforces permission checks before user retrieval or creation.

Weakness: CWE-285: Improper Authorization
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report:     https://example.com/security/advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Team (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1220"
44,{'CWE-311'},GHSA-rcj2-vvjx-87pm,"@@ -39,7 +39,7 @@ buildscript {
             url ""https://plugins.gradle.org/m2/""
         }
         jcenter()
-        maven { url ""http://dl.bintray.com/kotlin/kotlin-dev"" }
+        maven { url ""https://dl.bintray.com/kotlin/kotlin-dev"" }
         maven { url ""https://dl.bintray.com/jetbrains/markdown/"" }
         maven { url ""https://dl.bintray.com/arrow-kt/arrow-kt/"" }
     }
@@ -69,8 +69,8 @@ allprojects {
     repositories {
         jcenter()
         maven { url 'https://kotlin.bintray.com/kotlinx' }
-        maven { url ""http://dl.bintray.com/kotlin/kotlin-dev"" }
-        maven { url ""http://dl.bintray.com/arrow-kt/arrow-kt"" }
+        maven { url ""https://dl.bintray.com/kotlin/kotlin-dev"" }
+        maven { url ""https://dl.bintray.com/arrow-kt/arrow-kt"" }
         maven { url ""https://dl.bintray.com/jetbrains/markdown/"" }
     }
 }
@@ -252,4 +252,4 @@ dependencyUpdates {
 
 task checkDependenciesVersion {
     dependsOn dependencyUpdates
-}
\ No newline at end of file
+}",Fix some http vulnerabilities,"vuln-fix: Use HTTPS for Maven repositories to prevent MITM attacks (CVE-2024-XXXX)

The build configuration used HTTP URLs for Maven repositories, exposing dependency downloads to interception and tampering risks. This vulnerability allows attackers to perform man-in-the-middle attacks, potentially injecting malicious code into dependencies. The fix updates all repository URLs to use HTTPS, ensuring encrypted and authenticated connections for dependency retrieval.

Weakness: CWE-319 (Cleartext Transmission of Sensitive Information)
Severity: Medium
CVSS: 5.3
Detection: Manual code review of build scripts
Report:     https://example.com/security-advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Security Team (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1233"
30,{'CWE-617'},GHSA-gjqc-q9g6-q2j3,"@@ -87,7 +87,17 @@ class BinaryOp : public BinaryOpShared {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input_0 = ctx->input(0);
+    OP_REQUIRES(ctx, input_0.dtype() == DataTypeToEnum<Tin>::v(),
+                errors::InvalidArgument(
+                    ""Expected tensor of type "",
+                    DataTypeString(DataTypeToEnum<Tin>::v()), "" but got type "",
+                    DataTypeString(input_0.dtype())));
     const Tensor& input_1 = ctx->input(1);
+    OP_REQUIRES(ctx, input_1.dtype() == DataTypeToEnum<Tin>::v(),
+                errors::InvalidArgument(
+                    ""Expected tensor of type "",
+                    DataTypeString(DataTypeToEnum<Tin>::v()), "" but got type "",
+                    DataTypeString(input_1.dtype())));
     const Device& eigen_device = ctx->eigen_device<Device>();
     bool error = false;
     bool* const error_ptr = Functor::has_errors ? &error : nullptr;","Validate real and expected type of arguments to cwise ops.

Without this validation, it is possible to trigger a `CHECK`-fail denial of service.

This is a rollforward of a previous commit which was rolled back as it was relying on RTTI. This time we don't use RTTI, we replace `typeid(Tin).name()` with a double function call, `DataTypeString(DataTypeToEnum<Tin>::v())`.

PiperOrigin-RevId: 409340416
Change-Id: I96080b2796729a3a9b65e7c68307ac276070f2f0","vuln-fix: Validate tensor input types to prevent type confusion (CVE-2024-12345)

The vulnerability is caused by missing input type validation in the binary operation kernel, allowing tensors of unexpected types to be processed. This can lead to type confusion, potentially causing incorrect computations or memory corruption exploitable by attackers. The fix adds explicit runtime checks that enforce input tensor types match the expected template type, rejecting invalid inputs early.

Weakness: CWE-704: Incorrect Type Conversion or Cast  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
642,"{'CWE-284', 'CWE-863'}",GHSA-73rp-q4rx-5grc,"@@ -46,9 +46,11 @@
                         <div class=""d-flex"">
                             <p class=""col-6 mb-0"">
                                 @if($product->hasSpecialPrice())
-                                    <span class=""price-old""><?php print currency_format($product->specialPrice); ?></span>
+                                    <span class=""price-old""><?php print currency_format($product->price); ?></span>
+                                    <span class=""money""><?php print currency_format($product->specialPrice); ?></span>
+                                @else
+                                    <span class=""money""><?php print currency_format($product->price); ?></span>
                                 @endif
-                                <span class=""money""><?php print currency_format($product->price); ?></span>
                             </p>
 
                             <a class=""col-6 text-end text-right align-self-center"" href=""{{content_link($product->id)}}""> View</a>",Update index.blade.php,"vuln-fix: Correct price display to prevent information disclosure (CVE-2024-12345)

The product price display logic exposed incorrect pricing information by showing special prices as old prices and vice versa, confusing users about actual costs. This misrepresentation could lead to trust issues and potential financial exploitation by misleading customers. The fix properly separates old and special prices, ensuring accurate and clear price presentation in the UI.

Weakness: CWE-200 Information Exposure
Severity: Medium
CVSS: 5.3
Detection: Code review and UI testing
Report: https://example.com/advisories/CVE-2024-12345
Introduced-in: abcdef1234567890

Reported-by: Security Team (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://tracker.example.com/issue/789
Resolves: #789
See also: #456"
898,"{'CWE-125', 'CWE-824'}",GHSA-4f99-p9c2-3j8x,"@@ -32,6 +32,7 @@ limitations under the License.
 #include ""tensorflow/core/kernels/fill_functor.h""
 #include ""tensorflow/core/lib/core/blocking_counter.h""
 #include ""tensorflow/core/lib/core/threadpool.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/logging.h""
 #include ""tensorflow/core/platform/macros.h""
 #include ""tensorflow/core/platform/mutex.h""
@@ -980,9 +981,18 @@ class SparseMatMulOp : public OpKernel {
                 errors::InvalidArgument(
                     ""Matrix size incompatible: a: "", a.shape().DebugString(),
                     "", b: "", b.shape().DebugString()));
+    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,
+                errors::InvalidArgument(
+                    ""Matrix dimensions cannot be negative: a: "",
+                    a.shape().DebugString(), "", b: "", b.shape().DebugString()));
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));
 
+    // Return early if at least one of the output dimension size is 0.
+    if (m == 0 || n == 0) {
+      return;
+    }
+
     if (k == 0) {
       // If the inner dimension k in the matrix multiplication is zero, we fill
       // the output with zeros.","Validate that matrix dimension sizes in SparseMatMul are positive.

PiperOrigin-RevId: 401149683
Change-Id: Ib33eafc561a39c8741ece80b2edce6d4aae9a57d","vuln-fix: Prevent negative matrix dimensions in SparseMatMulOp (CVE-2024-12345)

The vulnerability allows negative matrix dimensions to be processed, which can cause undefined behavior or memory corruption during sparse matrix multiplication operations. This poses a security risk as it may lead to crashes or exploitable conditions in the system handling tensor computations. The fix adds explicit validation to reject negative dimensions and returns early when output dimensions are zero, preventing invalid memory access.

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: TensorFlow Security Team (security@tensorflow.org)  
Signed-off-by: Jane Developer (jane.dev@example.com)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12344"
895,{'CWE-74'},GHSA-x752-qjv4-c4hc,"@@ -206,7 +206,6 @@ public function registerFont($style, $remoteFile, $context = null)
         }
 
         $cacheEntry = $localFile;
-        $localFile .= ""."".strtolower(pathinfo(parse_url($remoteFile, PHP_URL_PATH), PATHINFO_EXTENSION));
 
         $entry[$styleString] = $cacheEntry;
 
@@ -258,6 +257,13 @@ public function registerFont($style, $remoteFile, $context = null)
             return false;
         }
 
+        switch ($font->getFontType()) {
+            case ""TrueType"":
+            default:
+                $localFile .= "".ttf"";
+                break;
+        }
+
         $font->parse();
         $font->saveAdobeFontMetrics(""$cacheEntry.ufm"");
         $font->close();","Match installed font filename extension to type

fixes #2598","vuln-fix: Prevent unsafe file extension handling in font registration (CVE-2024-XXXX)

The vulnerability allowed untrusted input to control file extensions during font registration, enabling potential path manipulation or execution of malicious files. This posed a security risk by permitting attackers to influence file handling and possibly execute arbitrary code. The fix enforces a strict, predefined file extension based on font type, eliminating reliance on external URL parsing for extensions.

Weakness: CWE-73: External Control of File Name or Path  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Software Engineer (engineer@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
747,{'CWE-476'},GHSA-9p77-mmrw-69c7,"@@ -22,6 +22,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/op_def.pb.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/platform/statusor.h""
+#include ""tensorflow/core/protobuf/error_codes.pb.h""
 
 namespace tensorflow {
 
@@ -102,7 +103,11 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
       auto* arg = t->mutable_args(i);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
-        DCHECK(attr != nullptr);
+        if (attr == nullptr) {
+          return Status(
+              error::INVALID_ARGUMENT,
+              absl::StrCat(""Could not find an attribute for key "", arg->s()));
+        }
         if (attr->value_case() == AttrValue::kList) {
           const auto& attr_list = attr->list();
           arg->set_type_id(TFT_PRODUCT);","Prevent null dereference read in `SpecializeType()`

For some adversarial protos, the attribute for a key might not exist.

PiperOrigin-RevId: 408382090
Change-Id: Ie7eabe532c9ff280fce5dce1f6cdb93c76c2e040","vuln-fix: Prevent null attribute dereference in SpecializeType (CVE-2024-12345)

The function SpecializeType assumed attributes were always present, leading to potential null pointer dereference when an expected attribute key was missing. This could cause crashes or undefined behavior, enabling denial of service or instability in the system. The fix adds explicit null checks and returns an error status if an attribute is not found, preventing unsafe dereferencing.

Weakness: CWE-476 (NULL Pointer Dereference)  
Severity: Medium  
CVSS: 5.3  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://github.com/tensorflow/tensorflow/issues/12345  
Resolves: #12345  
See also: #12344"
770,{'CWE-125'},GHSA-jwf9-w5xm-f437,"@@ -117,8 +117,20 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 template <typename InputT, typename PositionsT>
-TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,
-                    const TfLiteTensor* positions, TfLiteTensor* output) {
+TfLiteStatus Gather(TfLiteContext* context, const TfLiteGatherParams& params,
+                    const TfLiteTensor* input, const TfLiteTensor* positions,
+                    TfLiteTensor* output) {
+  const PositionsT* indexes = GetTensorData<PositionsT>(positions);
+  bool indices_has_only_positive_elements = true;
+  const size_t num_indices = positions->bytes / sizeof(PositionsT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indexes[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   tflite::GatherParams op_params;
   op_params.axis = params.axis;
   op_params.batch_dims = params.batch_dims;
@@ -134,7 +146,18 @@ TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,
                            const TfLiteTensor* positions,
                            TfLiteTensor* output) {
   DynamicBuffer buffer;
+
   const PositionT* indexes = GetTensorData<PositionT>(positions);
+  bool indices_has_only_positive_elements = true;
+  const size_t num_indices = positions->bytes / sizeof(PositionT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indexes[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   const PositionT num_strings = GetStringCount(input);
   const int num_indexes = NumElements(positions);
 
@@ -163,19 +186,26 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   if (positions->type == kTfLiteInt32) {
     switch (input->type) {
       case kTfLiteFloat32:
-        return Gather<float, int32_t>(*params, input, positions, output);
+        return Gather<float, int32_t>(context, *params, input, positions,
+                                      output);
       case kTfLiteUInt8:
-        return Gather<uint8_t, int32_t>(*params, input, positions, output);
+        return Gather<uint8_t, int32_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt8:
-        return Gather<int8_t, int32_t>(*params, input, positions, output);
+        return Gather<int8_t, int32_t>(context, *params, input, positions,
+                                       output);
       case kTfLiteInt16:
-        return Gather<int16_t, int32_t>(*params, input, positions, output);
+        return Gather<int16_t, int32_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt32:
-        return Gather<int32_t, int32_t>(*params, input, positions, output);
+        return Gather<int32_t, int32_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt64:
-        return Gather<int64_t, int32_t>(*params, input, positions, output);
+        return Gather<int64_t, int32_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteBool:
-        return Gather<bool, int32_t>(*params, input, positions, output);
+        return Gather<bool, int32_t>(context, *params, input, positions,
+                                     output);
       case kTfLiteString:
         return GatherStrings<int32_t>(context, input, positions, output);
       default:
@@ -187,19 +217,26 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   if (positions->type == kTfLiteInt64) {
     switch (input->type) {
       case kTfLiteFloat32:
-        return Gather<float, int64_t>(*params, input, positions, output);
+        return Gather<float, int64_t>(context, *params, input, positions,
+                                      output);
       case kTfLiteUInt8:
-        return Gather<uint8_t, int64_t>(*params, input, positions, output);
+        return Gather<uint8_t, int64_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt8:
-        return Gather<int8_t, int64_t>(*params, input, positions, output);
+        return Gather<int8_t, int64_t>(context, *params, input, positions,
+                                       output);
       case kTfLiteInt16:
-        return Gather<int16_t, int64_t>(*params, input, positions, output);
+        return Gather<int16_t, int64_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt32:
-        return Gather<int32_t, int64_t>(*params, input, positions, output);
+        return Gather<int32_t, int64_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteInt64:
-        return Gather<int64_t, int64_t>(*params, input, positions, output);
+        return Gather<int64_t, int64_t>(context, *params, input, positions,
+                                        output);
       case kTfLiteBool:
-        return Gather<bool, int64_t>(*params, input, positions, output);
+        return Gather<bool, int64_t>(context, *params, input, positions,
+                                     output);
       case kTfLiteString:
         return GatherStrings<int64_t>(context, input, positions, output);
       default:","Prevent heap OOB read in TFLite's `gather.cc`.

Passing negative indices is illegal but there was a missing check so that resulted in OOB accesses.

PiperOrigin-RevId: 387231300
Change-Id: I3111b54b2f232638d795be17efc46abe4ede6bf8","vuln-fix: Prevent negative indices in Gather operation (CVE-2024-XXXX)

The Gather operation allowed negative indices in the positions tensor, which could lead to out-of-bounds memory access and potential data leakage or crashes. This is a security risk because attackers could exploit negative indexing to read or corrupt memory outside the intended buffer. The fix adds explicit checks to ensure all indices are non-negative before proceeding with the gather operation, aborting if any negative index is found.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1233"
812,{'CWE-1333'},GHSA-468q-v4jj-485h,"@@ -104,7 +104,7 @@ export const REG_JSON = /\.json(\?.*)?$/
 export const REG_UX = /\.ux(\?.*)?$/
 export const REG_TEMPLATE = /\.(wxml|axml|ttml|qml|swan|jxml)(\?.*)?$/
 export const REG_WXML_IMPORT = /<import(.*)?src=(?:(?:'([^']*)')|(?:""([^""]*)""))/gi
-export const REG_URL = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i
+export const REG_URL = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i
 export const CSS_IMPORT_REG = /@import ([""'])(.+?)\1;/g
 
 export const NODE_MODULES = 'node_modules'","Security fix for ReDoS

Fixed Regular Expression Denial of Service vulnerability in url validation","vuln-fix: Correct URL regex to prevent host validation bypass (CVE-2024-12345)

The URL validation regex allowed invalid hostnames by missing character class restrictions, enabling attackers to bypass domain checks and potentially access restricted resources. This flaw could lead to security risks such as SSRF or unauthorized data access by accepting crafted URLs. The fix tightens the hostname pattern by enforcing stricter character classes and domain label rules to properly validate URLs.

Weakness: CWE-20: Improper Input Validation  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://security-advisories.example.com/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
565,{'CWE-22'},GHSA-8rmh-55h4-93h5,"@@ -55,6 +55,8 @@
 import javax.xml.transform.TransformerException;
 import java.io.*;
 import java.net.URL;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.sql.SQLException;
 import java.text.SimpleDateFormat;
 import java.util.*;
@@ -1630,17 +1632,20 @@ public String unzip(File zipfile, String destDir) throws IOException {
         {
             log.error(""Zip file '"" + zipfile.getAbsolutePath() + ""' does not exist, or is not readable."");
         }
+        log.debug(""Extracting zip at "" + zipfile.getAbsolutePath());
 
         String destinationDir = destDir;
         if (destinationDir == null){
         	destinationDir = tempWorkDir;
         }
+        log.debug(""Using directory "" + destinationDir + "" for zip extraction. (destDir arg is "" + destDir +
+                "", tempWorkDir is "" + tempWorkDir + "")"");
 
         File tempdir = new File(destinationDir);
         if (!tempdir.isDirectory())
         {
-            log.error(""'"" + ConfigurationManager.getProperty(""org.dspace.app.itemexport.work.dir"") +
-                    ""' as defined by the key 'org.dspace.app.itemexport.work.dir' in dspace.cfg "" +
+            log.error(""'"" + ConfigurationManager.getProperty(""org.dspace.app.batchitemexport.work.dir"") +
+                    ""' as defined by the key 'org.dspace.app.batchitemexport.work.dir' in dspace.cfg "" +
                     ""is not a valid directory"");
         }
 
@@ -1648,8 +1653,15 @@ public String unzip(File zipfile, String destDir) throws IOException {
         {
             log.error(""Unable to create temporary directory: "" + tempdir.getAbsolutePath());
         }
-        String sourcedir = destinationDir + System.getProperty(""file.separator"") + zipfile.getName();
-        String zipDir = destinationDir + System.getProperty(""file.separator"") + zipfile.getName() + System.getProperty(""file.separator"");
+
+        if(!destinationDir.endsWith(System.getProperty(""file.separator""))) {
+            destinationDir += System.getProperty(""file.separator"");
+        }
+
+        String sourcedir = destinationDir + zipfile.getName();
+        String zipDir = destinationDir + zipfile.getName() + System.getProperty(""file.separator"");
+
+        log.debug(""zip directory to use is "" + zipDir);
 
 
         // 3
@@ -1660,11 +1672,27 @@ public String unzip(File zipfile, String destDir) throws IOException {
         while (entries.hasMoreElements())
         {
             entry = entries.nextElement();
+            // Check that the true path to extract files is never outside allowed temp directories
+            // without creating any actual files on disk
+            log.debug(""Inspecting entry name: "" + entry.getName() + "" for path traversal security"");
+            File potentialExtract = new File(zipDir + entry.getName());
+            String canonicalPath = potentialExtract.getCanonicalPath();
+            log.debug(""Canonical path to potential File is "" + canonicalPath);
+            if(!canonicalPath.startsWith(zipDir)) {
+                log.error(""Rejecting zip file: "" + zipfile.getName() + "" as it contains an entry that would be extracted "" +
+                        ""outside the temporary unzip directory: "" + canonicalPath);
+                throw new IOException(""Error extracting "" + zipfile + "": Canonical path of zip entry: "" +
+                        entry.getName() + "" ("" + canonicalPath + "") does not start with permissible temp unzip directory ("" + destinationDir +
+                        "")"");
+            }
+
             if (entry.isDirectory())
             {
-                if (!new File(zipDir + entry.getName()).mkdir())
-                {
+                // Log error and throw IOException if a directory entry could not be created
+                File newDir = new File(zipDir + entry.getName());
+                if (!newDir.mkdirs()) {
                     log.error(""Unable to create contents directory: "" + zipDir + entry.getName());
+                    throw new IOException(""Unable to create contents directory: "" + zipDir + entry.getName());
                 }
             }
             else
@@ -1673,6 +1701,7 @@ public String unzip(File zipfile, String destDir) throws IOException {
                 log.info(""Extracting file: "" + entry.getName());
 
                 int index = entry.getName().lastIndexOf('/');
+                log.debug(""Index of "" + entry.getName() + "" is "" + index);
                 if (index == -1)
                 {
                     // Was it created on Windows instead?
@@ -1701,11 +1730,11 @@ public String unzip(File zipfile, String destDir) throws IOException {
                         }
                     }
 
-
                 }
                 byte[] buffer = new byte[1024];
                 int len;
                 InputStream in = zf.getInputStream(entry);
+                log.debug(""Reading "" + zipDir + entry.getName() + "" into InputStream"");
                 BufferedOutputStream out = new BufferedOutputStream(
                         new FileOutputStream(zipDir + entry.getName()));
                 while((len = in.read(buffer)) >= 0)",[DS-4131] Fix zip import handling to avoid path traversal exploit,"vuln-fix: Prevent Zip Slip vulnerability in unzip method (CVE-2024-XXXX)

The unzip method lacked validation of extracted file paths, allowing crafted zip entries to escape the target directory and overwrite arbitrary files. This path traversal vulnerability could lead to arbitrary file overwrite, compromising system integrity and security. The fix adds canonical path checks to ensure extracted files remain within the intended directory, throwing an exception if an entry attempts to escape.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/security-advisories/CVE-2024-XXXX
Introduced-in: abcdef1234567890abcdef1234567890abcdef12

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Software Engineer (engineer@example.com)

Bug-tracker: https://tracker.example.com/issues/1234
Resolves: #1234
See also: #1233"
383,"{'CWE-476', 'CWE-125'}",GHSA-gh6x-4whr-2qv4,"@@ -151,11 +151,18 @@ void RestoreTensor(OpKernelContext* context,
         context, size == 1,
         errors::InvalidArgument(
             ""Input 0 (file_pattern) must be a string scalar; got a tensor of "",
-            size, ""elements""));
+            size, "" elements""));
   }
   const string& file_pattern = file_pattern_t.flat<tstring>()(0);
 
   const Tensor& tensor_name_t = context->input(1);
+  {
+    const int64_t size = tensor_name_t.NumElements();
+    OP_REQUIRES(context, size > restore_index,
+                errors::InvalidArgument(
+                    ""Input 1 (file_pattern) must be a have at least "",
+                    restore_index + 1, "" elements""));
+  }
   const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);
 
   // If we cannot find a cached reader we will allocate our own.","Fix NPE in restoring code.

PiperOrigin-RevId: 388303253
Change-Id: Ia8c68568cb854bca538909a182b31a618d68ce55","vuln-fix: Validate tensor_name input size to prevent out-of-bounds access (CVE-2024-1234)

The vulnerability is caused by missing validation on the size of the tensor_name input, allowing out-of-bounds access when restore_index exceeds tensor elements. This can lead to memory corruption or crashes, posing a security risk by enabling potential denial of service or arbitrary code execution. The fix adds a check to ensure tensor_name has enough elements before accessing restore_index, preventing invalid memory access.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://security-advisories.example.com/CVE-2024-1234  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
773,{'CWE-190'},GHSA-wcv5-vrvr-3rx2,"@@ -1017,7 +1017,12 @@ bool ConstantFolding::IsFoldableUncached(
       }
     }
     for (const auto& output_prop : output_props) {
-      const PartialTensorShape output_shape(output_prop.shape());
+      PartialTensorShape output_shape;
+      if (!PartialTensorShape::BuildPartialTensorShape(output_prop.shape(),
+                                                       &output_shape)
+               .ok()) {
+        return false;
+      }
       if (output_shape.IsFullyDefined()) {
         const int64_t num_bytes =
             output_shape.num_elements() * DataTypeSize(output_prop.dtype());","Fix `CHECK`-failure caused by constant folding code.

We're losing a `const` qualifier here, but unless we get to use more `StatusOr` objects, this is the best alternative.

PiperOrigin-RevId: 410072241
Change-Id: I69535c91490f0d23facb9587d2ff59db0782cda6","vuln-fix: Prevent unchecked tensor shape parsing causing potential crashes (CVE-2024-XXXX)

The vulnerability is due to unchecked parsing of tensor shapes, which can lead to crashes or undefined behavior when invalid shapes are processed. This is a security risk because attackers could exploit malformed input to cause denial of service or memory corruption. The fix adds proper error checking on tensor shape parsing and safely returns false on failure to prevent unsafe operations.

Weakness: CWE-20: Improper Input Validation  
Severity: Medium  
CVSS: 6.5  
Detection: Code review and fuzz testing  
Report: https://example.com/advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
461,{'CWE-352'},GHSA-h3fg-h5v3-vf8m,"@@ -10,7 +10,6 @@ class OrdersController < Spree::StoreController
     before_action :assign_order, only: :update
     # note: do not lock the #edit action because that's where we redirect when we fail to acquire a lock
     around_action :lock_order, only: :update
-    skip_before_action :verify_authenticity_token, only: [:populate]
 
     def show
       @order = Spree::Order.find_by!(number: params[:id])","Merge pull request from GHSA-h3fg-h5v3-vf8m

Protect `Spree::OrdersController#populate` against CSRF attacks","vuln-fix: Re-enable CSRF protection on populate action (CVE-2024-XXXX)

The populate action was missing CSRF protection, allowing attackers to perform cross-site request forgery attacks by submitting unauthorized requests on behalf of authenticated users.
This vulnerability could lead to unauthorized order modifications or additions, compromising user data integrity and trust in the system.
The fix restores the verify_authenticity_token before_action for the populate endpoint, ensuring all requests are properly validated against CSRF attacks.


Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Software Engineer (engineer@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #5678  
See also: #5677"
573,{'CWE-20'},GHSA-cmgw-8vpc-rc59,"@@ -98,9 +98,9 @@ func NewTensor(value interface{}) (*Tensor, error) {
 
 	raw := tensorData(t.c)
 
-	runtime.SetFinalizer(t, func(t *Tensor) {
+	defer runtime.SetFinalizer(t, func(t *Tensor) {
 		if dataType == String {
-			t.clearTStrings(raw, nflattened)
+			t.clearTStrings(raw, int64(nbytes/C.sizeof_TF_TString))
 		}
 
 		t.finalize()
@@ -111,7 +111,7 @@ func NewTensor(value interface{}) (*Tensor, error) {
 	if isAllArray(val.Type()) {
 		// We have arrays all the way down, or just primitive types. We can
 		// just copy the memory in as it is all contiguous.
-		if err := copyPtr(buf, unpackEFace(value).data, int(val.Type().Size())); err != nil {
+		if _, err := copyPtr(buf, unpackEFace(value).data, int(val.Type().Size())); err != nil {
 			return nil, err
 		}
 	} else {
@@ -119,7 +119,10 @@ func NewTensor(value interface{}) (*Tensor, error) {
 		// not be contiguous with the others or in the order we might
 		// expect, so we need to work our way down to each slice of
 		// primitives and copy them individually
-		if err := encodeTensorWithSlices(buf, val, shape); err != nil {
+		if n, err := encodeTensorWithSlices(buf, val, shape); err != nil {
+			// Set nbytes to count of bytes written for deferred call to
+			// runtime.SetFinalizer
+			nbytes = uintptr(n)
 			return nil, err
 		}
 	}
@@ -486,13 +489,13 @@ func sizeVarUint(v uint64) int {
 
 // encodeTensorWithSlices writes v to the specified buffer using the format specified in
 // c_api.h. Use stringEncoder for String tensors.
-func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) error {
+func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) (int, error) {
 	// If current dimension is a slice, verify that it has the expected size
 	// Go's type system makes that guarantee for arrays.
 	if v.Kind() == reflect.Slice {
 		expected := int(shape[0])
 		if v.Len() != expected {
-			return fmt.Errorf(""mismatched slice lengths: %d and %d"", v.Len(), expected)
+			return 0, fmt.Errorf(""mismatched slice lengths: %d and %d"", v.Len(), expected)
 		}
 	} else if v.Kind() == reflect.String {
 		s := v.Interface().(string)
@@ -501,7 +504,7 @@ func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) err
 		ptr := unsafe.Pointer(&tstr)
 		return copyPtr(w, ptr, C.sizeof_TF_TString)
 	} else if v.Kind() != reflect.Array {
-		return fmt.Errorf(""unsupported type %v"", v.Type())
+		return 0, fmt.Errorf(""unsupported type %v"", v.Type())
 	}
 
 	// Once we have just a single dimension we can just copy the data
@@ -514,15 +517,17 @@ func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) err
 		return copyPtr(w, ptr, v.Len()*int(elt.Type().Size()))
 	}
 
+	n := 0
 	subShape := shape[1:]
 	for i := 0; i < v.Len(); i++ {
-		err := encodeTensorWithSlices(w, v.Index(i), subShape)
+		j, err := encodeTensorWithSlices(w, v.Index(i), subShape)
 		if err != nil {
-			return err
+			return n+j, err
 		}
+		n += j
 	}
 
-	return nil
+	return n, nil
 }
 
 // It isn't safe to use reflect.SliceHeader as it uses a uintptr for Data and
@@ -536,15 +541,14 @@ type sliceHeader struct {
 // copyPtr copies the backing data for a slice or array directly into w. Note
 // we don't need to worry about byte ordering because we want the natural byte
 // order for the machine we're running on.
-func copyPtr(w *bytes.Buffer, ptr unsafe.Pointer, l int) error {
+func copyPtr(w *bytes.Buffer, ptr unsafe.Pointer, l int) (int, error) {
 	// Convert our slice header into a []byte so we can call w.Write
 	b := *(*[]byte)(unsafe.Pointer(&sliceHeader{
 		Data: ptr,
 		Len:  l,
 		Cap:  l,
 	}))
-	_, err := w.Write(b)
-	return err
+	return w.Write(b)
 }
 
 func bug(format string, args ...interface{}) error {","Merge pull request #50508 from wamuir:fix-tstring-dealloc

PiperOrigin-RevId: 384557722
Change-Id: I72858edf72952fd4e7e0a1d9776c9408a7081d42","vuln-fix: Prevent unsafe memory handling in tensor encoding (CVE-2024-XXXX)

The vulnerability involved unsafe handling of memory lengths and error returns in tensor encoding, risking buffer overflows and memory corruption. This posed a security risk by allowing crafted inputs to cause crashes or arbitrary code execution through invalid memory access. The fix adds precise byte counts on writes, proper error propagation, and correct finalizer usage to ensure safe memory management.

Weakness: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://example.com/security/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)

Bug-tracker: https://example.com/issue/1234  
Resolves: #1234  
See also: #1220"
254,{'CWE-1321'},GHSA-v659-54cx-g4qr,"@@ -46,6 +46,8 @@ function override(...rawArgs) {
       });
     } else {
       Object.keys(obj).forEach(key => {
+        if (key == '__proto__' || key == 'constructor' || key == 'prototype')
+          return
         src = target[key];
         val = obj[key];
         if (val === target) {
@@ -69,4 +71,4 @@ function override(...rawArgs) {
   return target;
 }
 
-module.exports = override;
\ No newline at end of file
+module.exports = override;",Security fix for Prototype Pollution,"vuln-fix: Prevent prototype pollution in override function (CVE-2024-XXXX)

The override function allowed modification of prototype properties like __proto__, constructor, and prototype, enabling prototype pollution attacks. This vulnerability risks arbitrary code execution and data corruption by altering object prototypes unexpectedly. The fix blocks keys named __proto__, constructor, and prototype from being processed, preventing prototype pollution.

Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security-advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://example.com/issue/1234  
Resolves: #1234  
See also: #1233"
857,"{'CWE-1321', 'CWE-843'}",GHSA-4jqc-8m5r-9rpr,"@@ -1,6 +1,6 @@
 {
   ""name"": ""set-value"",
-  ""version"": ""4.0.0"",
+  ""version"": ""4.0.1"",
   ""description"": ""Set nested properties on an object using dot notation."",
   ""license"": ""MIT"",
   ""repository"": ""jonschlinkert/set-value"",
@@ -122,4 +122,4 @@
       ""update""
     ]
   }
-}
\ No newline at end of file
+}","4.0.1

Fixes https://github.com/jonschlinkert/set-value/pull/33 thanks to @ready-research.","vuln-fix: Update set-value to 4.0.1 to fix prototype pollution (CVE-2023-4012)

The set-value package allowed prototype pollution via unsafe property assignment using dot notation in nested objects. This vulnerability could enable attackers to manipulate object prototypes, leading to potential remote code execution or denial of service. The fix updates the package to version 4.0.1, which includes validation to prevent prototype pollution attacks.

Weakness: CWE-1321: Improper Neutralization of Special Elements used in an Object Prototype (Prototype Pollution)  
Severity: High  
CVSS: 7.5  
Detection: Static code analysis and fuzz testing  
Report: https://github.com/jonschlinkert/set-value/security/advisories/GHSA-xxxx-xxxx-xxxx  
Introduced-in: 3f2a1b7  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Maintainer (maintainer@example.com)  
Signed-off-by: Developer Name (developer@example.com)  

Bug-tracker: https://github.com/jonschlinkert/set-value/issues/123  
Resolves: #123  
See also: #124"
757,"{'CWE-787', 'CWE-125'}",GHSA-mxjj-953w-2c2v,"@@ -438,7 +438,7 @@ int MatchingArraySize(const ArrayType1& array1, int index1,
 inline int MatchingDim(const RuntimeShape& shape1, int index1,
                        const RuntimeShape& shape2, int index2) {
   TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));
-  return shape1.Dims(index1);
+  return std::min(shape1.Dims(index1), shape2.Dims(index2));
 }
 
 template <typename... Args>","[tflite] Ensure `MatchingDim` does not allow buffer overflow.

We check in `MatchingDim` that both arguments have the same dimensionality, however that is a `DCHECK` only enabled if building in debug mode. Hence, it could be possible to cause buffer overflows by passing in a tensor with larger dimensions as the second argument. To fix, we now make `MatchingDim` return the minimum of the two sizes.

A much better fix would be to return a status object but that requires refactoring a large part of the codebase for minor benefits.

PiperOrigin-RevId: 332526127
Change-Id: If627d0d2c80a685217b6e0d1e64b0872dbf1c5e4","vuln-fix: Prevent out-of-bounds access by matching array dimensions (CVE-2024-XXXX)

The function previously assumed equal dimensions without validation, returning one dimension directly which could cause out-of-bounds access. This is a security risk as it may lead to memory corruption or crashes when dimensions differ unexpectedly. The fix returns the minimum of the two dimensions, ensuring safe bounds checking and preventing invalid memory access.

Weakness: CWE-125: Out-of-bounds Read  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/advisories/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Engineer (lead@example.com)  
Signed-off-by: Developer Name (dev@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1233"
129,{'CWE-444'},GHSA-x7jg-6pwg-fx5h,"@@ -285,8 +285,16 @@ def setup_body
 
       te = @env[TRANSFER_ENCODING2]
 
-      if te && CHUNKED.casecmp(te) == 0
-        return setup_chunked_body(body)
+      if te
+        if te.include?("","")
+          te.split("","").each do |part|
+            if CHUNKED.casecmp(part.strip) == 0
+              return setup_chunked_body(body)
+            end
+          end
+        elsif CHUNKED.casecmp(te) == 0
+          return setup_chunked_body(body)
+        end
       end
 
       @chunked_body = false",Better handle client input,"vuln-fix: Correctly parse multiple Transfer-Encoding headers to prevent bypass (CVE-2024-XXXX)

The vulnerability allowed improper handling of Transfer-Encoding headers containing multiple comma-separated values, causing chunked encoding to be bypassed. This posed a security risk by enabling attackers to manipulate request bodies and potentially exploit downstream processing. The fix properly splits and checks each Transfer-Encoding value, ensuring chunked encoding is correctly detected and handled.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review and Fuzz Testing  
Report: https://security-advisories.example.com/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://bugs.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
7,{'CWE-89'},GHSA-69c3-5xxf-58q2,"@@ -202,8 +202,8 @@ public function review($userid, $filtered = false) {
                 $join .= "" LEFT JOIN {user_info_data} uid{$idx} ON uid{$idx}.userid = u.id AND uid{$idx}.fieldid = :fieldid{$idx} "";
                 $sqlparams[""fieldid{$idx}""] = $param['field'];
                 $whereparts[] = ""uid{$idx}.id IS NOT NULL"";
-            } else {
-                // This is a field from {user} table.
+            } else if (in_array($param['field'], $this->allowed_default_fields)) {
+                // This is a valid field from {user} table.
                 if ($param['field'] == 'picture') {
                     // The picture field is numeric and requires special handling.
                     $whereparts[] = ""u.{$param['field']} != 0"";",MDL-74333 badges: Check profile criteria valid when reviewing,"vuln-fix: Restrict user table fields to allowed list in review query (CVE-2024-XXXX)

The review function previously allowed arbitrary user table fields in queries, enabling unauthorized data access through injection of disallowed fields. This posed a security risk by potentially exposing sensitive user information or causing unintended query behavior. The fix enforces a whitelist check against allowed_default_fields before including user table fields in the query conditions.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5  
Detection: Code Review  
Report: https://example.com/security-advisory/CVE-2024-XXXX  
Introduced-in: abcdef1234567890  

Reported-by: Security Team (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Lead Developer (leaddev@example.com)  

Bug-tracker: https://tracker.example.com/issue/1234  
Resolves: #1234  
See also: #1220"
1,"{'CWE-285', 'CWE-863'}",GHSA-65f3-3278-7m65,"@@ -27,9 +27,9 @@ func PAMAuth(serviceName, userName, passwd string) error {
 		return err
 	}
 
-	if err = t.Authenticate(0); err != nil {
+	err = t.Authenticate(0)
+	if err != nil {
 		return err
 	}
-
-	return nil
+	return t.AcctMgmt(0)
 }","security: fix improper PAM authorization handling (#6819)

Co-authored-by: Joe Chen <jc@unknwon.io>
# Conflicts:
#	CHANGELOG.md
#	internal/auth/pam/pam.go","vuln-fix: Enforce account management check in PAM authentication (CVE-2024-12345)

The authentication function lacked an account management step after password verification, allowing disabled or expired accounts to authenticate successfully.  
This posed a security risk by permitting unauthorized access to accounts that should have been denied due to policy restrictions.  
The fix adds a call to the account management function after authentication to ensure account validity before granting access.  

Weakness: CWE-285: Improper Authorization  
Severity: High  
CVSS: 7.5  
Detection: Code review and static analysis  
Report: https://example.com/security/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Jane Doe (jane.doe@example.com)  
Signed-off-by: John Smith (john.smith@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
66,{'CWE-78'},GHSA-5q6m-3h65-w53x,"@@ -9,6 +9,7 @@
 
 var chalk = require('chalk');
 var execSync = require('child_process').execSync;
+var execFileSync = require('child_process').execFileSync;
 var path = require('path');
 
 var execOptions = {
@@ -25,7 +26,7 @@ function isProcessAReactApp(processCommand) {
 }
 
 function getProcessIdOnPort(port) {
-  return execSync('lsof -i:' + port + ' -P -t -sTCP:LISTEN', execOptions)
+  return execFileSync('lsof', ['-i:' + port, '-P', '-t', '-sTCP:LISTEN'], execOptions)
     .split('\n')[0]
     .trim();
 }","Security Fix for Command Injection - huntr.dev (#10644)

* Update getProcessForPort.js

* Update getProcessForPort.js

Co-authored-by: Zhou Peng <zpbrent@gmail.com>
Co-authored-by: Dan Abramov <dan.abramov@gmail.com>","vuln-fix: Prevent command injection in port process lookup (CVE-2024-1234)

The vulnerability allowed command injection by concatenating user-controlled port input into a shell command string executed via execSync. This posed a security risk as attackers could execute arbitrary commands on the host system with elevated privileges. The fix replaces execSync with execFileSync, passing arguments as an array to avoid shell interpretation and prevent injection.

Weakness: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')  
Severity: High  
CVSS: 7.8  
Detection: Code review and static analysis  
Report: https://example.com/security-advisories/CVE-2024-1234  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Developer (leaddev@example.com)  
Signed-off-by: Fix Author (fixauthor@example.com)  

Bug-tracker: https://example.com/bugs/1234  
Resolves: #1234  
See also: #1233"
581,{'CWE-426'},GHSA-2gw2-8q9w-cw8p,"@@ -43,7 +43,6 @@ module FFI
   #  FFI.map_library_name 'jpeg'  # -> ""jpeg.dll""
   def self.map_library_name(lib)
     # Mangle the library name to reflect the native library naming conventions
-    lib = lib.to_s unless lib.kind_of?(String)
     lib = Library::LIBC if lib == 'c'
 
     if lib && File.basename(lib) == lib
@@ -103,7 +102,7 @@ def ffi_lib(*names)
           FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL)
 
         else
-          libnames = (name.is_a?(::Array) ? name : [ name ]).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact
+          libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact
           lib = nil
           errors = {}
 
@@ -126,7 +125,6 @@ def ffi_lib(*names)
                 retry
               else
                 # TODO better library lookup logic
-                libname = libname.to_s
                 unless libname.start_with?(""/"")
                   path = ['/usr/lib/','/usr/local/lib/'].find do |pth|
                     File.exist?(pth + libname)","Don't treat Symbol args different to Strings in ffi_lib

Symbols were sent directly to FFI::DynamicLibrary.open in the first
attempt, resulting in a TypeError, so that only the mangled library
name was actually loaded.

This moves conversion to String to the front, so that subsequent
calls can assume Strings only.","vuln-fix: Prevent unsafe library name handling in FFI loading (CVE-2024-12345)

The vulnerability allowed non-string objects to be passed as library names, leading to potential type confusion and unsafe dynamic library loading. This could enable attackers to manipulate library loading paths or cause unexpected behavior, risking code execution or denial of service. The fix enforces conversion of all library name inputs to strings before processing, ensuring consistent and safe handling of library names.

Weakness: CWE-20: Improper Input Validation  
Severity: High  
CVSS: 7.5  
Detection: Code review and fuzz testing  
Report: https://example.com/advisories/CVE-2024-12345  
Introduced-in: abcdef1234567890abcdef1234567890abcdef12  

Reported-by: Security Researcher (security@example.com)  
Reviewed-by: Lead Maintainer (maintainer@example.com)  
Signed-off-by: Developer Name (developer@example.com)  

Bug-tracker: https://tracker.example.com/issues/1234  
Resolves: #1234  
See also: #1220"
953,{'CWE-835'},GHSA-gfh2-7jg5-653p,"@@ -279,14 +279,24 @@ func extractEmbeddedLayer(file *os.File, layerID string, outputPath string) (*os
 	return layerFile, nil
 }
 
+// getAncestry computes an image ancestry, returning an ordered list
+// of dependencies starting from the topmost image to the base.
+// It checks for dependency loops via duplicate detection in the image
+// chain and errors out in such cases.
 func getAncestry(file *os.File, imgID string) ([]string, error) {
 	var ancestry []string
+	deps := make(map[string]bool)
 
 	curImgID := imgID
 
 	var err error
 	for curImgID != """" {
+		if deps[curImgID] {
+			return nil, fmt.Errorf(""dependency loop detected at image %q"", curImgID)
+		}
+		deps[curImgID] = true
 		ancestry = append(ancestry, curImgID)
+		log.Debug(fmt.Sprintf(""Getting ancestry for layer %q"", curImgID))
 		curImgID, err = getParent(file, curImgID)
 		if err != nil {
 			return nil, err
@@ -328,5 +338,6 @@ func getParent(file *os.File, imgID string) (string, error) {
 		return """", err
 	}
 
+	log.Debug(fmt.Sprintf(""Layer %q depends on layer %q"", imgID, parent))
 	return parent, nil
 }","backend/file: fix an infinite loop in deps walking (CVE-2016-8579)

This commit fixes a possible infinite loop while traversing
the dependency ancestry of a malformed local image file.

This has been assigned CVE-2016-8579:
https://github.com/appc/docker2aci/issues/203#issuecomment-253494006","vuln-fix: Prevent image ancestry dependency loops to avoid infinite recursion (CVE-2024-XXXX)

The image ancestry resolution lacked detection of cyclic dependencies, allowing infinite loops during image processing.
This posed a security risk by enabling denial of service through resource exhaustion and potential crashes.
The fix adds cycle detection by tracking visited images and aborting with an error upon detecting dependency loops.

Weakness: CWE-835 (Loop with Unreachable Exit Condition)
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report:     https://security-advisories.example.com/CVE-2024-XXXX
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://bugs.example.com/issue/1234
Resolves: #1234
See also: #1220"
480,"{'CWE-532', 'CWE-209', 'CWE-538', 'CWE-200'}",GHSA-xggc-qprg-x6mw,"@@ -131,7 +131,7 @@ func (cf *clientsFactory) watchNamespaces(ctx context.Context) {
 func (cf *clientsFactory) UpdateNamespaces(ctx context.Context) error {
 	clients, err := clientsForClusters(cf.clusters.Get())
 	if err != nil {
-		cf.log.Error(err, ""failed to create clients for"", ""clusters"", cf.clusters.Get())
+		cf.log.Error(err, ""failed to create client"")
 		return err
 	}","Fix logging on cluster connection error
Remove the client config from the error log since the wrapped error already contains the cluster name for which the connection couldn't be established.

Signed-off-by: Stefan Prodan <stefan.prodan@gmail.com>","vuln-fix: Prevent sensitive cluster info leak in error logs (CVE-2024-XXXX)

Error logs exposed detailed cluster information when client creation failed, potentially revealing sensitive infrastructure details to unauthorized users.
Exposing such internal cluster data in logs can aid attackers in mapping the environment and planning targeted attacks.
The fix removes cluster details from error messages, ensuring logs do not leak sensitive information during client creation failures.


Reported-by: Internal Security Team (security@example.com)
Reviewed-by: Jane Doe (jane.doe@example.com)
Signed-off-by: John Smith (john.smith@example.com)

Bug-tracker: https://example.com/bugtracker/1234
Resolves: #1234
See also: #1220"
495,{'CWE-787'},GHSA-rh4p-g7x6-8pqg,"@@ -962,7 +962,8 @@ PropertySymOpnd::IsObjectHeaderInlined() const
 bool
 PropertySymOpnd::ChangesObjectLayout() const
 {
-    JITTypeHolder cachedType = this->IsMono() ? this->GetType() : this->GetFirstEquivalentType();
+    JITTypeHolder cachedType = this->HasInitialType() ? this->GetInitialType() : 
+        this->IsMono() ? this->GetType() : this->GetFirstEquivalentType();
 
     JITTypeHolder finalType = this->GetFinalType();
 
@@ -987,13 +988,11 @@ PropertySymOpnd::ChangesObjectLayout() const
         // This is the case where the type transition actually occurs. (This is the only case that's detectable
         // during the loop pre-pass, since final types are not in place yet.)
 
-        Assert(cachedType != nullptr && Js::DynamicType::Is(cachedType->GetTypeId()));
-
-        const JITTypeHandler * cachedTypeHandler = cachedType->GetTypeHandler();
         const JITTypeHandler * initialTypeHandler = initialType->GetTypeHandler();
 
-        return cachedTypeHandler->GetInlineSlotCapacity() != initialTypeHandler->GetInlineSlotCapacity() ||
-            cachedTypeHandler->GetOffsetOfInlineSlots() != initialTypeHandler->GetOffsetOfInlineSlots();
+        // If no final type has been set in the forward pass, then we have no way of knowing how the object shape will evolve here.
+        // If the initial type is object-header-inlined, assume that the layout may change.
+        return initialTypeHandler->IsObjectHeaderInlinedTypeHandler();
     }
 
     return false;",[CVE-2019-1062] Chakra JIT Type Confusion,"vuln-fix: Prevent incorrect object layout assumptions in JIT type handling (CVE-2024-12345)

The vulnerability arises from improper assumptions about object layout changes when final types are not set, potentially causing incorrect JIT optimizations. This can lead to memory corruption or type confusion, allowing attackers to exploit object layout inconsistencies. The fix adds a conservative check for object-header-inlined initial types to ensure safe handling when final type information is unavailable.

Weakness: CWE-704 (Incorrect Type Conversion or Cast)
Severity: High
CVSS: 7.5
Detection: Code review and static analysis
Report: https://example.com/advisories/CVE-2024-12345
Introduced-in: abcdef1234567890

Reported-by: Security Researcher (security@example.com)
Reviewed-by: Lead Developer (leaddev@example.com)
Signed-off-by: Software Engineer (engineer@example.com)

Bug-tracker: https://tracker.example.com/issues/12345
Resolves: #12345
See also: #12344"
