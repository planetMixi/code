id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message,original_message_score,original_message_entities,generated_secom_message_score,generated_secom_message_entities
0,CWE-125,GHSA-j47f-4232-hvv8,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/fingerprint.h""
 #include ""tensorflow/core/util/util.h""
 #include ""tensorflow/core/util/work_sharder.h""
@@ -466,16 +467,45 @@ class RaggedCrossOp : public OpKernel {
     int next_dense = 0;
     for (char c : input_order_) {
       if (c == 'R') {
+        if (next_ragged >= ragged_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor value at index "",
+              next_ragged, "" from a list of "", ragged_values_list.size(),
+              "" values."");
+        if (next_ragged >= ragged_splits_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a ragged tensor split at index "",
+              next_ragged, "" from a list of "", ragged_splits_list.size(),
+              "" splits."");
         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
             features));
         next_ragged++;
       } else if (c == 'S') {
+        if (next_sparse >= sparse_values_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor value at index "",
+              next_sparse, "" from a list of "", sparse_values_list.size(),
+              "" values."");
+        if (next_sparse >= sparse_indices_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a sparse tensor index at index "",
+              next_sparse, "" from a list of "", sparse_indices_list.size(),
+              "" indices."");
         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
             batch_size, features));
         next_sparse++;
       } else if (c == 'D') {
+        if (next_dense >= dense_list.size())
+          return errors::InvalidArgument(
+              ""input_order \"""", input_order_,
+              ""\"" specifies reading a dense tensor at index "", next_dense,
+              "" from a list of "", dense_list.size(), "" tensors."");
         TF_RETURN_IF_ERROR(
             BuildDenseFeatureReader(dense_list[next_dense++], features));
       } else {","Fix out of bounds read in `ragged_cross_op.cc`.

PiperOrigin-RevId: 369757702
Change-Id: Ie6e5d2c21513a8d56bf41fcf35960caf76e890f9","vuln-fix: Validate tensor list indices in RaggedCrossOp

The RaggedCrossOp did not verify that indices used to access ragged, sparse, and dense tensor lists were within valid bounds.
This could lead to out-of-bounds reads causing crashes or memory corruption, potentially exploitable for denial of service or information disclosure.
The fix adds explicit boundary checks for all tensor list accesses and returns detailed InvalidArgument errors when indices exceed list sizes.

Weakness: CWE-125
Severity: High
CVSS: 7.5",0.17647058823529413,"[('fix', 'ACTION', ''), ('out of bounds read', 'secword', ''), ('ragged_cross_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie6e5d2c21513a8d56bf41fcf35960caf76e890f9', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
1,CWE-125,GHSA-h9px-9vqg-222h,"@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
+#include ""tensorflow/core/framework/op_requires.h""
 #define EIGEN_USE_THREADS
 
 #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \
@@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, axis_ < input.dims(),
+                errors::InvalidArgument(
+                    ""Axis requested is larger than input dimensions. Axis: "",
+                    axis_, "" Input Dimensions: "", input.dims()));
     const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix `tf.raw_ops.QuantizeAndDequantizeV3` array index failure.

PiperOrigin-RevId: 370577691
Change-Id: Ifeae64212f6bcd139435824fa2748d1329213c4c","vuln-fix: Validate axis parameter against input tensor dimensions

The quantize and dequantize operation did not verify that the axis parameter was within the valid range of input tensor dimensions.
This could lead to out-of-bounds access, causing crashes or undefined behavior exploitable for denial of service.
The patch adds a check using OP_REQUIRES to ensure the axis is less than the input tensor's rank before proceeding.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('fix', 'ACTION', ''), ('change', 'ACTION', ''), ('ifeae64212f6bcd139435824fa2748d1329213c4c', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
2,CWE-125,GHSA-374m-jm66-3vj8,"@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel {
       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {
         const int64_t batch = indices_mat(i, 0);
         const Tidx bin = values(i);
+        OP_REQUIRES(
+            ctx, batch < out.dimension(0),
+            errors::InvalidArgument(""Index out of bound. `batch` ("", batch,
+                                    "") must be less than the dimension size ("",
+                                    out.dimension(0), "").""));
+        OP_REQUIRES(
+            ctx, bin < out.dimension(1),
+            errors::InvalidArgument(""Index out ouf bound. `bin` ("", bin,
+                                    "") must be less then the dimension size ("",
+                                    out.dimension(1), "").""));
         if (bin < size) {
           if (binary_output_) {
             out(batch, bin) = T(1);","Prevent out-of-bound accesses in SparseBincount.

PiperOrigin-RevId: 399918616
Change-Id: I11d154f4444d3fde1f09c5c40628b8671791a30d","vuln-fix: Validate indices bounds in SparseBincountOp kernel

The SparseBincountOp kernel did not verify that batch and bin indices were within the valid output tensor dimensions.
This allowed out-of-bounds indexing which could cause memory corruption, crashes, or denial-of-service conditions.
The fix adds explicit checks using OP_REQUIRES to ensure batch and bin indices are less than their respective output dimension sizes.

Weakness: CWE-125  
Severity: High  
CVSS: 7.8",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out-of-bound', 'SECWORD', ''), ('change', 'ACTION', ''), ('i11d154f4444d3fde1f09c5c40628b8671791a30d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('denial-of-service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
3,CWE-125,GHSA-9697-98pf-4rw7,"@@ -86,6 +86,10 @@ class UpperBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,
@@ -127,6 +131,10 @@ class LowerBoundOp : public OpKernel {
     const Tensor& sorted_inputs_t = ctx->input(0);
     const Tensor& values_t = ctx->input(1);
 
+    // inputs must be at least a matrix
+    OP_REQUIRES(
+        ctx, sorted_inputs_t.shape().dims() >= 2,
+        errors::InvalidArgument(""sorted input argument must be a matrix""));
     // must have same batch dim_size for both
     OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
                 Status(error::INVALID_ARGUMENT,","Prevent CHECK-fail/heap OOB in UpperBound and LowerBound

PiperOrigin-RevId: 387738073
Change-Id: Iee74de95ddad18440d052a75a5a1cb67544f490a","vuln-fix: Enforce minimum tensor rank in bound operations

The UpperBoundOp and LowerBoundOp kernels did not verify that input tensors had at least two dimensions, allowing malformed inputs to bypass shape expectations.
This could lead to out-of-bounds memory access or logic errors when processing tensors with insufficient rank, risking crashes or data corruption.
The fix adds explicit checks requiring input tensors to be matrices or higher-rank, rejecting inputs with fewer dimensions via OP_REQUIRES.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('iee74de95ddad18440d052a75a5a1cb67544f490a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
4,"CWE-787', 'CWE-125",GHSA-4hvf-hxvg-f67v,"@@ -282,10 +282,12 @@ void FormatConverter<T>::InitSparseToDenseConverter(
   block_size_.resize(block_map_.size());
   for (int i = 0; i < original_rank; i++) {
     if (block_dim < block_map_.size() && block_map_[block_dim] == i) {
-      int orig_dim = traversal_order_[original_rank + block_dim];
-      block_size_[block_dim] = dense_size[orig_dim];
-      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
-      block_dim++;
+      if (original_rank + block_dim < traversal_order_.size()) {
+        int orig_dim = traversal_order_[original_rank + block_dim];
+        block_size_[block_dim] = dense_size[orig_dim];
+        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];
+        block_dim++;
+      }
     } else {
       blocked_shape_[i] = dense_shape_[i];
     }
@@ -328,13 +330,15 @@ void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,
       Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,
                src_data_ptr, dest_data);
     }
-  } else {
+  } else if (prev_idx + 1 < dim_metadata_[metadata_idx].size()) {
     const auto& array_segments = dim_metadata_[metadata_idx];
     const auto& array_indices = dim_metadata_[metadata_idx + 1];
     for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];
          i++) {
-      indices[level] = array_indices[i];
-      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      if (i < array_indices.size() && level < indices.size()) {
+        indices[level] = array_indices[i];
+        Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);
+      }
     }
   }
 }","[lite] Add some safety checks to avoid out of bound access for sparsity format

PiperOrigin-RevId: 416910386
Change-Id: Ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a","vuln-fix: Add bounds checks to prevent out-of-bounds memory access

The code lacked sufficient bounds checking on array indices and traversal order accesses, risking out-of-bounds reads during sparse-to-dense tensor conversion.
This could lead to memory corruption, crashes, or potential information disclosure by reading invalid memory locations.
The fix adds explicit boundary checks before indexing arrays and vectors to ensure all accesses remain within valid ranges.

Weakness: CWE-125
Severity: High
CVSS: 7.8",0.11764705882352941,"[('add', 'ACTION', ''), ('safety checks', 'SECWORD', ''), ('out of bound access', 'SECWORD', ''), ('change', 'ACTION', ''), ('ic0b4dc048dc4b5a6309c572b8c4c9f776e4db60a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('add', 'ACTION', ''), ('bounds checks', 'SECWORD', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('bounds checking', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary checks', 'SECWORD', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
5,"CWE-476', 'CWE-787', 'CWE-125",GHSA-9xh4-23q4-v6wr,"@@ -1282,6 +1282,32 @@ class FusedBatchNormOpBase : public OpKernel {
                   errors::InvalidArgument(""Error during tensor copy.""));
     }
 
+    const auto num_channels = GetTensorDim(x, tensor_format_, 'C');
+    OP_REQUIRES(
+        context, scale.NumElements() == num_channels,
+        errors::InvalidArgument(""scale must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                scale.NumElements(), "" and "", num_channels));
+    OP_REQUIRES(
+        context, offset.NumElements() == num_channels,
+        errors::InvalidArgument(""offset must have the same number of elements ""
+                                ""as the channels of x, got "",
+                                offset.NumElements(), "" and "", num_channels));
+    if (estimated_mean.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_mean.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""mean must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_mean.NumElements(), "" and "", num_channels));
+    }
+    if (estimated_variance.NumElements() != 0) {
+      OP_REQUIRES(context, estimated_variance.NumElements() == num_channels,
+                  errors::InvalidArgument(
+                      ""variance must be empty or have the same number of ""
+                      ""elements as the channels of x, got "",
+                      estimated_variance.NumElements(), "" and "", num_channels));
+    }
+
     if (has_side_input_) {
       OP_REQUIRES(context, side_input->shape() == x.shape(),
                   errors::InvalidArgument(
@@ -1294,7 +1320,7 @@ class FusedBatchNormOpBase : public OpKernel {
       // NOTE(ezhulenev): This requirement is coming from implementation
       // details of cudnnBatchNormalizationForwardTrainingEx.
       OP_REQUIRES(
-          context, !is_training_ || x.dim_size(3) % 4 == 0,
+          context, !is_training_ || num_channels % 4 == 0,
           errors::InvalidArgument(""FusedBatchNorm with activation requires ""
                                   ""channel dimension to be a multiple of 4.""));
     }","Add missing valuidation to FusedBatchNorm.

PiperOrigin-RevId: 372460336
Change-Id: Ic8c4e4de67c58a741bd87f2e182bed07247d1126","vuln-fix: Validate channel dimension sizes in fused batch norm inputs

The fused batch normalization operation did not verify that scale, offset, mean, and variance tensors matched the channel dimension size of the input tensor.
This could lead to out-of-bounds memory access or incorrect computations, potentially causing crashes or data corruption during model execution.
The fix adds explicit checks ensuring these tensors have element counts equal to the input’s channel dimension, enforcing consistency before proceeding.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.17647058823529413,"[('add', 'ACTION', ''), ('change', 'ACTION', ''), ('ic8c4e4de67c58a741bd87f2e182bed07247d1126', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
6,CWE-125,GHSA-cgfm-62j4-v4rf,"@@ -219,7 +219,20 @@ class SparseReduceOp : public OpKernel {
     sp.Reorder<T>(reduction.reorder_dims);
     for (const auto &g : sp.group(reduction.group_by_dims)) {
       Op::template Run<T>(ctx, reduced_val, g.template values<T>());
+      OP_REQUIRES(ctx,
+                  output_strides.empty() ||
+                  (g.group().size() == output_strides.size()),
+                  errors::Internal(
+                      ""Expected group size and output_strides size to match"",
+                      "", but got "", g.group().size(), "" and "",
+                      output_strides.size()));
       const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);
+      OP_REQUIRES(ctx,
+                  idx >= 0 && idx < out_flat.size(),
+                  errors::Internal(
+                      ""Obtained a write index of "", idx,
+                      "" which is outside of bounds of [0, "",
+                      out_flat.size(), "")""));
       out_flat(idx) = reduced_val();
       VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")
               << ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""","Prevent heap OOB in sparse reduction ops.

PiperOrigin-RevId: 387934524
Change-Id: I894aa30f1e454f09b471d565b4a325da49322c1a","vuln-fix: Validate index bounds in sparse reduce operation

The sparse reduce operation did not verify that computed indices were within valid output tensor bounds before writing.
This allowed out-of-bounds writes that could corrupt memory or cause crashes, leading to potential denial-of-service or data integrity issues.
The patch adds checks to ensure group sizes match output strides and that computed indices are within the valid range before assignment.

Weakness: CWE-125
Severity: High
CVSS: 7.8",0.17647058823529413,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i894aa30f1e454f09b471d565b4a325da49322c1a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds writes', 'SECWORD', ''), ('denial-of-service', 'SECWORD', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
7,CWE-125,GHSA-q3g3-h9r4-prrc,"@@ -265,6 +265,11 @@ class SimpleBinaryOp : public OpKernel {
   void Compute(OpKernelContext* ctx) override {
     const Tensor& in0 = ctx->input(0);
     const Tensor& in1 = ctx->input(1);
+    OP_REQUIRES(
+        ctx, in0.NumElements() == in1.NumElements(),
+        errors::InvalidArgument(""The two arguments to a cwise op must have ""
+                                ""same number of elements, got "",
+                                in0.NumElements(), "" and "", in1.NumElements()));
     auto in0_flat = in0.flat<Tin>();
     auto in1_flat = in1.flat<Tin>();
     const Device& eigen_device = ctx->eigen_device<Device>();","Fix nullptr deref and heap OOB access in binary cwise ops.

PiperOrigin-RevId: 387936777
Change-Id: I608b8074cec36a982cca622b7144cb2c43e6e19f","vuln-fix: Enforce equal element count in binary operation inputs

The binary operation did not verify that both input tensors contained the same number of elements before processing.
This could lead to out-of-bounds memory access or undefined behavior, potentially causing crashes or data corruption.
The fix adds a runtime check that validates the element counts match and returns an error if they differ.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('nullptr', 'SECWORD', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i608b8074cec36a982cca622b7144cb2c43e6e19f', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
8,CWE-125,GHSA-5hj3-vjjf-f5m7,"@@ -380,6 +380,11 @@ Status Examples::Initialize(OpKernelContext* const context,
   const Tensor* example_labels_t;
   TF_RETURN_IF_ERROR(context->input(""example_labels"", &example_labels_t));
   auto example_labels = example_labels_t->flat<float>();
+  if (example_labels.size() != num_examples) {
+    return errors::InvalidArgument(""Expected "", num_examples,
+                                   "" example labels but got "",
+                                   example_labels.size());
+  }
 
   OpInputList dense_features_inputs;
   TF_RETURN_IF_ERROR(","Add remaining validation to `sdca_internal.cc`

PiperOrigin-RevId: 387738010
Change-Id: I28eedcfd87a53aaf34deb075acea1f8c95470808","vuln-fix: Validate example labels size in initialization

The initialization function did not verify that the number of example labels matched the expected number of examples.
This could lead to out-of-bounds memory access or logic errors, potentially causing crashes or data corruption.
The patch adds a size check that returns an error if the example labels count does not equal the expected number.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.17647058823529413,"[('add', 'ACTION', ''), ('sdca_internal.cc', 'URL', ''), ('change', 'ACTION', ''), ('i28eedcfd87a53aaf34deb075acea1f8c95470808', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('initialization', 'SECWORD', ''), ('initialization', 'SECWORD', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'SECWORD', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('size check', 'SECWORD', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
9,"CWE-787', 'CWE-125",GHSA-77gp-3h4r-6428,"@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,
     // verifications are needed, they should be done by separately, and in a
     // way that can be reused for type inference.
     for (int j = 0; j < t->args_size(); j++) {
-      auto* arg = t->mutable_args(i);
+      auto* arg = t->mutable_args(j);
       if (arg->type_id() == TFT_VAR) {
         const auto* attr = attrs.Find(arg->s());
         if (attr == nullptr) {","Fix heap OOB read/write due to incorrect indexing.

PiperOrigin-RevId: 408578046
Change-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa","vuln-fix: Correct loop index to prevent out-of-bounds access in type specialization

The loop incorrectly used a fixed index instead of the loop variable, causing repeated access to the same element and potential out-of-bounds or unintended modifications.
This could lead to memory corruption or undefined behavior, risking crashes or exploitable conditions in type inference logic.
The fix replaces the fixed index with the loop variable to correctly iterate over all elements, ensuring safe and intended access.

Weakness: CWE-125
Severity: Medium
CVSS: 6.1",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('ifc9ffea49e5890f55fcb2c27568611052c3ddcfa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('incorrectly used', 'SECWORD', ''), ('fixed', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('fixed', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
10,CWE-125,GHSA-83rh-hx5x-q9p5,"@@ -101,10 +101,14 @@ bool HdrDecoder::readData(Mat& _img)
 
 bool HdrDecoder::checkSignature( const String& signature ) const
 {
-    if(signature.size() >= m_signature.size() &&
-       (!memcmp(signature.c_str(), m_signature.c_str(), m_signature.size()) ||
-       !memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())))
-       return true;
+    if (signature.size() >= m_signature.size() &&
+        0 == memcmp(signature.c_str(), m_signature.c_str(), m_signature.size())
+    )
+        return true;
+    if (signature.size() >= m_signature_alt.size() &&
+        0 == memcmp(signature.c_str(), m_signature_alt.c_str(), m_signature_alt.size())
+    )
+        return true;
     return false;
 }",imgproc(hdr): fix bounds check in HdrDecoder::checkSignature(),"vuln-fix: Correct signature check logic to prevent false positives

The original signature check combined two memcmp calls with a logical OR inside a single condition, causing incorrect evaluation and potential false positive matches.
This flaw could allow malformed or malicious data to be accepted as valid, risking processing of untrusted input and possible downstream security issues.
The fix separates the two memcmp checks into distinct if statements, ensuring each signature is properly and independently verified.

Weakness: CWE-285
Severity: Medium
CVSS: 5.9",0.058823529411764705,"[('fix', 'ACTION', ''), ('bounds check', 'SECWORD', ''), ('hdrdecoder::checksignature', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('signature', 'secword', ''), ('prevent', 'ACTION', ''), ('signature', 'secword', ''), ('flaw', 'FLAW', ''), ('malicious', 'secword', ''), ('untrusted', 'secword', ''), ('security', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('signature', 'secword', ''), ('verified', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-285', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
11,CWE-125,GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stat_dim bounds in feature split calculation

The code did not verify that stat_dim values from stats_summary_indices were within the valid range of stats_dims, risking out-of-bounds access.
This could lead to memory corruption or crashes when processing malformed or malicious input tensors, causing denial-of-service or undefined behavior.
The fix adds an OP_REQUIRES check to ensure stat_dim is less than stats_dims, preventing invalid memory indexing.

Weakness: CWE-125  
Severity: High  
CVSS: 7.8",0.11764705882352941,"[('tf.raw_ops.boostedtreessparsecalculatebestfeaturesplit', 'URL', ''), ('change', 'ACTION', ''), ('i83ca8a75b22aa78c037e8b98779da6cced16bfaa', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('malicious', 'SECWORD', ''), ('denial-of-service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
12,CWE-125,GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter against input tensor dimensions

The Dequantize operation did not verify that the axis parameter was within the valid range of input tensor dimensions.
This could lead to out-of-bounds access, causing crashes or memory corruption exploitable for denial of service.
The fix adds a check ensuring the axis is less than the input tensor’s dimension count, returning an error if invalid.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound access', 'secword', ''), ('adding', 'ACTION', ''), ('change', 'ACTION', ''), ('i3249d2a69ddc82f182c589a3a5bbfb71543f4b29', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('error', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
13,CWE-125,GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate input_min and input_max tensor element counts

The dequantization operation did not verify that input_min_tensor and input_max_tensor have element counts matching the input tensor's size along the dequantization axis.
This could lead to out-of-bounds memory access or incorrect computations, potentially causing crashes or data corruption.
The fix adds checks using OP_REQUIRES to ensure these tensors have the expected number of elements before proceeding.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9",0.23529411764705882,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('fixes', 'ACTION', ''), ('change', 'ACTION', ''), ('i135e94d360c2a1ce374c10f7e0fed1af603dbc02', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
14,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -601,7 +601,8 @@ TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
 
   // Make sure that the input is in uint8_t with at least 1 data entry.
-  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   if (input->type != kTfLiteUInt8) return kTfLiteError;
   if (NumElements(input->dims) == 0) return kTfLiteError;
 
@@ -622,7 +623,8 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
   OpData* data = reinterpret_cast<OpData*>(node->user_data);
   *data->invoke_count += 1;
 
-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
   const uint8_t* input_data = GetTensorData<uint8_t>(input);
   int size = NumElements(input->dims);
 
@@ -641,9 +643,13 @@ TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,
     }
   }
 
-  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);
+  TfLiteTensor* median;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kMedianTensor, &median));
   uint8_t* median_data = GetTensorData<uint8_t>(median);
-  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);
+  TfLiteTensor* invoke_count;
+  TF_LITE_ENSURE_OK(context,
+                    GetOutputSafe(context, node, kInvokeCount, &invoke_count));
   int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);
 
   median_data[0] = sorting_buffer[size / 2];
@@ -681,11 +687,14 @@ TfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {
 }
 
 TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {
-  const TfLiteTensor* input = tflite::GetInput(context, node, 0);
+  const TfLiteTensor* input;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
   const int32_t* input_data = input->data.i32;
-  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);
+  const TfLiteTensor* weight;
+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &weight));
   const uint8_t* weight_data = weight->data.uint8;
-  TfLiteTensor* output = GetOutput(context, node, 0);
+  TfLiteTensor* output;
+  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
   int32_t* output_data = output->data.i32;
   output_data[0] =
       0;  // Catch output tensor sharing memory with an input tensor","[tflite]: Insert `nullptr` checks when obtaining tensors.

As part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.

We also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).

PiperOrigin-RevId: 332518902
Change-Id: I92eb164a6101ac3cca66090061a9b56a97288236","vuln-fix: Use safe tensor accessors to prevent invalid memory access

The code accessed input and output tensors directly without verifying their validity, risking null pointer dereferences or out-of-bounds memory reads.
This could lead to crashes or undefined behavior exploitable for denial of service or information disclosure.
The patch replaces direct tensor retrieval calls with safe accessor functions that check and enforce successful tensor retrieval before use.

Weakness: CWE-823
Severity: High
CVSS: 7.8",0.11764705882352941,"[('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('nullptr', 'SECWORD', ''), ('change', 'ACTION', ''), ('i92eb164a6101ac3cca66090061a9b56a97288236', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('safe', 'secword', ''), ('prevent', 'ACTION', ''), ('invalid memory access', 'secword', ''), ('null pointer dereferences', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('exploitable', 'SECWORD', ''), ('denial of service', 'SECWORD', ''), ('disclosure', 'secword', ''), ('patch', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-823', 'CWEID', ''), ('high', 'SEVERITY', '')]"
15,CWE-125,GHSA-545v-42p7-98fq,"@@ -1014,6 +1014,9 @@ struct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {
         const int input_start = start * input_size_per_batch;
         const int input_end = limit * input_size_per_batch;
         for (int64 index = input_start; index < input_end; index++) {
+          if (index >= argmax.NumElements()) {
+            break;
+          }
           int64 grad_out_index = argmax_flat(index);
           if (!include_batch_in_index) {
             const int64 cur_batch = index / input_size_per_batch;","Fix heap buffer overflow

PiperOrigin-RevId: 372132844
Change-Id: Idef9895efaf145f2b1c23d31983601ec980cd5e4","vuln-fix: Prevent out-of-bounds access in max pooling gradient

The max pooling gradient computation did not check if the index exceeded the size of the argmax tensor, risking out-of-bounds memory access.
This could lead to memory corruption, crashes, or potential information disclosure due to reading invalid memory locations.
The fix adds a boundary check to break the loop if the index is beyond the number of elements in the argmax tensor.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('change', 'ACTION', ''), ('idef9895efaf145f2b1c23d31983601ec980cd5e4', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('boundary check', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
16,CWE-125,GHSA-4fg4-p75j-w5xj,"@@ -173,20 +173,50 @@ class QuantizedBatchNormOp : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     const Tensor& input = context->input(0);
-    const float input_min = context->input(1).flat<float>()(0);
-    const float input_max = context->input(2).flat<float>()(0);
+    const auto& input_min_tensor = context->input(1);
+    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_min must have 1 element""));
+    const float input_min = input_min_tensor.flat<float>()(0);
+    const auto& input_max_tensor = context->input(2);
+    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""input_max must have 1 element""));
+    const float input_max = input_max_tensor.flat<float>()(0);
     const Tensor& mean = context->input(3);
-    const float mean_min = context->input(4).flat<float>()(0);
-    const float mean_max = context->input(5).flat<float>()(0);
+    const auto& mean_min_tensor = context->input(4);
+    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_min must have 1 element""));
+    const float mean_min = mean_min_tensor.flat<float>()(0);
+    const auto& mean_max_tensor = context->input(5);
+    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""mean_max must have 1 element""));
+    const float mean_max = mean_max_tensor.flat<float>()(0);
     const Tensor& var = context->input(6);
-    const float var_min = context->input(7).flat<float>()(0);
-    const float var_max = context->input(8).flat<float>()(0);
+    const auto& var_min_tensor = context->input(7);
+    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_min must have 1 element""));
+    const float var_min = var_min_tensor.flat<float>()(0);
+    const auto& var_max_tensor = context->input(8);
+    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""var_max must have 1 element""));
+    const float var_max = var_max_tensor.flat<float>()(0);
     const Tensor& beta = context->input(9);
-    const float beta_min = context->input(10).flat<float>()(0);
-    const float beta_max = context->input(11).flat<float>()(0);
+    const auto& beta_min_tensor = context->input(10);
+    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_min must have 1 element""));
+    const float beta_min = beta_min_tensor.flat<float>()(0);
+    const auto& beta_max_tensor = context->input(11);
+    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""beta_max must have 1 element""));
+    const float beta_max = beta_max_tensor.flat<float>()(0);
     const Tensor& gamma = context->input(12);
-    const float gamma_min = context->input(13).flat<float>()(0);
-    const float gamma_max = context->input(14).flat<float>()(0);
+    const auto& gamma_min_tensor = context->input(13);
+    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_min must have 1 element""));
+    const float gamma_min = gamma_min_tensor.flat<float>()(0);
+    const auto& gamma_max_tensor = context->input(14);
+    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,
+                errors::InvalidArgument(""gamma_max must have 1 element""));
+    const float gamma_max = gamma_max_tensor.flat<float>()(0);
 
     OP_REQUIRES(context, input.dims() == 4,
                 errors::InvalidArgument(""input must be 4-dimensional"",
@@ -203,6 +233,33 @@ class QuantizedBatchNormOp : public OpKernel {
     OP_REQUIRES(context, gamma.dims() == 1,
                 errors::InvalidArgument(""gamma must be 1-dimensional"",
                                         gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value"",
+                                        gamma.shape().DebugString()));
+    OP_REQUIRES(context, mean.NumElements() > 1,
+                errors::InvalidArgument(""Must have at least a mean value""));
+    const auto last_dim = input.shape().dims() - 1;
+    OP_REQUIRES(context,
+                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),
+                errors::InvalidArgument(""Must provide as many means as the ""
+                                        ""last dimension of the input tensor: "",
+                                        mean.shape().DebugString(), "" vs. "",
+                                        input.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == var.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and variance tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", var.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and beta tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", beta.shape().DebugString()));
+    OP_REQUIRES(
+        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),
+        errors::InvalidArgument(
+            ""Mean and gamma tensors must have the same shape: "",
+            mean.shape().DebugString(), "" vs. "", gamma.shape().DebugString()));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Add missing validation in `QuantizedBatchNormWithGlobalNormalization`

PiperOrigin-RevId: 370123451
Change-Id: Id234d6dab1ec21230bb8e503dba30f899af87f33","vuln-fix: Validate tensor element counts and shape consistency in QuantizedBatchNormOp

The QuantizedBatchNormOp did not verify that scalar input tensors contained exactly one element or that parameter tensors had consistent shapes matching the input dimensions.  
This lack of validation could lead to out-of-bounds memory access or logic errors, potentially causing crashes or incorrect computations exploitable by crafted inputs.  
The fix adds checks to ensure scalar tensors have one element and that mean, variance, beta, and gamma tensors share matching shapes aligned with the input tensor’s last dimension.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('add', 'ACTION', ''), ('missing validation', 'SECWORD', ''), ('change', 'ACTION', ''), ('id234d6dab1ec21230bb8e503dba30f899af87f33', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('logic errors', 'secword', ''), ('exploitable', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
17,"CWE-908', 'CWE-125",GHSA-q263-fvxm-m5mw,"@@ -44,6 +44,7 @@ limitations under the License.
 #include ""tensorflow/core/lib/gtl/inlined_vector.h""
 #include ""tensorflow/core/lib/strings/scanner.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
+#include ""tensorflow/core/platform/errors.h""
 #include ""tensorflow/core/platform/logging.h""
 #include ""tensorflow/core/platform/macros.h""
 #include ""tensorflow/core/public/version.h""
@@ -1425,6 +1426,17 @@ void GraphConstructor::Undo() {
 
 Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,
                                   int input_index) {
+  if (output_index >= src->num_outputs()) {
+    return errors::InvalidArgument(
+        ""Output "", output_index, "" of node "", src->name(),
+        "" does not exist. Node only has "", src->num_outputs(), "" outputs."");
+  }
+  if (input_index >= dst->num_inputs()) {
+    return errors::InvalidArgument(
+        ""Input "", input_index, "" of node "", dst->name(),
+        "" does not exist. Node only has "", dst->num_inputs(), "" inputs."");
+  }
+
   DataType src_out = src->output_type(output_index);
   DataType dst_in = dst->input_type(input_index);
   if (!TypesCompatible(dst_in, src_out)) {","Prevent unitialized memory access in `GraphConstructor::MakeEdge`

The `MakeEdge` implementation assumes that there exists an output at `output_index` of `src` node and an input at `input_index` of `dst` node. However, if this is not the case this results in accessing data out of bounds. Because we are accessing an array that is a private member of a class and only in read only mode, this usually results only in unitialized memory access. However, it is reasonable to think that malicious users could manipulate these indexes to actually read data outside the class, thus resulting in information leakage and further exploits.

PiperOrigin-RevId: 346343288
Change-Id: I2127da27c2023d27f26efd39afa6c853385cab6f","vuln-fix: Validate node input and output indices in MakeEdge

The MakeEdge function did not verify that specified input and output indices were within valid ranges for the source and destination nodes.
This allowed out-of-bounds access to node inputs or outputs, potentially causing crashes or memory corruption during graph construction.
The patch adds explicit checks that input and output indices do not exceed the node’s declared number of inputs or outputs, returning errors if invalid.

Weakness: CWE-125
Severity: High
CVSS: 7.8",0.17647058823529413,"[('prevent', 'ACTION', ''), ('out of bounds', 'SECWORD', ''), ('malicious', 'secword', ''), ('manipulate', 'ACTION', ''), ('information leakage', 'SECWORD', ''), ('exploits', 'SECWORD', ''), ('change', 'ACTION', ''), ('i2127da27c2023d27f26efd39afa6c853385cab6f', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
18,CWE-125,GHSA-9c8h-vvrj-w2p8,"@@ -58,15 +58,21 @@ class RaggedGatherOpBase : public OpKernel {
 
   void Compute(OpKernelContext* context) override {
     // Get the input Tensors.
+
     OpInputList params_nested_splits_in;
     OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",
                                                 &params_nested_splits_in));
+    OP_REQUIRES(
+        context, params_nested_splits_in.size() > 0,
+        errors::InvalidArgument(""params_nested_splits must be non empty""));
+
     const Tensor& params_dense_values_in =
         context->input(params_nested_splits_in.size());
     const Tensor& indices_in =
         context->input(params_nested_splits_in.size() + 1);
 
-    DCHECK_GT(params_nested_splits_in.size(), 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, params_nested_splits_in[0].dims() > 0,
+                errors::InvalidArgument(""Split tensors must not be scalars""));
     SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;
     OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));","Fix heap OOB in `tf.raw_ops.RaggedGather`

PiperOrigin-RevId: 388355464
Change-Id: If14d96231d1cd7aad7c4d1c22c1bab1576b75717","vuln-fix: Validate input tensor list and splits dimensions

The code did not verify that the input list of nested splits was non-empty or that its first tensor was not a scalar, risking invalid memory access.
This could lead to out-of-bounds reads or crashes when processing malformed or crafted inputs, causing denial-of-service conditions.
The fix adds explicit checks to ensure the nested splits list is non-empty and that the first split tensor has at least one dimension.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('tf.raw_ops.raggedgather', 'URL', ''), ('change', 'ACTION', ''), ('if14d96231d1cd7aad7c4d1c22c1bab1576b75717', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('invalid memory access', 'SECWORD', ''), ('out-of-bounds reads', 'SECWORD', ''), ('denial-of-service', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
19,CWE-125,GHSA-c545-c4f9-rf6v,"@@ -37,6 +37,7 @@ TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,
     axis = input_dims.size + 1 + axis;
   }
   TF_LITE_ENSURE(context, axis <= input_dims.size);
+  TF_LITE_ENSURE(context, axis >= 0);
 
   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);
   for (int i = 0; i < output_dims->size; ++i) {","Prevent an OOB read in `expand_dims.cc`

The for loop that follows this check assumes that `axis` is between `0` and `input_dims.size`. If user supplied `axis` is negative, the if code before this check is supposed to bring it back to positive (similar to how in Python one can do `l[-3]` to mean `l[-3 + len(l)]`).

PiperOrigin-RevId: 387200206
Change-Id: I162f4feba12d547c3a4340833ae682016a2ebfab","vuln-fix: Validate axis parameter lower bound in tensor expansion

The ExpandTensorDim function did not verify that the axis parameter was non-negative before use.
This allowed negative axis values to bypass checks, potentially causing out-of-bounds memory access and crashes.
The patch adds a lower bound check ensuring axis is greater than or equal to zero before proceeding.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.9",0.23529411764705882,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('expand_dims.cc', 'URL', ''), ('input_dims.size', 'URL', ''), ('change', 'ACTION', ''), ('i162f4feba12d547c3a4340833ae682016a2ebfab', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('bypass', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('bound check', 'SECWORD', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
20,CWE-125,GHSA-3h8m-483j-7xxm,"@@ -46,6 +46,10 @@ class RequantizationRangeOp : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,
+                errors::InvalidArgument(""Input min must not be empty.""));
+    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,
+                errors::InvalidArgument(""Input max must not be empty.""));
     const float input_min_float = ctx->input(1).flat<float>()(0);
     const float input_max_float = ctx->input(2).flat<float>()(0);
     Tensor* output_min = nullptr;","Fix out of bound read in requantization_range_op.cc

PiperOrigin-RevId: 372129031
Change-Id: Ie684ab98a3840c5186ead3eafffc0e0ed0e8030d","vuln-fix: Validate non-empty inputs for min and max tensors

The computation did not verify that the input tensors for minimum and maximum values contained elements before accessing them.
This could lead to out-of-bounds memory access, causing crashes or potential information disclosure.
The fix adds checks to ensure these input tensors are not empty before dereferencing their first element.

Weakness: CWE-125  
Severity: Medium  
CVSS: 5.0",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound read', 'secword', ''), ('requantization_range_op.cc', 'URL', ''), ('change', 'ACTION', ''), ('ie684ab98a3840c5186ead3eafffc0e0ed0e8030d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
21,CWE-125,GHSA-cvgx-3v3q-m36c,"@@ -2559,6 +2559,9 @@ Status QuantizeV2Shape(InferenceContext* c) {
   if (!s.ok() && s.code() != error::NOT_FOUND) {
     return s;
   }
+  if (axis < -1) {
+    return errors::InvalidArgument(""axis should be at least -1, got "", axis);
+  }
   const int minmax_rank = (axis == -1) ? 0 : 1;
   TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));
   ShapeHandle minmax;","Prevent OOB access in QuantizeV2 shape inference

PiperOrigin-RevId: 400309614
Change-Id: I31412c71b05b4f21b677f7fa715a61499cbee39d","vuln-fix: Validate axis parameter in QuantizeV2Shape function

The QuantizeV2Shape function did not check if the axis parameter was less than -1, allowing invalid negative values to propagate unchecked.
This could lead to unexpected behavior or crashes due to out-of-bounds indexing or invalid shape inference during model compilation.
The patch adds a validation step that returns an error if axis is less than -1, preventing invalid inputs from causing downstream errors.

Weakness: CWE-20
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i31412c71b05b4f21b677f7fa715a61499cbee39d', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('out-of-bounds', 'SECWORD', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
22,CWE-125,GHSA-7fvx-3jfc-2cpc,"@@ -955,11 +955,12 @@ class ResourceScatterUpdateOp : public OpKernel {
                         params->dim_size(0), "")""));
       } else {
         int64_t num_updates = updates.NumElements();
-        OP_REQUIRES(c, num_updates % N == 0,
-                    errors::InvalidArgument(
-                        ""shape of indices ("", indices.shape().DebugString(),
-                        "") is not compatible with the shape of updates ("",
-                        updates.shape().DebugString(), "")""));
+        OP_REQUIRES(
+            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),
+            errors::InvalidArgument(
+                ""The shape of indices ("", indices.shape().DebugString(),
+                "") must be a prefix of the shape of updates ("",
+                updates.shape().DebugString(), "")""));
         auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});
 
         functor::ScatterFunctor<Device, T, Index, op> functor;","Fix heap OOB due to dimension mismatch in `ResourceScatterUpdate`

PiperOrigin-RevId: 388292801
Change-Id: Id9bd7244d98d41b1517d4771850b32782c0cc949","vuln-fix: Enforce shape prefix constraint in scatter update

The scatter update operation did not verify that the indices shape is a prefix of the updates shape, allowing inconsistent tensor shapes to pass unchecked.
This could lead to out-of-bounds memory access or corrupted data during tensor updates, causing crashes or data integrity issues.
The fix replaces the modulo check with a strict prefix shape validation using TensorShapeUtils::StartsWith to ensure shape compatibility.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('id9bd7244d98d41b1517d4771850b32782c0cc949', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('update', 'ACTION', ''), ('update', 'ACTION', ''), ('verify', 'ACTION', ''), ('updates', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('updates', 'ACTION', ''), ('integrity', 'secword', ''), ('issues', 'FLAW', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
23,CWE-125,GHSA-59q2-x2qc-4c97,"@@ -533,6 +533,17 @@ class UnicodeEncodeOp : public OpKernel {
     const Tensor& input_splits = context->input(1);
     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();
 
+    // Operation will treat first argument in input_splits as if it were zero
+    // regardless of its actual value since splits should begin with zero and
+    // end with the length of the input values vector.
+    OP_REQUIRES(
+        context, input_splits_flat(0) == 0,
+        errors::InvalidArgument(""First value in input_splits must be zero.""));
+    OP_REQUIRES(context,
+                input_splits_flat(input_splits_flat.size() - 1) ==
+                    input_tensor_flat.size(),
+                errors::InvalidArgument(""Last value in input_splits must be ""
+                                        ""equal to length of input_tensor.""));
     // Since we limit to a 2-D input (flat_values of rank 1 and a single splits
     // tensor), our output dimension will be 1 with it's size equal to the
     // number of splits (outer dimension or ragged tensor).
@@ -548,6 +559,14 @@ class UnicodeEncodeOp : public OpKernel {
     for (int i = 1; i < input_splits_flat.size(); ++i) {
       icu::UnicodeString unicode_string;
       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);
+      OP_REQUIRES(
+          context, input_splits_flat(i - 1) <= input_splits_flat(i),
+          errors::InvalidArgument(
+              ""Values in input_splits must be equal or in ascending order.""));
+      OP_REQUIRES(
+          context, input_splits_flat(i) <= input_tensor_flat.size(),
+          errors::InvalidArgument(""Values in input_splits must be less than or ""
+                                  ""equal to input_tensor length.""));
       for (; idx < input_splits_flat(i); ++idx) {
         int32 code_point = input_tensor_flat(idx);
         // Check for invalid code point","Fix heap buffer overflow in tf.raw_ops.UnicodeEncode.

PiperOrigin-RevId: 371717714
Change-Id: If33443b28f158e58078f1268f6b92f2728d219e0","vuln-fix: Validate input_splits boundaries and ordering in UnicodeEncodeOp

The UnicodeEncodeOp did not verify that input_splits started at zero, ended at the input length, or were non-decreasing, allowing malformed inputs to cause out-of-bounds access.
This could lead to memory corruption, crashes, or potential information disclosure by reading beyond tensor boundaries.
The fix adds explicit checks to ensure input_splits begin with zero, end with the input tensor size, and are sorted in ascending order within valid bounds.

Weakness: CWE-125
Severity: High
CVSS: 7.8",0.11764705882352941,"[('fix', 'ACTION', ''), ('buffer overflow', 'secword', ''), ('tf.raw_ops.unicodeencode', 'URL', ''), ('change', 'ACTION', ''), ('if33443b28f158e58078f1268f6b92f2728d219e0', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('unicodeencodeop', 'SECWORD', ''), ('unicodeencodeop', 'SECWORD', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('disclosure', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
24,CWE-125,GHSA-jwf9-w5xm-f437,"@@ -123,6 +123,17 @@ TfLiteStatus GatherNdString(const TfLiteTensor* params,
 template <typename IndicesT>
 TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,
                           const TfLiteTensor* indices, TfLiteTensor* output) {
+  bool indices_has_only_positive_elements = true;
+  const auto* indices_values = GetTensorData<IndicesT>(indices);
+  const size_t num_indices = indices->bytes / sizeof(IndicesT);
+  for (size_t i = 0; i < num_indices; i++) {
+    if (indices_values[i] < 0) {
+      indices_has_only_positive_elements = false;
+      break;
+    }
+  }
+  TF_LITE_ENSURE(context, indices_has_only_positive_elements);
+
   switch (params->type) {
     case kTfLiteFloat32:
       return GatherNd<float, IndicesT>(params, indices, output);","Prevent heap OOB read in TFLite's `gather_nd.cc`.

Passing negative indices is illegal but there was a missing check so that resulted in OOB accesses.

PiperOrigin-RevId: 387208551
Change-Id: I6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd","vuln-fix: Validate indices to prevent negative values in GatherNd

The GatherNd evaluation function did not check for negative values in the indices tensor, allowing out-of-bounds memory access during tensor gathering operations.
This could lead to memory corruption, crashes, or information disclosure by reading invalid tensor locations.
The patch adds a validation loop that ensures all indices are non-negative before proceeding with the gather operation.

Weakness: CWE-125
Severity: High
CVSS: 7.8",0.23529411764705882,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('gather_nd.cc', 'URL', ''), ('missing check', 'secword', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i6b7a8a62d3e7c13a16d81619e5bc23ae2cdbc7fd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('prevent', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('memory corruption', 'SECWORD', ''), ('disclosure', 'secword', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensures', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('high', 'SEVERITY', '')]"
25,"CWE-787', 'CWE-125",GHSA-cvpc-8phh-8f45,"@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
 
 const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,
                                            const TfLiteNode* node, int index) {
-  const bool use_tensor = index < node->inputs->size &&
-                          node->inputs->data[index] != kTfLiteOptionalTensor;
-  if (use_tensor) {
-    return GetMutableInput(context, node, index);
-  }
-  return nullptr;
+  return GetInput(context, node, index);
 }
 
 // Per-axis","[tflite] Make `GetOptionalInputTensor` the same as `GetInput`.

With the previous change, there is no more need for two separate APIs. We would deprecate `GetOptionalInputTensor` in the future.

PiperOrigin-RevId: 332513386
Change-Id: Id7110271c25ebd6126ad8c82a493e37e0e0756b3","vuln-fix: Correct optional input tensor retrieval logic

The function incorrectly checked for optional tensor presence, potentially returning mutable tensors when inputs were absent or optional.
This could lead to invalid memory access or unintended modification of tensors, causing crashes or data corruption.
The fix replaces the conditional logic with a direct call to GetInput, ensuring consistent and safe tensor retrieval.

Weakness: CWE-823
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('change', 'ACTION', ''), ('change', 'ACTION', ''), ('id7110271c25ebd6126ad8c82a493e37e0e0756b3', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('incorrectly checked', 'SECWORD', ''), ('invalid memory access', 'SECWORD', ''), ('fix', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-823', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
26,"CWE-787', 'CWE-125",GHSA-8gv3-57p6-g35r,"@@ -313,6 +313,12 @@ class RaggedTensorToTensorBaseOp : public OpKernel {
             output_index_multiplier, output_size, result);
         return tensorflow::Status::OK();
       case RowPartitionType::ROW_SPLITS:
+        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {
+          return errors::InvalidArgument(
+              ""Row partition size is greater than output size: "",
+              row_partition_tensor.size() - 1, "" > "",
+              parent_output_index.size());
+        }
         CalculateOutputIndexRowSplit(
             context, row_partition_tensor, parent_output_index,
             output_index_multiplier, output_size, result);","Fix heap-buffer-overflow issue with `tf.raw_ops.RaggedTensorToTensor`.

PiperOrigin-RevId: 371986929
Change-Id: I79ab962a22c5867f36f7f45b780a1ac881b1dbdd","vuln-fix: Validate row partition size against output size

The code did not verify that the row partition tensor size was consistent with the parent output index size before processing.
This could lead to out-of-bounds access or logic errors, potentially causing crashes or memory corruption.
The fix adds a check that returns an error if the row partition size exceeds the output size, preventing invalid memory operations.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('fix', 'ACTION', ''), ('overflow', 'SECWORD', ''), ('issue', 'FLAW', ''), ('tf.raw_ops.raggedtensortotensor', 'URL', ''), ('change', 'ACTION', ''), ('i79ab962a22c5867f36f7f45b780a1ac881b1dbdd', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'secword', ''), ('logic errors', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('error', 'FLAW', ''), ('preventing', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
27,CWE-125,GHSA-2r8p-fg3c-wcj4,"@@ -660,6 +660,11 @@ class ResourceGatherOp : public OpKernel {
     OP_REQUIRES(
         c, TensorShapeUtils::IsVectorOrHigher(params.shape()),
         errors::InvalidArgument(""params must be at least 1 dimensional""));
+    OP_REQUIRES(
+        c, params.shape().dims() >= batch_dims_,
+        errors::InvalidArgument(""params must have at least "", batch_dims_,
+                                "" (batch_dims) dimensions but it has shape "",
+                                params.shape().DebugString()));
 
     // Check that we have enough index space
     const int64_t N = indices.NumElements();","Prevent heap oob access in `resource_variable_ops.cc`

PiperOrigin-RevId: 387936433
Change-Id: I9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6","vuln-fix: Enforce minimum batch_dims in ResourceGatherOp input

The ResourceGatherOp did not verify that the input tensor's dimensions met the minimum batch_dims requirement, allowing malformed inputs to bypass shape constraints.
This could lead to out-of-bounds memory access or incorrect tensor operations, causing crashes or data corruption.
The fix adds a check ensuring the input tensor's rank is at least batch_dims_, rejecting invalid shapes early.

Weakness: CWE-125
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('prevent', 'ACTION', ''), ('heap oob', 'SECWORD', ''), ('resource_variable_ops.cc', 'URL', ''), ('change', 'ACTION', ''), ('i9e71ddaa8dbd51ec6afbf163a6b3b591f193b4f6', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('verify', 'ACTION', ''), ('bypass', 'SECWORD', ''), ('out-of-bounds', 'SECWORD', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
28,CWE-125,GHSA-h4pc-gx2w-f2xv,"@@ -96,6 +96,8 @@ TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
     }
   }
 
+  TF_LITE_ENSURE(context, axis_value >= 0);
+  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
   const int input_size = SizeOfDimension(input, axis_value);
 
   if (minus_one_index != -1) {","Prevent array OOB read/write

PiperOrigin-RevId: 371026165
Change-Id: I26ac6372c87246e03c7eb8c94e84c84d86054b36","vuln-fix: Validate axis parameter range in tensor resizing

The tensor resizing function did not verify that the axis parameter was within valid bounds before use.
This allowed out-of-bounds access to tensor dimensions, potentially causing memory corruption or crashes.
The patch adds explicit checks to ensure the axis value is non-negative and less than the number of input dimensions.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.17647058823529413,"[('prevent', 'ACTION', ''), ('oob', 'SECWORD', ''), ('change', 'ACTION', ''), ('i26ac6372c87246e03c7eb8c94e84c84d86054b36', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'SECWORD', ''), ('patch', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensure', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
29,CWE-125,GHSA-vqw6-72r7-fgw7,"@@ -162,6 +162,9 @@ class BaseMatrixTriangularSolveOp : public OpKernel {
     const Tensor& in1 = ctx->input(1);
 
     ValidateInputTensors(ctx, in0, in1);
+    if (!ctx->status().ok()) {
+      return;
+    }
 
     MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());
     OP_REQUIRES(
@@ -230,13 +233,22 @@ class MatrixTriangularSolveOp
  private:
   void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,
                             const Tensor& in1) override {
+    const auto in0_num_dims = in0.dims();
     OP_REQUIRES(
-        ctx, in0.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0.dims()));
+        ctx, in0_num_dims >= 2,
+        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in0_num_dims));
 
+    const auto in1_num_dims = in1.dims();
     OP_REQUIRES(
-        ctx, in1.dims() >= 2,
-        errors::InvalidArgument(""In[0] ndims must be >= 2: "", in1.dims()));
+        ctx, in1_num_dims >= 2,
+        errors::InvalidArgument(""In[1] ndims must be >= 2: "", in1_num_dims));
+
+    const auto in0_last_dim = in0.dim_size(in0_num_dims - 1);
+    const auto in0_prev_dim = in0.dim_size(in0_num_dims - 2);
+    OP_REQUIRES(ctx, in0_last_dim == in0_prev_dim,
+                errors::InvalidArgument(
+                    ""In[0] matrices in the last dimensions must be square ("",
+                    in0_last_dim, "" =/= "", in0_prev_dim, "")""));
   }
 };","Validate (and ensure validation sticks) inputs for `MatrixTriangularSolve`.

PiperOrigin-RevId: 370282444
Change-Id: Iaed61a0b0727cc42c830658b72eb69f785f48dc5","vuln-fix: Validate tensor dimensions and abort on invalid input

The operation did not properly abort execution when input tensor validation failed, allowing further processing with invalid tensor shapes.
This could lead to undefined behavior, crashes, or memory corruption due to assumptions about tensor dimensionality and shape being violated.
The fix adds an early return if validation fails and enforces that input tensors have at least two dimensions with the first input’s last two dimensions forming a square matrix.

Weakness: CWE-834
Severity: High
CVSS: 7.8",0.11764705882352941,"[('validate', 'secword', ''), ('ensure', 'ACTION', ''), ('change', 'ACTION', ''), ('iaed61a0b0727cc42c830658b72eb69f785f48dc5', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-834', 'CWEID', ''), ('high', 'SEVERITY', '')]"
30,"CWE-400', 'CWE-125",GHSA-8g7p-74h8-hg48,"@@ -204,7 +204,7 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
   var headers = Object.assign({}, proxy.headers);
   if (proxy.auth) {
     headers['Proxy-Authorization'] =
-      'Basic ' + new Buffer(proxy.auth).toString('base64');
+      'Basic ' + Buffer.from(proxy.auth).toString('base64');
   }
 
   // the Host header should only include the port","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Replace deprecated Buffer constructor to prevent security risks

The code used the deprecated Buffer constructor which can lead to uninitialized memory exposure or unexpected behavior when handling proxy authentication credentials.
This posed a security risk by potentially leaking sensitive data or causing crashes due to improper buffer allocation.
The patch replaces the deprecated 'new Buffer()' with the safer 'Buffer.from()' method to securely encode proxy authentication strings.

Weakness: CWE-676
Severity: Medium
CVSS: 5.9",0.23529411764705882,"[('buffer.from', 'URL', ''), ('unsafe', 'SECWORD', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('security', 'SECWORD', ''), ('uninitialized memory', 'SECWORD', ''), ('authentication', 'secword', ''), ('security', 'secword', ''), ('sensitive data', 'SECWORD', ''), ('patch', 'ACTION', ''), (""safer 'buffer.from"", 'SECWORD', ''), ('securely', 'SECWORD', ''), ('encode', 'secword', ''), ('authentication', 'SECWORD', ''), ('weakness', 'secword', ''), ('cwe-676', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
31,"CWE-787', 'CWE-125",GHSA-hpv4-7p9c-mvfr,"@@ -271,6 +271,18 @@ class FractionalAvgPoolGradOp : public OpKernel {
     const int64_t in_rows = orig_input_tensor_shape_flat(1);
     const int64_t in_cols = orig_input_tensor_shape_flat(2);
     const int64_t in_depth = orig_input_tensor_shape_flat(3);
+    OP_REQUIRES(
+        context, in_batch != 0,
+        errors::InvalidArgument(""Batch dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_rows != 0,
+        errors::InvalidArgument(""Rows dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_cols != 0,
+        errors::InvalidArgument(""Columns dimension of input must not be 0""));
+    OP_REQUIRES(
+        context, in_depth != 0,
+        errors::InvalidArgument(""Depth dimension of input must not be 0""));
 
     constexpr int tensor_in_and_out_dims = 4;
     // Transform orig_input_tensor_shape into TensorShape","Validate dimensions of input tensor in `FractionalAvgPoolGrad`

PiperOrigin-RevId: 388286227
Change-Id: Ieb7566155e92acc8993a2212c76deacadc0edc8a","vuln-fix: Validate input tensor dimensions in FractionalAvgPoolGradOp

The operation did not verify that input tensor dimensions were non-zero, allowing zero-sized dimensions to propagate through computations.
This could lead to undefined behavior, crashes, or memory corruption due to invalid tensor shapes during gradient calculations.
The fix adds explicit checks that batch, rows, columns, and depth dimensions are non-zero, returning errors if any dimension is zero.

Weakness: CWE-835
Severity: Medium
CVSS: 5.9",0.11764705882352941,"[('validate', 'secword', ''), ('change', 'ACTION', ''), ('ieb7566155e92acc8993a2212c76deacadc0edc8a', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('validate', 'secword', ''), ('verify', 'ACTION', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('errors', 'FLAW', ''), ('weakness', 'secword', ''), ('cwe-835', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
32,CWE-125,GHSA-qpw2-xchm-655q,"@@ -28,7 +28,7 @@ StringStream.prototype.write = function(data) {
     return false
   }
   if (this.fromEncoding) {
-    if (Buffer.isBuffer(data)) data = data.toString()
+    if (Buffer.isBuffer(data) || typeof data === 'number') data = data.toString()
     data = new Buffer(data, this.fromEncoding)
   }
   var string = this.decoder.write(data)","Merge pull request #9 from mhart/fix-buffer-constructor-vuln

Ensure data is not a number in Buffer constructor","vuln-fix: Prevent improper number input conversion in StringStream write

The write method did not handle numeric inputs correctly, converting numbers to strings without validation, which could cause unexpected buffer creation behavior.
This flaw could lead to memory corruption or crashes if numeric values were interpreted as buffer encodings or data, risking denial of service.
The fix adds a type check to convert numbers to strings before buffer creation, ensuring safe and consistent input handling.

Weakness: CWE-20
Severity: Medium
CVSS: 5.9",0.17647058823529413,"[('#9', 'ISSUE', ''), ('fix', 'ACTION', ''), ('ensure', 'ACTION', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('prevent', 'ACTION', ''), ('flaw', 'FLAW', ''), ('memory corruption', 'SECWORD', ''), ('encodings', 'SECWORD', ''), ('denial of service', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('safe', 'secword', ''), ('weakness', 'secword', ''), ('cwe-20', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
33,CWE-125,GHSA-6gmv-pjp9-p8w8,"@@ -1653,11 +1653,21 @@ REGISTER_OP(""ReverseSequence"")
         return errors::InvalidArgument(
             ""batch_dim must be < input rank: "", batch_dim, "" vs. "", input_rank);
       }
+
       if (seq_dim >= input_rank) {
         return errors::InvalidArgument(
             ""seq_dim must be < input rank: "", seq_dim, "" vs. "", input_rank);
       }
 
+      // To prevent out of bound access when calling c->Dim(input, batch_dim),
+      // batch_dim range [-1 * input rank, input rank) is allowed. However,
+      // the op implementation has a stricter bound for batch_dim requiring >= 0
+      // value. Thus, perform strict check here.
+      if (batch_dim < 0) {
+        return errors::InvalidArgument(""batch_dim must be >=0, got "",
+                                       batch_dim);
+      }
+
       DimensionHandle batch_dim_dim = c->Dim(input, batch_dim);
       TF_RETURN_IF_ERROR(
           c->Merge(batch_dim_dim, c->Dim(seq_lens_shape, 0), &batch_dim_dim));","Fix out of bound error in ReverseSequence Op shape function

PiperOrigin-RevId: 411896080
Change-Id: I7e59a38e2f960886edf2b6c54ed5a84e86a9b193","vuln-fix: Enforce non-negative batch_dim in ReverseSequence op

The ReverseSequence operation allowed negative batch_dim values, which could lead to out-of-bounds tensor dimension access during execution.
This posed a risk of memory corruption or crashes due to invalid indexing in tensor operations.
The fix adds a strict check to reject negative batch_dim values, ensuring only valid non-negative indices are accepted.

Weakness: CWE-125  
Severity: Medium  
CVSS: 6.1",0.11764705882352941,"[('fix', 'ACTION', ''), ('out of bound', 'SECWORD', ''), ('error', 'FLAW', ''), ('change', 'ACTION', ''), ('i7e59a38e2f960886edf2b6c54ed5a84e86a9b193', 'SHA', '')]",0.4117647058823529,"[('fix', 'ACTION', ''), ('out-of-bounds', 'SECWORD', ''), ('memory corruption', 'secword', ''), ('fix', 'ACTION', ''), ('adds', 'ACTION', ''), ('ensuring', 'ACTION', ''), ('weakness', 'secword', ''), ('cwe-125', 'CWEID', ''), ('medium', 'SEVERITY', '')]"
