{
  "schema":{
    "fields":[
      {
        "name":"index",
        "type":"integer"
      },
      {
        "name":"vuln_id",
        "type":"string"
      },
      {
        "name":"cwe_id",
        "type":"string"
      },
      {
        "name":"score",
        "type":"number"
      },
      {
        "name":"chain",
        "type":"string"
      },
      {
        "name":"dataset",
        "type":"string"
      },
      {
        "name":"summary",
        "type":"string"
      },
      {
        "name":"published_date",
        "type":"string"
      },
      {
        "name":"chain_len",
        "type":"integer"
      },
      {
        "name":"project",
        "type":"string"
      },
      {
        "name":"commit_href",
        "type":"string"
      },
      {
        "name":"commit_sha",
        "type":"string"
      },
      {
        "name":"patch",
        "type":"string"
      },
      {
        "name":"chain_ord",
        "type":"string"
      },
      {
        "name":"before_first_fix_commit",
        "type":"string"
      },
      {
        "name":"last_fix_commit",
        "type":"string"
      },
      {
        "name":"chain_ord_pos",
        "type":"number"
      },
      {
        "name":"commit_datetime",
        "type":"string"
      },
      {
        "name":"message",
        "type":"string"
      },
      {
        "name":"author",
        "type":"string"
      },
      {
        "name":"comments",
        "type":"string"
      },
      {
        "name":"stats",
        "type":"string"
      },
      {
        "name":"files",
        "type":"string"
      },
      {
        "name":"message_norm",
        "type":"string"
      },
      {
        "name":"language",
        "type":"string"
      },
      {
        "name":"entities",
        "type":"string"
      },
      {
        "name":"classification_level_1",
        "type":"string"
      },
      {
        "name":"classification_level_2",
        "type":"string"
      },
      {
        "name":"list_files",
        "type":"string"
      },
      {
        "name":"num_files",
        "type":"number"
      },
      {
        "name":"patch_content",
        "type":"string"
      },
      {
        "name":"code_diff",
        "type":"string"
      }
    ],
    "primaryKey":[
      "index"
    ],
    "pandas_version":"1.4.0"
  },
  "data":[
    {
      "index":0,
      "vuln_id":"GHSA-5f38-9jw2-6r6h",
      "cwe_id":"{'CWE-79', 'CWE-843'}",
      "score":5.4,
      "chain":"{'https:\/\/github.com\/rooseveltframework\/teddy\/commit\/64c556717b4879bf8d4c30067cf6e70d899a3dc0'}",
      "dataset":"osv",
      "summary":"Cross-site Scripting in teddy Teddy is a readable and easy to learn templating language. This affects the package teddy before 0.5.9. A type confusion vulnerability can be used to bypass input sanitization when the model content is an array (instead of a string).",
      "published_date":"2021-10-12",
      "chain_len":1,
      "project":"https:\/\/github.com\/rooseveltframework\/teddy",
      "commit_href":"https:\/\/github.com\/rooseveltframework\/teddy\/commit\/64c556717b4879bf8d4c30067cf6e70d899a3dc0",
      "commit_sha":"64c556717b4879bf8d4c30067cf6e70d899a3dc0",
      "patch":"SINGLE",
      "chain_ord":"['64c556717b4879bf8d4c30067cf6e70d899a3dc0']",
      "before_first_fix_commit":"{'90387d97c7a8f458a08dd3b72a4b0574000af5f8', 'fea0b218069ff00f86f2b24f2fd08be01cd6b8c1'}",
      "last_fix_commit":"64c556717b4879bf8d4c30067cf6e70d899a3dc0",
      "chain_ord_pos":1.0,
      "commit_datetime":"10\/07\/2021, 01:27:38",
      "message":"Merge pull request #518 from kethinov\/refactor-escape-entities\n\nrefactor escape entities for better type checking",
      "author":"Eric Newport",
      "comments":null,
      "stats":"{'additions': 15, 'deletions': 4, 'total': 19}",
      "files":"{'utils.js': {'additions': 15, 'deletions': 4, 'changes': 19, 'status': 'modified', 'raw_url': 'https:\/\/github.com\/rooseveltframework\/teddy\/raw\/64c556717b4879bf8d4c30067cf6e70d899a3dc0\/utils.js', 'patch': \"@@ -96,10 +96,21 @@ function escapeEntities (value) {\\n   let i\\n   let j\\n \\n-  if (value === undefined || typeof value === 'boolean' || typeof value === 'object') { \/\/ Cannot escape on these values\\n-    return value\\n-  } else if (typeof value === 'number') { \/\/ Value is a number, no reason to escape\\n-    return `${value}`\\n+  if (typeof value === 'object') { \/\/ Cannot escape on this value\\n+    if (!value) {\\n+      return false \/\/ it is falsey to return false\\n+    } else if (Array.isArray(value)) {\\n+      if (value.length === 0) {\\n+        return false \/\/ empty arrays are falsey\\n+      } else {\\n+        return '[Array]' \/\/ print that it is an array with content in it, but do not print the contents\\n+      }\\n+    }\\n+    return '[Object]' \/\/ just print that it is an object, do not print the contents\\n+  } else if (value === undefined) { \/\/ Cannot escape on this value\\n+    return false \/\/ undefined is falsey\\n+  } else if (typeof value === 'boolean' || typeof value === 'number') { \/\/ Cannot escape on these values\\n+    return value \/\/ if it's already a boolean or a number just return it\\n   } else {\\n     \/\/ Loop through value to find HTML entities\\n     for (i = 0; i < value.length; i++) {\"}}",
      "message_norm":"merge pull request #518 from kethinov\/refactor-escape-entities\n\nrefactor escape entities for better type checking",
      "language":"en",
      "entities":"[('#518', 'ISSUE', ''), ('escape', 'SECWORD', ''), ('escape', 'SECWORD', '')]",
      "classification_level_1":null,
      "classification_level_2":null,
      "list_files":"dict_keys(['utils.js'])",
      "num_files":1.0,
      "patch_content":"From f51225de37295e73306281246eed808bb9867288 Mon Sep 17 00:00:00 2001\nFrom: Eric Newport <kethinov@gmail.com>\nDate: Mon, 4 Oct 2021 13:32:14 -0400\nSubject: [PATCH 1\/5] refactor escape entities for better type checking\n\n---\n utils.js | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\ndiff --git a\/utils.js b\/utils.js\nindex d8803272..7a2c3972 100644\n--- a\/utils.js\n+++ b\/utils.js\n@@ -96,8 +96,15 @@ function escapeEntities (value) {\n   let i\n   let j\n \n-  if (value === undefined || typeof value === 'boolean' || typeof value === 'object') { \/\/ Cannot escape on these values\n-    return value\n+  if (typeof value === 'object') { \/\/ Cannot escape on this value\n+    if (Array.isArray(value) && value.length === 0) {\n+      return false \/\/ empty arrays are falsey\n+    }\n+    return true \/\/ assumed to be truthy if something is in it\n+  } else if (value === undefined) { \/\/ Cannot escape on this value\n+    return false \/\/ undefined is falsey\n+  } else if (typeof value === 'boolean') { \/\/ Cannot escape on this value\n+    return value \/\/ it's already a boolean so just return the boolean\n   } else if (typeof value === 'number') { \/\/ Value is a number, no reason to escape\n     return `${value}`\n   } else {\n\nFrom 11c082c83d05ab1b359e8a51ef475604b149e742 Mon Sep 17 00:00:00 2001\nFrom: Eric Newport <kethinov@gmail.com>\nDate: Tue, 5 Oct 2021 13:37:33 -0400\nSubject: [PATCH 2\/5] remove unnecessary abstraction\n\n---\n utils.js | 6 ++----\n 1 file changed, 2 insertions(+), 4 deletions(-)\n\ndiff --git a\/utils.js b\/utils.js\nindex 7a2c3972..605c1f5b 100644\n--- a\/utils.js\n+++ b\/utils.js\n@@ -103,10 +103,8 @@ function escapeEntities (value) {\n     return true \/\/ assumed to be truthy if something is in it\n   } else if (value === undefined) { \/\/ Cannot escape on this value\n     return false \/\/ undefined is falsey\n-  } else if (typeof value === 'boolean') { \/\/ Cannot escape on this value\n-    return value \/\/ it's already a boolean so just return the boolean\n-  } else if (typeof value === 'number') { \/\/ Value is a number, no reason to escape\n-    return `${value}`\n+  } else if (typeof value === 'boolean' || typeof value === 'number') { \/\/ Cannot escape on these values\n+    return value \/\/ if it's already a boolean or a number just return it\n   } else {\n     \/\/ Loop through value to find HTML entities\n     for (i = 0; i < value.length; i++) {\n\nFrom 370c9abf6a15ed517d65e9a55cabc36911bbcd95 Mon Sep 17 00:00:00 2001\nFrom: Eric Newport <kethinov@gmail.com>\nDate: Tue, 5 Oct 2021 13:49:13 -0400\nSubject: [PATCH 3\/5] refactor to make output more clear\n\n---\n utils.js | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\ndiff --git a\/utils.js b\/utils.js\nindex 605c1f5b..00cb6761 100644\n--- a\/utils.js\n+++ b\/utils.js\n@@ -97,10 +97,14 @@ function escapeEntities (value) {\n   let j\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n-    if (Array.isArray(value) && value.length === 0) {\n-      return false \/\/ empty arrays are falsey\n+    if (Array.isArray(value)) {\n+      if (value.length === 0) {\n+        return false \/\/ empty arrays are falsey\n+      } else {\n+        return '[Array]' \/\/ print that it is an array with content in it, but do not print the contents\n+      }\n     }\n-    return true \/\/ assumed to be truthy if something is in it\n+    return '[Object]' \/\/ just print that it is an object, do not print the contents\n   } else if (value === undefined) { \/\/ Cannot escape on this value\n     return false \/\/ undefined is falsey\n   } else if (typeof value === 'boolean' || typeof value === 'number') { \/\/ Cannot escape on these values\n\nFrom 1b09ea8280875fdc1333a7a372774fcd90161a1f Mon Sep 17 00:00:00 2001\nFrom: Eric Newport <kethinov@gmail.com>\nDate: Tue, 5 Oct 2021 13:55:10 -0400\nSubject: [PATCH 4\/5] catch all falsey values\n\n---\n utils.js | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a\/utils.js b\/utils.js\nindex 00cb6761..08188707 100644\n--- a\/utils.js\n+++ b\/utils.js\n@@ -97,7 +97,9 @@ function escapeEntities (value) {\n   let j\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n-    if (Array.isArray(value)) {\n+    if (!value) {\n+      return false \/\/ it is otherwise falsey\n+    } else if (Array.isArray(value)) {\n       if (value.length === 0) {\n         return false \/\/ empty arrays are falsey\n       } else {\n\nFrom fea0b218069ff00f86f2b24f2fd08be01cd6b8c1 Mon Sep 17 00:00:00 2001\nFrom: Eric Newport <kethinov@gmail.com>\nDate: Tue, 5 Oct 2021 13:56:04 -0400\nSubject: [PATCH 5\/5] clarify comment\n\n---\n utils.js | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a\/utils.js b\/utils.js\nindex 08188707..b81be34d 100644\n--- a\/utils.js\n+++ b\/utils.js\n@@ -98,7 +98,7 @@ function escapeEntities (value) {\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n     if (!value) {\n-      return false \/\/ it is otherwise falsey\n+      return false \/\/ it is falsey to return false\n     } else if (Array.isArray(value)) {\n       if (value.length === 0) {\n         return false \/\/ empty arrays are falsey",
      "code_diff":"@@ -96,8 +96,15 @@ function escapeEntities (value) {\n   let i\n   let j\n \n-  if (value === undefined || typeof value === 'boolean' || typeof value === 'object') { \/\/ Cannot escape on these values\n-    return value\n+  if (typeof value === 'object') { \/\/ Cannot escape on this value\n+    if (Array.isArray(value) && value.length === 0) {\n+      return false \/\/ empty arrays are falsey\n+    }\n+    return true \/\/ assumed to be truthy if something is in it\n+  } else if (value === undefined) { \/\/ Cannot escape on this value\n+    return false \/\/ undefined is falsey\n+  } else if (typeof value === 'boolean') { \/\/ Cannot escape on this value\n+    return value \/\/ it's already a boolean so just return the boolean\n   } else if (typeof value === 'number') { \/\/ Value is a number, no reason to escape\n     return `${value}`\n   } else {\n\nFrom: Eric Newport <kethinov@gmail.com>\n\n utils.js | 6 ++----\n 1 file changed, 2 insertions(+), 4 deletions(-)\n\n@@ -103,10 +103,8 @@ function escapeEntities (value) {\n     return true \/\/ assumed to be truthy if something is in it\n   } else if (value === undefined) { \/\/ Cannot escape on this value\n     return false \/\/ undefined is falsey\n-  } else if (typeof value === 'boolean') { \/\/ Cannot escape on this value\n-    return value \/\/ it's already a boolean so just return the boolean\n-  } else if (typeof value === 'number') { \/\/ Value is a number, no reason to escape\n-    return `${value}`\n+  } else if (typeof value === 'boolean' || typeof value === 'number') { \/\/ Cannot escape on these values\n+    return value \/\/ if it's already a boolean or a number just return it\n   } else {\n     \/\/ Loop through value to find HTML entities\n     for (i = 0; i < value.length; i++) {\n\nFrom: Eric Newport <kethinov@gmail.com>\n\n utils.js | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n@@ -97,10 +97,14 @@ function escapeEntities (value) {\n   let j\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n-    if (Array.isArray(value) && value.length === 0) {\n-      return false \/\/ empty arrays are falsey\n+    if (Array.isArray(value)) {\n+      if (value.length === 0) {\n+        return false \/\/ empty arrays are falsey\n+      } else {\n+        return '[Array]' \/\/ print that it is an array with content in it, but do not print the contents\n+      }\n     }\n-    return true \/\/ assumed to be truthy if something is in it\n+    return '[Object]' \/\/ just print that it is an object, do not print the contents\n   } else if (value === undefined) { \/\/ Cannot escape on this value\n     return false \/\/ undefined is falsey\n   } else if (typeof value === 'boolean' || typeof value === 'number') { \/\/ Cannot escape on these values\n\nFrom: Eric Newport <kethinov@gmail.com>\n\n utils.js | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n@@ -97,7 +97,9 @@ function escapeEntities (value) {\n   let j\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n-    if (Array.isArray(value)) {\n+    if (!value) {\n+      return false \/\/ it is otherwise falsey\n+    } else if (Array.isArray(value)) {\n       if (value.length === 0) {\n         return false \/\/ empty arrays are falsey\n       } else {\n\nFrom: Eric Newport <kethinov@gmail.com>\n\n utils.js | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n@@ -98,7 +98,7 @@ function escapeEntities (value) {\n \n   if (typeof value === 'object') { \/\/ Cannot escape on this value\n     if (!value) {\n-      return false \/\/ it is otherwise falsey\n+      return false \/\/ it is falsey to return false\n     } else if (Array.isArray(value)) {\n       if (value.length === 0) {\n         return false \/\/ empty arrays are falsey"
    },
    {
      "index":1,
      "vuln_id":"GHSA-f4rr-5m7v-wxcw",
      "cwe_id":"{'CWE-843'}",
      "score":5.5,
      "chain":"{'https:\/\/github.com\/tensorflow\/tensorflow\/commit\/b917181c29b50cb83399ba41f4d938dc369109a1'}",
      "dataset":"osv",
      "summary":"Type confusion leading to `CHECK`-failure based denial of service in TensorFlow ### Impact\nThe [macros that TensorFlow uses for writing assertions (e.g., `CHECK_LT`, `CHECK_GT`, etc.)](https:\/\/github.com\/tensorflow\/tensorflow\/blob\/f3b9bf4c3c0597563b289c0512e98d4ce81f886e\/tensorflow\/core\/platform\/default\/logging.h) have an incorrect logic when comparing `size_t` and `int` values. Due to type conversion rules, several of the macros would trigger incorrectly.\n\n### Patches\nWe have patched the issue in GitHub commit [b917181c29b50cb83399ba41f4d938dc369109a1](https:\/\/github.com\/tensorflow\/tensorflow\/commit\/b917181c29b50cb83399ba41f4d938dc369109a1) (merging GitHub PR [#55730](https:\/\/github.com\/tensorflow\/tensorflow\/pull\/55730)).\n\nThe fix will be included in TensorFlow 2.9.0. We will also cherrypick this commit on TensorFlow 2.8.1, TensorFlow 2.7.2, and TensorFlow 2.6.4, as these are also affected and still in supported range.\n\n### For more information\nPlease consult [our security guide](https:\/\/github.com\/tensorflow\/tensorflow\/blob\/master\/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.\n\n### Attribution\nThis vulnerability has been reported externally via a [GitHub issue](https:\/\/github.com\/tensorflow\/tensorflow\/issues\/55530).",
      "published_date":"2022-05-24",
      "chain_len":1,
      "project":"https:\/\/github.com\/tensorflow\/tensorflow",
      "commit_href":"https:\/\/github.com\/tensorflow\/tensorflow\/commit\/b917181c29b50cb83399ba41f4d938dc369109a1",
      "commit_sha":"b917181c29b50cb83399ba41f4d938dc369109a1",
      "patch":"SINGLE",
      "chain_ord":"['b917181c29b50cb83399ba41f4d938dc369109a1']",
      "before_first_fix_commit":"{'cce6f6484e967a0be4df8702c8ac36d021542455', 'd73521b7603f10e3029a2f1cd5067ca985738fc8'}",
      "last_fix_commit":"b917181c29b50cb83399ba41f4d938dc369109a1",
      "chain_ord_pos":1.0,
      "commit_datetime":"04\/28\/2022, 21:41:18",
      "message":"Merge pull request #55730 from graphcore:awf\/issue-55530\n\nPiperOrigin-RevId: 445252025",
      "author":"TensorFlower Gardener",
      "comments":null,
      "stats":"{'additions': 73, 'deletions': 28, 'total': 101}",
      "files":"{'tensorflow\/core\/platform\/default\/logging.h': {'additions': 73, 'deletions': 28, 'changes': 101, 'status': 'modified', 'raw_url': 'https:\/\/github.com\/tensorflow\/tensorflow\/raw\/b917181c29b50cb83399ba41f4d938dc369109a1\/tensorflow%2Fcore%2Fplatform%2Fdefault%2Flogging.h', 'patch': '@@ -85,7 +85,7 @@ class LogMessage : public std::basic_ostringstream<char> {\\n \/\/ that the ternary VLOG() implementation is balanced, type wise.\\n struct Voidifier {\\n   template <typename T>\\n-  void operator&(const T&)const {}\\n+  void operator&(const T&) const {}\\n };\\n \\n \/\/ LogMessageFatal ensures the process will exit in failure after\\n@@ -348,11 +348,13 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\\n }\\n \\n \/\/ Helper functions for CHECK_OP macro.\\n-\/\/ The (int, int) specialization works around the issue that the compiler\\n+\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\\n+\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\\n+\/\/ This happens if, for example, those are used as token names in a\\n+\/\/ yacc grammar.\\n+\/\/ The (int, int) overload works around the issue that the compiler\\n \/\/ will not instantiate the template version of the function on values of\\n \/\/ unnamed enum type - see comment below.\\n-\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\\n-\/\/ comparison errors while still being thorough with the comparison.\\n #define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\\\\n   template <typename T1, typename T2>                                     \\\\\\n   inline string* name##Impl(const T1& v1, const T2& v2,                   \\\\\\n@@ -364,34 +366,77 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\\n   }                                                                       \\\\\\n   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\\\\n     return name##Impl<int, int>(v1, v2, exprtext);                        \\\\\\n-  }                                                                       \\\\\\n-  inline string* name##Impl(const size_t v1, const int v2,                \\\\\\n-                            const char* exprtext) {                       \\\\\\n-    if (TF_PREDICT_FALSE(v2 < 0)) {                                       \\\\\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\\\\n-    }                                                                     \\\\\\n-    return name##Impl<size_t, size_t>(v1, v2, exprtext);                  \\\\\\n-  }                                                                       \\\\\\n-  inline string* name##Impl(const int v1, const size_t v2,                \\\\\\n-                            const char* exprtext) {                       \\\\\\n-    if (TF_PREDICT_FALSE(v2 >= std::numeric_limits<int>::max())) {        \\\\\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\\\\n-    }                                                                     \\\\\\n-    const size_t uval = (size_t)((unsigned)v2);                           \\\\\\n-    return name##Impl<size_t, size_t>(v1, uval, exprtext);                \\\\\\n   }\\n \\n-\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\\n-\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\\n-\/\/ This happens if, for example, those are used as token names in a\\n-\/\/ yacc grammar.\\n-TF_DEFINE_CHECK_OP_IMPL(Check_EQ,\\n-                        ==)  \/\/ Compilation error with CHECK_EQ(NULL, x)?\\n-TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)  \/\/ Use CHECK(x == NULL) instead.\\n+\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\\n+\/\/ comparison errors while still being thorough with the comparison.\\n+\\n+TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\\n+\/\/ Compilation error with CHECK_EQ(NULL, x)?\\n+\/\/ Use CHECK(x == NULL) instead.\\n+\\n+inline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {\\n+  if (TF_PREDICT_FALSE(v1 < 0))\\n+    ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\\n+\\n+  return Check_EQImpl(size_t(v1), v2, exprtext);\\n+}\\n+\\n+inline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {\\n+  return Check_EQImpl(v2, v1, exprtext);\\n+}\\n+\\n+TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\\n+\\n+inline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {\\n+  if (v1 < 0) return NULL;\\n+\\n+  return Check_NEImpl(size_t(v1), v2, exprtext);\\n+}\\n+\\n+inline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {\\n+  return Check_NEImpl(v2, v1, exprtext);\\n+}\\n+\\n TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\\n+\\n+inline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {\\n+  if (v1 <= 0) return NULL;\\n+\\n+  return Check_LEImpl(size_t(v1), v2, exprtext);\\n+}\\n+\\n+inline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {\\n+  if (TF_PREDICT_FALSE(v2 < 0))\\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\\n+  return Check_LEImpl(v1, size_t(v2), exprtext);\\n+}\\n+\\n TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\\n-TF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)\\n-TF_DEFINE_CHECK_OP_IMPL(Check_GT, >)\\n+\\n+inline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {\\n+  if (v1 < 0) return NULL;\\n+\\n+  return Check_LTImpl(size_t(v1), v2, exprtext);\\n+}\\n+\\n+inline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {\\n+  if (v2 < 0)\\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\\n+  return Check_LTImpl(v1, size_t(v2), exprtext);\\n+}\\n+\\n+\/\/ Implement GE,GT in terms of LE,LT\\n+template <typename T1, typename T2>\\n+inline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {\\n+  return Check_LEImpl(v2, v1, exprtext);\\n+}\\n+\\n+template <typename T1, typename T2>\\n+inline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {\\n+  return Check_LTImpl(v2, v1, exprtext);\\n+}\\n+\\n #undef TF_DEFINE_CHECK_OP_IMPL\\n \\n \/\/ In optimized mode, use CheckOpString to hint to compiler that'}}",
      "message_norm":"merge pull request #55730 from graphcore:awf\/issue-55530\n\npiperorigin-revid: 445252025",
      "language":"en",
      "entities":"[('#55730', 'ISSUE', ''), ('445252025', 'SHA', 'generic_sha')]",
      "classification_level_1":null,
      "classification_level_2":null,
      "list_files":"dict_keys(['tensorflow\/core\/platform\/default\/logging.h'])",
      "num_files":1.0,
      "patch_content":"From a3aada9b20f48f36f4484f8da3df290d3ee3a5da Mon Sep 17 00:00:00 2001\nFrom: Andrew Fitzgibbon <awf@graphcore.ai>\nDate: Mon, 25 Apr 2022 14:40:21 +0100\nSubject: [PATCH 1\/3] Fixe size_t vs int logic in CHECK_OP\n\n---\n tensorflow\/core\/platform\/default\/logging.h | 114 +++++++++++++++------\n 1 file changed, 85 insertions(+), 29 deletions(-)\n\ndiff --git a\/tensorflow\/core\/platform\/default\/logging.h b\/tensorflow\/core\/platform\/default\/logging.h\nindex 86e7da1d9669b2..95f55ca187399d 100644\n--- a\/tensorflow\/core\/platform\/default\/logging.h\n+++ b\/tensorflow\/core\/platform\/default\/logging.h\n@@ -348,12 +348,14 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n }\n \n \/\/ Helper functions for CHECK_OP macro.\n-\/\/ The (int, int) specialization works around the issue that the compiler\n+\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\n+\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n+\/\/ This happens if, for example, those are used as token names in a\n+\/\/ yacc grammar.\n+\/\/ The (int, int) overload works around the issue that the compiler\n \/\/ will not instantiate the template version of the function on values of\n \/\/ unnamed enum type - see comment below.\n-\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n-\/\/ comparison errors while still being thorough with the comparison.\n-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \\\n   template <typename T1, typename T2>                                     \\\n   inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                             const char* exprtext) {                       \\\n@@ -364,34 +366,88 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n   }                                                                       \\\n   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n     return name##Impl<int, int>(v1, v2, exprtext);                        \\\n-  }                                                                       \\\n-  inline string* name##Impl(const size_t v1, const int v2,                \\\n-                            const char* exprtext) {                       \\\n-    if (TF_PREDICT_FALSE(v2 < 0)) {                                       \\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n-    }                                                                     \\\n-    return name##Impl<size_t, size_t>(v1, v2, exprtext);                  \\\n-  }                                                                       \\\n-  inline string* name##Impl(const int v1, const size_t v2,                \\\n-                            const char* exprtext) {                       \\\n-    if (TF_PREDICT_FALSE(v2 >= std::numeric_limits<int>::max())) {        \\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n-    }                                                                     \\\n-    const size_t uval = (size_t)((unsigned)v2);                           \\\n-    return name##Impl<size_t, size_t>(v1, uval, exprtext);                \\\n-  }\n+  }                                                                       \n+\n+\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n+\/\/ comparison errors while still being thorough with the comparison.\n+\n+TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n+\/\/ Compilation error with CHECK_EQ(NULL, x)?\n+\/\/ Use CHECK(x == NULL) instead.\n+\n+inline string* Check_EQImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (TF_PREDICT_FALSE(v1 < 0))\n+    ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+\n+  return Check_EQImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_EQImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  return Check_EQImpl(v2, v1, exprtext);\n+}\n+\n+TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n+\n+inline string* Check_NEImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 < 0)\n+    return NULL; \n+    \n+  return Check_NEImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_NEImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  return Check_NEImpl(v2, v1, exprtext);\n+}\n \n-\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\n-\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n-\/\/ This happens if, for example, those are used as token names in a\n-\/\/ yacc grammar.\n-TF_DEFINE_CHECK_OP_IMPL(Check_EQ,\n-                        ==)  \/\/ Compilation error with CHECK_EQ(NULL, x)?\n-TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)  \/\/ Use CHECK(x == NULL) instead.\n TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n+\n+inline string* Check_LEImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 <= 0)\n+    return NULL;\n+\n+  return Check_LEImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_LEImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  if (TF_PREDICT_FALSE(v2 < 0))\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+  return Check_LEImpl(v1, size_t(v2), exprtext);\n+}\n+\n TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n-TF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)\n-TF_DEFINE_CHECK_OP_IMPL(Check_GT, >)\n+\n+inline string* Check_LTImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 < 0)\n+    return NULL;\n+\n+  return Check_LTImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_LTImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  if (v2 < 0)\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+  return Check_LTImpl(v1, size_t(v2), exprtext);\n+}\n+\n+\/\/ Implement GE,GT in terms of LE,LT\n+template <typename T1, typename T2>\n+inline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {\n+  return Check_LEImpl(v2, v1, exprtext);\n+}\n+\n+template <typename T1, typename T2>\n+inline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {\n+  return Check_LTImpl(v2, v1, exprtext);\n+}\n+\n #undef TF_DEFINE_CHECK_OP_IMPL\n \n \/\/ In optimized mode, use CheckOpString to hint to compiler that\n\nFrom f564d1feb7b56349e30028cd26690e651f7f0558 Mon Sep 17 00:00:00 2001\nFrom: Andrew Fitzgibbon <awf@graphcore.ai>\nDate: Mon, 25 Apr 2022 17:50:23 +0100\nSubject: [PATCH 2\/3] clang-format\n\n---\n tensorflow\/core\/platform\/default\/logging.h | 39 ++++++++--------------\n 1 file changed, 14 insertions(+), 25 deletions(-)\n\ndiff --git a\/tensorflow\/core\/platform\/default\/logging.h b\/tensorflow\/core\/platform\/default\/logging.h\nindex 95f55ca187399d..8666a8d4ace254 100644\n--- a\/tensorflow\/core\/platform\/default\/logging.h\n+++ b\/tensorflow\/core\/platform\/default\/logging.h\n@@ -355,7 +355,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n \/\/ The (int, int) overload works around the issue that the compiler\n \/\/ will not instantiate the template version of the function on values of\n \/\/ unnamed enum type - see comment below.\n-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \\\n+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n   template <typename T1, typename T2>                                     \\\n   inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                             const char* exprtext) {                       \\\n@@ -366,7 +366,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n   }                                                                       \\\n   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n     return name##Impl<int, int>(v1, v2, exprtext);                        \\\n-  }                                                                       \n+  }\n \n \/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n \/\/ comparison errors while still being thorough with the comparison.\n@@ -375,46 +375,38 @@ TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n \/\/ Compilation error with CHECK_EQ(NULL, x)?\n \/\/ Use CHECK(x == NULL) instead.\n \n-inline string* Check_EQImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n+inline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {\n   if (TF_PREDICT_FALSE(v1 < 0))\n     ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n \n   return Check_EQImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_EQImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {\n   return Check_EQImpl(v2, v1, exprtext);\n }\n \n TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n \n-inline string* Check_NEImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 < 0)\n-    return NULL; \n-    \n+inline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 < 0) return NULL;\n+\n   return Check_NEImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_NEImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {\n   return Check_NEImpl(v2, v1, exprtext);\n }\n \n TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n \n-inline string* Check_LEImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 <= 0)\n-    return NULL;\n+inline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 <= 0) return NULL;\n \n   return Check_LEImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_LEImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {\n   if (TF_PREDICT_FALSE(v2 < 0))\n     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n   return Check_LEImpl(v1, size_t(v2), exprtext);\n@@ -422,16 +414,13 @@ inline string* Check_LEImpl(size_t v1, int v2,\n \n TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n \n-inline string* Check_LTImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 < 0)\n-    return NULL;\n+inline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 < 0) return NULL;\n \n   return Check_LTImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_LTImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {\n   if (v2 < 0)\n     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n   return Check_LTImpl(v1, size_t(v2), exprtext);\n\nFrom d73521b7603f10e3029a2f1cd5067ca985738fc8 Mon Sep 17 00:00:00 2001\nFrom: Andrew Fitzgibbon <awf@graphcore.ai>\nDate: Tue, 26 Apr 2022 08:30:22 +0100\nSubject: [PATCH 3\/3] Clang format version mismatch\n\n---\n tensorflow\/core\/platform\/default\/logging.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a\/tensorflow\/core\/platform\/default\/logging.h b\/tensorflow\/core\/platform\/default\/logging.h\nindex 8666a8d4ace254..dfee3a62c47028 100644\n--- a\/tensorflow\/core\/platform\/default\/logging.h\n+++ b\/tensorflow\/core\/platform\/default\/logging.h\n@@ -85,7 +85,7 @@ class LogMessage : public std::basic_ostringstream<char> {\n \/\/ that the ternary VLOG() implementation is balanced, type wise.\n struct Voidifier {\n   template <typename T>\n-  void operator&(const T&)const {}\n+  void operator&(const T&) const {}\n };\n \n \/\/ LogMessageFatal ensures the process will exit in failure after",
      "code_diff":"@@ -348,12 +348,14 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n }\n \n \/\/ Helper functions for CHECK_OP macro.\n-\/\/ The (int, int) specialization works around the issue that the compiler\n+\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\n+\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n+\/\/ This happens if, for example, those are used as token names in a\n+\/\/ yacc grammar.\n+\/\/ The (int, int) overload works around the issue that the compiler\n \/\/ will not instantiate the template version of the function on values of\n \/\/ unnamed enum type - see comment below.\n-\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n-\/\/ comparison errors while still being thorough with the comparison.\n-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \\\n   template <typename T1, typename T2>                                     \\\n   inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                             const char* exprtext) {                       \\\n@@ -364,34 +366,88 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n   }                                                                       \\\n   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n     return name##Impl<int, int>(v1, v2, exprtext);                        \\\n-  }                                                                       \\\n-  inline string* name##Impl(const size_t v1, const int v2,                \\\n-                            const char* exprtext) {                       \\\n-    if (TF_PREDICT_FALSE(v2 < 0)) {                                       \\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n-    }                                                                     \\\n-    return name##Impl<size_t, size_t>(v1, v2, exprtext);                  \\\n-  }                                                                       \\\n-  inline string* name##Impl(const int v1, const size_t v2,                \\\n-                            const char* exprtext) {                       \\\n-    if (TF_PREDICT_FALSE(v2 >= std::numeric_limits<int>::max())) {        \\\n-      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n-    }                                                                     \\\n-    const size_t uval = (size_t)((unsigned)v2);                           \\\n-    return name##Impl<size_t, size_t>(v1, uval, exprtext);                \\\n-  }\n+  }                                                                       \n+\n+\/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n+\/\/ comparison errors while still being thorough with the comparison.\n+\n+TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n+\/\/ Compilation error with CHECK_EQ(NULL, x)?\n+\/\/ Use CHECK(x == NULL) instead.\n+\n+inline string* Check_EQImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (TF_PREDICT_FALSE(v1 < 0))\n+    ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+\n+  return Check_EQImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_EQImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  return Check_EQImpl(v2, v1, exprtext);\n+}\n+\n+TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n+\n+inline string* Check_NEImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 < 0)\n+    return NULL; \n+    \n+  return Check_NEImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_NEImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  return Check_NEImpl(v2, v1, exprtext);\n+}\n \n-\/\/ We use the full name Check_EQ, Check_NE, etc. in case the file including\n-\/\/ base\/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n-\/\/ This happens if, for example, those are used as token names in a\n-\/\/ yacc grammar.\n-TF_DEFINE_CHECK_OP_IMPL(Check_EQ,\n-                        ==)  \/\/ Compilation error with CHECK_EQ(NULL, x)?\n-TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)  \/\/ Use CHECK(x == NULL) instead.\n TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n+\n+inline string* Check_LEImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 <= 0)\n+    return NULL;\n+\n+  return Check_LEImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_LEImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  if (TF_PREDICT_FALSE(v2 < 0))\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+  return Check_LEImpl(v1, size_t(v2), exprtext);\n+}\n+\n TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n-TF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)\n-TF_DEFINE_CHECK_OP_IMPL(Check_GT, >)\n+\n+inline string* Check_LTImpl(int v1, size_t v2,\n+                            const char* exprtext) {\n+  if (v1 < 0)\n+    return NULL;\n+\n+  return Check_LTImpl(size_t(v1), v2, exprtext);\n+}\n+\n+inline string* Check_LTImpl(size_t v1, int v2,\n+                            const char* exprtext) {\n+  if (v2 < 0)\n+    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n+  return Check_LTImpl(v1, size_t(v2), exprtext);\n+}\n+\n+\/\/ Implement GE,GT in terms of LE,LT\n+template <typename T1, typename T2>\n+inline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {\n+  return Check_LEImpl(v2, v1, exprtext);\n+}\n+\n+template <typename T1, typename T2>\n+inline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {\n+  return Check_LTImpl(v2, v1, exprtext);\n+}\n+\n #undef TF_DEFINE_CHECK_OP_IMPL\n \n \/\/ In optimized mode, use CheckOpString to hint to compiler that\n\nFrom: Andrew Fitzgibbon <awf@graphcore.ai>\n\n tensorflow\/core\/platform\/default\/logging.h | 39 ++++++++--------------\n 1 file changed, 14 insertions(+), 25 deletions(-)\n\n@@ -355,7 +355,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n \/\/ The (int, int) overload works around the issue that the compiler\n \/\/ will not instantiate the template version of the function on values of\n \/\/ unnamed enum type - see comment below.\n-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                            \\\n+#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n   template <typename T1, typename T2>                                     \\\n   inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                             const char* exprtext) {                       \\\n@@ -366,7 +366,7 @@ string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n   }                                                                       \\\n   inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n     return name##Impl<int, int>(v1, v2, exprtext);                        \\\n-  }                                                                       \n+  }\n \n \/\/ The (size_t, int) and (int, size_t) specialization are to handle unsigned\n \/\/ comparison errors while still being thorough with the comparison.\n@@ -375,46 +375,38 @@ TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n \/\/ Compilation error with CHECK_EQ(NULL, x)?\n \/\/ Use CHECK(x == NULL) instead.\n \n-inline string* Check_EQImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n+inline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {\n   if (TF_PREDICT_FALSE(v1 < 0))\n     ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n \n   return Check_EQImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_EQImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {\n   return Check_EQImpl(v2, v1, exprtext);\n }\n \n TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n \n-inline string* Check_NEImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 < 0)\n-    return NULL; \n-    \n+inline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 < 0) return NULL;\n+\n   return Check_NEImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_NEImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {\n   return Check_NEImpl(v2, v1, exprtext);\n }\n \n TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n \n-inline string* Check_LEImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 <= 0)\n-    return NULL;\n+inline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 <= 0) return NULL;\n \n   return Check_LEImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_LEImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {\n   if (TF_PREDICT_FALSE(v2 < 0))\n     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n   return Check_LEImpl(v1, size_t(v2), exprtext);\n@@ -422,16 +414,13 @@ inline string* Check_LEImpl(size_t v1, int v2,\n \n TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n \n-inline string* Check_LTImpl(int v1, size_t v2,\n-                            const char* exprtext) {\n-  if (v1 < 0)\n-    return NULL;\n+inline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {\n+  if (v1 < 0) return NULL;\n \n   return Check_LTImpl(size_t(v1), v2, exprtext);\n }\n \n-inline string* Check_LTImpl(size_t v1, int v2,\n-                            const char* exprtext) {\n+inline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {\n   if (v2 < 0)\n     return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n   return Check_LTImpl(v1, size_t(v2), exprtext);\n\nFrom: Andrew Fitzgibbon <awf@graphcore.ai>\n\n tensorflow\/core\/platform\/default\/logging.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n@@ -85,7 +85,7 @@ class LogMessage : public std::basic_ostringstream<char> {\n \/\/ that the ternary VLOG() implementation is balanced, type wise.\n struct Voidifier {\n   template <typename T>\n-  void operator&(const T&)const {}\n+  void operator&(const T&) const {}\n };\n \n \/\/ LogMessageFatal ensures the process will exit in failure after"
    },
    {
      "index":2,
      "vuln_id":"GHSA-4jqc-8m5r-9rpr",
      "cwe_id":"{'CWE-1321', 'CWE-843'}",
      "score":7.3,
      "chain":"{'https:\/\/github.com\/jonschlinkert\/set-value\/commit\/7cf8073bb06bf0c15e08475f9f952823b4576452'}",
      "dataset":"osv",
      "summary":"Prototype Pollution in set-value This affects the package `set-value` before 2.0.1, and starting with 3.0.0 but prior to 4.0.1. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the path parameter are arrays.",
      "published_date":"2021-09-13",
      "chain_len":1,
      "project":"https:\/\/github.com\/jonschlinkert\/set-value",
      "commit_href":"https:\/\/github.com\/jonschlinkert\/set-value\/commit\/7cf8073bb06bf0c15e08475f9f952823b4576452",
      "commit_sha":"7cf8073bb06bf0c15e08475f9f952823b4576452",
      "patch":"SINGLE",
      "chain_ord":"['7cf8073bb06bf0c15e08475f9f952823b4576452']",
      "before_first_fix_commit":"{'17ac6b7baa01f328a41987e02c73b71b5b82bc3a'}",
      "last_fix_commit":"7cf8073bb06bf0c15e08475f9f952823b4576452",
      "chain_ord_pos":1.0,
      "commit_datetime":"09\/12\/2021, 07:36:46",
      "message":"4.0.1\n\nFixes https:\/\/github.com\/jonschlinkert\/set-value\/pull\/33 thanks to @ready-research.",
      "author":"Jon Schlinkert",
      "comments":null,
      "stats":"{'additions': 2, 'deletions': 2, 'total': 4}",
      "files":"{'package.json': {'additions': 2, 'deletions': 2, 'changes': 4, 'status': 'modified', 'raw_url': 'https:\/\/github.com\/jonschlinkert\/set-value\/raw\/7cf8073bb06bf0c15e08475f9f952823b4576452\/package.json', 'patch': '@@ -1,6 +1,6 @@\\n {\\n   \"name\": \"set-value\",\\n-  \"version\": \"4.0.0\",\\n+  \"version\": \"4.0.1\",\\n   \"description\": \"Set nested properties on an object using dot notation.\",\\n   \"license\": \"MIT\",\\n   \"repository\": \"jonschlinkert\/set-value\",\\n@@ -122,4 +122,4 @@\\n       \"update\"\\n     ]\\n   }\\n-}\\n\\\\ No newline at end of file\\n+}'}}",
      "message_norm":"4.0.1\n\nfixes https:\/\/github.com\/jonschlinkert\/set-value\/pull\/33 thanks to @ready-research.",
      "language":"en",
      "entities":"[('4.0.1', 'VERSION', ''), ('https:\/\/github.com\/jonschlinkert\/set-value\/pull\/33', 'URL', '')]",
      "classification_level_1":null,
      "classification_level_2":null,
      "list_files":"dict_keys(['package.json'])",
      "num_files":1.0,
      "patch_content":"From 7cf8073bb06bf0c15e08475f9f952823b4576452 Mon Sep 17 00:00:00 2001\nFrom: Jon Schlinkert <github@sellside.com>\nDate: Sun, 12 Sep 2021 03:36:46 -0400\nSubject: [PATCH] 4.0.1\n\nFixes https:\/\/github.com\/jonschlinkert\/set-value\/pull\/33 thanks to @ready-research.\n---\n package.json | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a\/package.json b\/package.json\nindex a9b264e..3865c1f 100644\n--- a\/package.json\n+++ b\/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"set-value\",\n-  \"version\": \"4.0.0\",\n+  \"version\": \"4.0.1\",\n   \"description\": \"Set nested properties on an object using dot notation.\",\n   \"license\": \"MIT\",\n   \"repository\": \"jonschlinkert\/set-value\",\n@@ -122,4 +122,4 @@\n       \"update\"\n     ]\n   }\n-}\n\\ No newline at end of file\n+}",
      "code_diff":"@@ -1,6 +1,6 @@\n {\n   \"name\": \"set-value\",\n-  \"version\": \"4.0.0\",\n+  \"version\": \"4.0.1\",\n   \"description\": \"Set nested properties on an object using dot notation.\",\n   \"license\": \"MIT\",\n   \"repository\": \"jonschlinkert\/set-value\",\n@@ -122,4 +122,4 @@\n       \"update\"\n     ]\n   }\n-}\n\\ No newline at end of file\n+}"
    },
    {
      "index":3,
      "vuln_id":"GHSA-p92x-r36w-9395",
      "cwe_id":"{'CWE-843'}",
      "score":5.6,
      "chain":"{'https:\/\/github.com\/aheckmann\/mpath\/commit\/89402d2880d4ea3518480a8c9847c541f2d824fc'}",
      "dataset":"osv",
      "summary":"Type confusion in mpath This affects the package mpath before 0.8.4. A type confusion vulnerability can lead to a bypass of CVE-2018-16490. In particular, the condition ignoreProperties.indexOf(parts[i]) !== -1 returns -1 if parts[i] is ['__proto__']. This is because the method that has been called if the input is an array is Array.prototype.indexOf() and not String.prototype.indexOf(). They behave differently depending on the type of the input.",
      "published_date":"2021-09-02",
      "chain_len":1,
      "project":"https:\/\/github.com\/aheckmann\/mpath",
      "commit_href":"https:\/\/github.com\/aheckmann\/mpath\/commit\/89402d2880d4ea3518480a8c9847c541f2d824fc",
      "commit_sha":"89402d2880d4ea3518480a8c9847c541f2d824fc",
      "patch":"SINGLE",
      "chain_ord":"['89402d2880d4ea3518480a8c9847c541f2d824fc']",
      "before_first_fix_commit":"{'03c4efef8b25425476c1e0d7b6a0fb5adc18c0f9'}",
      "last_fix_commit":"89402d2880d4ea3518480a8c9847c541f2d824fc",
      "chain_ord_pos":1.0,
      "commit_datetime":"09\/01\/2021, 15:12:24",
      "message":"fix: throw error if `parts` contains an element that isn't a string or number\n\nFix #13",
      "author":"Valeri Karpov",
      "comments":null,
      "stats":"{'additions': 12, 'deletions': 0, 'total': 12}",
      "files":"{'lib\/index.js': {'additions': 12, 'deletions': 0, 'changes': 12, 'status': 'modified', 'raw_url': 'https:\/\/github.com\/mongoosejs\/mpath\/raw\/89402d2880d4ea3518480a8c9847c541f2d824fc\/lib%2Findex.js', 'patch': \"@@ -64,6 +64,9 @@ exports.get = function(path, o, special, map) {\\n \\n   for (var i = 0; i < parts.length; ++i) {\\n     part = parts[i];\\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\\n+      throw new TypeError('Each segment of path to `get()` must be a string or number, got ' + typeof parts[i]);\\n+    }\\n \\n     if (Array.isArray(obj) && !\/^\\\\d+$\/.test(part)) {\\n       \/\/ reading a property from the array items\\n@@ -112,6 +115,9 @@ exports.has = function(path, o) {\\n   var len = parts.length;\\n   var cur = o;\\n   for (var i = 0; i < len; ++i) {\\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\\n+      throw new TypeError('Each segment of path to `has()` must be a string or number, got ' + typeof parts[i]);\\n+    }\\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\\n       return false;\\n     }\\n@@ -143,6 +149,9 @@ exports.unset = function(path, o) {\\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\\n       return false;\\n     }\\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\\n+      throw new TypeError('Each segment of path to `unset()` must be a string or number, got ' + typeof parts[i]);\\n+    }\\n     \/\/ Disallow any updates to __proto__ or special properties.\\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {\\n       return false;\\n@@ -193,6 +202,9 @@ exports.set = function(path, val, o, special, map, _copying) {\\n   if (null == o) return;\\n \\n   for (var i = 0; i < parts.length; ++i) {\\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\\n+      throw new TypeError('Each segment of path to `set()` must be a string or number, got ' + typeof parts[i]);\\n+    }\\n     \/\/ Silently ignore any updates to `__proto__`, these are potentially\\n     \/\/ dangerous if using mpath with unsanitized data.\\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {\"}}",
      "message_norm":"fix: throw error if `parts` contains an element that isn't a string or number\n\nfix #13",
      "language":"en",
      "entities":"[('error', 'FLAW', ''), ('fix', 'ACTION', ''), ('#13', 'ISSUE', '')]",
      "classification_level_1":null,
      "classification_level_2":null,
      "list_files":"dict_keys(['lib\/index.js'])",
      "num_files":1.0,
      "patch_content":"From 89402d2880d4ea3518480a8c9847c541f2d824fc Mon Sep 17 00:00:00 2001\nFrom: Valeri Karpov <val@karpov.io>\nDate: Wed, 1 Sep 2021 11:12:24 -0400\nSubject: [PATCH] fix: throw error if `parts` contains an element that isn't a\n string or number\n\nFix #13\n---\n lib\/index.js | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a\/lib\/index.js b\/lib\/index.js\nindex 338bf9b..c9e7e5f 100644\n--- a\/lib\/index.js\n+++ b\/lib\/index.js\n@@ -64,6 +64,9 @@ exports.get = function(path, o, special, map) {\n \n   for (var i = 0; i < parts.length; ++i) {\n     part = parts[i];\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `get()` must be a string or number, got ' + typeof parts[i]);\n+    }\n \n     if (Array.isArray(obj) && !\/^\\d+$\/.test(part)) {\n       \/\/ reading a property from the array items\n@@ -112,6 +115,9 @@ exports.has = function(path, o) {\n   var len = parts.length;\n   var cur = o;\n   for (var i = 0; i < len; ++i) {\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `has()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n       return false;\n     }\n@@ -143,6 +149,9 @@ exports.unset = function(path, o) {\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n       return false;\n     }\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `unset()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     \/\/ Disallow any updates to __proto__ or special properties.\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {\n       return false;\n@@ -193,6 +202,9 @@ exports.set = function(path, val, o, special, map, _copying) {\n   if (null == o) return;\n \n   for (var i = 0; i < parts.length; ++i) {\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `set()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     \/\/ Silently ignore any updates to `__proto__`, these are potentially\n     \/\/ dangerous if using mpath with unsanitized data.\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {",
      "code_diff":"@@ -64,6 +64,9 @@ exports.get = function(path, o, special, map) {\n \n   for (var i = 0; i < parts.length; ++i) {\n     part = parts[i];\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `get()` must be a string or number, got ' + typeof parts[i]);\n+    }\n \n     if (Array.isArray(obj) && !\/^\\d+$\/.test(part)) {\n       \/\/ reading a property from the array items\n@@ -112,6 +115,9 @@ exports.has = function(path, o) {\n   var len = parts.length;\n   var cur = o;\n   for (var i = 0; i < len; ++i) {\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `has()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n       return false;\n     }\n@@ -143,6 +149,9 @@ exports.unset = function(path, o) {\n     if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n       return false;\n     }\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `unset()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     \/\/ Disallow any updates to __proto__ or special properties.\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {\n       return false;\n@@ -193,6 +202,9 @@ exports.set = function(path, val, o, special, map, _copying) {\n   if (null == o) return;\n \n   for (var i = 0; i < parts.length; ++i) {\n+    if (typeof parts[i] !== 'string' && typeof parts[i] !== 'number') {\n+      throw new TypeError('Each segment of path to `set()` must be a string or number, got ' + typeof parts[i]);\n+    }\n     \/\/ Silently ignore any updates to `__proto__`, these are potentially\n     \/\/ dangerous if using mpath with unsanitized data.\n     if (ignoreProperties.indexOf(parts[i]) !== -1) {"
    }
  ]
}