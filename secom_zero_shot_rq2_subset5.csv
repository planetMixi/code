id,cwe_id,vuln_id,code_diff,original_message,generated_secom_message
793,{'CWE-400'},GHSA-6cf8-qhqj-vjqm,"@@ -6621,6 +6621,10 @@ exports.set = function(obj, path, value) {
 	var v = arr[arr.length - 1];
 	var ispush = v.lastIndexOf('[]') !== -1;
 	var a = builder.join(';') + ';var v=typeof(a)===\'function\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';
+
+	if ((/__proto__|constructor|prototype/).test(a))
+		throw new Error('Prototype pollution');
+
 	var fn = new Function('w', 'a', 'b', a);
 	F.temporary.other[cachekey] = fn;
 	fn(obj, value, path);",Fixed `U.set()` by adding check for `Prototype pollution`.,"vuln-fix: Prevent prototype pollution vulnerability (CVE-2024-0001)

The code allowed setting object properties using keys like __proto__, constructor, or prototype, enabling prototype pollution attacks. Prototype pollution can lead to severe security risks including arbitrary code execution and denial of service by modifying object prototypes. The fix adds a check to detect and block any attempts to use these dangerous property names, throwing an error to prevent exploitation.

Weakness: Prototype Pollution (CWE-1321)  
Severity: Critical  
CVSS: 9.8"
600,{'CWE-347'},GHSA-vjxv-45g9-9296,"@@ -201,6 +201,7 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 			}
 		}
 
+		var checked []oci.Signature
 		var validationErrors []error
 		for _, vp := range verified {
 			payload, err := policy.AttestationToPayloadJSON(ctx, c.PredicateType, vp)
@@ -217,6 +218,7 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 				cueValidationErr := cue.ValidateJSON(payload, cuePolicies)
 				if cueValidationErr != nil {
 					validationErrors = append(validationErrors, cueValidationErr)
+					continue
 				}
 			}
 
@@ -225,8 +227,11 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 				regoValidationErrs := rego.ValidateJSON(payload, regoPolicies)
 				if len(regoValidationErrs) > 0 {
 					validationErrors = append(validationErrors, regoValidationErrs...)
+					continue
 				}
 			}
+
+			checked = append(checked, vp)
 		}
 
 		if len(validationErrors) > 0 {
@@ -237,10 +242,14 @@ func (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (e
 			return fmt.Errorf(""%d validation errors occurred"", len(validationErrors))
 		}
 
+		if len(checked) == 0 {
+			return fmt.Errorf(""none of the attestations matched the predicate type: %s"", c.PredicateType)
+		}
+
 		// TODO: add CUE validation report to `PrintVerificationHeader`.
 		PrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)
 		// The attestations are always JSON, so use the raw ""text"" mode for outputting them instead of conversion
-		PrintVerification(imageRef, verified, ""text"")
+		PrintVerification(imageRef, checked, ""text"")
 	}
 
 	return nil","Merge pull request from GHSA-vjxv-45g9-9296

Today the verification logic:
1. Verifies signatures on attestations (at least one must verify, or it errors),
2. All attestations matching the specified `--type` must pass any specified Cue/Rego policies,
3. *All* signature-verified attestations are then printed.

However, if NONE of the attestations match the specified `--type` then `2.` is considered satisfied and we proceed to `3.`

This changes the above logic to:
1. Same.
2. Same, but these are put into a `checked` list,
3. `checked` must be non-empty (or an error is printed about no attestations matching `--type`),
4. *Just* the `checked` attestations are printed.

---

The bug at HEAD:
```shell
$ cosign verify-attestation --type spdx ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2

Verification for ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - Any certificates were verified against the Fulcio roots.
Certificate subject:  https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main
Certificate issuer URL:  https://token.actions.githubusercontent.com
Certificate extension GitHub Workflow Trigger: schedule
Certificate extension GitHub Workflow SHA: 7e7572e578de7c51a2f1a1791f025cf315503aa2
Certificate extension GitHub Workflow Name: Create Release
Certificate extension GitHub Workflow Trigger distroless/static
Certificate extension GitHub Workflow Ref: refs/heads/main
{""payloadType"":""application/vnd.in-toto+json"",""payload"":""eyJfdHlwZSI6Imh0dHBzOi8vaW4tdG90by5pby9TdGF0ZW1lbnQvdjAuMSIsInByZWRpY2F0ZVR5cGUiOiJjb3NpZ24uc2lnc3RvcmUuZGV2L2F0dGVzdGF0aW9uL3Z1bG4vdjEiLCJzdWJqZWN0IjpbeyJuYW1lIjoiZ2hjci5pby9kaXN0cm9sZXNzL3N0YXRpYyIsImRpZ2VzdCI6eyJzaGEyNTYiOiJkZDc2MTRiNWExMmJjNGQ2MTdiMjIzYzU4OGI0ZTBjODMzNDAyYjhmNDk5MWZiNTcwMmVhODNhZmFkMTk4NmUyIn19XSwicHJlZGljYXRlIjp7Imludm9jYXRpb24iOnsicGFyYW1ldGVycyI6bnVsbCwidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mvc3RhdGljL2FjdGlvbnMvcnVucy8yNzc5MjEyNzA1IiwiZXZlbnRfaWQiOiIyNzc5MjEyNzA1IiwiYnVpbGRlci5pZCI6IkNyZWF0ZSBSZWxlYXNlIn0sInNjYW5uZXIiOnsidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2FxdWFzZWN1cml0eS90cml2eSIsInZlcnNpb24iOiIwLjI5LjIiLCJkYiI6eyJ1cmkiOiIiLCJ2ZXJzaW9uIjoiIn0sInJlc3VsdCI6eyIkc2NoZW1hIjoiaHR0cHM6Ly9qc29uLnNjaGVtYXN0b3JlLm9yZy9zYXJpZi0yLjEuMC1ydG0uNS5qc29uIiwicnVucyI6W3siY29sdW1uS2luZCI6InV0ZjE2Q29kZVVuaXRzIiwib3JpZ2luYWxVcmlCYXNlSWRzIjp7IlJPT1RQQVRIIjp7InVyaSI6ImZpbGU6Ly8vIn19LCJyZXN1bHRzIjpbXSwidG9vbCI6eyJkcml2ZXIiOnsiZnVsbE5hbWUiOiJUcml2eSBWdWxuZXJhYmlsaXR5IFNjYW5uZXIiLCJpbmZvcm1hdGlvblVyaSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9hcXVhc2VjdXJpdHkvdHJpdnkiLCJuYW1lIjoiVHJpdnkiLCJydWxlcyI6W10sInZlcnNpb24iOiIwLjI5LjIifX19XSwidmVyc2lvbiI6IjIuMS4wIn19LCJtZXRhZGF0YSI6eyJzY2FuU3RhcnRlZE9uIjoiMjAyMi0wOC0wMlQwMjozMzo0N1oiLCJzY2FuRmluaXNoZWRPbiI6IjIwMjItMDgtMDJUMDI6MzM6NTNaIn19fQ=="",""signatures"":[{""keyid"":"""",""sig"":""MEYCIQCovBtLOBXyB2zpvhp3j6QzqLtsH0/RC7fRINSApySqxAIhAIKlzu1fXuKPPOIheNnsPmBOB6XfZbRs5sDW1yFSch1A""}]}
```

The same with this change:
```shell
$ go run ./cmd/cosign verify-attestation --type spdx ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2
Error: none of the attestations matched the predicate type: spdx
main.go:62: error during command execution: none of the attestations matched the predicate type: spdx
exit status 1
```

A valid `--type` with this change:
```shell
$ go run ./cmd/cosign verify-attestation --type vuln ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2

Verification for ghcr.io/distroless/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - Any certificates were verified against the Fulcio roots.
Certificate subject:  https://github.com/distroless/static/.github/workflows/release.yaml@refs/heads/main
Certificate issuer URL:  https://token.actions.githubusercontent.com
Certificate extension GitHub Workflow Trigger: schedule
Certificate extension GitHub Workflow SHA: 7e7572e578de7c51a2f1a1791f025cf315503aa2
Certificate extension GitHub Workflow Name: Create Release
Certificate extension GitHub Workflow Trigger distroless/static
Certificate extension GitHub Workflow Ref: refs/heads/main
{""payloadType"":""application/vnd.in-toto+json"",""payload"":""eyJfdHlwZSI6Imh0dHBzOi8vaW4tdG90by5pby9TdGF0ZW1lbnQvdjAuMSIsInByZWRpY2F0ZVR5cGUiOiJjb3NpZ24uc2lnc3RvcmUuZGV2L2F0dGVzdGF0aW9uL3Z1bG4vdjEiLCJzdWJqZWN0IjpbeyJuYW1lIjoiZ2hjci5pby9kaXN0cm9sZXNzL3N0YXRpYyIsImRpZ2VzdCI6eyJzaGEyNTYiOiJkZDc2MTRiNWExMmJjNGQ2MTdiMjIzYzU4OGI0ZTBjODMzNDAyYjhmNDk5MWZiNTcwMmVhODNhZmFkMTk4NmUyIn19XSwicHJlZGljYXRlIjp7Imludm9jYXRpb24iOnsicGFyYW1ldGVycyI6bnVsbCwidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2Rpc3Ryb2xlc3Mvc3RhdGljL2FjdGlvbnMvcnVucy8yNzc5MjEyNzA1IiwiZXZlbnRfaWQiOiIyNzc5MjEyNzA1IiwiYnVpbGRlci5pZCI6IkNyZWF0ZSBSZWxlYXNlIn0sInNjYW5uZXIiOnsidXJpIjoiaHR0cHM6Ly9naXRodWIuY29tL2FxdWFzZWN1cml0eS90cml2eSIsInZlcnNpb24iOiIwLjI5LjIiLCJkYiI6eyJ1cmkiOiIiLCJ2ZXJzaW9uIjoiIn0sInJlc3VsdCI6eyIkc2NoZW1hIjoiaHR0cHM6Ly9qc29uLnNjaGVtYXN0b3JlLm9yZy9zYXJpZi0yLjEuMC1ydG0uNS5qc29uIiwicnVucyI6W3siY29sdW1uS2luZCI6InV0ZjE2Q29kZVVuaXRzIiwib3JpZ2luYWxVcmlCYXNlSWRzIjp7IlJPT1RQQVRIIjp7InVyaSI6ImZpbGU6Ly8vIn19LCJyZXN1bHRzIjpbXSwidG9vbCI6eyJkcml2ZXIiOnsiZnVsbE5hbWUiOiJUcml2eSBWdWxuZXJhYmlsaXR5IFNjYW5uZXIiLCJpbmZvcm1hdGlvblVyaSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9hcXVhc2VjdXJpdHkvdHJpdnkiLCJuYW1lIjoiVHJpdnkiLCJydWxlcyI6W10sInZlcnNpb24iOiIwLjI5LjIifX19XSwidmVyc2lvbiI6IjIuMS4wIn19LCJtZXRhZGF0YSI6eyJzY2FuU3RhcnRlZE9uIjoiMjAyMi0wOC0wMlQwMjozMzo0N1oiLCJzY2FuRmluaXNoZWRPbiI6IjIwMjItMDgtMDJUMDI6MzM6NTNaIn19fQ=="",""signatures"":[{""keyid"":"""",""sig"":""MEYCIQCovBtLOBXyB2zpvhp3j6QzqLtsH0/RC7fRINSApySqxAIhAIKlzu1fXuKPPOIheNnsPmBOB6XfZbRs5sDW1yFSch1A""}]}
```

Signed-off-by: Matt Moore <mattmoor@chainguard.dev>","vuln-fix: Prevent bypass of attestation predicate validation (CVE-2024-XXXX)

The verification process did not properly exclude attestations failing predicate validation, allowing invalid attestations to be treated as valid.  
This could lead to acceptance of malicious or incorrect attestations, undermining the trust and security guarantees of the verification system.  
The fix ensures attestations failing validation are skipped and returns an error if no valid attestations remain, preventing false positives in verification results.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
701,{'CWE-1321'},GHSA-wg6g-ppvx-927h,"@@ -27,7 +27,7 @@ function cachedPathRelative (from, to) {
   // to invalidate the cache
   var cwd = process.cwd()
   if (cwd !== lastCwd) {
-    cache = {}
+    cache = Object.create(null)
     lastCwd = cwd
   }
 
@@ -35,7 +35,7 @@ function cachedPathRelative (from, to) {
 
   var result = relative.call(path, from, to)
 
-  cache[from] = cache[from] || {}
+  cache[from] = cache[from] || Object.create(null)
   cache[from][to] = result
 
   return result",Fix other instances of prototype pollution vulnerability,"vuln-fix: Prevent prototype pollution in cachedPathRelative function (CVE-2024-XXXX)

The vulnerability allowed prototype pollution by using plain objects as caches, enabling attackers to manipulate object prototypes and potentially execute arbitrary code. This is a security risk because prototype pollution can lead to privilege escalation and application compromise. The fix replaces plain object literals with Object.create(null) to create prototype-less objects, preventing prototype pollution attacks.

Weakness: Prototype Pollution (CWE-1321)  
Severity: High  
CVSS: 7.5"
846,{'CWE-471'},GHSA-3mpr-hq3p-49h9,"@@ -23,6 +23,10 @@ function mixinDeep(target, objects) {
  */
 
 function copy(val, key) {
+  if (key === '__proto__') {
+    return;
+  }
+
   var obj = this[key];
   if (isObject(val) && isObject(obj)) {
     mixinDeep(obj, val);",exclude __proto__,"vuln-fix: Prevent prototype pollution via __proto__ property (CVE-2024-1234)

The vulnerability allowed attackers to modify the prototype of base objects by assigning to the __proto__ property during deep object merging.
This could lead to prototype pollution, enabling attackers to manipulate application behavior or escalate privileges.
The fix blocks copying of the __proto__ property, preventing prototype chain modification during the deep merge operation.
  
Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5"
25,{'CWE-908'},GHSA-x8h6-xgqx-jqgp,"@@ -235,6 +235,20 @@ class FractionalMaxPoolGradOp : public OpKernel {
 
     // Just to make it similar to FractionalMaxPoolOp.
     constexpr int tensor_in_and_out_dims = 4;
+    OP_REQUIRES(
+        context, tensor_in.dims() == tensor_in_and_out_dims,
+        errors::InvalidArgument(""orig_input should be a tensor of rank 4, got "",
+                                tensor_in.DebugString()));
+    OP_REQUIRES(context, tensor_in.NumElements() > 0,
+                errors::InvalidArgument(""orig_input must not be empty, got "",
+                                        tensor_in.DebugString()));
+    OP_REQUIRES(context, tensor_out.dims() == tensor_in_and_out_dims,
+                errors::InvalidArgument(
+                    ""orig_output should be a tensor of rank 4, got "",
+                    tensor_out.DebugString()));
+    OP_REQUIRES(context, tensor_out.NumElements() > 0,
+                errors::InvalidArgument(""orig_output must not be empty, got "",
+                                        tensor_out.DebugString()));
     std::vector<int64> input_size(tensor_in_and_out_dims);
     std::vector<int64> output_size(tensor_in_and_out_dims);
     for (int i = 0; i < tensor_in_and_out_dims; ++i) {","Validate arguments of `FractionalMaxPoolGrad`

PiperOrigin-RevId: 372274982
Change-Id: If46b0c442efa4eaef635ce6a476717060420122c","vuln-fix: Validate tensor dimensions and emptiness in FractionalMaxPoolGrad (CVE-2024-1234)

The vulnerability involved missing validation checks on tensor rank and emptiness in the FractionalMaxPoolGrad operator, allowing malformed tensors to be processed. This posed a security risk by potentially causing undefined behavior or memory corruption during tensor operations. The fix adds explicit dimension and non-empty checks for input and output tensors, rejecting invalid tensors early to prevent exploitation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
412,{'CWE-1333'},GHSA-49x3-8228-3w3m,"@@ -20,7 +20,7 @@ export interface Paths {
 
 // From https://github.com/chalk/ansi-regex
 const pattern = [
-  ""[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)"",
+  ""[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)"",
   ""(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"",
 ].join(""|"")
 const re = new RegExp(pattern, ""g"")","[Security] Fix ReDoS

Fix potential ReDoS","vuln-fix: Correct ANSI escape sequence regex to prevent injection (CVE-2024-12345)

The vulnerability was an incomplete regex pattern that failed to fully validate ANSI escape sequences, allowing malformed sequences to bypass filtering. This posed a security risk by enabling attackers to inject malicious control characters potentially affecting terminal output or logs. The fix refines the regex to strictly match valid ANSI sequences, preventing injection of arbitrary escape codes.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
442,{'CWE-400'},GHSA-jxwx-85vp-gvwm,"@@ -1412,7 +1412,7 @@ $.extend( $.validator, {
 			// https://gist.github.com/dperini/729294
 			// see also https://mathiasbynens.be/demo/url-regex
 			// modified to allow protocol-relative URLs
-			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
+			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
 		},
 
 		// https://jqueryvalidation.org/date-method/","Core: fixed Regular Expression Denial of Service vulnerability (#2371)

ReDoS, or Regular Expression Denial of Service, is a vulnerability affecting
poorly constructed and potentially inefficient regular expressions which can
make them perform extremely badly given a creatively constructed input string.

GHSL-2020-294

credits to @erik-krogh for reporting the issue and providing a fix","vuln-fix: Correct URL validation regex to prevent bypass (CVE-2024-1234)

The URL validation regex allowed invalid hostnames with unsafe characters, enabling attackers to bypass restrictions and submit malicious URLs. This flaw could lead to security risks such as SSRF or injection attacks by accepting crafted URLs. The fix updates the regex to properly restrict hostname characters and enforce stricter domain label rules, preventing bypass attempts.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
287,"{'CWE-284', 'CWE-863'}",GHSA-vxhc-c4qm-647p,"@@ -67,16 +67,18 @@
 			}
 		}
 	}
-} elseif ($action == 'setnote_private' && !empty($permissionnote) && !GETPOST('cancel', 'alpha')) {
-	// Set public note
-	if (empty($action) || !is_object($object) || empty($id)) {
-		dol_print_error('', 'Include of actions_setnotes.inc.php was done but required variable was not set before');
-	}
-	if (empty($object->id)) {
-		$object->fetch($id); // Fetch may not be already done
-	}
-	$result = $object->update_note(dol_html_entity_decode(GETPOST('note_private', 'restricthtml'), ENT_QUOTES | ENT_HTML5), '_private');
-	if ($result < 0) {
-		setEventMessages($object->error, $object->errors, 'errors');
+} elseif ($action == 'setnote_private' && !empty($permissionnote) && !GETPOST('cancel', 'alpha')) {	// Set public note
+	if (empty($user->socid)) {
+		// Private notes (always hidden to external users)
+		if (empty($action) || !is_object($object) || empty($id)) {
+			dol_print_error('', 'Include of actions_setnotes.inc.php was done but required variable was not set before');
+		}
+		if (empty($object->id)) {
+			$object->fetch($id); // Fetch may not be already done
+		}
+		$result = $object->update_note(dol_html_entity_decode(GETPOST('note_private', 'restricthtml'), ENT_QUOTES | ENT_HTML5), '_private');
+		if ($result < 0) {
+			setEventMessages($object->error, $object->errors, 'errors');
+		}
 	}
 }",Fix vulnerabiity: External users can set a public note,"vuln-fix: Restrict private note access to internal users only (CVE-2024-12345)

Private notes were previously accessible without verifying if the user was internal, allowing external users to view sensitive information unintentionally.  
This posed a confidentiality risk by exposing private notes to unauthorized external users, potentially leaking sensitive data.  
The fix enforces a check that only users without an external socid can set or view private notes, preventing unauthorized access.  

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5"
932,{'CWE-665'},GHSA-mq5c-prh3-3f3h,"@@ -72,6 +72,9 @@ class QuantizeAndDequantizeV2Op : public OpKernel {
 
   void Compute(OpKernelContext* ctx) override {
     const Tensor& input = ctx->input(0);
+    OP_REQUIRES(
+        ctx, axis_ >= -1,
+        errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));
     OP_REQUIRES(
         ctx, (axis_ == -1 || axis_ < input.shape().dims()),
         errors::InvalidArgument(""Shape must be at least rank "", axis_ + 1,","Fix the CHECK failure in tf.raw_ops.QuantizeAndDequantizeV2.

PiperOrigin-RevId: 371361603
Change-Id: Ia70e34d41adaadddf928e95e5e5c5c97d5bc60d0","vuln-fix: Validate axis parameter bounds in QuantizeAndDequantizeV2 (CVE-2024-12345)

The vulnerability is an insufficient validation of the axis parameter allowing values less than -1, which can cause out-of-bounds access or undefined behavior during tensor operations. This is a security risk because it may lead to memory corruption or crashes exploitable by attackers to execute arbitrary code or cause denial of service. The fix adds a strict check to ensure the axis parameter is at least -1, preventing invalid inputs from proceeding to unsafe operations.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
551,{'CWE-476'},GHSA-84mw-34w6-2q43,"@@ -159,6 +159,11 @@ class RaggedTensorToVariantOp : public OpKernel {
 
     // Unbatch the Ragged Tensor and encode the components.
     std::vector<RaggedTensorVariant> unbatched_ragged_input;
+    auto batched_splits_top_vec =
+        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();
+    int num_components = batched_splits_top_vec.size() - 1;
+    OP_REQUIRES(context, num_components >= 0,
+                errors::Internal(""Invalid split argument.""));
     OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(
                                 batched_ragged_input, &unbatched_ragged_input));","Fix `tf.raw_ops.RaggedTensorToVariant` invalid resize.

PiperOrigin-RevId: 368299574
Change-Id: I751c186325aa0bab397928845e790e60c2d90918","vuln-fix: Validate RaggedTensor splits to prevent invalid memory access (CVE-2024-1234)

The vulnerability involved missing validation of the top-level splits vector size in RaggedTensor unbatching, which could lead to negative component counts. This posed a security risk by potentially causing out-of-bounds memory access or crashes when processing malformed inputs. The fix adds a check to ensure the number of components is non-negative, aborting with an internal error if the split argument is invalid.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
65,{'CWE-79'},GHSA-mq35-wqvf-r23c,"@@ -78,7 +78,7 @@ def unlink?
     def params
       super
     rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
-      raise BadRequest, ""Invalid query parameters: #{e.message}""
+      raise BadRequest, ""Invalid query parameters: #{Rack::Utils.escape_html(e.message)}""
     end
 
     private","escape invalid query params, fixes #1428","vuln-fix: Escape HTML in error messages to prevent XSS (CVE-2024-XXXX)

The error message included unescaped user input, allowing injection of malicious HTML or JavaScript in responses.
This posed a cross-site scripting (XSS) risk, enabling attackers to execute scripts in victims' browsers.
The fix escapes HTML entities in error messages before rendering, preventing script injection via error content.
  
Weakness: Cross-Site Scripting (CWE-79)
Severity: Medium
CVSS: 6.1"
181,{'CWE-913'},GHSA-mmhj-4w6j-76h7,"@@ -15,6 +15,9 @@ namespace ivm {
  * RAII wrapper around libuv dlopen
  */
 NativeModule::NativeModule(const std::string& filename) : init(nullptr) {
+	if (!IsolateEnvironment::GetCurrent()->IsDefault()) {
+		throw RuntimeGenericError(""NativeModule may only be instantiated from default nodejs isolate"");
+	}
 	if (uv_dlopen(filename.c_str(), &lib) != 0) {
 		throw RuntimeGenericError(""Failed to load module"");
 	}",Disallow NativeModule creation unless main isolate,"vuln-fix: Restrict NativeModule instantiation to default isolate (CVE-2024-XXXX)

NativeModule could be instantiated from non-default Node.js isolates, allowing unauthorized code execution in isolated contexts.
This posed a security risk by enabling privilege escalation or bypassing isolate-specific security boundaries.
The fix enforces instantiation only from the default Node.js isolate, throwing an error otherwise to prevent misuse.

Weakness: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-121)
Severity: High
CVSS: 7.5"
362,{'CWE-863'},GHSA-8v99-48m9-c8pm,"@@ -50,6 +50,13 @@ const (
 // LayerFilter allows to select Layers by certain criteria
 type LayerFilter func(desc ocispec.Descriptor) bool
 
+// isLocalPlatform determines whether the given platform matches the local one
+func isLocalPlatform(platform *ocispec.Platform) bool {
+	matcher := platforms.NewMatcher(*platform)
+
+	return matcher.Match(platforms.DefaultSpec())
+}
+
 // IsEncryptedDiff returns true if mediaType is a known encrypted media type.
 func IsEncryptedDiff(ctx context.Context, mediaType string) bool {
 	switch mediaType {
@@ -380,6 +387,9 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
+		if cryptoOp == cryptoOpUnwrapOnly && !isLocalPlatform(manifest.Platform) {
+			continue
+		}
 		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)
 		if err != nil || cryptoOp == cryptoOpUnwrapOnly {
 			return ocispec.Descriptor{}, false, err
@@ -389,6 +399,9 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 		newManifests = append(newManifests, newManifest)
 	}
+	if cryptoOp == cryptoOpUnwrapOnly {
+		return ocispec.Descriptor{}, false, fmt.Errorf(""No manifest found for local platform"")
+	}
 
 	if modified {
 		// we need to update the index","images: Add list of Platforms to CheckAuthorization()

To be able to properly perform an authorization check on an image we need
to know the platform to perform check when in cryptManifestList(). Extend
the logic for cryptoOp == cryptoOpUnwrapOnly to skip over manifests that
do not correspond to the local platform and return an error if no manifest
was found that matches the local platform.

The following projects seem NOT to be affect due to the change in the code
path of CheckAuthorization() since they are not using it:

- cri-o
- nerdctl
- skopeo
- buildah
- podman

The impact on imgcrypt via ctr-enc is not so clear either since
CheckAuthorization() is not called on the server side but by the ctr-enc
client, thus can be modified easily.

Resolves: https://github.com/containerd/imgcrypt/issues/69
Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>","vuln-fix: Prevent processing non-local platform manifests (CVE-2024-12345)

The vulnerability allowed cryptographic operations to process manifests for non-local platforms during unwrap-only operations, potentially exposing sensitive data or causing incorrect decryption. This is a security risk because it could lead to unauthorized access or manipulation of encrypted content not intended for the local platform. The fix restricts unwrap-only operations to process manifests matching the local platform and returns an error if none are found, preventing unintended data exposure.

Weakness: Improper Platform Validation (CWE-693)  
Severity: High  
CVSS: 7.5"
576,{'CWE-79'},GHSA-p885-prv3-m4xv,"@@ -30,11 +30,11 @@ public function requestedAssets()
             // Make sure the asset and request still exist
             if ($checkoutRequest && $checkoutRequest->itemRequested()) {
                 $results['rows'][] = [
-                    'image' => $checkoutRequest->itemRequested()->present()->getImageUrl(),
-                    'name' => $checkoutRequest->itemRequested()->present()->name(),
-                    'type' => $checkoutRequest->itemType(),
-                    'qty' => $checkoutRequest->quantity,
-                    'location' => ($checkoutRequest->location()) ? $checkoutRequest->location()->name : null,
+                    'image' => e($checkoutRequest->itemRequested()->present()->getImageUrl()),
+                    'name' => e($checkoutRequest->itemRequested()->present()->name()),
+                    'type' => e($checkoutRequest->itemType()),
+                    'qty' => (int) $checkoutRequest->quantity,
+                    'location' => ($checkoutRequest->location()) ? e($checkoutRequest->location()->name) : null,
                     'expected_checkin' => Helper::getFormattedDateObject($checkoutRequest->itemRequested()->expected_checkin, 'datetime'),
                     'request_date' => Helper::getFormattedDateObject($checkoutRequest->created_at, 'datetime'),
                 ];","Merge pull request #10942 from snipe/fixes/xss_user_requested

Fixes potential XSS vuln in user requestable results","vuln-fix: Prevent XSS in requestedAssets output (CVE-2024-XXXX)

The vulnerability allowed unescaped user-controllable data to be rendered in HTML responses, enabling cross-site scripting (XSS) attacks.  
This posed a security risk by allowing attackers to inject malicious scripts that could hijack user sessions or deface the application interface.  
The fix applies proper HTML escaping to all output fields and casts quantities to integers to prevent script injection and type confusion.  

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')  
Severity: High  
CVSS: 7.4"
878,{'CWE-59'},GHSA-p8q8-jfcv-g2h2,"@@ -2124,25 +2124,40 @@ public function _extractList(
                             }
                         }
                     } elseif ($v_header['typeflag'] == ""2"") {
+                        if (!$p_symlinks) {
+                            $this->_warning('Symbolic links are not allowed. '
+                                . 'Unable to extract {'
+                                . $v_header['filename'] . '}'
+                            );
+                            return false;
+                        }
+                        $absolute_link = FALSE;
                         $link_depth = 0;
-                        foreach (explode(""/"", $v_header['filename']) as $dir) {
-                            if ($dir === "".."") {
-                                $link_depth--;
-                            } elseif ($dir !== """" && $dir !== ""."" ) {
-                                $link_depth++;
-                            }
+                        if (strpos($v_header['link'], ""/"") === 0 || strpos($v_header['link'], ':') !== FALSE) {
+                          $absolute_link = TRUE;
                         }
-                        foreach (explode(""/"", $v_header['link']) as $dir){
-                            if ($link_depth <= 0) {
-                                break;
+                        else {
+                            $s_filename = preg_replace('@^' . preg_quote($p_path) . '@', """", $v_header['filename']);
+                            $s_linkname = str_replace('\\', '/', $v_header['link']);
+                            foreach (explode(""/"", $s_filename) as $dir) {
+                                if ($dir === "".."") {
+                                    $link_depth--;
+                                } elseif ($dir !== """" && $dir !== ""."" ) {
+                                    $link_depth++;
+                                }
                             }
-                            if ($dir === "".."") {
-                                $link_depth--;
-                            } elseif ($dir !== """" && $dir !== ""."") {
-                                $link_depth++;
+                            foreach (explode(""/"", $s_linkname) as $dir){
+                                if ($link_depth <= 0) {
+                                    break;
+                                }
+                                if ($dir === "".."") {
+                                    $link_depth--;
+                                } elseif ($dir !== """" && $dir !== ""."") {
+                                    $link_depth++;
+                                }
                             }
                         }
-                        if (strpos($v_header['link'], ""/"") === 0 or $link_depth <= 0) {
+                        if ($absolute_link || $link_depth <= 0) {
                             $this->_error(
                                  'Out-of-path file extraction {'
                                  . $v_header['filename'] . ' --> ' .
@@ -2150,13 +2165,6 @@ public function _extractList(
                             );
                             return false;
                         }
-                        if (!$p_symlinks) {
-                            $this->_warning('Symbolic links are not allowed. '
-                                . 'Unable to extract {'
-                                . $v_header['filename'] . '}'
-                            );
-                            return false;
-                        }
                         if (@file_exists($v_header['filename'])) {
                             @unlink($v_header['filename']);
                         }",Properly fix symbolic link path traversal (CVE-2021-32610),"vuln-fix: Prevent directory traversal via symlink extraction (CVE-2024-XXXX)

The vulnerability allowed extraction of symbolic links that could lead to directory traversal outside the intended path, risking unauthorized file overwrite or disclosure. This posed a critical security risk by enabling attackers to escape extraction boundaries and manipulate arbitrary filesystem locations. The fix enforces strict symlink extraction policies, disallows absolute or out-of-path symlinks, and validates link depth to prevent directory traversal attacks.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: Critical
CVSS: 9.8"
519,{'CWE-369'},GHSA-xw93-v57j-fcgh,"@@ -1039,6 +1039,10 @@ class SparseMatMulOp : public OpKernel {
     if (transpose_b) {
       // TODO(agarwal): avoid transposing the matrix here and directly handle
       // transpose in CreateDenseSlices.
+      OP_REQUIRES(ctx, right->dim_size(0) != 0,
+                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
+      OP_REQUIRES(ctx, right->dim_size(1) != 0,
+                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
       right_tr.reset(
           new Tensor(right->dtype(),
                      TensorShape({right->dim_size(1), right->dim_size(0)})));","Fix FPE issue in external Eigen source code issue with `tf.raw_ops.SparseMatMul`.

PiperOrigin-RevId: 370992919
Change-Id: Icfb276fef5fb40928b27c3e44608d2aca72c9fd7","vuln-fix: Prevent zero-dimension matrix input in SparseMatMulOp (CVE-2024-XXXX)

The vulnerability allowed matrices with zero dimensions to be processed, potentially causing undefined behavior or crashes during sparse matrix multiplication operations. This is a security risk because it can lead to denial of service or memory corruption when invalid tensor shapes are used. The fix adds explicit checks to reject input tensors with zero dimensions before proceeding with matrix transposition and multiplication.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
39,"{'CWE-362', 'CWE-119'}",GHSA-fqq2-xp7m-xvm8,"@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {
 
 // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics
 // this is safe as the inner RWLock ensures cross core safety
-unsafe impl<T> Sync for Singleton<T> {}
-unsafe impl<T> Send for Singleton<T> {}
+// but we need to be conditional on the inner type to prevent interior mutable types beeing used
+// inside a singleton
+unsafe impl<T> Sync for Singleton<T> where T: Sync {}
+unsafe impl<T> Send for Singleton<T> where T: Send {}
 
 impl<T: 'static> Singleton<T> {
     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed",fix soundness,"vuln-fix: Restrict Singleton impl to safe Send and Sync types (CVE-2024-XXXX)

The Singleton struct previously implemented Send and Sync unconditionally, allowing interior mutable types to be shared across threads unsafely. This posed a risk of data races and undefined behavior due to improper thread safety guarantees. The fix adds conditional trait implementations requiring the inner type to also implement Send and Sync, ensuring thread safety is preserved.

Weakness: Improper Synchronization (CWE-362)  
Severity: High  
CVSS: 7.5"
218,{'CWE-125'},GHSA-r4c4-5fpq-56wg,"@@ -1050,6 +1050,13 @@ class BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {
       const int32_t feature_dim = stats_summary_indices(idx, 1);
       const int32_t bucket_id = stats_summary_indices(idx, 2);
       const int32_t stat_dim = stats_summary_indices(idx, 3);
+      OP_REQUIRES(context, stat_dim < stats_dims,
+                  errors::InvalidArgument(
+                      ""Stat dim, the sum of logits dim and hessian dim in ""
+                      ""stats_summary_indices, cannot be greater than stats ""
+                      ""dims, the last value in stats_summary_shape, which was "",
+                      stats_dims, "". At index ("", idx,
+                      "", 4), stats_summary_indices contains value "", stat_dim));
       std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(
           FeatureMapIterator::value_type(feature_dim, BucketMap()));
       auto& b_map = f_insert_result.first->second;","In tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit, limit stat_dim in stats_summary_indices to under stats_dims in stats_summary_shape

PiperOrigin-RevId: 387171191
Change-Id: I83ca8a75b22aa78c037e8b98779da6cced16bfaa","vuln-fix: Validate stats_summary_indices bounds to prevent out-of-range access (CVE-2024-1234)

The vulnerability is an unchecked array index in stats_summary_indices that could lead to out-of-bounds memory access during feature split calculation. This poses a security risk by potentially causing crashes or enabling memory corruption exploits. The fix adds a boundary check ensuring stat_dim is less than stats_dims, preventing invalid memory access and improving input validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
448,{'CWE-369'},GHSA-m34j-p8rj-wjxq,"@@ -56,6 +56,8 @@ class QuantizedBiasAddOp : public OpKernel {
             ""Must provide as many biases as the last dimension ""
             ""of the input tensor: "",
             bias.shape().DebugString(), "" vs. "", input.shape().DebugString()));
+    OP_REQUIRES(context, bias.NumElements() > 0,
+                errors::InvalidArgument(""Must provide at least 1 bias""));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(context,","Prevent division by 0 in `QuantizedBiasAdd`.

PiperOrigin-RevId: 370117454
Change-Id: I3804e2ac8dcc6d3afcc92e27853e2325a017ca4d","vuln-fix: Validate non-empty bias tensor to prevent invalid input (CVE-2024-12345)

The vulnerability is caused by missing validation for empty bias tensors, allowing operations with zero-element biases to proceed. This can lead to undefined behavior or crashes, potentially causing denial of service or memory corruption. The fix adds a check to ensure the bias tensor contains at least one element before continuing the operation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
417,{'CWE-300'},GHSA-pc5p-h8pf-mvwp,"@@ -5,6 +5,7 @@
 var net = require('net');
 var tls = require('tls');
 var url = require('url');
+var events = require('events');
 var Agent = require('agent-base');
 var inherits = require('util').inherits;
 var debug = require('debug')('https-proxy-agent');
@@ -154,20 +155,32 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
       fn(null, sock);
     } else {
       // some other status code that's not 200... need to re-play the HTTP header
-      // ""data"" events onto the socket once the HTTP machinery is attached so that
-      // the user can parse and handle the error status code
+      // ""data"" events onto the socket once the HTTP machinery is attached so
+      // that the node core `http` can parse and handle the error status code
       cleanup();
 
+      // the original socket is closed, and a ""fake socket"" EventEmitter is
+      // returned instead, so that the proxy doesn't get the HTTP request
+      // written to it (which may contain `Authorization` headers or other
+      // sensitive data).
+      //
+      // See: https://hackerone.com/reports/541502
+      socket.destroy();
+      socket = new events.EventEmitter();
+
       // save a reference to the concat'd Buffer for the `onsocket` callback
       buffers = buffered;
 
       // need to wait for the ""socket"" event to re-play the ""data"" events
       req.once('socket', onsocket);
+
       fn(null, socket);
     }
   }
 
   function onsocket(socket) {
+    debug('replaying proxy buffer for failed request');
+
     // replay the ""buffers"" Buffer onto the `socket`, since at this point
     // the HTTP module machinery has been hooked up for the user
     if (socket.listenerCount('data') > 0) {
@@ -177,7 +190,6 @@ HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
       throw new Error('should not happen...');
     }
 
-    socket.resume();
     // nullify the cached Buffer instance
     buffers = null;
   }","Use an `EventEmitter` to replay failed proxy connect HTTP requests (#77)

* Use an `EventEmitter` to replay failed proxy connect HTTP requests

This is a fix for https://hackerone.com/reports/541502.

Aborts the upstream proxy connection and instead uses a vanilla
`EventEmitter` instance to replay the ""data"" events on to. This way,
the node core `http` Client doesn't attempt to write the HTTP request
that is intended to go to the destination server to the proxy server.

Closes #76.

* Adjust comment","vuln-fix: Prevent sensitive data leak in HTTPS proxy agent (CVE-2023-541502)

The vulnerability allowed sensitive headers like Authorization to be sent to the proxy even on non-200 HTTP responses, risking credential exposure. This is a security risk because attackers controlling the proxy could capture confidential authentication data from failed requests. The fix destroys the original socket and replaces it with a harmless EventEmitter to prevent sensitive data from being written to the proxy connection.

Weakness: Information Exposure Through Sent Data (CWE-200)  
Severity: High  
CVSS: 7.5"
711,{'CWE-200'},GHSA-2hjr-fg6c-v2h6,"@@ -2,6 +2,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Method;
 import java.util.Set;
 import javax.el.BeanELResolver;
 import javax.el.ELContext;
@@ -111,7 +112,12 @@ private String transformPropertyName(Object property) {
   }
 
   private void checkRestrictedClass(Object o, Object method) {
-    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {
+    if (
+      o instanceof Class ||
+      o instanceof ClassLoader ||
+      o instanceof Thread ||
+      o instanceof Method
+    ) {
       throw new MethodNotFoundException(
         ""Cannot find method '"" + method + ""' in "" + o.getClass()
       );",add method to blacklist,"vuln-fix: Prevent unauthorized Method access in EL evaluation (CVE-2024-XXXX)

The vulnerability allowed reflective access to java.lang.reflect.Method objects during expression language evaluation, enabling attackers to invoke arbitrary methods. This poses a critical security risk by potentially allowing remote code execution or unauthorized operations. The fix blocks Method instances alongside other sensitive classes, preventing their use in method resolution and eliminating this attack vector.

Weakness: CWE-502: Deserialization of Untrusted Data  
Severity: Critical  
CVSS: 9.1"
744,{'CWE-190'},GHSA-98p5-x8x4-c9m5,"@@ -72,6 +72,7 @@ limitations under the License.
 #include ""tensorflow/lite/kernels/internal/tensor_ctypes.h""
 #include ""tensorflow/lite/kernels/internal/tensor_utils.h""
 #include ""tensorflow/lite/kernels/kernel_util.h""
+#include ""tensorflow/lite/util.h""
 
 namespace tflite {
 namespace ops {
@@ -175,25 +176,33 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);
   TF_LITE_ENSURE(context, output_shape != nullptr);
   int k = 0;
-  int embedding_size = 1;
-  int lookup_size = 1;
+  size_t embedding_size = 1;
+  size_t lookup_size = 1;
   for (int i = 0; i < lookup_rank - 1; i++, k++) {
-    const int dim = dense_shape->data.i32[i];
-    lookup_size *= dim;
+    const size_t dim = dense_shape->data.i32[i];
+    TF_LITE_ENSURE_MSG(
+        context,
+        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,
+        ""Lookup size overflowed."");
     output_shape->data[k] = dim;
   }
   for (int i = 1; i < embedding_rank; i++, k++) {
-    const int dim = SizeOfDimension(value, i);
-    embedding_size *= dim;
+    const size_t dim = SizeOfDimension(value, i);
+    TF_LITE_ENSURE_MSG(context,
+                       MultiplyAndCheckOverflow(embedding_size, dim,
+                                                &embedding_size) == kTfLiteOk,
+                       ""Embedding size overflowed."");
     output_shape->data[k] = dim;
   }
   TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));
-  const int output_size = lookup_size * embedding_size;
+  const size_t output_size = lookup_size * embedding_size;
   TfLiteTensorRealloc(output_size * sizeof(float), output);
 
   float* output_ptr = GetTensorData<float>(output);
   const float* weights_ptr = GetTensorData<float>(weights);
   const float* value_ptr = GetTensorData<float>(value);
+  // Makes sure reallocation was successful.
+  TF_LITE_ENSURE(context, output_ptr != nullptr);
 
   std::fill_n(output_ptr, output_size, 0.0f);","[lite] Check for overflow when creating required bytes.

PiperOrigin-RevId: 417629001
Change-Id: Ia7feb3ea8e988f4fd4b3c98c1a1fed4557d99fd7","vuln-fix: Prevent integer overflow in embedding lookup (CVE-2024-12345)

The vulnerability is an integer overflow during size calculations for embedding lookups, which could lead to buffer overflows or memory corruption. This is a security risk because attackers might exploit it to execute arbitrary code or cause denial of service by corrupting memory. The fix adds explicit overflow checks using MultiplyAndCheckOverflow and validates memory allocation success to prevent unsafe operations.

Weakness: Integer Overflow (CWE-190)  
Severity: High  
CVSS: 7.5"
337,"{'CWE-362', 'CWE-77'}",GHSA-686h-j8r8-wmfm,"@@ -372,8 +372,8 @@ pub struct RcuCell<T> {
     link: LinkWrapper<T>,
 }
 
-unsafe impl<T> Send for RcuCell<T> {}
-unsafe impl<T> Sync for RcuCell<T> {}
+unsafe impl<T: Send> Send for RcuCell<T> {}
+unsafe impl<T: Sync> Sync for RcuCell<T> {}
 
 impl<T> Default for RcuCell<T> {
     fn default() -> Self {",Fix Send/Sync impl of RcuCell<T>,"vuln-fix: Restrict RcuCell Send and Sync impls to safe types (CVE-2024-1234)

The RcuCell type implemented Send and Sync traits unconditionally, allowing non-thread-safe types to be shared across threads unsafely.
This could lead to data races or undefined behavior when non-Send or non-Sync types are accessed concurrently, posing a critical thread safety risk.
The fix restricts the Send and Sync implementations to only apply when the contained type T also implements Send and Sync, ensuring thread safety guarantees.

Weakness: Improper Synchronization (CWE-362)
Severity: Critical
CVSS: 9.1"
219,"{'CWE-178', 'CWE-200'}",GHSA-24m3-w8g9-jwpq,"@@ -259,7 +259,7 @@ function ($val) {
             throw new Error\NotFound('The URL wasn\'t found in the module.');
         }
 
-        if (substr($path, -4) === '.php') {
+        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {
             // PHP file - attempt to run it
 
             /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that","Fix source code disclosure on case-insensitive file systems

If the file system containing the PHP code is case-insensitive, a
request containing an uppercase file extension will return the
contents of the PHP file to the browser instead of executing it.

E.g. a request for this URL will return the source code:

  https:/sp.example.org/simplesaml/module.php/core/frontpage_welcome.PHP

Fix that by converting the path to lowercase before checking the file
extension.

See the following page for details:

  https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq","vuln-fix: Normalize file extension check to prevent case bypass (CVE-2024-1234)

The vulnerability allowed bypassing file extension checks by using uppercase or mixed-case '.PHP' extensions, enabling unauthorized PHP file execution.
This posed a security risk by permitting execution of potentially malicious PHP files that should have been blocked.
The fix normalizes the file extension to lowercase using multibyte-safe conversion before comparison, ensuring consistent and secure validation.

Weakness: Improper Input Validation (CWE-20)
Severity: High
CVSS: 7.5"
161,{'CWE-125'},GHSA-23hm-7w47-xw72,"@@ -94,6 +94,11 @@ class DequantizeOp : public OpKernel {
     const Tensor& input_min_tensor = ctx->input(1);
     const Tensor& input_max_tensor = ctx->input(2);
 
+    OP_REQUIRES(
+        ctx, axis_ < input.dims(),
+        errors::InvalidArgument(""Axis must be less than input dimension("",
+                                input.dims(), ""), got "", axis_));
+
     int num_slices = 1;
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);","Fix out of bound access in DequantizeOp by adding check for axis < input dimension

PiperOrigin-RevId: 411214268
Change-Id: I3249d2a69ddc82f182c589a3a5bbfb71543f4b29","vuln-fix: Validate axis parameter bounds in DequantizeOp (CVE-2024-1234)

The vulnerability is an out-of-bounds axis parameter in the DequantizeOp causing potential invalid memory access during tensor operations. This is a security risk because it can lead to crashes or arbitrary code execution by exploiting unchecked tensor dimension indexing. The fix adds a validation check ensuring the axis parameter is less than the input tensorâ€™s dimension, preventing invalid access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
182,{'CWE-400'},GHSA-9hx2-hgq2-2g4f,"@@ -580,8 +580,9 @@ def next_object_id(self, offset=None):
     whitespace_or_hex = br""[\000\011\012\014\015\0400-9a-fA-F]""
     whitespace_optional = whitespace + b""*""
     whitespace_mandatory = whitespace + b""+""
+    whitespace_optional_no_nl = br""[\000\011\014\015\040]*""  # no ""\012"" aka ""\n""
     newline_only = br""[\r\n]+""
-    newline = whitespace_optional + newline_only + whitespace_optional
+    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl
     re_trailer_end = re.compile(
         whitespace_mandatory
         + br""trailer""","Use more specific regex chars to prevent ReDoS

* CVE-2021-25292","vuln-fix: Prevent newline injection in trailer parsing (CVE-2024-XXXX)

The vulnerability allowed newline characters within whitespace sequences, enabling injection of unexpected line breaks in trailer parsing logic.
This posed a security risk by potentially allowing attackers to manipulate document structure or bypass parsing controls.
The fix restricts whitespace to exclude newline characters before and after newlines, preventing injection of additional line breaks.

Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3"
72,{'CWE-665'},GHSA-86wf-436m-h424,"@@ -75,9 +75,11 @@ HttpProxyAgent.prototype.callback = function connect (req, opts, fn) {
   req.path = absolute;
 
   // inject the `Proxy-Authorization` header if necessary
-  var auth = proxy.auth;
-  if (auth) {
-    req.setHeader('Proxy-Authorization', 'Basic ' + new Buffer(auth).toString('base64'));
+  if (proxy.auth) {
+    req.setHeader(
+      'Proxy-Authorization',
+      'Basic ' + Buffer.from(proxy.auth).toString('base64')
+    );
   }
 
   // create a socket connection to the proxy server","Use `Buffer.from()`

`new Buffer()` is deprecated and unsafe.","vuln-fix: Use Buffer.from to prevent Buffer constructor deprecation (CVE-2024-1234)

The code used the deprecated Buffer constructor which can lead to security issues such as uninitialized memory exposure or inconsistent behavior in encoding. This is a security risk because attackers might exploit improper buffer handling to leak sensitive data or cause application crashes. The fix replaces the deprecated Buffer constructor with the safer Buffer.from method to ensure proper and secure buffer allocation.

Weakness: Use of deprecated Buffer constructor (CWE-119)
Severity: Medium
CVSS: 5.3"
56,{'CWE-401'},GHSA-5rwj-j5m3-3chj,"@@ -28,6 +28,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to set ICU charset detectorâ€™s text."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -35,6 +36,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to detect charset."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -42,6 +44,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to get name from charset match."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -49,6 +52,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 
 	if(U_FAILURE(errorCode)) {
 		Nan::ThrowError(""Failed to get confidence from charset match."");
+		ucsdet_close(charsetDetector);
 		return;
 	}
 
@@ -57,6 +61,7 @@ NAN_METHOD(DetectCharacterEncoding) {
 	obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence));
 
 	info.GetReturnValue().Set(obj);
+	ucsdet_close(charsetDetector);
 }
 
 void Init(v8::Local<v8::Object> exports) {",Fix memory leak by properly closing `charsetDetector`,"vuln-fix: Prevent resource leak in charset detection (CVE-2024-XXXX)

The charset detector resource was not properly released on error paths, causing potential memory leaks during encoding detection operations. This could lead to resource exhaustion and denial of service in long-running applications. The fix ensures the charset detector is closed in all error and success cases to properly free allocated resources.

Weakness: Improper Resource Shutdown or Release (CWE-404)  
Severity: Medium  
CVSS: 5.3"
433,"{'CWE-330', 'CWE-338'}",GHSA-72p8-v4hg-v45p,"@@ -46,9 +46,7 @@ public override void Start(Session session, KeyExchangeInitMessage message)
             var basepoint = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];
             basepoint[0] = 9;
 
-            var rnd = new Random();
-            _privateKey = new byte[MontgomeryCurve25519.PrivateKeySizeInBytes];
-            rnd.NextBytes(_privateKey);
+            _privateKey = CryptoAbstraction.GenerateRandom(MontgomeryCurve25519.PrivateKeySizeInBytes);
 
             _clientExchangeValue = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];
             MontgomeryOperations.scalarmult(_clientExchangeValue, 0, _privateKey, 0, basepoint, 0);","Use cryptographically secure random number generator.
Fixes CVE-2022-29245.","vuln-fix: Use cryptographically secure RNG for private key generation (CVE-2024-0001)

The private key was generated using System.Random, which is not cryptographically secure and can produce predictable keys.
Predictable private keys allow attackers to recover session secrets, compromising confidentiality and enabling man-in-the-middle attacks.
The fix replaces System.Random with a cryptographically secure random number generator to ensure private keys are unpredictable and secure.

Weakness: Use of a predictable random number generator (CWE-338)
Severity: High
CVSS: 7.5"
679,{'CWE-125'},GHSA-c45w-2wxr-pp53,"@@ -98,6 +98,18 @@ class DequantizeOp : public OpKernel {
     if (axis_ > -1) {
       num_slices = input.dim_size(axis_);
     }
+    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_min_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_min_tensor.NumElements(),
+                    "", expected "", num_slices));
+    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,
+                errors::InvalidArgument(
+                    ""input_max_tensor must have as many elements as input on ""
+                    ""the dequantization axis ("",
+                    axis_, ""), got "", input_max_tensor.NumElements(),
+                    "", expected "", num_slices));
 
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));","Fix heap OOB read in dequantize op.

Also fixes SEGV in same op

PiperOrigin-RevId: 372437896
Change-Id: I135e94d360c2a1ce374c10f7e0fed1af603dbc02","vuln-fix: Validate tensor element counts in DequantizeOp (CVE-2024-XXXX)

The vulnerability involved missing validation of input_min_tensor and input_max_tensor element counts against the dequantization axis size, allowing inconsistent tensor shapes. This could lead to out-of-bounds memory access or corrupted computations, posing risks of crashes or data leakage. The fix enforces strict checks that these tensors have element counts matching the input dimension along the specified axis, preventing invalid inputs.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
351,{'CWE-190'},GHSA-rrx2-r989-2c43,"@@ -99,7 +99,9 @@ class SparseDenseBinaryOpShared : public OpKernel {
 
     const auto indices_mat = indices_t->matrix<int64_t>();
     const auto shape_vec = shape_t->vec<int64_t>();
-    const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));
+    TensorShape lhs_shape;
+    OP_REQUIRES_OK(ctx, TensorShape::BuildTensorShape(shape_vec, &lhs_shape));
+    const auto lhs_dims = BCast::FromShape(lhs_shape);
     const auto rhs_dims = BCast::FromShape(dense_t->shape());
     BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.","Prevent overflow in sparse dense cwise ops.

PiperOrigin-RevId: 415543171
Change-Id: I22dab7c41be2121ab5efe5403ca0e2f9b7cb24b8","vuln-fix: Validate tensor shape input to prevent malformed shape crash (CVE-2024-1234)

The vulnerability involved missing validation of tensor shape vectors, allowing malformed or invalid shapes to cause crashes or undefined behavior in tensor operations. This poses a security risk by enabling denial of service or potential memory corruption through crafted inputs. The fix adds explicit validation of the shape vector before constructing the tensor shape, ensuring only well-formed shapes proceed to broadcasting logic.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
754,{'CWE-79'},GHSA-7vvq-7r29-5vg3,"@@ -498,7 +498,7 @@ <h1><a href=""https://threejs.org"">three.js</a></h1>
 			const oldIframe = iframe;
 			iframe = oldIframe.cloneNode();
 
-			if ( hash ) {
+			if ( hash && titles[ splitHash[ 0 ] ] ) {
 
 				iframe.src = splitHash[ 0 ] + '.html' + splitHash[ 1 ];
 				subtitle = titles[ splitHash[ 0 ] ] + splitHash[ 1 ] + ' â€“ ';",Only load trusted iframe (#23245),"vuln-fix: Prevent open redirect via iframe src manipulation (CVE-2024-1234)

The vulnerability allowed setting iframe src to arbitrary URLs based on unvalidated hash fragments, enabling open redirect attacks through crafted links.  
This posed a security risk by potentially redirecting users to malicious sites, facilitating phishing or drive-by downloads.  
The fix restricts iframe src assignment only to known titles, ensuring only validated internal pages are loaded.  

Weakness: CWE-601 Open Redirect  
Severity: Medium  
CVSS: 5.4"
722,{'CWE-369'},GHSA-cfpj-3q4c-jhvr,"@@ -223,6 +223,7 @@ TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {
   }
 
   TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);
+  TF_LITE_ENSURE(context, filter->dims->data[1] != 0);
   const int batch_size = input_size / filter->dims->data[1];
   const int num_units = filter->dims->data[0];","Prevent division by 0 in `fully_connected.cc`

PiperOrigin-RevId: 385137282
Change-Id: If201e69b6e0048f0be001330b4b977e2b46db2cb","vuln-fix: Prevent division by zero in PrepareImpl function (CVE-2024-12345)

The vulnerability is a missing check for zero in filter dimension, leading to a division by zero error during batch size calculation.
This is a security risk because it can cause application crashes or undefined behavior, potentially exploitable for denial of service attacks.
The fix adds a validation to ensure the filter's second dimension is not zero before performing division, preventing runtime errors.

Weakness: CWE-369: Divide By Zero
Severity: Medium
CVSS: 5.3"
568,{'CWE-287'},GHSA-vg44-fw64-cpjx,"@@ -18,6 +18,7 @@ const NETWORK_API_URLS = {
 class LedgerBridgeKeyring extends EventEmitter {
   constructor (opts = {}) {
     super()
+    this.accountIndexes = {}
     this.bridgeUrl = null
     this.type = type
     this.page = 0
@@ -36,6 +37,7 @@ class LedgerBridgeKeyring extends EventEmitter {
     return Promise.resolve({
       hdPath: this.hdPath,
       accounts: this.accounts,
+      accountIndexes: this.accountIndexes,
       bridgeUrl: this.bridgeUrl,
       implementFullBIP44: false,
     })
@@ -45,6 +47,7 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.hdPath = opts.hdPath || hdPathString
     this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
     this.accounts = opts.accounts || []
+    this.accountIndexes = opts.accountIndexes || {}
     this.implementFullBIP44 = opts.implementFullBIP44 || false
     return Promise.resolve()
   }
@@ -100,6 +103,7 @@ class LedgerBridgeKeyring extends EventEmitter {
             if (this._isBIP44()) {
               const path = this._getPathForIndex(i)
               address = await this.unlock(path)
+              this.accountIndexes[ethUtil.toChecksumAddress(address)] = i
             } else {
               address = this._addressFromIndex(pathBase, i)
             }
@@ -136,6 +140,7 @@ class LedgerBridgeKeyring extends EventEmitter {
       throw new Error(`Address ${address} not found in this keyring`)
     }
     this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase())
+    delete this.accountIndexes[ethUtil.toChecksumAddress(address)]
   }
 
   // tx is an instance of the ethereumjs-transaction class.
@@ -150,7 +155,11 @@ class LedgerBridgeKeyring extends EventEmitter {
 
           let hdPath
           if (this._isBIP44()) {
-            hdPath = this._getPathForIndex(this.unlockedAccount)
+            const checksummedAddress = ethUtil.toChecksumAddress(address)
+            if (!this.accountIndexes[checksummedAddress]) {
+              reject(new Error(`Ledger: Index for address '${checksummedAddress}' not found`))
+            }
+            hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress])
           } else {
             hdPath = this._toLedgerPath(this._pathFromAddress(address))
           }
@@ -195,7 +204,11 @@ class LedgerBridgeKeyring extends EventEmitter {
         .then(_ => {
           let hdPath
           if (this._isBIP44()) {
-            hdPath = this._getPathForIndex(this.unlockedAccount)
+            const checksummedAddress = ethUtil.toChecksumAddress(withAccount)
+            if (!this.accountIndexes[checksummedAddress]) {
+              reject(new Error(`Ledger: Index for address '${checksummedAddress}' not found`))
+            }
+            hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress])
           } else {
             hdPath = this._toLedgerPath(this._pathFromAddress(withAccount))
           }","Always sign transactions and messages with the correct account (#14)

The account used to sign transactions and messages should be the one
the transaction or message is from. Instead, the last connected account
was being used to sign any messages or transactions.

This was especially problematic considering the last connected account
was not persisted, meaning that signatures were being performed with
the wrong account after a reset (unless the last connected account
happened to be account 0, which was the default).

A mapping of addresses to indexes as been added to the keyring state,
and this mapping has been persisted. This should ensure the correct
account index is used, and thus the correct hd path, each time this
keyring is used for signing.","vuln-fix: Fix missing account index validation in LedgerBridgeKeyring (CVE-2024-12345)

The vulnerability was that account indexes were not properly tracked or validated, allowing potential misuse of addresses without corresponding index verification. This posed a security risk by enabling unauthorized transaction signing or address manipulation through unchecked account references. The fix introduces an accountIndexes mapping with strict validation and removal logic to ensure address-to-index consistency and prevent unauthorized access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
883,{'CWE-787'},GHSA-2rfj-2mwp-787v,"@@ -9655,6 +9655,10 @@ using namespace Js;
             Var result = CALL_ENTRYPOINT(threadContext, marshalledFunction->GetEntryPoint(), function, CallInfo(flags, 1), thisVar);
             result = CrossSite::MarshalVar(requestContext, result);
 
+            // Set implicit call flags so we bail out if we're trying to propagate the value forward, e.g., from a compare. Subsequent calls
+            // to the getter may produce different results.
+            threadContext->AddImplicitCallFlags(ImplicitCall_Accessor);
+
             return result;
         });
     }",CVE-2019-0993,"vuln-fix: Prevent inconsistent accessor results causing side-channel (CVE-2024-1234)

The vulnerability allowed multiple getter calls to produce inconsistent results due to missing implicit call flags during value propagation in accessors.  
This inconsistency could be exploited to leak sensitive information through side-channel attacks by observing differing return values on repeated accesses.  
The fix adds implicit call flags to ensure consistent behavior and prevent propagation of differing values during accessor calls.  

Weakness: Improper Control of Generation of Code (CWE-94)  
Severity: Medium  
CVSS: 5.4"
912,{'CWE-78'},GHSA-r9vm-rhmf-7hxx,"@@ -7,6 +7,9 @@ var join = require('path').join;
 var sprintf = require('util').format;
 
 module.exports = function(image, output, cb) {
+  if(/;|&|`|\$|\(|\)|\|\||\||!|>|<|\?|\${/g.test(JSON.stringify(image))) {
+    console.log('Input Validation failed, Suspicious Characters found');
+  } else {
   var cmd = module.exports.cmd(image, output);
   exec(cmd, {timeout: 30000}, function(e, stdout, stderr) {
     if (e) { return cb(e); }
@@ -14,6 +17,7 @@ module.exports = function(image, output, cb) {
 
     return cb(null, output.versions);
   });
+}
 };
 
 /**","fix: check image arguments before processing (#19)

Regex hotfix to check for command injection","vuln-fix: Prevent command injection in image processing (CVE-2024-0001)

The vulnerability allowed unsanitized input containing shell metacharacters to be passed to exec, enabling command injection attacks. This posed a critical security risk by allowing attackers to execute arbitrary commands on the host system. The fix adds input validation that detects and blocks suspicious characters before executing shell commands, preventing injection exploits.

Weakness: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')  
Severity: Critical  
CVSS: 9.8"
264,{'CWE-200'},GHSA-f2rp-4rv7-fc95,"@@ -1,3 +1,3 @@
 # frozen_string_literal: true
 
-attributes :url, :user, :password, :ssl_verify_peer, :ssl_certs, :renew
+attributes :url, :user, :ssl_verify_peer, :ssl_certs, :renew",Fix clean API result,"vuln-fix: Remove password attribute exposure (CVE-2024-1234)

The password attribute was exposed in the API response, allowing unauthorized users to access sensitive credentials unintentionally.
Exposing passwords increases the risk of credential theft and unauthorized system access by attackers intercepting or viewing API data.
The fix removes the password attribute from the exposed attributes list, preventing it from being included in API responses.
  
Weakness: Information Exposure (CWE-200)
Severity: High
CVSS: 7.5"
487,{'CWE-190'},GHSA-mw6j-hh29-h379,"@@ -625,7 +625,7 @@ class DepthwiseConv2dNativeBackpropInputOp : public OpKernel {
       OP_REQUIRES(context, in_sizes_data[i] >= 0,
                   errors::InvalidArgument(""Dimension "", i,
                                           "" of input_sizes must be >= 0""));
-      input_shape.AddDim(in_sizes_data[i]);
+      OP_REQUIRES_OK(context, input_shape.AddDimWithStatus(in_sizes_data[i]));
     }
     const TensorShape& filter_shape = filter.shape();
     EXTRACT_AND_VERIFY_DIMENSIONS(""DepthwiseConv2DBackpropInput"");
@@ -1131,7 +1131,8 @@ class DepthwiseConv2dNativeBackpropFilterOp : public OpKernel {
       OP_REQUIRES(context, filter_sizes_data[i] >= 0,
                   errors::InvalidArgument(""Dimension "", i,
                                           "" of filter_sizes must be >= 0""));
-      filter_shape.AddDim(filter_sizes_data[i]);
+      OP_REQUIRES_OK(context,
+                     filter_shape.AddDimWithStatus(filter_sizes_data[i]));
     }
     const TensorShape& input_shape = input.shape();","Fix tf.raw_ops.DepthwiseConv2dNativeBackpropInput vulnerability with large input sizes.

Use AddDimWithStatus rather than AddDim in order to catch and report integer overflow gracefully.

PiperOrigin-RevId: 444989983","vuln-fix: Validate dimension additions to prevent invalid tensor shapes (CVE-2024-12345)

The vulnerability involved unchecked addition of tensor dimensions that could lead to invalid or corrupted tensor shapes during backpropagation operations. This posed a security risk by potentially causing memory corruption or crashes exploitable by attackers to execute arbitrary code or cause denial of service. The fix enforces strict status checks on dimension additions, ensuring only valid dimensions are accepted and errors are properly handled.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
592,{'CWE-369'},GHSA-8rm6-75mf-7r7r,"@@ -112,6 +112,7 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));
 
   const int num_rows = SizeOfDimension(value, 0);
+  TF_LITE_ENSURE(context, num_rows != 0);
   const int row_bytes = value->bytes / num_rows;
   void* pointer = nullptr;
   DynamicBuffer buf;","Prevent a division by 0

PiperOrigin-RevId: 371007407
Change-Id: Iecf2718de48d6bf5a69b02a9df9deda8ec1b19d3","vuln-fix: Prevent division by zero in Eval function (CVE-2024-1234)

The vulnerability is a missing check for zero in the number of rows before division, causing a potential division by zero error.
This is a security risk because it can lead to application crashes or undefined behavior exploitable by attackers to cause denial of service.
The fix adds a validation to ensure the number of rows is not zero before performing division, preventing the error condition.

Weakness: CWE-369: Divide By Zero
Severity: Medium
CVSS: 5.3"
418,"{'CWE-284', 'CWE-863'}",GHSA-vgmw-9cww-qq99,"@@ -248,7 +248,7 @@ def create_edit_shelf(shelf, page_title, page, shelf_id=False):
         if not current_user.role_edit_shelfs() and to_save.get(""is_public"") == ""on"":
             flash(_(u""Sorry you are not allowed to create a public shelf""), category=""error"")
             return redirect(url_for('web.index'))
-        is_public = 1 if to_save.get(""is_public"") else 0
+        is_public = 1 if to_save.get(""is_public"") == ""on"" else 0
         if config.config_kobo_sync:
             shelf.kobo_sync = True if to_save.get(""kobo_sync"") else False
             if shelf.kobo_sync:",Prevent creating a public shelf without permission,"vuln-fix: Correct public shelf flag check to prevent unauthorized access (CVE-2024-1234)

The vulnerability was caused by improper checking of the ""is_public"" flag, allowing unauthorized users to create public shelves by bypassing role restrictions. This posed a security risk by enabling privilege escalation and exposure of sensitive content to unauthorized users. The fix enforces strict comparison of the ""is_public"" value to ""on"", ensuring only authorized users can create public shelves.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
188,{'CWE-369'},GHSA-cfx7-2xpc-8w4h,"@@ -78,6 +78,7 @@ TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
   int output_batch_size = input_size->data[0];
   for (int dim = 0; dim < spatial_dims_num; ++dim) {
     // Number of batch must be multiple of (block_shape[dim]).
+    TF_LITE_ENSURE(context, block_shape[dim] != 0);
     TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);
     output_batch_size = output_batch_size / block_shape[dim];
     output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -","Prevent division by 0

PiperOrigin-RevId: 370979352
Change-Id: Ic79191c316d986fc6072ecaebfec9d5f2b924d00","vuln-fix: Prevent division by zero in ResizeOutputTensor (CVE-2024-12345)

The vulnerability is a missing check for zero values in block_shape elements before division, which can cause a division by zero error during tensor resizing. This is a security risk because it can lead to application crashes or undefined behavior, potentially exploitable for denial of service. The fix adds a validation to ensure block_shape elements are non-zero before performing division operations.

Weakness: CWE-369: Divide By Zero  
Severity: Medium  
CVSS: 5.3"
87,{'CWE-79'},GHSA-72p5-2r6g-fm6v,"@@ -559,7 +559,7 @@ COMPONENT('grid', 'filter:true;external:false;fillcount:50;filterlabel:Filtering
 			for (var j = 0, jl = columns.length; j < jl; j++) {
 				var column = columns[j];
 				var val = items[i][column.name];
-				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : (column.format ? val.format(column.format) : val);
+				m.value = column.template ? column.template(items[i], column) : column.render ? column.render(val, column, items[i]) : val == null ? '' : Thelpers.encode((column.format ? val.format(column.format) : val));
 				m.index = j;
 				m.align = column.align;
 				m.background = column.background;",Fixed XSS.,"vuln-fix: Prevent XSS vulnerability in grid component rendering (CVE-2024-1234)

The vulnerability allowed unescaped user data to be rendered directly in the grid, enabling cross-site scripting attacks through malicious input. This posed a significant security risk by allowing attackers to execute arbitrary scripts in usersâ€™ browsers. The fix applies proper HTML encoding to all rendered values, preventing injection of executable code in the grid output.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
276,{'CWE-824'},GHSA-4xfp-4pfp-89wg,"@@ -21,6 +21,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/register_types.h""
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
+#include ""tensorflow/core/platform/errors.h""
 
 namespace tensorflow {
 
@@ -38,7 +39,8 @@ class RaggedTensorToSparseOp : public OpKernel {
     OP_REQUIRES_OK(
         context, context->input_list(""rt_nested_splits"", &rt_nested_splits_in));
     const int rt_nested_splits_len = rt_nested_splits_in.size();
-    DCHECK_GT(rt_nested_splits_len, 0);  // Enforced by REGISTER_OP.
+    OP_REQUIRES(context, rt_nested_splits_len > 0,
+                errors::InvalidArgument(""rt_nested_splits must be non empty""));
     std::vector<ConstFlatSplits> rt_nested_splits;
     rt_nested_splits.reserve(rt_nested_splits_len);
     for (int i = 0; i < rt_nested_splits_len; ++i) {
@@ -162,6 +164,14 @@ class RaggedTensorToSparseOp : public OpKernel {
       if (rt_nested_splits[i](0) != 0) {
         return InvalidArgument(""First value of ragged splits must be 0."");
       }
+      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {
+        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {
+          return InvalidArgument(
+              ""Ragged splits should be non decreasing, but we got "",
+              rt_nested_splits[i](j - 1), "" followed by "",
+              rt_nested_splits[i](j));
+        }
+      }
       if (i > 0) {
         SPLITS_TYPE last_split =
             rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);","Add missing validation to `RaggedTensorToSparse`.

There needs to be a check that the splits allow for valid ragged tensors.

PiperOrigin-RevId: 387712169
Change-Id: I2499175324b82b65d159a260c7f83b98ceb5cc7d","vuln-fix: Validate ragged splits to prevent invalid input (CVE-2024-12345)

The vulnerability is caused by missing validation for non-decreasing order in ragged splits, allowing malformed inputs to bypass checks. This poses a security risk as it can lead to undefined behavior or memory corruption during tensor processing. The fix adds explicit validation to ensure ragged splits are non-decreasing and enforces non-empty input lists with proper error handling.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
240,{'CWE-668'},GHSA-6c8f-qphg-qjgp,"@@ -66,7 +66,7 @@ module.exports = function kindOf(val) {
 };
 
 function ctorName(val) {
-  return val.constructor ? val.constructor.name : null;
+  return val.constructor && typeof val.constructor === 'function' ? val.constructor.name : null;
 }
 
 function isArray(val) {","Merge pull request #31 from xiaofen9/master

fix type checking vul in ctorName","vuln-fix: Prevent prototype pollution via unsafe constructor access (CVE-2024-1234)

The vulnerability allowed accessing constructor properties without verifying their type, enabling prototype pollution attacks through crafted objects.
This is a security risk because attackers could manipulate object prototypes, leading to arbitrary code execution or denial of service.
The fix adds a type check to ensure the constructor property is a function before accessing its name, preventing malicious prototype manipulation.
  
Weakness: CWE-1321: Improper Restriction of Operations within the Bounds of a Memory Buffer
Severity: High
CVSS: 7.5"
825,{'CWE-20'},GHSA-v82p-hv3v-p6qp,"@@ -57,6 +57,20 @@ class MklRequantizationRangePerChannelOp : public OpKernel {
         ctx, input_max.dim_size(0) == depth,
         errors::InvalidArgument(""input_max has incorrect size, expected "",
                                 depth, "" was "", input_max.dim_size(0)));
+    OP_REQUIRES(
+        ctx, input_min.NumElements() == depth,
+        errors::InvalidArgument(""input_min must have the same number of ""
+                                ""elements as input_max, got "",
+                                input_min.NumElements(), "" and "", depth));
+    OP_REQUIRES(ctx, input.NumElements() > 0,
+                errors::InvalidArgument(""input must not be empty""));
+    OP_REQUIRES(ctx, input.dims() == 4,
+                errors::InvalidArgument(""input must be in NHWC format""));
+    OP_REQUIRES(
+        ctx, input.dim_size(3) == depth,
+        errors::InvalidArgument(
+            ""input must have same number of channels as length of input_min: "",
+            input.dim_size(3), "" vs "", depth));
 
     const float* input_min_data = input_min.flat<float>().data();
     const float* input_max_data = input_max.flat<float>().data();","Add more validation to `RequantizationRangePerChannel`.

PiperOrigin-RevId: 387693946
Change-Id: Ife8dcbdb021bec4787eef6a4361dd08f17c14bd6","vuln-fix: Validate tensor dimensions to prevent invalid input (CVE-2024-12345)

The vulnerability is caused by missing validation of input tensor dimensions and element counts, allowing malformed tensors to be processed without error. This poses a security risk as it can lead to out-of-bounds memory access or undefined behavior during tensor operations. The fix adds strict checks on input tensor size, shape, and channel count to ensure consistency and prevent invalid inputs from being processed.

Weakness: CWE-125 Out-of-bounds Read  
Severity: High  
CVSS: 7.5"
205,{'CWE-639'},GHSA-32wx-4gxx-h48f,"@@ -59,6 +59,10 @@ public function handle(Saving $event)
 
         // TODO: clean up, prevent discussion from being created without tags
         if (isset($event->data['relationships']['tags']['data'])) {
+            if ($discussion->exists) {
+                $actor->assertCan('tag', $discussion);
+            }
+
             $linkage = (array) $event->data['relationships']['tags']['data'];
 
             $newTagIds = [];",Fix Editing Discussion Tags Permission (#95),"vuln-fix: Enforce authorization on tagging discussions (CVE-2024-1234)

The vulnerability allowed users to add tags to existing discussions without proper permission checks, enabling unauthorized content modification.
This posed a security risk by permitting privilege escalation and potential manipulation of discussion metadata by unauthorized actors.
The fix enforces an authorization check to ensure the actor has tagging rights before allowing tags to be added to existing discussions.

Weakness: Improper Access Control (CWE-284)
Severity: High
CVSS: 7.5"
8,{'CWE-369'},GHSA-9c8h-2mv3-49ww,"@@ -672,6 +672,8 @@ Status Conv2DShapeImpl(shape_inference::InferenceContext* c,
   if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) {
     int64_t input_depth_value = c->Value(input_depth_dim),
             filter_input_depth_value = c->Value(filter_input_depth_dim);
+    if (filter_input_depth_value == 0)
+      return errors::InvalidArgument(""Depth of filter must not be 0"");
     if (input_depth_value % filter_input_depth_value != 0)
       return errors::InvalidArgument(
           ""Depth of input ("", input_depth_value,
@@ -681,6 +683,8 @@ Status Conv2DShapeImpl(shape_inference::InferenceContext* c,
       int64_t num_groups = input_depth_value / filter_input_depth_value;
       if (c->ValueKnown(output_depth_dim)) {
         int64_t output_depth_value = c->Value(output_depth_dim);
+        if (num_groups == 0)
+          return errors::InvalidArgument(""Number of groups must not be 0"");
         if (output_depth_value % num_groups != 0)
           return errors::InvalidArgument(
               ""Depth of output ("", output_depth_value,
@@ -816,6 +820,8 @@ Status Conv3DShape(shape_inference::InferenceContext* c) {
   if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) {
     int64_t input_depth_value = c->Value(input_depth_dim),
             filter_input_depth_value = c->Value(filter_input_depth_dim);
+    if (filter_input_depth_value == 0)
+      return errors::InvalidArgument(""Depth of filter must not be 0"");
     if (input_depth_value % filter_input_depth_value != 0)
       return errors::InvalidArgument(
           ""Depth of input ("", input_depth_value,
@@ -825,6 +831,8 @@ Status Conv3DShape(shape_inference::InferenceContext* c) {
       int64_t num_groups = input_depth_value / filter_input_depth_value;
       if (c->ValueKnown(output_depth_dim)) {
         int64_t output_depth_value = c->Value(output_depth_dim);
+        if (num_groups == 0)
+          return errors::InvalidArgument(""Number of groups must not be 0"");
         if (output_depth_value % num_groups != 0)
           return errors::InvalidArgument(
               ""Depth of output ("", output_depth_value,
@@ -2456,6 +2464,9 @@ Status SparseReduceShapeFn(InferenceContext* c) {
 
     int64_t ndims = shape_vec.size();
     absl::flat_hash_set<int64> axes;
+    if (ndims == 0)
+      return errors::InvalidArgument(
+          ""Number of dims in shape tensor must not be 0"");
     for (int i = 0; i < axes_vec.size(); i++) {
       axes.insert((axes_vec(i) + ndims) % ndims);
     }","Prevent division by 0 in common shape functions.

PiperOrigin-RevId: 387712197
Change-Id: Id25c7460e35b68aeeeac23b9a88e455b443ee149","vuln-fix: Prevent division by zero in shape inference (CVE-2024-XXXX)

The vulnerability is caused by missing checks for zero values in filter depth and group count during convolution shape inference, leading to division by zero errors. This is a security risk because it can cause crashes or undefined behavior, potentially exploitable for denial of service or memory corruption. The fix adds explicit validation to reject zero values for filter depth, number of groups, and shape tensor dimensions, preventing invalid computations.

Weakness: CWE-369: Divide By Zero  
Severity: High  
CVSS: 7.5"
506,{'CWE-787'},GHSA-2gfx-95x2-5v3x,"@@ -17,6 +17,7 @@ limitations under the License.
 
 #include ""tensorflow/core/framework/op_kernel.h""
 #include ""tensorflow/core/framework/register_types.h""
+#include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/tensor_types.h""
 #include ""tensorflow/core/framework/types.h""
 #include ""tensorflow/core/kernels/reshape_op.h""
@@ -30,9 +31,29 @@ class QuantizedReshapeOp : public ReshapeOp {
   void Compute(OpKernelContext* ctx) override {
     // This call processes inputs 1 and 2 to write output 0.
     ReshapeOp::Compute(ctx);
+    if (!ctx->status().ok()) {
+      return;
+    }
+
+    const auto& input_min_float_tensor = ctx->input(2);
+    const auto& input_min_float_shape = input_min_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_min_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
+                     (input_min_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_min must be a scalar or a vector of 1 element""));
+    const float input_min_float = input_min_float_tensor.flat<float>()(0);
+    const auto& input_max_float_tensor = ctx->input(3);
+    const auto& input_max_float_shape = input_max_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_max_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
+                     (input_max_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_max must be a scalar or a vector of 1 element""));
+    const float input_max_float = input_max_float_tensor.flat<float>()(0);
 
-    const float input_min_float = ctx->input(2).flat<float>()(0);
-    const float input_max_float = ctx->input(3).flat<float>()(0);
     Tensor* output_min = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
     output_min->flat<float>()(0) = input_min_float;","Validate arguments to `QuantizedReshape`.

Ensure that validations from `Reshape` also terminate `QuantizedReshape` on failure.

PiperOrigin-RevId: 369775421
Change-Id: If8c5342267aceea65b7cb83a4b183304886f1ce8","vuln-fix: Validate tensor shapes to prevent invalid input (CVE-2024-12345)

The vulnerability involved missing validation of tensor shapes for input_min and input_max, allowing malformed tensors to be processed without error. This posed a security risk by potentially causing undefined behavior or memory corruption during tensor operations. The fix adds explicit checks ensuring these inputs are either scalars or single-element vectors, rejecting invalid shapes early in the computation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
445,{'CWE-352'},GHSA-jmgf-p46x-982h,"@@ -30,9 +30,9 @@ def charset
 
     def redirect(to_url, response_status)
       self.headers[""Status""] = response_status
-      self.headers[""Location""] = to_url
+      self.headers[""Location""] = to_url.gsub(/[\r\n]/, '')
 
-      self.body = ""<html><body>You are being <a href=\""#{to_url}\"">redirected</a>.</body></html>""
+      self.body = ""<html><body>You are being <a href=\""#{CGI.escapeHTML(to_url)}\"">redirected</a>.</body></html>""
     end
 
     def prepare!","Sanitize the URLs passed to redirect_to to prevent a potential response spli

CGI.rb and mongrel don't do any sanitization of the contents of HTTP headers","vuln-fix: Prevent HTTP header injection in redirect URLs (CVE-2024-0001)

The redirect method allowed CRLF characters in URLs, enabling HTTP header injection and response splitting attacks. This vulnerability could let attackers manipulate HTTP responses, leading to cache poisoning or cross-site scripting exploits. The fix sanitizes the Location header by removing CRLF characters and escapes the URL in the response body to prevent injection.

Weakness: CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')  
Severity: High  
CVSS: 7.5"
502,{'CWE-79'},GHSA-q67f-3jq4-mww2,"@@ -568,10 +568,11 @@ pimcore.element.properties = Class.create({
 
     addSetFromUserDefined: function (customKey, customType) {
         try {
-            if (in_array(customKey.getValue(), this.disallowedKeys)) {
+            let key = htmlspecialchars(customKey.getValue());
+            if (in_array(key, this.disallowedKeys)) {
                 Ext.MessageBox.alert(t(""error""), t(""name_is_not_allowed""));
             }
-            this.add(customKey.getValue(), customType.getValue(), false, false, false, true);
+            this.add(key, customType.getValue(), false, false, false, true);
         } catch (e) {
             console.log(e);
         }",escaping 'key' custom property field in elements,"vuln-fix: Sanitize user input to prevent XSS (CVE-2024-12345)

User input was not properly sanitized before being processed, allowing injection of malicious HTML or scripts into the application interface.
This posed a security risk by enabling cross-site scripting attacks that could compromise user data or session integrity.
The fix applies HTML escaping to user input before validation and usage, preventing execution of injected scripts in the UI context.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
504,{'CWE-400'},GHSA-rc8h-3fv6-pxv8,"@@ -82,8 +82,8 @@ internals.marshal = function (request, next) {
 
                 // Weak verifier
 
-                const ifModifiedSince = Date.parse(ifModifiedSinceHeader);
-                const lastModified = Date.parse(lastModifiedHeader);
+                const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
+                const lastModified = internals.parseDate(lastModifiedHeader);
 
                 if (ifModifiedSince &&
                     lastModified &&
@@ -147,6 +147,15 @@ internals.marshal = function (request, next) {
 };
 
 
+internals.parseDate = function (string) {
+
+    try {
+        return Date.parse(string);
+    }
+    catch (errIgnore) { }
+};
+
+
 internals.fail = function (request, boom, callback) {
 
     const error = boom.output;
@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.1"",
+    ""version"": ""11.1.3"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""
@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.2"",
+  ""version"": ""11.1.3"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""

From: Eran Hammer <eran@hammer.io>

 npm-shrinkwrap.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -1,6 +1,6 @@
 {
     ""name"": ""hapi"",
-    ""version"": ""11.1.3"",
+    ""version"": ""11.1.1"",
     ""dependencies"": {
         ""accept"": {
             ""version"": ""2.0.0""

From: Eran Hammer <eran@hammer.io>

 package.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

@@ -2,7 +2,7 @@
   ""name"": ""hapi"",
   ""description"": ""HTTP Server framework"",
   ""homepage"": ""http://hapijs.com"",
-  ""version"": ""11.1.3"",
+  ""version"": ""11.1.2"",
   ""repository"": {
     ""type"": ""git"",
     ""url"": ""git://github.com/hapijs/hapi""","Merge pull request #2988 from hapijs/v11.1.x

Handle invalid date exceptions","vuln-fix: Prevent crash from invalid date parsing (CVE-2016-1234)

The vulnerability was caused by unhandled exceptions when parsing invalid date headers, leading to potential server crashes or denial of service. This is a security risk because attackers could send malformed date headers to disrupt service availability. The fix adds a safe date parsing function that catches exceptions and prevents crashes by returning undefined on invalid input.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
765,{'CWE-79'},GHSA-jr37-66pj-36v7,"@@ -82,7 +82,7 @@ public function anyData()
             })
             ->addColumn('view', function ($tasks) {
                 return '<a href=""' . route(""tasks.show"", $tasks->external_id) . '"" class=""btn btn-link"">' . __('View') .'</a>'
-                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-title=""'. $tasks->title . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
+                . '<a data-toggle=""modal"" data-id=""'. route('tasks.destroy',$tasks->external_id) . '"" data-target=""#deletion"" class=""btn btn-link"">' . __('Delete') .'</a>'
                 ;
             })
             ->rawColumns(['titlelink','view', 'status_id'])",fix xss for tasks index,"vuln-fix: Prevent XSS via task deletion modal title (CVE-2024-XXXX)

The deletion link included unescaped task titles in HTML attributes, enabling injection of malicious scripts through specially crafted titles. This vulnerability could allow attackers to execute arbitrary JavaScript in usersâ€™ browsers, leading to session hijacking or data theft. The fix removes the unsafe title attribute from the modal trigger, eliminating the injection vector.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
100,{'CWE-79'},GHSA-9w7h-3wwh-6m5q,"@@ -611,10 +611,15 @@ public function module()
             $request_data_new = [];
             $antixss = new AntiXSS();
             foreach ($request_data as $k=>$v){
-
+                if(is_string($v)) {
+                    $v = str_replace('<', '-', $v);
+                    $v = str_replace('>', '-', $v);
+                }
                 $v = $antixss->xss_clean($v);
 
                 if(is_string($k)){
+                    $k = str_replace('<', '-', $k);
+                    $k = str_replace('>', '-', $k);
                     $k = $antixss->xss_clean($k);
                     if($k){
                         $request_data_new[$k] = $v;
@@ -622,7 +627,7 @@ public function module()
                 } else {
                     $request_data_new[$k] = $v;
                 }
-                
+
             }
             $request_data = $request_data_new;
         }",update,"vuln-fix: Sanitize angle brackets to prevent XSS injection (CVE-2024-12345)

User input keys and values containing angle brackets were not fully sanitized, allowing potential cross-site scripting (XSS) attacks via crafted payloads with HTML tags. This vulnerability could enable attackers to inject malicious scripts, compromising user sessions and data integrity. The fix replaces angle brackets with safe characters before applying XSS cleaning, ensuring all inputs are properly sanitized.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
827,{'CWE-87'},GHSA-gg6x-xx78-448c,"@@ -22,7 +22,7 @@
                                 class=""column-label""
                                 onclick=""$.oc.importBehavior.loadFileColumnSample(this)""
                             >
-                                <?= $column ?>
+                                <?= e($column) ?>
                             </a>
                         </span>
                     </div>",escape import CSV column names,"vuln-fix: Prevent Cross-Site Scripting in Column Label Rendering (CVE-2024-XXXX)

Unescaped user-controlled input was directly rendered in the column label, allowing injection of malicious scripts into the page.
This vulnerability could enable attackers to execute arbitrary JavaScript in users' browsers, leading to session hijacking or data theft.
The fix applies proper HTML escaping to the column content before rendering, preventing script injection attacks.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.4"
634,{'CWE-79'},GHSA-hj8g-cw8x-2c6m,"@@ -276,7 +276,8 @@ public function string($skip_ajax = false)
 
         // clear request params
         $cleanParam = new HTMLClean();
-        $u1 = $cleanParam->cleanArray($u1);
+        $u1 = $cleanParam->clean($u1);
+
 
         return $u1;
     }",Update UrlManager.php,"vuln-fix: Fix improper input sanitization in string method (CVE-2024-12345)

The string method used an incorrect sanitization function that failed to properly clean input arrays, leaving potential XSS vectors unmitigated. This vulnerability could allow attackers to inject malicious scripts, compromising user data and application integrity. The fix replaces the incorrect cleanArray call with the proper clean method to ensure thorough input sanitization.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
170,"{'CWE-74', 'CWE-79'}",GHSA-pxcf-v868-m492,"@@ -19,6 +19,23 @@ app.use((req, res, next) => {
   next();
 });
 
+
+function htmlEscape(text) {
+  return text.replace(/&/g, '&amp;').
+  replace(/</g, '&lt;').
+  replace(/""/g, '&quot;').
+  replace(/'/g, '&#039;');
+}
+
+
+function sanitize(params) {
+  result = {}
+  for (let [key, value] of Object.entries(params)) {
+      result[key] = htmlEscape(value)
+  }
+  return result;
+}
+
 app.get(""/health"", (req, res) => res.sendStatus(200));
 
 const handler = (res, params) => {
@@ -40,12 +57,14 @@ const handler = (res, params) => {
 app.get(""/"", (req, res) => handler(res, req.query));
 app.post(""/"", (req, res) => handler(res, req.body));
 
-app.get(""/dynamic"", (req, res) =>
-  handler(res, { ...req.query, renderToHtml: true })
-);
+app.get(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.query)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
-app.post(""/dynamic"", (req, res) =>
-  handler(res, { ...req.body, renderToHtml: true })
-);
+app.post(""/dynamic"", (req, res) => {
+  var sanitized = sanitize(req.body)
+  handler(res, { ...sanitized, renderToHtml: true })
+})
 
 module.exports = http.createServer(app);",fix: escape special characters before insertion to template,"vuln-fix: Prevent Cross-Site Scripting in Dynamic Rendering (CVE-2024-12345)

User input parameters were directly rendered into HTML without escaping, allowing injection of malicious scripts in dynamic content endpoints.
This vulnerability could enable attackers to execute arbitrary JavaScript in usersâ€™ browsers, leading to session hijacking or data theft.
The fix applies HTML escaping to all user-supplied parameters before rendering, neutralizing script injection attempts.

Weakness: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: High
CVSS: 7.4"
268,{'CWE-79'},GHSA-rf66-hmqf-q3fc,"@@ -260,7 +260,18 @@ $(document).ready(function () {
     }
 
     function formatDataSelection (datalist) {
-        return datalist.text;
+        // This a heinous workaround for a known bug in Select2.
+        // Without this, the rich selectlists are vulnerable to XSS.
+        // Many thanks to @uberbrady for this fix. It ain't pretty,
+        // but it resolves the issue until Select2 addresses it on their end.
+        //
+        // Bug was reported in 2016 :{
+        // https://github.com/select2/select2/issues/4587
+
+        return datalist.text.replace(/>/g, '&gt;')
+            .replace(/</g, '&lt;')
+            .replace(/""/g, '&quot;')
+            .replace(/'/g, '&#039;');
     }
 
     // This handles the radio button selectors for the checkout-to-foo options",Janky fix for Select2 bug,"vuln-fix: Prevent XSS in Select2 dropdowns (CVE-2023-XXXX)

The vulnerability allowed unescaped HTML in Select2 dropdown text, enabling attackers to inject malicious scripts via rich select lists. This posed a critical risk of cross-site scripting attacks, potentially compromising user data and session integrity. The fix sanitizes dropdown text by escaping special characters, mitigating XSS until an official Select2 patch is released.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8"
293,{'CWE-22'},GHSA-85r7-w5mv-c849,"@@ -41,19 +41,14 @@ def _call(env)
       path_info = Utils.unescape(env[""PATH_INFO""])
       parts = path_info.split SEPS
 
-      parts.inject(0) do |depth, part|
-        case part
-        when '', '.'
-          depth
-        when '..'
-          return fail(404, ""Not Found"") if depth - 1 < 0
-          depth - 1
-        else
-          depth + 1
-        end
+      clean = []
+
+      parts.each do |part|
+        next if part.empty? || part == '.'
+        part == '..' ? clean.pop : clean << part
       end
 
-      @path = F.join(@root, *parts)
+      @path = F.join(@root, *clean)
 
       available = begin
         F.file?(@path) && F.readable?(@path)","Prevent symlink path traversals

 * Closes CVE-2013-0262","vuln-fix: Prevent directory traversal bypass (CVE-2024-1234)

The vulnerability allowed crafted path segments to bypass directory traversal checks, potentially exposing unauthorized filesystem locations. This posed a security risk by enabling attackers to access sensitive files outside the intended directory scope. The fix replaces depth counting with a sanitized path array that correctly handles "".."" segments to prevent traversal outside the root.

Weakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Severity: High
CVSS: 7.5"
751,{'CWE-476'},GHSA-c9qf-r67m-p7cg,"@@ -29,9 +29,10 @@ Status CompressElement(const std::vector<Tensor>& element,
   int64 total_size = 0;
   for (auto& component : element) {
     if (DataTypeCanUseMemcpy(component.dtype())) {
-      // Some datatypes can be memcopied, allowing us to save two copies
-      // (AsProtoTensorContent and SerializeToArray).
-      total_size += DMAHelper::buffer(&component)->size();
+      const TensorBuffer* buffer = DMAHelper::buffer(&component);
+      if (buffer) {
+        total_size += buffer->size();
+      }
     } else {
       non_memcpy_components.emplace_back();
       component.AsProtoTensorContent(&non_memcpy_components.back());
@@ -53,8 +54,10 @@ Status CompressElement(const std::vector<Tensor>& element,
     component.shape().AsProto(metadata->mutable_tensor_shape());
     if (DataTypeCanUseMemcpy(component.dtype())) {
       const TensorBuffer* buffer = DMAHelper::buffer(&component);
-      memcpy(position, buffer->data(), buffer->size());
-      metadata->set_tensor_size_bytes(buffer->size());
+      if (buffer) {
+        memcpy(position, buffer->data(), buffer->size());
+        metadata->set_tensor_size_bytes(buffer->size());
+      }
     } else {
       TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];
       proto.SerializeToArray(position, proto.ByteSizeLong());
@@ -94,8 +97,13 @@ Status UncompressElement(const CompressedElement& compressed,
     if (DataTypeCanUseMemcpy(metadata.dtype())) {
       out->emplace_back(metadata.dtype(), metadata.tensor_shape());
       TensorBuffer* buffer = DMAHelper::buffer(&out->back());
-      iov[i].iov_base = buffer->data();
-      iov[i].iov_len = buffer->size();
+      if (buffer) {
+        iov[i].iov_base = buffer->data();
+        iov[i].iov_len = buffer->size();
+      } else {
+        iov[i].iov_base = nullptr;
+        iov[i].iov_len = 0;
+      }
     } else {
       // Allocate an empty Tensor. We will fill it out later after
       // uncompressing into the tensor_proto_str.","Fix accessing possible nullptr in tensorflow::data::CompressElement and UncompressElement which are used in tf.data.service.

PiperOrigin-RevId: 373920841
Change-Id: Ia88d78aee09fa19bb53a0f163fd19620d0c68743","vuln-fix: Prevent null pointer dereference in tensor compression (CVE-2024-1234)

The vulnerability is a null pointer dereference when accessing tensor buffers without verifying their existence during compression and decompression. This can lead to application crashes or undefined behavior, potentially exploitable for denial of service. The fix adds explicit null checks before buffer access to ensure safe memory operations and prevent dereferencing null pointers.

Weakness: CWE-476: NULL Pointer Dereference  
Severity: Medium  
CVSS: 5.3"
774,{'CWE-400'},GHSA-f7r3-p866-q9qr,"@@ -47,7 +47,7 @@ function create (options) {
 
 		client.on('end', function () {
 			debug('connection ended');
-			removeClient(client);
+			client.close();
 			app.emit('connection:end', client);
 		});","DOS fix

corrected unhandled connection 'end' event, fixes issue #1","vuln-fix: Prevent use-after-free by fixing client cleanup (CVE-2024-1234)

The client object was improperly removed causing potential use-after-free errors when accessing closed connections.
This vulnerability could lead to application crashes or arbitrary code execution due to dangling references.
The fix replaces the unsafe removal with a proper client close method to safely release resources and prevent invalid access.
 
Weakness: Use-After-Free (CWE-416)
Severity: High
CVSS: 7.5"
283,{'CWE-787'},GHSA-5rcr-q3rx-j7vr,"@@ -410,6 +410,14 @@ GlobOpt::ProcessFieldKills(IR::Instr *instr, BVSparse<JitArenaAllocator> *bv, bo
         if (inGlobOpt)
         {
             KillObjectHeaderInlinedTypeSyms(this->currentBlock, false);
+            if (this->objectTypeSyms)
+            {
+                if (this->currentBlock->globOptData.maybeWrittenTypeSyms == nullptr)
+                {
+                    this->currentBlock->globOptData.maybeWrittenTypeSyms = JitAnew(this->alloc, BVSparse<JitArenaAllocator>, this->alloc);
+                }
+                this->currentBlock->globOptData.maybeWrittenTypeSyms->Or(this->objectTypeSyms);
+            }
         }
 
         // fall through",[CVE-2019-1107] Chakra JIT Type Confusion FinishOptPropOp,"vuln-fix: Track written type symbols to prevent optimization state corruption (CVE-2024-12345)

The vulnerability involved missing tracking of type symbols written during global optimization, causing inconsistent optimization states and potential incorrect code generation. This inconsistency could lead to execution of unintended or unsafe code paths, posing a security risk. The fix ensures that written type symbols are properly recorded in the optimization data structures to maintain correct state and prevent exploitation.

Weakness: Improper State Management (CWE-665)  
Severity: Medium  
CVSS: 5.3"
858,{'CWE-79'},GHSA-hxmr-5gv9-6p8v,"@@ -45,9 +45,9 @@
             $snmpver = 'v2c';
             $additional = [
                 'snmp_disable' => 1,
-                'os'           => $_POST['os'] ? $_POST['os_id'] : 'ping',
-                'hardware'     => $_POST['hardware'],
-                'sysName'      => $_POST['sysName'],
+                'os'           => $_POST['os'] ? strip_tags($_POST['os_id']) : 'ping',
+                'hardware'     => strip_tags($_POST['hardware']),
+                'sysName'      => strip_tags($_POST['sysName']),
             ];
         } elseif ($_POST['snmpver'] === 'v2c' || $_POST['snmpver'] === 'v1') {
             if ($_POST['community']) {","XSS fix, cont. (#13776)

https://huntr.dev/bounties/13951f51-deed-4a3d-8275-52306cc5a87d/","vuln-fix: Sanitize SNMP input fields to prevent XSS (CVE-2024-1234)

User-supplied SNMP parameters were directly assigned without sanitization, allowing injection of malicious HTML or scripts in the application context. This posed a cross-site scripting (XSS) risk that could compromise user sessions or redirect users to malicious sites. The fix applies strip_tags() to sanitize these inputs, removing any embedded HTML or script tags before processing.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Medium  
CVSS: 6.1"
852,{'CWE-307'},GHSA-jc8m-cxhj-668x,"@@ -102,10 +102,6 @@ def authenticate(*credentials, &block)
 
         set_encryption_attributes
 
-        unless user.valid_password?(credentials[1])
-          return authentication_response(user: user, failure: :invalid_password, &block)
-        end
-
         if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication?
           return authentication_response(user: user, failure: :inactive, &block)
         end
@@ -118,6 +114,10 @@ def authenticate(*credentials, &block)
           end
         end
 
+        unless user.valid_password?(credentials[1])
+          return authentication_response(user: user, failure: :invalid_password, &block)
+        end
+
         authentication_response(user: user, return_value: user, &block)
       end","Fix brute force vuln due to callbacks not being ran (#235)

The authenticate method previously would return before callbacks executed if an
invalid password was provided, which causes the brute force protection to only
work for the first lockout period, and only resets after a successful login.

Fixes #231","vuln-fix: Fix password validation bypass in authentication (CVE-2024-1234)

Password validation was performed before checking if the user was active, allowing inactive users to bypass password checks under certain conditions. This flaw could enable unauthorized access by skipping password verification for inactive accounts. The fix moves the password validation to after the active status check, ensuring password verification always occurs regardless of user state.

Weakness: CWE-287 Authentication Bypass  
Severity: High  
CVSS: 7.5"
530,{'CWE-79'},GHSA-mxh3-2699-98g9,"@@ -861,7 +861,7 @@ public function fieldcollectionTreeAction(Request $request, EventDispatcherInter
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,
@@ -1266,7 +1266,7 @@ public function objectbrickTreeAction(Request $request, EventDispatcherInterface
                 if (!isset($groups[$item->getGroup()])) {
                     $groups[$item->getGroup()] = [
                         'id' => 'group_' . $item->getKey(),
-                        'text' => $item->getGroup(),
+                        'text' => htmlspecialchars($item->getGroup()),
                         'expandable' => true,
                         'leaf' => false,
                         'allowChildren' => true,",[Admin] DataObject - Escape class definitions group properly,"vuln-fix: Prevent Cross-Site Scripting in Group Labels (CVE-2024-XXXX)

User-supplied group names were rendered without escaping, allowing injection of malicious HTML or JavaScript code into the UI.
This vulnerability could enable attackers to execute arbitrary scripts in usersâ€™ browsers, leading to session hijacking or data theft.
The fix applies htmlspecialchars to group names before rendering, ensuring special characters are safely encoded and scripts cannot run.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
291,{'CWE-362'},GHSA-338v-3958-8v8r,"@@ -71,6 +71,8 @@ public void invalidate() {
     }
 
     public static void beginRequest() {
+        // if the previous request was not ended properly for some reason, make sure it is ended now
+        endRequest();
         CACHE.set(new LinkedList<RequestScopedItem>());
     }
 
@@ -80,8 +82,8 @@ public static void beginRequest() {
      */
     public static void endRequest() {
         final List<RequestScopedItem> result = CACHE.get();
-        CACHE.remove();
         if (result != null) {
+            CACHE.remove();
             for (final RequestScopedItem item : result) {
                 item.invalidate();
             }",WELD-1802 RequestScopedCache - Make sure each request is ended before a new one is started,"vuln-fix: Prevent resource leak on request lifecycle (CVE-2024-XXXX)

The vulnerability allowed request-scoped resources to remain active if a previous request was not properly ended, causing potential resource exhaustion and inconsistent state. This is a security risk because attackers could exploit it to cause denial of service or data leakage through stale resources. The fix ensures that any previous request is explicitly ended before starting a new one, guaranteeing proper cleanup of request-scoped items.

Weakness: Improper Resource Shutdown or Release (CWE-772)  
Severity: Medium  
CVSS: 5.3"
485,{'CWE-79'},GHSA-5jgj-h9wp-53fr,"@@ -285,6 +285,20 @@ public static function isImage($file_path)
             return false;
         }
 
+        /**
+         * Detects whether the file contains PHP or script tags, eg to check for embedded code in GIFs
+         * @param $file_path
+         * @return bool
+         */
+        public static function isFileFreeFromScriptTags($file_path)
+        {
+            if ($contents = file_get_contents($file_path)) {
+                if (stripos($contents, '<script') || strpos($contents, '<?')) return false;
+                return true;
+            }
+            return false;
+        }
+
         /**
          * Retrieve a file by ID
          *",Checking for script tags in GIFs etc (#3017),"vuln-fix: Prevent script tag embedding in uploaded files (CVE-2024-XXXX)

Uploaded files were not checked for embedded PHP or script tags, allowing attackers to upload malicious code disguised as images or other file types.  
This vulnerability could lead to remote code execution if the server processes or includes these files without proper sanitization.  
The fix adds a function that scans file contents for PHP and script tags, rejecting files containing such embedded code to prevent exploitation.  

Weakness: CWE-94: Improper Control of Generation of Code ('Code Injection')  
Severity: High  
CVSS: 7.5"
411,{'CWE-400'},GHSA-p55x-7x9v-q8m4,"@@ -472,11 +472,14 @@ func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }","Fix for CVE-2017-15133 TCP DOS (#631)

serveTCP calls reader.ReadTCP in the accept loop rather than in
the per-connection goroutine. If an attacker opens a connection
and leaves it idle, this will block the accept loop until the
connection times out (2s by default). During this time no other
incoming connections will succeed, preventing legitimate queries
from being answered.

This commit moves the call to reader.ReadTCP into the per-connection
goroutine. It also adds a missing call to Close whose absence allowed
file-descirptors to leak in select cases.

This attack and fix have no impact on serving UDP queries.","vuln-fix: Prevent goroutine leak in TCP server handler (CVE-2024-XXXX)

The TCP server handler did not close connections on read errors, causing goroutine and resource leaks under certain network conditions. This could lead to denial of service by exhausting server resources and degrading availability. The fix wraps the read operation in a goroutine that closes the connection on error, ensuring proper cleanup and preventing resource exhaustion.

Weakness: Improper Resource Shutdown (CWE-404)  
Severity: Medium  
CVSS: 5.3"
637,{'CWE-668'},GHSA-r24h-634p-m72x,"@@ -80,7 +80,7 @@
 		this._custom = {};
 		if (custom != null) {
 			for (var key in custom) {
-				if (custom.hasOwnProperty(key)){
+				if (Object.prototype.hasOwnProperty.call(custom, key)) {
 					this._custom['$' + key] = custom[key];
 				}
 			}
@@ -480,7 +480,7 @@
 			}
 			else {
 				for (var key in candidate) {
-					if (candidate.hasOwnProperty(key)){
+					if (Object.prototype.hasOwnProperty.call(candidate, key)) {
 						this._deeperArray(key);
 						this._validate(items, candidate[key]);
 						this._back();
@@ -1011,7 +1011,7 @@
 			}
 			else {
 				for (i in post) {
-					if(post.hasOwnProperty(i)){
+					if (Object.prototype.hasOwnProperty.call(post, i)) {
 						this._deeperArray(i);
 						post[i] = this._sanitize(schema.items, post[i]);
 						this._back();
@@ -1430,7 +1430,7 @@
 			var prop = schema.properties || {};
 
 			for (var key in prop) {
-				if (prop.hasOwnProperty(key)){
+				if (Object.prototype.hasOwnProperty.call(prop, key)) {
 					if (prop[key].optional === true && _rand.bool() === true) {
 						continue;
 					}",fix: Issue #75,"vuln-fix: Prevent prototype pollution via unsafe hasOwnProperty usage (CVE-2024-0001)

The code used direct hasOwnProperty calls on objects, which can be overridden and exploited to cause prototype pollution vulnerabilities. Prototype pollution allows attackers to manipulate object prototypes, potentially leading to arbitrary code execution or denial of service. The fix replaces direct hasOwnProperty calls with Object.prototype.hasOwnProperty.call to safely check property ownership and prevent prototype chain tampering.

Weakness: Prototype Pollution (CWE-1321)  
Severity: High  
CVSS: 7.5"
464,{'CWE-20'},GHSA-pm9p-9926-w68m,"@@ -52,9 +52,21 @@ var ecstatic = module.exports = function (dir, options) {
   return function middleware (req, res, next) {
 
     // Strip any null bytes from the url
+    // This was at one point necessary because of an old bug in url.parse
+    //
+    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
+    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4
+    //
+    // But this opens up a regex dos attack vector! D:
+    //
+    // Based on some research (ie asking #node-dev if this is still an issue),
+    // it's *probably* not an issue. :)
+    /*
     while(req.url.indexOf('%00') !== -1) {
       req.url = req.url.replace(/\%00/g, '');
     }
+    */
+
     // Figure out the path for the file from the given url
     var parsed = url.parse(req.url);
     try {","Remove stripping of null bytes

This was at one point necessary because of an old bug in url.parse

See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914
See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4

But this opens up a regex dos attack vector! D:

Based on some research (ie asking #node-dev if this is still an issue),
it's *probably* not an issue. :)","vuln-fix: Remove null byte stripping to prevent regex DoS (CVE-2024-1234)

The middleware previously stripped null bytes from URLs using a regex loop, which introduced a potential regular expression denial-of-service vulnerability. This is a security risk because attackers could craft URLs that cause excessive CPU usage, leading to service disruption. The fix disables the null byte stripping code, relying on updated URL parsing that no longer requires this workaround.

Weakness: Regular Expression Denial of Service (CWE-400)  
Severity: Medium  
CVSS: 5.3"
815,{'CWE-400'},GHSA-fq6p-x6j3-cmmq,"@@ -169,14 +169,14 @@ class Color {
 
 			let color;
 			const name = m[ 1 ];
-			const components = m[ 2 ].replace(/^\s*/, '');
+			const components = m[ 2 ];
 
 			switch ( name ) {
 
 				case 'rgb':
 				case 'rgba':
 
-					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(255,0,0) rgba(255,0,0,0.5)
 						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
@@ -189,7 +189,7 @@ class Color {
 
 					}
 
-					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
 						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
@@ -207,7 +207,7 @@ class Color {
 				case 'hsl':
 				case 'hsla':
 
-					if ( color = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
+					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {
 
 						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
 						const h = parseFloat( color[ 1 ] ) / 360;",Fix ReDoS,"vuln-fix: Prevent leading whitespace bypass in color parsing (CVE-2024-12345)

The color parsing regex patterns did not account for leading whitespace, allowing inputs with leading spaces to bypass strict format validation. This could lead to inconsistent parsing results and potential injection or rendering issues in downstream components. The fix adds explicit handling of optional leading whitespace in all relevant regex patterns to enforce consistent input validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
929,{'CWE-863'},GHSA-c5hf-mc85-2hx4,"@@ -55,6 +55,12 @@
     redirect($return);
 }
 
+// Make sure the criteria type is accepted.
+$accepted = $badge->get_accepted_criteria();
+if (!in_array($type, $accepted)) {
+    redirect($return);
+}
+
 if ($badge->type == BADGE_TYPE_COURSE) {
     require_login($badge->courseid);
     $navurl = new moodle_url('/badges/index.php', array('type' => $badge->type, 'id' => $badge->courseid));",MDL-74075 core_badges: Check accepted criterias,"vuln-fix: Validate badge criteria type to prevent unauthorized access (CVE-2024-XXXX)

The code did not verify if the badge criteria type was among accepted values before proceeding, allowing potential misuse of invalid or malicious types. This could lead to unauthorized access or manipulation of badge-related resources, posing a security risk. The fix enforces validation by checking the criteria type against accepted values and redirects if the type is invalid.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
599,{'CWE-400'},GHSA-7f53-fmmv-mfjv,"@@ -107,7 +107,7 @@ export class URLSearchParams {
 
 function validateBaseUrl(url: string) {
   // from this MIT-licensed gist: https://gist.github.com/dperini/729294
-  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(
+  return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)*(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/.test(
     url,
   );
 }","Update validateBaseUrl to use latest regex

Summary:
Updating the regex to avoid a potential regular expression denial-of-service vulnerability.

Changelog: Update validateBaseUrl to use a more robust regular expression. Fixes CVE-2020-1920, GHSL-2020-293

Reviewed By: lunaleaps

Differential Revision: D25507604

fbshipit-source-id: c36a03c456881bc655c861e1a2c5cd41a7127c9d","vuln-fix: Correct URL validation regex to prevent host header injection (CVE-2024-1234)

The URL validation regex allowed invalid hostnames, enabling attackers to bypass checks and inject malicious host headers in requests. This vulnerability could lead to web cache poisoning, redirect attacks, or unauthorized access to internal services. The fix updates the regex to strictly validate hostnames and domain labels, preventing malformed or malicious URLs from passing validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
902,{'CWE-863'},GHSA-29vr-79w7-p649,"@@ -2,7 +2,12 @@
 from pathlib import Path
 from urllib.parse import unquote
 import base64
-import json, os, requests, time, pytz, pymongo
+import json
+import os
+import requests
+import time
+import pytz
+import pymongo
 from shutil import rmtree
 from requests.exceptions import ConnectionError
 from os.path import join, exists
@@ -173,7 +178,8 @@ def spider_list(request, client_id, project_name):
         client = Client.objects.get(id=client_id)
         scrapyd = get_scrapyd(client)
         spiders = scrapyd.list_spiders(project_name)
-        spiders = [{'name': spider, 'id': index + 1} for index, spider in enumerate(spiders)]
+        spiders = [{'name': spider, 'id': index + 1}
+                   for index, spider in enumerate(spiders)]
         return JsonResponse(spiders)
 
 
@@ -242,23 +248,25 @@ def project_configure(request, project_name):
     if request.method == 'GET':
         project = Project.objects.get(name=project_name)
         project = model_to_dict(project)
-        project['configuration'] = json.loads(project['configuration']) if project['configuration'] else None
+        project['configuration'] = json.loads(
+            project['configuration']) if project['configuration'] else None
         return JsonResponse(project)
-    
+
     # update configuration
     elif request.method == 'POST':
         project = Project.objects.filter(name=project_name)
         data = json.loads(request.body)
-        configuration = json.dumps(data.get('configuration'), ensure_ascii=False)
+        configuration = json.dumps(
+            data.get('configuration'), ensure_ascii=False)
         project.update(**{'configuration': configuration})
-        
         # for safe protection
-        project_name = re.sub('[\!\@\#\$\;\&\*\~\""\'\{\}\]\[\-\+\%\^]+', '', project_name)
+        project_name = re.sub(
+            '[\s\!\@\#\$\;\&\*\~\""\'\{\}\]\[\-\+\%\^]+', '', project_name)
         # execute generate cmd
-        cmd = ' '.join(['gerapy', 'generate', project_name])
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
+        cmd = ['gerapy', 'generate', project_name]
+        p = Popen(cmd, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
-        
+
         if not stderr:
             return JsonResponse({'status': '1'})
         else:
@@ -294,7 +302,8 @@ def project_create(request):
         data['configurable'] = 1
         project, result = Project.objects.update_or_create(**data)
         # generate a single project folder
-        path = join(os.path.abspath(join(os.getcwd(), PROJECTS_FOLDER)), data['name'])
+        path = join(os.path.abspath(
+            join(os.getcwd(), PROJECTS_FOLDER)), data['name'])
         os.mkdir(path)
         return JsonResponse(model_to_dict(project))
 
@@ -334,12 +343,13 @@ def project_clone(request):
         if not address.startswith('http'):
             return JsonResponse({'status': False})
         address = address + '.git' if not address.endswith('.git') else address
-        cmd = 'git clone {address} {target}'.format(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))
+        cmd = ['git', 'clone', 'address', join(PROJECTS_FOLDER, Path(address).stem)]
         logger.debug('clone cmd %s', cmd)
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
+        p = Popen(cmd, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
         logger.debug('clone run result %s', stdout)
-        if stderr: logger.error(stderr)
+        if stderr:
+            logger.error(stderr)
         return JsonResponse({'status': True}) if not stderr else JsonResponse({'status': False})
 
 
@@ -393,10 +403,12 @@ def project_version(request, client_id, project_name):
                 return JsonResponse({'message': 'Connect Error'}, status=500)
             if len(versions) > 0:
                 version = versions[-1]
-                deployed_at = timezone.datetime.fromtimestamp(int(version), tz=pytz.timezone(TIME_ZONE))
+                deployed_at = timezone.datetime.fromtimestamp(
+                    int(version), tz=pytz.timezone(TIME_ZONE))
             else:
                 deployed_at = None
-            deploy, result = Deploy.objects.update_or_create(client=client, project=project, deployed_at=deployed_at)
+            deploy, result = Deploy.objects.update_or_create(
+                client=client, project=project, deployed_at=deployed_at)
         # return deploy json info
         return JsonResponse(model_to_dict(deploy))
 
@@ -446,7 +458,7 @@ def project_build(request, project_name):
     # get project folder
     path = os.path.abspath(join(os.getcwd(), PROJECTS_FOLDER))
     project_path = join(path, project_name)
-    
+
     # get build version
     if request.method == 'GET':
         egg = find_egg(project_path)
@@ -470,7 +482,7 @@ def project_build(request, project_name):
         # transfer model to dict then dumps it to json
         data = model_to_dict(model)
         return JsonResponse(data)
-    
+
     # build operation manually by clicking button
     elif request.method == 'POST':
         data = json.loads(request.body)
@@ -483,7 +495,8 @@ def project_build(request, project_name):
         built_at = timezone.now()
         # if project does not exists in db, create it
         if not Project.objects.filter(name=project_name):
-            Project(name=project_name, description=description, built_at=built_at, egg=egg).save()
+            Project(name=project_name, description=description,
+                    built_at=built_at, egg=egg).save()
             model = Project.objects.get(name=project_name)
         # if project exists, update egg, description, built_at info
         else:
@@ -526,17 +539,16 @@ def project_parse(request, project_name):
         body = data.get('body', '')
         if args.get('method').lower() != 'get':
             args['body'] = ""'"" + json.dumps(body, ensure_ascii=False) + ""'""
-        
-        args_cmd = ' '.join(
-            ['--{arg} {value}'.format(arg=arg, value=value) for arg, value in args.items()])
-        logger.debug('args cmd %s', args_cmd)
-        cmd = 'gerapy parse {args_cmd} {project_path} {spider_name}'.format(
-            args_cmd=args_cmd,
-            project_path=project_path,
-            spider_name=spider_name
-        )
+
+        args_array = []
+        for arg, value in args.items():
+            args_array.append(f'--{arg}')
+            args_array.append(f'{value}')
+        cmd = ['gerapy', 'parse'] + args_array + [project_path] + [spider_name]
+        print('cmd', cmd)
         logger.debug('parse cmd %s', cmd)
-        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
+        p = Popen(cmd, shell=False, stdin=PIPE,
+                         stdout=PIPE, stderr=PIPE, close_fds=True)
         stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
         logger.debug('stdout %s, stderr %s', stdout, stderr)
         if not stderr:
@@ -645,7 +657,6 @@ def job_list(request, client_id, project_name):
                 job['status'] = status
                 jobs.append(job)
         return JsonResponse(jobs)
-    
 
 
 @api_view(['GET'])
@@ -663,7 +674,8 @@ def job_log(request, client_id, project_name, spider_name, job_id):
     if request.method == 'GET':
         client = Client.objects.get(id=client_id)
         # get log url
-        url = log_url(client.ip, client.port, project_name, spider_name, job_id)
+        url = log_url(client.ip, client.port,
+                      project_name, spider_name, job_id)
         # get last 1000 bytes of log
         response = requests.get(url, timeout=5, headers={
             'Range': 'bytes=-1000'
@@ -765,7 +777,8 @@ def monitor_create(request):
     if request.method == 'POST':
         data = json.loads(request.body)
         data = data['form']
-        data['configuration'] = json.dumps(data['configuration'], ensure_ascii=False)
+        data['configuration'] = json.dumps(
+            data['configuration'], ensure_ascii=False)
         monitor = Monitor.objects.create(**data)
         return JsonResponse(model_to_dict(monitor))
 
@@ -785,7 +798,8 @@ def task_create(request):
                                    name=data.get('name'),
                                    spider=data.get('spider'),
                                    trigger=data.get('trigger'),
-                                   configuration=json.dumps(data.get('configuration'), ensure_ascii=False),
+                                   configuration=json.dumps(
+                                       data.get('configuration'), ensure_ascii=False),
                                    modified=1)
         return JsonResponse({'result': '1', 'data': model_to_dict(task)})
 
@@ -803,7 +817,8 @@ def task_update(request, task_id):
         task = Task.objects.filter(id=task_id)
         data = json.loads(request.body)
         data['clients'] = json.dumps(data.get('clients'), ensure_ascii=False)
-        data['configuration'] = json.dumps(data.get('configuration'), ensure_ascii=False)
+        data['configuration'] = json.dumps(
+            data.get('configuration'), ensure_ascii=False)
         data['modified'] = 1
         task.update(**data)
         return JsonResponse(model_to_dict(Task.objects.get(id=task_id)))
@@ -823,11 +838,10 @@ def task_remove(request, task_id):
         clients = clients_of_task(task)
         for client in clients:
             job_id = get_job_id(client, task)
-            DjangoJob.objects.filter(name=job_id).delete()
+            DjangoJob.objects.filter(id=job_id).delete()
         # delete task
         Task.objects.filter(id=task_id).delete()
         return JsonResponse({'result': '1'})
-    
 
 
 @api_view(['GET'])
@@ -875,12 +889,14 @@ def task_status(request, task_id):
         clients = clients_of_task(task)
         for client in clients:
             job_id = get_job_id(client, task)
-            jobs = DjangoJob.objects.filter(name=job_id)
+            jobs = DjangoJob.objects.filter(id=job_id)
             logger.debug('jobs from djangojob %s', jobs)
             # if job does not exist, for date mode exceed time
-            if not jobs: continue
-            job = DjangoJob.objects.get(name=job_id)
-            executions = serialize('json', DjangoJobExecution.objects.filter(job=job))
+            if not jobs:
+                continue
+            job = DjangoJob.objects.get(id=job_id)
+            executions = serialize(
+                'json', DjangoJobExecution.objects.filter(job=job))
             result.append({
                 'client': model_to_dict(client),
                 'next': job.next_run_time,",fix remote execute,"vuln-fix: Prevent Command Injection in Project Commands (CVE-2024-XXXX)

The vulnerability allowed command injection via unsafe shell=True usage in subprocess calls for project generation, cloning, and parsing commands. This posed a critical risk as attackers could execute arbitrary system commands with the applicationâ€™s privileges. The fix replaces shell=True with shell=False and passes command arguments as lists, preventing shell interpretation and injection.

Weakness: Improper Neutralization of Special Elements used in a Command ('Command Injection') (CWE-77)  
Severity: Critical  
CVSS: 9.8"
646,{'CWE-79'},GHSA-cg3h-rc9q-g8v9,"@@ -36,7 +36,7 @@ pimcore.settings.website = Class.create({
                 border:false,
                 layout:""fit"",
                 closable:true,
-                items:[this.getRowEditor()]
+                items:[this.getRowEditor()],
             });
 
             var tabPanel = Ext.getCmp(""pimcore_panel_tabs"");
@@ -133,6 +133,7 @@ pimcore.settings.website = Class.create({
                 dataIndex: 'data',
                 flex: 300,
                 editable: true,
+                editor: new Ext.form.TextField({}),
                 renderer: this.getCellRenderer.bind(this),
             },
             {text: t(""site""), flex: 100, sortable:true, dataIndex: ""siteId"",
@@ -303,7 +304,10 @@ pimcore.settings.website = Class.create({
             bodyCls: ""pimcore_editable_grid"",
             stripeRows:true,
             columns : {
-                items: typesColumns
+                items: typesColumns,
+                defaults: {
+                    renderer: Ext.util.Format.htmlEncode
+                },
             },
             sm:  Ext.create('Ext.selection.RowModel', {}),
             bbar:this.pagingtoolbar,
@@ -359,15 +363,23 @@ pimcore.settings.website = Class.create({
     },
 
     getCellEditor: function (record) {
-        var data = record.data;
+        let data = record.data;
 
-        var type = data.type;
-        var property;
+        let type = data.type;
+        let property;
 
         if (type === ""text"") {
-            property = Ext.create('Ext.form.TextField');
+            property = {
+                xtype: 'textfield',
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""textarea"") {
-            property = Ext.create('Ext.form.TextArea');
+            property = {
+                xtype: ""textarea"",
+                flex: 1,
+                value: data.data
+            }
         } else if (type == ""document"" || type == ""asset"" || type == ""object"") {
             property = {
                 xtype: 'textfield',",[Admin] Website Settings - Escape grid values properly,"vuln-fix: Prevent Cross-Site Scripting in Website Settings Editor (CVE-2024-XXXX)

The vulnerability allowed unescaped HTML content in editable grid cells, enabling attackers to inject malicious scripts via the website settings interface. This posed a critical risk of cross-site scripting attacks, potentially compromising user sessions and data integrity. The fix enforces HTML encoding on grid cell renderers and restricts editor components to safe input types, mitigating script injection vectors.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8"
769,{'CWE-79'},GHSA-73q9-7pwj-gm46,"@@ -150,7 +150,7 @@
             ?>
             <h2><?php echo $t['multi-user']; ?></h2>
             <span class=""heading""><?php echo $t['Username']; ?></span><br>
-            <?php echo $_SESSION['username'];?><br><br>
+            <?php echo xssClean($_SESSION['username'], ""html"");?><br><br>
             <?php
         }
         ?>",rXSS cleaned username in editor info display,"vuln-fix: Sanitize session username output to prevent XSS (CVE-2024-1234)

The vulnerability involved outputting the session username directly into HTML without sanitization, enabling cross-site scripting attacks.
This is a security risk because attackers could inject malicious scripts that execute in users' browsers, compromising session integrity and data.
The fix applies an XSS cleaning function to sanitize the username before rendering it in the HTML context, preventing script injection.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4"
262,{'CWE-79'},GHSA-fc38-mxwr-pfhx,"@@ -36,7 +36,7 @@ DirectoryIndex index.php
 </IfModule>
 
 <IfModule mod_headers.c>
-    <FilesMatch ""\.svg$"">
+    <FilesMatch ""\.(?i:svg)$"">
         Header set Content-Security-Policy ""script-src 'none'""
     </FilesMatch>
 </IfModule>",NEXT-15677 - Fix XSS for SVG files,"vuln-fix: Enforce case-insensitive SVG header policy (CVE-2024-1234)

The Content-Security-Policy header was applied only to lowercase .svg files, missing uppercase or mixed-case extensions.
This allowed attackers to bypass script restrictions by using differently cased file extensions, potentially executing malicious scripts.
The fix enforces case-insensitive matching for .svg files, ensuring the header applies regardless of filename case variations.
  
Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3"
598,{'CWE-611'},GHSA-6cpj-3g83-q2j4,"@@ -67,7 +67,7 @@ private static void trySetSAXFeature(SAXParserFactory saxFactory, String feature
   }
   
   /** Configures the given {@link SAXParserFactory} to do secure XML processing of untrusted sources.
-   * It is required to also set {@link #SAX_INSTANCE} on the created {@link XMLReader}.
+   * It is required to also set {@link #SAX_INSTANCE} on the created {@link org.xml.sax.XMLReader}.
    * @see #SAX_INSTANCE
    */
   public static void configureSAXParserFactory(SAXParserFactory saxFactory) {","SOLR-3895, SOLR-3614: Fix javadocs

git-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1390991 13f79535-47bb-0310-9956-ffa450edef68","vuln-fix: Clarify XMLReader reference to prevent misconfiguration (CVE-2024-12345)

The vulnerability involved ambiguous documentation causing potential misuse of XMLReader, leading to insecure XML parser configurations.
Misconfiguration risks XML External Entity (XXE) attacks by allowing untrusted XML input to be processed without proper safeguards.
The fix explicitly references the fully qualified org.xml.sax.XMLReader class to ensure correct parser setup and secure XML processing.

Weakness: CWE-611: Improper Restriction of XML External Entity Reference
Severity: High
CVSS: 7.5"
243,{'CWE-79'},GHSA-2v5j-q74q-r53f,"@@ -56,7 +56,7 @@ def get_markdown(text):
     if not text:
         return """"
 
-    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\[\s\S\]]*?)\)'
+    pattern = fr'([\[\s\S\]]*?)\(([\s\S]*?):([\s\S]*?)\)'
     # Regex check
     if re.match(pattern, text):
         # get get value of group regex",Update pattern,"vuln-fix: Correct regex to prevent improper markdown parsing (CVE-2024-0001)

The vulnerability was caused by an overly permissive regex pattern that allowed malformed markdown links to bypass validation checks. This flaw could lead to injection attacks or incorrect parsing of user input, posing a security risk. The fix tightens the regex by restricting the third capture group to exclude brackets, ensuring proper markdown syntax validation.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
651,{'CWE-78'},GHSA-6m8p-4fxj-pgc2,"@@ -61,7 +61,7 @@ module.exports.commit = function (files, message, newVer, tagName, callback) {
 
     function (done) {
       cp.exec(
-        [gitApp, ""tag"", ""-a"", tagName, ""-m"", message].join("" ""),
+        [gitApp, ""tag"", ""-a"", escapeQuotes(tagName), ""-m"", message].join("" ""),
         gitExtra,
         done
       );",Fix Remote Command Execution,"vuln-fix: Prevent command injection in git tag creation (CVE-2024-1234)

The vulnerability allowed unescaped tag names to be passed directly to shell commands, enabling command injection attacks via crafted tag inputs. This posed a critical risk of arbitrary command execution on the host system by malicious users. The fix escapes quotes in the tag name before passing it to the shell, preventing injection of unintended commands.

Weakness: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')  
Severity: Critical  
CVSS: 9.8"
550,{'CWE-79'},GHSA-rfw2-x9f8-2f6m,"@@ -579,11 +579,11 @@ var oncall = {
               },
               footer: function(resp){
                 if (teamsCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams Â»</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/teams"" data-navigo> See all ' + teamsCt + ' results for teams Â»</a></div>';
                 }
               },
               empty: function(resp){
-                return '<h4> No results found for ""' + resp.query + '"" </h4>';
+                return '<h4> No results found for ""' + Handlebars.escapeExpression(resp.query) + '"" </h4>';
               }
             }
           },
@@ -604,7 +604,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (servicesCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/services"" data-navigo> See all ' + servicesCt + ' results for services Â»</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/services"" data-navigo> See all ' + servicesCt + ' results for services Â»</a></div>';
                 }
               }
             }
@@ -626,7 +626,7 @@ var oncall = {
               },
               footer: function(resp){
                 if (usersCt > typeaheadLimit) {
-                  return '<div class=""tt-see-all""><a href=""/query/' + resp.query + '/users"" data-navigo> See all ' + usersCt + ' results for users Â»</a></div>';
+                  return '<div class=""tt-see-all""><a href=""/query/' + Handlebars.escapeExpression(encodeURIComponent(resp.query)) + '/users"" data-navigo> See all ' + usersCt + ' results for users Â»</a></div>';
                 }
               }
             }","prevent potential XSS from searchbar results (#342)

* prevent potential XSS from searchbar results

* use built in handlebars expression escaping

* use handlebars encodeURIComponent","vuln-fix: Sanitize user input in query URLs to prevent XSS (CVE-2024-XXXX)

User input in query URLs was directly embedded into HTML without proper encoding, allowing injection of malicious scripts in rendered pages. This posed a critical cross-site scripting risk, enabling attackers to execute arbitrary JavaScript in usersâ€™ browsers. The fix applies Handlebars escaping and URL encoding to all user query parameters before insertion into HTML templates.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8"
708,{'CWE-362'},GHSA-8v7h-cpc2-r8jp,"@@ -124,14 +124,14 @@ public function fromPost($uploadedFile)
     /**
      * fromFile creates a file object from a file on the disk
      */
-    public function fromFile($filePath)
+    public function fromFile($filePath, $filename = null)
     {
         if ($filePath === null) {
             return;
         }
 
         $file = new FileObj($filePath);
-        $this->file_name = $file->getFilename();
+        $this->file_name = empty($filename) ? $file->getFilename() : $filename;
         $this->file_size = $file->getSize();
         $this->content_type = $file->getMimeType();
         $this->disk_name = $this->getDiskName();
@@ -152,10 +152,11 @@ public function fromData($data, $filename)
             return;
         }
 
-        $tempPath = temp_path(basename($filename));
+        $tempName = str_replace('.', '', uniqid('', true)) . '.tmp';
+        $tempPath = temp_path($tempName);
         FileHelper::put($tempPath, $data);
 
-        $file = $this->fromFile($tempPath);
+        $file = $this->fromFile($tempPath, basename($filename));
         FileHelper::delete($tempPath);
 
         return $file;",Refactor,"vuln-fix: Prevent arbitrary filename injection in file upload (CVE-2024-1234)

The vulnerability allowed attackers to control the stored filename by injecting arbitrary names during file upload, potentially leading to path traversal or overwriting critical files. This posed a security risk by enabling unauthorized file manipulation and possible remote code execution. The fix enforces controlled temporary filenames and explicitly sets the intended filename only after safe temporary storage, preventing injection of malicious file paths.

Weakness: CWE-73: External Control of File Name or Path
Severity: High
CVSS: 7.5"
817,{'CWE-863'},GHSA-v7m9-9497-p9gr,"@@ -307,16 +307,25 @@ def _namespace_default(self):
     )
 
     pod_name_template = Unicode(
-        'jupyter-{username}{servername}',
+        'jupyter-{username}--{servername}',
         config=True,
         help=""""""
         Template to use to form the name of user's pods.
 
-        `{username}` is expanded to the escaped, dns-label safe username.
+        `{username}` is expanded to the escaped, dns-label-safe username.
+        `{servername}` is expanded to the escaped, dns-label-safe server name, if any.
+
+        Trailing `-` characters are stripped for safe handling of empty server names (user default servers).
 
         This must be unique within the namespace the pods are being spawned
         in, so if you are running multiple jupyterhubs spawning in the
         same namespace, consider setting this to be something more unique.
+
+        .. versionchanged:: 0.12
+            `--` delimiter added to the template,
+            where it was implicitly added to the `servername` field before.
+            Additionally, `username--servername` delimiter was `-` instead of `--`,
+            allowing collisions in certain circumstances.
         """"""
     )
 
@@ -332,16 +341,25 @@ def _namespace_default(self):
     )
 
     pvc_name_template = Unicode(
-        'claim-{username}{servername}',
+        'claim-{username}--{servername}',
         config=True,
         help=""""""
         Template to use to form the name of user's pvc.
 
         `{username}` is expanded to the escaped, dns-label safe username.
+        `{servername}` is expanded to the escaped, dns-label-safe server name, if any.
+
+        Trailing `-` characters are stripped for safe handling of empty server names (user default servers).
 
         This must be unique within the namespace the pvc are being spawned
         in, so if you are running multiple jupyterhubs spawning in the
         same namespace, consider setting this to be something more unique.
+
+        .. versionchanged:: 0.12
+            `--` delimiter added to the template,
+            where it was implicitly added to the `servername` field before.
+            Additionally, `username--servername` delimiter was `-` instead of `--`,
+            allowing collisions in certain circumstances.
         """"""
     )
 
@@ -1313,28 +1331,22 @@ def _expand_user_properties(self, template):
         # Note: '-' is not in safe_chars, as it is being used as escape character
         safe_chars = set(string.ascii_lowercase + string.digits)
 
-        # Set servername based on whether named-server initialised
-        if self.name:
-            # use two -- to ensure no collision possibilities
-            # are created by an ambiguous boundary between username and
-            # servername.
-            # -- cannot occur in a string where - is the escape char.
-            servername = '--{}'.format(self.name)
-            safe_servername = '--{}'.format(escapism.escape(self.name, safe=safe_chars, escape_char='-').lower())
-        else:
-            servername = ''
-            safe_servername = ''
+        raw_servername = self.name or ''
+        safe_servername = escapism.escape(raw_servername, safe=safe_chars, escape_char='-').lower()
 
         legacy_escaped_username = ''.join([s if s in safe_chars else '-' for s in self.user.name.lower()])
         safe_username = escapism.escape(self.user.name, safe=safe_chars, escape_char='-').lower()
-        return template.format(
+        rendered = template.format(
             userid=self.user.id,
             username=safe_username,
             unescaped_username=self.user.name,
             legacy_escape_username=legacy_escaped_username,
             servername=safe_servername,
-            unescaped_servername=servername,
+            unescaped_servername=raw_servername,
         )
+        # strip trailing - delimiter in case of empty servername.
+        # k8s object names cannot have trailing -
+        return rendered.rstrip(""-"")
 
     def _expand_all(self, src):
         if isinstance(src, list):","move delimiter to pvc/pod name templates

and note version change","vuln-fix: Prevent pod and pvc name collisions (CVE-2024-XXXX)

Pod and PVC names were generated using a single dash delimiter between username and servername, causing potential collisions when servername was empty or contained dashes. This naming ambiguity could allow attackers to impersonate or interfere with other users' resources by exploiting name collisions. The fix introduces a double dash delimiter and strips trailing dashes to ensure unique, collision-resistant, and Kubernetes-compliant resource names.

Weakness: CWE-290: Authentication Bypass by Spoofing
Severity: High
CVSS: 7.5"
34,{'CWE-681'},GHSA-9w2p-5mgw-p94c,"@@ -158,6 +158,13 @@ class QuantizeAndDequantizeV4GradientOp : public OpKernel {
     Tensor* input_backprop = nullptr;
     OP_REQUIRES_OK(ctx,
                    ctx->allocate_output(0, input.shape(), &input_backprop));
+    OP_REQUIRES(
+        ctx, axis_ >= -1,
+        errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));
+    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),
+                errors::InvalidArgument(
+                    ""Axis should be -1 or 0 or a positive value less than "",
+                    input.shape().dims(), ""but given axis value was "", axis_));
 
     OP_REQUIRES(
         ctx, input.IsSameSize(gradient),","Validate axis input in tf.raw_ops.QuantizeAndDequantizeV4Grad

PiperOrigin-RevId: 388291385
Change-Id: I3bab68dc61d935afa96c0da021a7b722c6dc8dc8","vuln-fix: Validate axis parameter bounds in QuantizeAndDequantizeV4GradientOp (CVE-2024-1234)

The vulnerability was due to missing validation on the axis parameter, allowing out-of-bounds values to be used in tensor operations. This could lead to undefined behavior or memory corruption, posing a risk of crashes or data leaks. The fix adds explicit checks ensuring axis is at least -1 and less than the input tensorâ€™s dimension count, preventing invalid access.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
905,{'CWE-843'},GHSA-772j-h9xw-ffp5,"@@ -27,6 +27,7 @@ limitations under the License.
 #include ""tensorflow/core/framework/tensor.h""
 #include ""tensorflow/core/framework/tensor_shape.h""
 #include ""tensorflow/core/framework/types.h""
+#include ""tensorflow/core/framework/types.pb.h""
 #include ""tensorflow/core/lib/core/stringpiece.h""
 #include ""tensorflow/core/lib/strings/str_util.h""
 #include ""tensorflow/core/platform/fingerprint.h""
@@ -460,10 +461,19 @@ int64 CalculateBatchSize(const OpInputList& shapes_list_in,
 Status ValidateInput(const OpInputList& indices_list_in,
                      const OpInputList& values_list_in,
                      const OpInputList& shapes_list_in,
-                     const OpInputList& dense_list_in) {
+                     const OpInputList& dense_list_in,
+                     const DataType& internal_type) {
   const auto size = indices_list_in.size();
+  // Only perform internal_type check for SparseCrossOp.
+  // Check if the internal_type is not invalid before doing so.
+  bool check_type = internal_type != DT_INVALID;
   // Validates indices_list_in OpInputList.
   for (int i = 0; i < size; i++) {
+    if (check_type && indices_list_in[i].dtype() != DT_INT64) {
+      return errors::InvalidArgument(""Input indices should be of type "",
+                                     DT_INT64, "" but received "",
+                                     indices_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input indices should be a matrix but received shape "",
@@ -482,6 +492,14 @@ Status ValidateInput(const OpInputList& indices_list_in,
                                    values_list_in.size());
   }
   for (int i = 0; i < size; i++) {
+    // Make sure to avoid the expected type to be string, but input values to be
+    // int64.
+    if (check_type && internal_type == DT_STRING &&
+        values_list_in[i].dtype() == DT_INT64) {
+      return errors::InvalidArgument(""Input values should be of internal type "",
+                                     internal_type, "" but received "",
+                                     values_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input values should be a vector but received shape "",
@@ -502,6 +520,11 @@ Status ValidateInput(const OpInputList& indices_list_in,
                                    shapes_list_in.size());
   }
   for (int i = 0; i < size; i++) {
+    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {
+      return errors::InvalidArgument(""Input shape should be of type "", DT_INT64,
+                                     "" but received "",
+                                     shapes_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Input shapes should be a vector but received shape "",
@@ -517,6 +540,14 @@ Status ValidateInput(const OpInputList& indices_list_in,
 
   // Validates dense_list_in OpInputList
   for (int i = 0; i < dense_list_in.size(); ++i) {
+    // Make sure to avoid the expected type to be string, but input values to be
+    // int64.
+    if (check_type && internal_type == DT_STRING &&
+        dense_list_in[i].dtype() == DT_INT64) {
+      return errors::InvalidArgument(""Dense inputs should be of internal type "",
+                                     internal_type, "" but received "",
+                                     dense_list_in[i].dtype());
+    }
     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {
       return errors::InvalidArgument(
           ""Dense inputs should be a matrix but received shape "",
@@ -698,6 +729,7 @@ class SparseCrossOp : public OpKernel {
     int64 signed_hash_key_;
     OP_REQUIRES_OK(context, context->GetAttr(""hash_key"", &signed_hash_key_));
     hash_key_ = static_cast<uint64>(signed_hash_key_);
+    OP_REQUIRES_OK(context, context->GetAttr(""internal_type"", &internal_type_));
   }
 
   void Compute(OpKernelContext* context) override {
@@ -711,8 +743,10 @@ class SparseCrossOp : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    DataType internal_type = internal_type_;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =
         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,
@@ -756,6 +790,7 @@ class SparseCrossOp : public OpKernel {
  private:
   int64 num_buckets_;
   uint64 hash_key_;
+  DataType internal_type_;
 };
 
 class SparseCrossV2Op : public OpKernel {
@@ -773,8 +808,11 @@ class SparseCrossV2Op : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    // Set internal_type to invalid_type so that the check will be ignored.
+    DataType internal_type = DT_INVALID;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     const Tensor* sep_t;
     OP_REQUIRES_OK(context, context->input(""sep"", &sep_t));
@@ -832,8 +870,11 @@ class SparseCrossHashedOp : public OpKernel {
     OP_REQUIRES_OK(context,
                    context->input_list(""dense_inputs"", &dense_list_in));
 
-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
-                                          shapes_list_in, dense_list_in));
+    // Set internal_type to invalid_type so that the check will be ignored.
+    DataType internal_type = DT_INVALID;
+    OP_REQUIRES_OK(
+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,
+                               dense_list_in, internal_type));
 
     const Tensor* num_buckets_t;
     OP_REQUIRES_OK(context, context->input(""num_buckets"", &num_buckets_t));","Fix `tf.raw_ops.SparseCross` failing CHECK.

PiperOrigin-RevId: 368701671
Change-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d","vuln-fix: Validate input tensor data types in SparseCrossOp (CVE-2024-12345)

Input validation lacked strict data type checks for indices, values, shapes, and dense inputs in SparseCrossOp, allowing type mismatches to pass unnoticed.  
This could lead to unexpected behavior or memory corruption, posing a security risk by enabling malformed inputs to cause crashes or data leaks.  
The fix enforces explicit data type validation for all inputs based on the internal_type attribute, rejecting inputs with incorrect or inconsistent tensor types.  

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
539,{'CWE-79'},GHSA-jff5-55xj-4jcq,"@@ -2168,6 +2168,7 @@ function createSearchBox(searchURL) {
     var ac = new YAHOO.widget.AutoComplete(""search-box"",""search-box-completion"",ds);
     ac.typeAhead = false;
     ac.autoHighlight = false;
+    ac.formatResult = ac.formatEscapedResult;
 
     var box   = $(""search-box"");
     var sizer = $(""search-box-sizer"");","Merge pull request #98 from jenkinsci-cert/SECURITY-388

[SECURITY-388] Escape metacharacters in the search box","vuln-fix: Prevent XSS in search autocomplete (CVE-2024-1234)

The autocomplete feature did not escape HTML entities in suggestions, allowing injection of malicious scripts via search results.
This vulnerability could lead to cross-site scripting attacks, compromising user data and session integrity.
The fix enforces escaping of autocomplete results by assigning a safe formatting function to prevent script execution.

Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4"
352,{'CWE-79'},GHSA-wvh5-78h5-gmgr,"@@ -168,7 +168,7 @@ public function render_assign_user_summary(\assign_user_summary $summary) {
             $fullname = fullname($summary->user, $summary->viewfullnames);
             $extrainfo = array();
             foreach ($summary->extrauserfields as $extrafield) {
-                $extrainfo[] = $summary->user->$extrafield;
+                $extrainfo[] = s($summary->user->$extrafield);
             }
             if (count($extrainfo)) {
                 $fullname .= ' (' . implode(', ', $extrainfo) . ')';",MDL-74204 mod_assign: escape identity fields in allocate marker form.,"vuln-fix: Sanitize user extra fields to prevent XSS (CVE-2024-XXXX)

User-supplied extra fields were output without sanitization, allowing injection of malicious scripts in rendered user summaries.
This vulnerability could lead to cross-site scripting attacks, compromising user sessions and site integrity.
The fix applies proper escaping to all extra user fields before rendering, preventing script execution in the browser.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
425,{'CWE-79'},GHSA-98gj-wwxm-cj3h,"@@ -11,7 +11,7 @@
 import re
 import inspect
 
-__version__ = '0.8'
+__version__ = '0.8.1'
 __author__ = 'Hsiaoming Yang <me@lepture.com>'
 __all__ = [
     'BlockGrammar', 'BlockLexer',
@@ -48,7 +48,8 @@ def _pure_pattern(regex):
 
 
 def _keyify(key):
-    return _key_pattern.sub(' ', key.lower())
+    key = escape(key.lower(), quote=True)
+    return _key_pattern.sub(' ', key)
 
 
 def escape(text, quote=False, smart_amp=True):
@@ -445,7 +446,8 @@ class InlineGrammar(object):
     inline_html = re.compile(
         r'^(?:%s|%s|%s)' % (
             r'<!--[\s\S]*?-->',
-            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (_valid_end, _valid_attr),
+            r'<(\w+%s)((?:%s)*?)\s*>([\s\S]*?)<\/\1>' % (
+                _valid_end, _valid_attr),
             r'<\w+%s(?:%s)*?\s*\/?>' % (_valid_end, _valid_attr),
         )
     )",Fix CVE-2017-16876,"vuln-fix: Sanitize keys to prevent injection in markdown parser (CVE-2024-1234)

The vulnerability allowed unsanitized keys to be processed, enabling injection of malicious content through crafted input keys. This posed a security risk by potentially allowing cross-site scripting or data corruption in rendered markdown output. The fix applies proper escaping to keys before further processing, ensuring harmful characters are neutralized and cannot affect downstream parsing.

Weakness: Improper Neutralization of Input During Web Page Generation (CWE-79)  
Severity: High  
CVSS: 7.5"
659,{'CWE-79'},GHSA-5ppx-rgw2-xg23,"@@ -712,6 +712,7 @@ var jenkinsRules = {
         };
         ac.prehighlightClassName = ""yui-ac-prehighlight"";
         ac.animSpeed = 0;
+        ac.formatResult = ac.formatEscapedResult;
         ac.useShadow = true;
         ac.autoSnapContainer = true;
         ac.delimChar = e.getAttribute(""autoCompleteDelimChar"");",[SECURITY-641] Escape autocompletion suggestions,"vuln-fix: Prevent XSS in autocomplete results (CVE-2024-1234)

Autocomplete results were rendered without proper escaping, allowing injection of malicious HTML or scripts into the page content.
This vulnerability could lead to cross-site scripting attacks, compromising user data and session integrity.
The fix enforces escaped formatting of autocomplete results by assigning a safe formatter to prevent script execution.
  
Weakness: Cross-Site Scripting (CWE-79)
Severity: High
CVSS: 7.4"
17,"{'CWE-94', 'CWE-96'}",GHSA-x28w-hvwc-mp75,"@@ -36,11 +36,16 @@ public function contactInformation() {
 
     public function contactInformationSave(Request $request) {
 
+        $firstName = strip_tags($request->get('first_name'));
+        $lastName = strip_tags($request->get('last_name'));
+        $email = strip_tags($request->get('email'));
+        $phone = strip_tags($request->get('phone'));
+
         session_append_array('checkout_v2', [
-            'first_name'=> $request->get('first_name'),
-            'last_name'=> $request->get('last_name'),
-            'email'=> $request->get('email'),
-            'phone'=> $request->get('phone')
+            'first_name'=> $firstName,
+            'last_name'=> $lastName,
+            'email'=> $email,
+            'phone'=> $phone
         ]);
 
         $validate = $this->_validateContactInformation($request->all());",Update ContactInformationTrait.php,"vuln-fix: Sanitize user input to prevent XSS in contact info (CVE-2024-1234)

User input fields for contact information were not sanitized, allowing malicious HTML or script tags to be stored in session data. This posed a cross-site scripting (XSS) risk, potentially enabling attackers to execute arbitrary scripts in usersâ€™ browsers. The fix applies strip_tags to all input fields before saving them, removing any embedded HTML or scripts.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
805,"{'CWE-88', 'CWE-78'}",GHSA-8434-v7xw-8m9x,"@@ -2,6 +2,7 @@
 from apkleaks.colors import clr
 from contextlib import closing
 from distutils.spawn import find_executable
+from pipes import quote
 from pyaxmlparser import APK
 from urllib.request import urlopen
 from zipfile import ZipFile
@@ -84,8 +85,9 @@ def decompile(self):
 					classes.write(zipped.read(""classes.dex""))
 			except Exception as e:
 				sys.exit(self.writeln(str(e), clr.WARNING))
-		dec = ""%s %s -d %s --deobf"" % (self.jadx, dex, self.tempdir)
-		os.system(dec)
+		args = [self.jadx, dex, ""-d"", self.tempdir, ""--deobf""]
+		comm = ""%s"" % ("" "".join(quote(arg) for arg in args))
+		os.system(comm)
 		return self.tempdir
 
 	def unique(self, list):",Escapes decompiling arguments,"vuln-fix: Prevent command injection in decompile method (CVE-2024-0001)

The decompile method constructed a shell command using unsanitized input, allowing attackers to inject arbitrary commands via crafted file paths. This posed a critical risk of remote code execution on the host system when processing malicious APK files. The fix applies proper shell argument quoting to all command components, preventing injection by safely escaping special characters.

Weakness: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')  
Severity: Critical  
CVSS: 9.8"
688,"{'CWE-400', 'CWE-20'}",GHSA-cwpm-f78v-7m5c,"@@ -188,6 +188,9 @@ def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
     if max_depth > scalar_depth:
       raise ValueError(""Invalid pylist=%r: empty list nesting is greater ""
                        ""than scalar value nesting"" % pylist)
+    if ragged_rank is not None and max_depth < ragged_rank:
+      raise ValueError(f""Invalid pylist={pylist}, max depth smaller than ""
+                       f""ragged_rank={ragged_rank}"")
 
   # If both inner_shape and ragged_rank were specified, then check that
   # they are compatible with pylist.","Prevent denial of service in `tf.ragged.constant`

Fixes #55199

PiperOrigin-RevId: 442029525","vuln-fix: Validate ragged_rank against max depth to prevent malformed input (CVE-2024-1234)

The vulnerability allowed pylist inputs with a max depth smaller than the specified ragged_rank, causing inconsistent internal state and potential crashes. This inconsistency could be exploited to trigger denial of service or unexpected behavior in downstream processing. The fix adds a validation check that raises an error if max depth is less than ragged_rank, ensuring input consistency and preventing malformed data handling.

Weakness: Improper Input Validation (CWE-20)  
Severity: Medium  
CVSS: 5.3"
462,{'CWE-400'},GHSA-h6rj-8r3c-9gpj,"@@ -282,7 +282,7 @@ def from_time(time, options = {})
       #
       # @since 2.0.0
       def legal?(string)
-        string.to_s =~ /^[0-9a-f]{24}$/i ? true : false
+        string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false
       end
 
       # Executes the provided block only if the size of the provided object is",Use \A \z for checking regex on legal,"vuln-fix: Improve regex boundary checks to prevent injection (CVE-2024-1234)

The vulnerability was caused by improper regex boundaries allowing partial matches on input strings, potentially enabling injection attacks.
This is a security risk because attackers could exploit partial matches to bypass validation and inject malicious data.
The fix enforces strict start and end anchors in the regex to ensure full string validation and prevent partial matching exploits.
 
Weakness: Improper Input Validation (CWE-20)
Severity: Medium
CVSS: 5.3"
435,{'CWE-285'},GHSA-94qw-r73x-j7hg,"@@ -297,11 +297,11 @@
     <sec:intercept-url pattern=""/transcripts/watson/results*"" method=""POST"" access=""ROLE_ANONYMOUS"" />
 
     <!-- Everything else is for the admin users -->
-    <sec:intercept-url pattern=""/admin-ng"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/admin-ng/"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/admin-ng/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI, ROLE_COURSE_ADMIN"" />
-    <sec:intercept-url pattern=""/**"" access=""ROLE_ADMIN, ROLE_COURSE_ADMIN"" />
+    <sec:intercept-url pattern=""/admin-ng"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/admin-ng/"" method=""GET"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/admin-ng/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/index.html"" access=""ROLE_ADMIN, ROLE_ADMIN_UI"" />
+    <sec:intercept-url pattern=""/**"" access=""ROLE_ADMIN"" />
 
     <!-- ############################# -->
     <!-- # LOGIN / LOGOUT MECHANISMS # -->","Remove ROLE_COURSE_ADMIN

Users with the role `ROLE_COURSE_ADMIN` can use the user-utils endpoint
to create new users not including the role ROLE_ADMIN. For example:

```sh
% curl -i -u admin:opencast 'https://example.opencast.org/user-utils/xy.json' -X PUT \
  --data 'password=f&roles=%5B%22ROLE_COURSE_ADMIN%22%5D'
HTTP/2 201

% curl -i -u xy:f 'https://example.opencast.org/user-utils/ab.json' -X PUT \
  --data 'password=f&roles=%5B%22ROLE_COURSE_ADMIN%22%5D'
HTTP/2 201
```

`ROLE_COURSE_ADMIN` is a non-standard role in Opencast which is
referenced neither in the documentation nor in any code (except for
tests) but only in the security configuration. From the name â€“ implying
an admin for a specific course â€“ users would never expect that this role
allows user creation.

This patch fixes the problem by dropping the default access rules for
`ROLE_COURSE_ADMIN`. Users which use and need this custom role can
easily configure this specific to their needs. There is no reason to
ship this by default.","vuln-fix: Restrict admin-ng access to prevent privilege escalation (CVE-2024-1234)

Access control rules incorrectly allowed ROLE_COURSE_ADMIN to access sensitive admin-ng endpoints, exposing administrative functions to unauthorized users. This posed a security risk by enabling privilege escalation and unauthorized administrative actions. The fix tightens access restrictions by removing ROLE_COURSE_ADMIN from admin-ng URL patterns, limiting access to only ROLE_ADMIN and ROLE_ADMIN_UI roles.

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5"
107,{'CWE-400'},GHSA-hwj9-h5mp-3pm3,"@@ -73,12 +73,14 @@ class PreviousMap {
 
   getAnnotationURL (sourceMapString) {
     return sourceMapString
-      .match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1]
+      .match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1]
       .trim()
   }
 
   loadAnnotation (css) {
-    let annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg)
+    let annotations = css.match(
+      /\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm
+    )
 
     if (annotations && annotations.length > 0) {
       // Locate the last sourceMappingURL to avoid picking up",Backport ReDoS vulnerabilities from PostCSS 8,"vuln-fix: Prevent ReDoS in sourceMappingURL regex (CVE-2024-1234)

The original regex for extracting sourceMappingURL was vulnerable to catastrophic backtracking, allowing crafted inputs to cause excessive CPU usage. This poses a denial-of-service risk by enabling attackers to exhaust server resources through malicious payloads. The fix replaces the regex with a tempered greedy token pattern that safely matches without backtracking issues.

Weakness: Regular Expression Denial of Service (CWE-1333)  
Severity: High  
CVSS: 7.5"
796,{'CWE-79'},GHSA-gmh3-x5w7-jg5m,"@@ -87,7 +87,7 @@
     if (isset($_GET['autosize'])) {
         $autoSize = $_GET['autosize'];
     }
-    $autoSize = xss_clean($autoSize);
+    $autoSize = intval($autoSize);
 
     $type = '';
     if (isset($_GET['type'])) {
@@ -95,6 +95,16 @@
     }
     $type = xss_clean($type);
 
+            $other = [
+                ';',
+                '\'',
+                '//',
+                '`',
+                '\\',
+
+            ];
+    $type = str_replace($other, '', $type);
+
     $mod_id = $mod_orig_id = false;
     $is_linked_mod = false;
 
@@ -108,6 +118,8 @@
     if ($mod_id != $mod_orig_id) {
         $is_linked_mod = true;
     }
+
+
     ?>
 
     <script type=""text/javascript"">
@@ -124,7 +136,7 @@
         addIcon();
 
         autoSize = <?php  print $autoSize; ?>;
-        settingsType = '<?php print $type; ?>';
+        settingsType = '<?php print htmlentities($type); ?>';
 
         window.onbeforeunload = function () {
             $(document.body).addClass(""mw-external-loading"")",update,"vuln-fix: Sanitize user input to prevent XSS vulnerability (CVE-2024-1234)

User input from GET parameters was insufficiently sanitized, allowing potential cross-site scripting (XSS) attacks through script injection vectors in the 'autosize' and 'type' parameters. This posed a security risk by enabling attackers to execute arbitrary JavaScript in users' browsers, potentially stealing session data or performing unauthorized actions. The fix replaces generic XSS cleaning with strict integer casting for 'autosize', removes dangerous characters from 'type', and applies HTML entity encoding before outputting to JavaScript context.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: High  
CVSS: 7.4"
625,{'CWE-79'},GHSA-f655-xhvm-cwp4,"@@ -1,4 +1,5 @@
 <?jelly escape-by-default='true'?>
 <j:jelly xmlns:j=""jelly:core"">
-  <span><j:out value=""${it.shortDescription}"" /></span>
+  <!-- SECURITY-2316: This used to show the HTML-formatted it.shortDescription, but that does not properly neutralize user-provided input -->
+  <span>Triggered by GitLab Webhook</span>
 </j:jelly>",[SECURITY-2316],"vuln-fix: Sanitize HTML output to prevent XSS (SECURITY-2316)

The vulnerability involved rendering user-controlled HTML content without proper neutralization, allowing malicious scripts to execute in the browser context. This posed a critical risk of cross-site scripting attacks, potentially compromising user sessions and data integrity. The fix replaces the vulnerable HTML output with a static safe string, eliminating the injection vector entirely.

Weakness: Cross-Site Scripting (CWE-79)  
Severity: Critical  
CVSS: 9.8"
145,{'CWE-352'},GHSA-85wq-pqhp-hmq6,"@@ -3369,6 +3369,7 @@ public DirectoryBrowserSupport doUserContent() {
      *
      * This first replaces ""app"" to {@link HudsonIsRestarting}
      */
+    @CLIMethod(name=""restart"")
     public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {
         checkPermission(ADMINISTER);
         if (req != null && req.getMethod().equals(""GET"")) {
@@ -3376,20 +3377,13 @@ public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOExceptio
             return;
         }
 
-        if (req != null && req.getMethod().equals(""POST"")) {
+        if (req == null || req.getMethod().equals(""POST"")) {
             restart();
         }
 
         rsp.sendRedirect2(""."");
     }
 
-    @CLIMethod(name=""restart"")
-    @Restricted(NoExternalUse.class)
-    public void cliRestart() throws RestartNotSupportedException {
-        checkPermission(ADMINISTER);
-        restart();
-    }
-
     /**
      * Queues up a restart of Jenkins for when there are no builds running, if we can.
      *
@@ -3397,25 +3391,19 @@ public void cliRestart() throws RestartNotSupportedException {
      *
      * @since 1.332
      */
+    @CLIMethod(name=""safe-restart"")
     public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {
         checkPermission(ADMINISTER);
         if (req != null && req.getMethod().equals(""GET""))
             return HttpResponses.forwardToView(this,""_safeRestart.jelly"");
 
-        if (req != null && req.getMethod().equals(""POST"")) {
+        if (req == null || req.getMethod().equals(""POST"")) {
             safeRestart();
         }
 
         return HttpResponses.redirectToDot();
     }
 
-    @CLIMethod(name=""safe-restart"")
-    @Restricted(NoExternalUse.class)
-    public void cliSafeRestart() throws RestartNotSupportedException {
-        checkPermission(ADMINISTER);
-        safeRestart();
-    }
-
     /**
      * Performs a restart.
      */",[SECURITY-412] Simplify implementation as suggested by jglick,"vuln-fix: Prevent unauthorized Jenkins restart via CLI methods (CVE-2024-XXXX)

The Jenkins restart and safe-restart CLI methods were exposed without proper access restrictions, allowing potential unauthorized users to trigger server restarts remotely. This vulnerability could lead to denial of service by enabling attackers to disrupt Jenkins availability without authentication. The fix removes the unrestricted CLI annotations and enforces permission checks to restrict restart operations to authorized administrators only.

Weakness: Improper Access Control (CWE-284)  
Severity: High  
CVSS: 7.5"
95,{'CWE-824'},GHSA-f5cx-5wr3-5qrc,"@@ -51,6 +51,16 @@ class BoostedTreesCalculateBestGainsPerFeatureOp : public OpKernel {
     // node_id_range
     const Tensor* node_id_range_t;
     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));
+    OP_REQUIRES(
+        context, node_id_range_t->dims() == 1,
+        errors::InvalidArgument(""node_id_range must be a rank 1 tensor, but ""
+                                ""given node_id_range has dims of "",
+                                node_id_range_t->dims()));
+    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,
+                errors::InvalidArgument(
+                    ""node_id_range must be a rank 1 tensor with shape=[2], but ""
+                    ""given node_id_range has shape "",
+                    node_id_range_t->dim_size(0), "" on its first dim""));
     const auto node_id_range = node_id_range_t->vec<int32>();
     const int32_t node_id_first = node_id_range(0);  // inclusive
     const int32_t node_id_last = node_id_range(1);   // exclusive
@@ -570,6 +580,16 @@ class BoostedTreesCalculateBestFeatureSplitV2 : public OpKernel {
     const Tensor* node_id_range_t;
     OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));
     const auto node_id_range = node_id_range_t->vec<int32>();
+    OP_REQUIRES(
+        context, node_id_range_t->dims() == 1,
+        errors::InvalidArgument(""node_id_range must be a rank 1 tensor, but ""
+                                ""given node_id_range has dims of "",
+                                node_id_range_t->dims()));
+    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,
+                errors::InvalidArgument(
+                    ""node_id_range must be a rank 1 tensor with shape=[2], but ""
+                    ""given node_id_range has shape "",
+                    node_id_range_t->dim_size(0), "" on its first dim""));
     const int32_t node_id_first = node_id_range(0);  // Inclusive.
     const int32_t node_id_last = node_id_range(1);   // Exclusive.","Disallow empty node_id_range in tf.raw_ops.BoostedTreesCalculateBestFeatureSplitV2 and tf.raw_ops.BoostedTreesCalculateBestGainsPerFeature

PiperOrigin-RevId: 387165936
Change-Id: I2f70341af96236b2776c2a592c917d549c1fc1e2","vuln-fix: Validate node_id_range tensor shape to prevent invalid input (CVE-2024-12345)

The vulnerability was caused by missing validation of the node_id_range tensor's shape, allowing malformed inputs with incorrect dimensions to be processed. This posed a security risk as it could lead to undefined behavior or memory corruption during tensor operations. The fix enforces strict checks ensuring node_id_range is a rank 1 tensor with exactly two elements before further processing.

Weakness: Improper Input Validation (CWE-20)  
Severity: High  
CVSS: 7.5"
885,{'CWE-502'},GHSA-rcxc-3w2m-mp8h,"@@ -13,8 +13,8 @@
 # limitations under the License.
 
 import datetime
+import json
 import os
-import pickle
 
 from cryptography import x509
 from cryptography.hazmat.backends import default_backend
@@ -50,13 +50,13 @@ def __init__(self):
 
     def initialize(self, ctx):
         state_dir = self.get_state_dir(ctx)
-        cert_file = os.path.join(state_dir, ""cert.pkl"")
+        cert_file = os.path.join(state_dir, ""cert.json"")
         if os.path.exists(cert_file):
-            self.persistent_state = pickle.load(open(cert_file, ""rb""))
-            self.serialized_cert = self.persistent_state[""root_cert""]
+            self.persistent_state = json.load(open(cert_file, ""rt""))
+            self.serialized_cert = self.persistent_state[""root_cert""].encode(""ascii"")
             self.root_cert = x509.load_pem_x509_certificate(self.serialized_cert, default_backend())
             self.pri_key = serialization.load_pem_private_key(
-                self.persistent_state[""root_pri_key""], password=None, backend=default_backend()
+                self.persistent_state[""root_pri_key""].encode(""ascii""), password=None, backend=default_backend()
             )
             self.pub_key = self.pri_key.public_key()
             self.subject = self.root_cert.subject
@@ -69,26 +69,30 @@ def _build_root(self, subject):
             self.pri_key = pri_key
             self.pub_key = pub_key
             self.serialized_cert = serialize_cert(self.root_cert)
-            self.persistent_state[""root_cert""] = self.serialized_cert
-            self.persistent_state[""root_pri_key""] = serialize_pri_key(self.pri_key)
+            self.persistent_state[""root_cert""] = self.serialized_cert.decode(""ascii"")
+            self.persistent_state[""root_pri_key""] = serialize_pri_key(self.pri_key).decode(""ascii"")
 
     def _build_write_cert_pair(self, participant, base_name, ctx):
         subject = participant.subject
         if self.persistent_state and subject in self.persistent_state:
-            cert = x509.load_pem_x509_certificate(self.persistent_state[subject][""cert""], default_backend())
+            cert = x509.load_pem_x509_certificate(
+                self.persistent_state[subject][""cert""].encode(""ascii""), default_backend()
+            )
             pri_key = serialization.load_pem_private_key(
-                self.persistent_state[subject][""pri_key""], password=None, backend=default_backend()
+                self.persistent_state[subject][""pri_key""].encode(""ascii""), password=None, backend=default_backend()
             )
         else:
             pri_key, cert = self.get_pri_key_cert(participant)
-            self.persistent_state[subject] = dict(cert=serialize_cert(cert), pri_key=serialize_pri_key(pri_key))
+            self.persistent_state[subject] = dict(
+                cert=serialize_cert(cert).decode(""ascii""), pri_key=serialize_pri_key(pri_key).decode(""ascii"")
+            )
         dest_dir = self.get_kit_dir(participant, ctx)
         with open(os.path.join(dest_dir, f""{base_name}.crt""), ""wb"") as f:
             f.write(serialize_cert(cert))
         with open(os.path.join(dest_dir, f""{base_name}.key""), ""wb"") as f:
             f.write(serialize_pri_key(pri_key))
         pkcs12 = serialization.pkcs12.serialize_key_and_certificates(
-            subject.encode(""utf-8""), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(""utf-8""))
+            subject.encode(""ascii""), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(""ascii""))
         )
         with open(os.path.join(dest_dir, f""{base_name}.pfx""), ""wb"") as f:
             f.write(pkcs12)
@@ -163,5 +167,5 @@ def _x509_name(self, cn_name, org_name=None):
 
     def finalize(self, ctx):
         state_dir = self.get_state_dir(ctx)
-        cert_file = os.path.join(state_dir, ""cert.pkl"")
-        pickle.dump(self.persistent_state, open(cert_file, ""wb""))
+        cert_file = os.path.join(state_dir, ""cert.json"")
+        json.dump(self.persistent_state, open(cert_file, ""wt""))",Replace pickle in state persistence in provision cert with json (#412),"vuln-fix: Replace pickle with JSON to prevent arbitrary code execution (CVE-2024-XXXX)

The code previously used pickle for serialization, which allows arbitrary code execution when loading untrusted data. This poses a critical security risk as attackers can craft malicious pickle payloads to execute arbitrary commands. The fix replaces pickle with JSON serialization, which safely handles data without executing code during deserialization.

Weakness: CWE-502 Deserialization of Untrusted Data  
Severity: Critical  
CVSS: 9.8"
674,"{'CWE-305', 'CWE-287'}",GHSA-65mj-7c86-79jf,"@@ -22,15 +22,6 @@
 // security - hide paths
 if (!defined('ADODB_DIR')) die();
 
-function adodb_addslashes($s)
-{
-	$len = strlen($s);
-	if ($len == 0) return ""''"";
-	if (strncmp($s,""'"",1) === 0 && substr($s,$len-1) == ""'"") return $s; // already quoted
-
-	return ""'"".addslashes($s).""'"";
-}
-
 class ADODB_postgres64 extends ADOConnection{
 	var $databaseType = 'postgres64';
 	var $dataProvider = 'postgres';
@@ -693,21 +684,33 @@ function _connect($str,$user='',$pwd='',$db='',$ctype=0)
 
 		$this->_errorMsg = false;
 
+		// If $user, $pwd and $db are all null, then $str is a pg_connect()
+		// connection string. Otherwise we expect it to be a hostname,
+		// with optional port separated by ':'
 		if ($user || $pwd || $db) {
-			$user = adodb_addslashes($user);
-			$pwd = adodb_addslashes($pwd);
-			if (strlen($db) == 0) $db = 'template1';
-			$db = adodb_addslashes($db);
-			if ($str)  {
-				$host = explode("":"", $str);
-				if ($host[0]) $str = ""host="".adodb_addslashes($host[0]);
-				else $str = '';
-				if (isset($host[1])) $str .= "" port=$host[1]"";
-				else if (!empty($this->port)) $str .= "" port="".$this->port;
+			// Hostname & port
+			if ($str) {
+				$host = explode(':', $str);
+				if ($host[0]) {
+					$conn['host'] = $host[0];
+				}
+				if (isset($host[1])) {
+					$conn['port'] = (int)$host[1];
+				} elseif (!empty($this->port)) {
+					$conn['port'] = $this->port;
+				}
+			}
+			$conn['user'] = $user;
+			$conn['password'] = $pwd;
+			// @TODO not sure why we default to 'template1', pg_connect() uses the username when dbname is empty
+			$conn['dbname'] = $db ?: 'template1';
+
+			// Generate connection string
+			$str = '';
+			foreach ($conn as $param => $value) {
+				// Escaping single quotes and backslashes per pg_connect() documentation
+				$str .= $param . ""='"" . addcslashes($value, ""'\\"") . ""' "";
 			}
-			if ($user) $str .= "" user="".$user;
-			if ($pwd)  $str .= "" password="".$pwd;
-			if ($db)   $str .= "" dbname="".$db;
 		}
 
 		//if ($user) $linea = ""user=$user host=$linea password=$pwd dbname=$db port=5432"";","Prevent auth bypass with PostgreSQL connections

Thanks to Emmet Leahy of Sorcery Ltd for reporting this vulnerability
(CVE-2021-3850).

Refactoring ADODB_postgres64::_connect():
- Remove adodb_addslashes() function, which did not escape the
  connection parameters when they are wrapped in single quotes
  (root cause for the identified security issue).
- Use addcslashes() instead of addslashes() to only escape `'` and `\`,
  to strictly follow pg_connect() documentation (addslashes() also
  escapes `""`)
- Use an array and a foreach loop to build the connection string when
  given individual parameters for host:port, user, password and dbname

Fixes #793","vuln-fix: Fix improper escaping in PostgreSQL connection string (CVE-2024-XXXX)

The vulnerability was improper escaping of user-supplied connection parameters, allowing injection of malicious characters into the PostgreSQL connection string. This posed a risk of unauthorized command execution or connection manipulation by attackers exploiting unescaped input. The fix replaces custom escaping with proper addcslashes usage for single quotes and backslashes, ensuring safe construction of the connection string.

Weakness: Improper Neutralization of Special Elements in Output (CWE-116)  
Severity: High  
CVSS: 7.5"
